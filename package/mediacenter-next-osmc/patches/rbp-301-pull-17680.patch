From 8eeb10f57a58d8c3ab627fc7448b0286d13cd7b5 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Sun, 12 Apr 2020 14:07:40 +0200
Subject: [PATCH 01/10] [addons][audioengine] add #ifdef __cplusplus

This to separate the C++ and C parts inside.
In following commits becomes it more cleaned to have them also
working in C
---
 xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
index 051d4955d6c0..ed83591fc0fe 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
@@ -36,8 +36,10 @@
 ///
 //------------------------------------------------------------------------------
 
+#ifdef __cplusplus
 extern "C"
 {
+#endif /* __cplusplus */
 
 //============================================================================
 /// \ingroup cpp_kodi_audioengine_Defs
@@ -171,6 +173,7 @@ typedef struct AddonToKodiFuncTable_kodi_audioengine
   void (*aestream_set_resample_ratio)(void *kodiBase, AEStreamHandle *handle, double ratio);
 } AddonToKodiFuncTable_kodi_audioengine;
 
+#ifdef __cplusplus
 } /* extern "C" */
 
 namespace kodi
@@ -584,3 +587,4 @@ inline bool GetCurrentSinkFormat(AudioEngineFormat &format)
 
 } /* audioengine */
 } /* kodi */
+#endif /* __cplusplus */

From a5fbcdbe26556501dc5e15da60dc48b9b26ddd09 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Tue, 14 Apr 2020 11:58:37 +0200
Subject: [PATCH 02/10] [addons][audioengine] change interface code to match
 "C"

This changes the code where work between Kodi and addon to correct
"C" where also allow (in future) to use in "C" only.

There on few functions the "struct" added where "C" needed, further
is a separate class added where handle AudioEngineFormat itself and
them before is renamed to AUDIO_ENGINE_FORMAT.
This was needed to remove the C++ contructor and functions inside structure
where not match to "C".
---
 xbmc/addons/interfaces/AudioEngine.cpp        |   4 +-
 xbmc/addons/interfaces/AudioEngine.h          |   6 +-
 .../include/kodi/AudioEngine.h                | 179 ++++++++++++------
 3 files changed, 123 insertions(+), 66 deletions(-)

diff --git a/xbmc/addons/interfaces/AudioEngine.cpp b/xbmc/addons/interfaces/AudioEngine.cpp
index 3c19c0503ffb..244264622d07 100644
--- a/xbmc/addons/interfaces/AudioEngine.cpp
+++ b/xbmc/addons/interfaces/AudioEngine.cpp
@@ -65,7 +65,7 @@ void Interface_AudioEngine::DeInit(AddonGlobalInterface* addonInterface)
   }
 }
 
-AEStreamHandle* Interface_AudioEngine::audioengine_make_stream(void* kodiBase, AudioEngineFormat* streamFormat, unsigned int options)
+AEStreamHandle* Interface_AudioEngine::audioengine_make_stream(void* kodiBase, AUDIO_ENGINE_FORMAT* streamFormat, unsigned int options)
 {
   if (!kodiBase || !streamFormat)
   {
@@ -111,7 +111,7 @@ void Interface_AudioEngine::audioengine_free_stream(void* kodiBase, AEStreamHand
     engine->FreeStream(static_cast<IAEStream*>(streamHandle), true);
 }
 
-bool Interface_AudioEngine::audioengine_get_current_sink_format(void* kodiBase, AudioEngineFormat *format)
+bool Interface_AudioEngine::audioengine_get_current_sink_format(void* kodiBase, AUDIO_ENGINE_FORMAT *format)
 {
   if (!kodiBase || !format)
   {
diff --git a/xbmc/addons/interfaces/AudioEngine.h b/xbmc/addons/interfaces/AudioEngine.h
index 77805d01151a..d181c579636b 100644
--- a/xbmc/addons/interfaces/AudioEngine.h
+++ b/xbmc/addons/interfaces/AudioEngine.h
@@ -27,7 +27,7 @@ struct Interface_AudioEngine
    * @return a new Handle to an IAEStream that will accept data in the requested format
    */
   static AEStreamHandle* audioengine_make_stream(void* kodiBase,
-                                                 AudioEngineFormat* streamFormat,
+                                                 AUDIO_ENGINE_FORMAT* streamFormat,
                                                  unsigned int options);
 
   /**
@@ -40,10 +40,10 @@ struct Interface_AudioEngine
   /**
    * Get the current sink data format
    *
-   * @param[in] sinkFormat sink data format. For more details see AudioEngineFormat.
+   * @param[in] sinkFormat sink data format. For more details see AUDIO_ENGINE_FORMAT.
    * @return Returns true on success, else false.
    */
-  static bool audioengine_get_current_sink_format(void* kodiBase, AudioEngineFormat* sinkFormat);
+  static bool audioengine_get_current_sink_format(void* kodiBase, AUDIO_ENGINE_FORMAT* sinkFormat);
 
   /**
    * Returns the amount of space available in the stream
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
index ed83591fc0fe..5e15a916851c 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
@@ -56,14 +56,7 @@ typedef enum AudioEngineStreamOptions
 } AudioEngineStreamOptions;
 //----------------------------------------------------------------------------
 
-//============================================================================
-/// \defgroup cpp_kodi_audioengine_Defs_AudioEngineFormat struct AudioEngineFormat
-/// \ingroup cpp_kodi_audioengine_Defs
-/// @brief The audio format structure that fully defines a stream's audio
-/// information
-///
-//@{
-struct AudioEngineFormat
+struct AUDIO_ENGINE_FORMAT
 {
   /// The stream's data format (eg, AE_FMT_S16LE)
   enum AEDataFormat m_dataFormat;
@@ -85,53 +78,7 @@ struct AudioEngineFormat
 
   /// The size of one frame in bytes
   unsigned int m_frameSize;
-
-  AudioEngineFormat()
-  {
-    m_dataFormat = AE_FMT_INVALID;
-    m_sampleRate = 0;
-    m_encodedRate = 0;
-    m_frames = 0;
-    m_frameSize = 0;
-    m_channelCount = 0;
-
-    for (unsigned int ch = 0; ch < AE_CH_MAX; ++ch)
-    {
-      m_channels[ch] = AE_CH_MAX;
-    }
-  }
-
-  /// Function to compare the format structure with another
-  bool compareFormat(const AudioEngineFormat *fmt)
-  {
-    if (!fmt)
-    {
-      return false;
-    }
-
-    if (m_dataFormat    != fmt->m_dataFormat    ||
-        m_sampleRate    != fmt->m_sampleRate    ||
-        m_encodedRate   != fmt->m_encodedRate   ||
-        m_frames        != fmt->m_frames        ||
-        m_frameSize     != fmt->m_frameSize     ||
-        m_channelCount  != fmt->m_channelCount)
-    {
-      return false;
-    }
-
-    for (unsigned int ch = 0; ch < AE_CH_MAX; ++ch)
-    {
-      if (fmt->m_channels[ch] != m_channels[ch])
-      {
-        return false;
-      }
-    }
-
-    return true;
-  }
 };
-//@}
-//----------------------------------------------------------------------------
 
 /* A stream handle pointer, which is only used internally by the addon stream handle */
 typedef void AEStreamHandle;
@@ -142,9 +89,9 @@ typedef void AEStreamHandle;
   */
 typedef struct AddonToKodiFuncTable_kodi_audioengine
 {
-  AEStreamHandle* (*make_stream)(void *kodiBase, AudioEngineFormat* format, unsigned int options);
+  AEStreamHandle* (*make_stream)(void *kodiBase, struct AUDIO_ENGINE_FORMAT* format, unsigned int options);
   void (*free_stream)(void *kodiBase, AEStreamHandle *stream);
-  bool (*get_current_sink_format)(void *kodiBase, AudioEngineFormat* sink_format);
+  bool (*get_current_sink_format)(void *kodiBase, struct AUDIO_ENGINE_FORMAT* sink_format);
 
   // Audio Engine Stream definitions
   unsigned int (*aestream_get_space)(void *kodiBase, AEStreamHandle *handle);
@@ -168,7 +115,7 @@ typedef struct AddonToKodiFuncTable_kodi_audioengine
   unsigned int (*aestream_get_frame_size)(void *kodiBase, AEStreamHandle *handle);
   unsigned int (*aestream_get_channel_count)(void *kodiBase, AEStreamHandle *handle);
   unsigned int (*aestream_get_sample_rate)(void *kodiBase, AEStreamHandle *handle);
-  AEDataFormat (*aestream_get_data_format)(void *kodiBase, AEStreamHandle *handle);
+  enum AEDataFormat (*aestream_get_data_format)(void *kodiBase, AEStreamHandle *handle);
   double (*aestream_get_resample_ratio)(void *kodiBase, AEStreamHandle *handle);
   void (*aestream_set_resample_ratio)(void *kodiBase, AEStreamHandle *handle, double ratio);
 } AddonToKodiFuncTable_kodi_audioengine;
@@ -181,6 +128,116 @@ namespace kodi
 namespace audioengine
 {
 
+//============================================================================
+/// \defgroup cpp_kodi_audioengine_Defs_AudioEngineFormat struct AudioEngineFormat
+/// \ingroup cpp_kodi_audioengine_Defs
+/// @brief The audio format structure that fully defines a stream's audio
+/// information
+///
+//@{
+class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGINE_FORMAT>
+{
+public:
+  AudioEngineFormat()
+  {
+    m_cStructure->m_dataFormat = AE_FMT_INVALID;
+    m_cStructure->m_sampleRate = 0;
+    m_cStructure->m_encodedRate = 0;
+    m_cStructure->m_frames = 0;
+    m_cStructure->m_frameSize = 0;
+    m_cStructure->m_channelCount = 0;
+
+    for (size_t ch = 0; ch < AE_CH_MAX; ++ch)
+      m_cStructure->m_channels[ch] = AE_CH_NULL;
+  }
+  AudioEngineFormat(const AudioEngineFormat& channel) : CStructHdl(channel) {}
+  AudioEngineFormat(const AUDIO_ENGINE_FORMAT* channel) : CStructHdl(channel) {}
+  AudioEngineFormat(AUDIO_ENGINE_FORMAT* channel) : CStructHdl(channel) {}
+
+  /// The stream's data format (eg, AE_FMT_S16LE)
+  void SetDataFormat(enum AEDataFormat format) { m_cStructure->m_dataFormat = format; }
+
+  enum AEDataFormat GetDataFormat() const { return m_cStructure->m_dataFormat; }
+
+  /// The stream's sample rate (eg, 48000)
+  void SetSampleRate(unsigned int rate) { m_cStructure->m_sampleRate = rate; }
+
+  unsigned int GetSampleRate() const { return m_cStructure->m_sampleRate; }
+
+  /// The encoded streams sample rate if a bitstream, otherwise undefined
+  void SetEncodedRate(unsigned int rate) { m_cStructure->m_encodedRate = rate; }
+
+  unsigned int GetEncodedRate() const { return m_cStructure->m_encodedRate; }
+
+  /// The amount of used speaker channels
+  void SetChannelCount(unsigned int count) { m_cStructure->m_channelCount = count; }
+
+  unsigned int GetChannelCount() const { return m_cStructure->m_channelCount; }
+
+  /// The stream's channel layout
+  void SetChannelLayout(const std::vector<enum AEChannel>& layout)
+  {
+    // Reset first all to empty values to AE_CH_NULL, in case given list is empty
+    for (size_t ch = 0; ch < AE_CH_MAX; ++ch)
+      m_cStructure->m_channels[ch] = AE_CH_NULL;
+    for (size_t ch = 0; ch < layout.size() && ch < AE_CH_MAX-1; ++ch)
+      m_cStructure->m_channels[ch] = layout[ch];
+  }
+  std::vector<enum AEChannel> GetChannelLayout() const
+  {
+    std::vector<enum AEChannel> channels;
+    for (size_t ch = 0; ch < AE_CH_MAX; ++ch)
+    {
+      if (m_cStructure->m_channels[ch] == AE_CH_NULL)
+        break;
+
+      channels.push_back(m_cStructure->m_channels[ch]);
+    }
+    return channels;
+  }
+
+  /// The number of frames per period
+  void SetFramesAmount(unsigned int frames) { m_cStructure->m_frames = frames; }
+
+  unsigned int GetFramesAmount() const { return m_cStructure->m_frames; }
+
+  /// The size of one frame in bytes
+  void SetFrameSize(unsigned int frameSize) { m_cStructure->m_frameSize = frameSize; }
+
+  unsigned int GetFrameSize() const { return m_cStructure->m_frameSize; }
+
+  /// Function to compare the format structure with another
+  bool CompareFormat(const AudioEngineFormat *fmt)
+  {
+    if (!fmt)
+    {
+      return false;
+    }
+
+    if (m_cStructure->m_dataFormat    != fmt->m_cStructure->m_dataFormat    ||
+        m_cStructure->m_sampleRate    != fmt->m_cStructure->m_sampleRate    ||
+        m_cStructure->m_encodedRate   != fmt->m_cStructure->m_encodedRate   ||
+        m_cStructure->m_frames        != fmt->m_cStructure->m_frames        ||
+        m_cStructure->m_frameSize     != fmt->m_cStructure->m_frameSize     ||
+        m_cStructure->m_channelCount  != fmt->m_cStructure->m_channelCount)
+    {
+      return false;
+    }
+
+    for (unsigned int ch = 0; ch < AE_CH_MAX; ++ch)
+    {
+      if (fmt->m_cStructure->m_channels[ch] != m_cStructure->m_channels[ch])
+      {
+        return false;
+      }
+    }
+
+    return true;
+  }
+};
+//@}
+//----------------------------------------------------------------------------
+
 //============================================================================
 ///
 /// \defgroup cpp_kodi_audioengine_CAddonAEStream class CAddonAEStream
@@ -264,11 +321,11 @@ class CAddonAEStream
   ///
   /// ~~~~~~~~~~~~~
   ///
-  CAddonAEStream(AudioEngineFormat format, unsigned int options = 0)
+  CAddonAEStream(AudioEngineFormat& format, unsigned int options = 0)
     : m_kodiBase(::kodi::addon::CAddonBase::m_interface->toKodi->kodiBase),
       m_cb(::kodi::addon::CAddonBase::m_interface->toKodi->kodi_audioengine)
   {
-    m_StreamHandle = m_cb->make_stream(m_kodiBase, &format, options);
+    m_StreamHandle = m_cb->make_stream(m_kodiBase, format, options);
     if (m_StreamHandle == nullptr)
     {
       kodi::Log(ADDON_LOG_FATAL, "CAddonAEStream: make_stream failed!");
@@ -578,10 +635,10 @@ class CAddonAEStream
 /// @param[in] format Current sink data format. For more details see AudioEngineFormat.
 /// @return Returns true on success, else false.
 ///
-inline bool GetCurrentSinkFormat(AudioEngineFormat &format)
+inline bool GetCurrentSinkFormat(AudioEngineFormat& format)
 {
   using namespace kodi::addon;
-  return CAddonBase::m_interface->toKodi->kodi_audioengine->get_current_sink_format(CAddonBase::m_interface->toKodi->kodiBase, &format);
+  return CAddonBase::m_interface->toKodi->kodi_audioengine->get_current_sink_format(CAddonBase::m_interface->toKodi->kodiBase, format);
 }
 //----------------------------------------------------------------------------
 

From be25e4927ef169d8ec7af18ff441586d25c41d25 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Tue, 14 Apr 2020 14:00:14 +0200
Subject: [PATCH 03/10] [addons][audioengine] separate Kodi and Addon enum
 parts

This add own enums on addon interface to identify channels and stream types.
That becomes be by 4 new functions translated between Kodi and Addon.

The enums become futher on next changes a detailed documentation to have
better on addons.

Also are this thought to use in future on AudioDecoder interface and if
comes (maybe) back on audio dsp.

Most mandatory background of this is to make 100% sure, that if on Kodi's
AudioEngine is something changed, that the addon not become a mistmatch
with them.
---
 xbmc/addons/interfaces/AudioEngine.cpp        | 266 +++++++++++++++++-
 xbmc/addons/interfaces/AudioEngine.h          |  18 +-
 .../include/kodi/AudioEngine.h                | 142 +++++++---
 3 files changed, 378 insertions(+), 48 deletions(-)

diff --git a/xbmc/addons/interfaces/AudioEngine.cpp b/xbmc/addons/interfaces/AudioEngine.cpp
index 244264622d07..70f9593eaaf9 100644
--- a/xbmc/addons/interfaces/AudioEngine.cpp
+++ b/xbmc/addons/interfaces/AudioEngine.cpp
@@ -12,7 +12,6 @@
 #include "addons/kodi-addon-dev-kit/include/kodi/AddonBase.h"
 #include "cores/AudioEngine/Interfaces/AE.h"
 #include "cores/AudioEngine/Interfaces/AEStream.h"
-#include "cores/AudioEngine/Utils/AEChannelData.h"
 #include "cores/AudioEngine/Utils/AEStreamData.h"
 #include "utils/log.h"
 
@@ -65,6 +64,238 @@ void Interface_AudioEngine::DeInit(AddonGlobalInterface* addonInterface)
   }
 }
 
+AEChannel Interface_AudioEngine::TranslateAEChannelToKodi(AudioEngineChannel channel)
+{
+  switch (channel)
+  {
+    case AUDIOENGINE_CH_RAW:
+      return AE_CH_RAW;
+    case AUDIOENGINE_CH_FL:
+      return AE_CH_FL;
+    case AUDIOENGINE_CH_FR:
+      return AE_CH_FR;
+    case AUDIOENGINE_CH_FC:
+      return AE_CH_FC;
+    case AUDIOENGINE_CH_LFE:
+      return AE_CH_LFE;
+    case AUDIOENGINE_CH_BL:
+      return AE_CH_BL;
+    case AUDIOENGINE_CH_BR:
+      return AE_CH_BR;
+    case AUDIOENGINE_CH_FLOC:
+      return AE_CH_FLOC;
+    case AUDIOENGINE_CH_FROC:
+      return AE_CH_FROC;
+    case AUDIOENGINE_CH_BC:
+      return AE_CH_BC;
+    case AUDIOENGINE_CH_SL:
+      return AE_CH_SL;
+    case AUDIOENGINE_CH_SR:
+      return AE_CH_SR;
+    case AUDIOENGINE_CH_TFL:
+      return AE_CH_TFL;
+    case AUDIOENGINE_CH_TFR:
+      return AE_CH_TFR;
+    case AUDIOENGINE_CH_TFC:
+      return AE_CH_TFC;
+    case AUDIOENGINE_CH_TC:
+      return AE_CH_TC;
+    case AUDIOENGINE_CH_TBL:
+      return AE_CH_TBL;
+    case AUDIOENGINE_CH_TBR:
+      return AE_CH_TBR;
+    case AUDIOENGINE_CH_TBC:
+      return AE_CH_TBC;
+    case AUDIOENGINE_CH_BLOC:
+      return AE_CH_BLOC;
+    case AUDIOENGINE_CH_BROC:
+      return AE_CH_BROC;
+    case AUDIOENGINE_CH_MAX:
+      return AE_CH_MAX;
+    case AUDIOENGINE_CH_NULL:
+    default:
+      return AE_CH_NULL;
+  }
+}
+
+AudioEngineChannel Interface_AudioEngine::TranslateAEChannelToAddon(AEChannel channel)
+{
+  switch (channel)
+  {
+    case AE_CH_RAW:
+      return AUDIOENGINE_CH_RAW;
+    case AE_CH_FL:
+      return AUDIOENGINE_CH_FL;
+    case AE_CH_FR:
+      return AUDIOENGINE_CH_FR;
+    case AE_CH_FC:
+      return AUDIOENGINE_CH_FC;
+    case AE_CH_LFE:
+      return AUDIOENGINE_CH_LFE;
+    case AE_CH_BL:
+      return AUDIOENGINE_CH_BL;
+    case AE_CH_BR:
+      return AUDIOENGINE_CH_BR;
+    case AE_CH_FLOC:
+      return AUDIOENGINE_CH_FLOC;
+    case AE_CH_FROC:
+      return AUDIOENGINE_CH_FROC;
+    case AE_CH_BC:
+      return AUDIOENGINE_CH_BC;
+    case AE_CH_SL:
+      return AUDIOENGINE_CH_SL;
+    case AE_CH_SR:
+      return AUDIOENGINE_CH_SR;
+    case AE_CH_TFL:
+      return AUDIOENGINE_CH_TFL;
+    case AE_CH_TFR:
+      return AUDIOENGINE_CH_TFR;
+    case AE_CH_TFC:
+      return AUDIOENGINE_CH_TFC;
+    case AE_CH_TC:
+      return AUDIOENGINE_CH_TC;
+    case AE_CH_TBL:
+      return AUDIOENGINE_CH_TBL;
+    case AE_CH_TBR:
+      return AUDIOENGINE_CH_TBR;
+    case AE_CH_TBC:
+      return AUDIOENGINE_CH_TBC;
+    case AE_CH_BLOC:
+      return AUDIOENGINE_CH_BLOC;
+    case AE_CH_BROC:
+      return AUDIOENGINE_CH_BROC;
+    case AE_CH_MAX:
+      return AUDIOENGINE_CH_MAX;
+    case AE_CH_NULL:
+    default:
+      return AUDIOENGINE_CH_NULL;
+  }
+}
+
+AEDataFormat Interface_AudioEngine::TranslateAEFormatToKodi(AudioEngineDataFormat format)
+{
+  switch (format)
+  {
+    case AUDIOENGINE_FMT_U8:
+      return AE_FMT_U8;
+    case AUDIOENGINE_FMT_S16BE:
+      return AE_FMT_S16BE;
+    case AUDIOENGINE_FMT_S16LE:
+      return AE_FMT_S16LE;
+    case AUDIOENGINE_FMT_S16NE:
+      return AE_FMT_S16NE;
+    case AUDIOENGINE_FMT_S32BE:
+      return AE_FMT_S32BE;
+    case AUDIOENGINE_FMT_S32LE:
+      return AE_FMT_S32LE;
+    case AUDIOENGINE_FMT_S32NE:
+      return AE_FMT_S32NE;
+    case AUDIOENGINE_FMT_S24BE4:
+      return AE_FMT_S24BE4;
+    case AUDIOENGINE_FMT_S24LE4:
+      return AE_FMT_S24LE4;
+    case AUDIOENGINE_FMT_S24NE4:
+      return AE_FMT_S24NE4;
+    case AUDIOENGINE_FMT_S24NE4MSB:
+      return AE_FMT_S24NE4MSB;
+    case AUDIOENGINE_FMT_S24BE3:
+      return AE_FMT_S24BE3;
+    case AUDIOENGINE_FMT_S24LE3:
+      return AE_FMT_S24LE3;
+    case AUDIOENGINE_FMT_S24NE3:
+      return AE_FMT_S24NE3;
+    case AUDIOENGINE_FMT_DOUBLE:
+      return AE_FMT_DOUBLE;
+    case AUDIOENGINE_FMT_FLOAT:
+      return AE_FMT_FLOAT;
+    case AUDIOENGINE_FMT_RAW:
+      return AE_FMT_RAW;
+    case AUDIOENGINE_FMT_U8P:
+      return AE_FMT_U8P;
+    case AUDIOENGINE_FMT_S16NEP:
+      return AE_FMT_S16NEP;
+    case AUDIOENGINE_FMT_S32NEP:
+      return AE_FMT_S32NEP;
+    case AUDIOENGINE_FMT_S24NE4P:
+      return AE_FMT_S24NE4P;
+    case AUDIOENGINE_FMT_S24NE4MSBP:
+      return AE_FMT_S24NE4MSBP;
+    case AUDIOENGINE_FMT_S24NE3P:
+      return AE_FMT_S24NE3P;
+    case AUDIOENGINE_FMT_DOUBLEP:
+      return AE_FMT_DOUBLEP;
+    case AUDIOENGINE_FMT_FLOATP:
+      return AE_FMT_FLOATP;
+    case AUDIOENGINE_FMT_MAX:
+      return AE_FMT_MAX;
+    case AUDIOENGINE_FMT_INVALID:
+    default:
+      return AE_FMT_INVALID;
+  }
+}
+
+AudioEngineDataFormat Interface_AudioEngine::TranslateAEFormatToAddon(AEDataFormat format)
+{
+  switch (format)
+  {
+    case AE_FMT_U8:
+      return AUDIOENGINE_FMT_U8;
+    case AE_FMT_S16BE:
+      return AUDIOENGINE_FMT_S16BE;
+    case AE_FMT_S16LE:
+      return AUDIOENGINE_FMT_S16LE;
+    case AE_FMT_S16NE:
+      return AUDIOENGINE_FMT_S16NE;
+    case AE_FMT_S32BE:
+      return AUDIOENGINE_FMT_S32BE;
+    case AE_FMT_S32LE:
+      return AUDIOENGINE_FMT_S32LE;
+    case AE_FMT_S32NE:
+      return AUDIOENGINE_FMT_S32NE;
+    case AE_FMT_S24BE4:
+      return AUDIOENGINE_FMT_S24BE4;
+    case AE_FMT_S24LE4:
+      return AUDIOENGINE_FMT_S24LE4;
+    case AE_FMT_S24NE4:
+      return AUDIOENGINE_FMT_S24NE4;
+    case AE_FMT_S24NE4MSB:
+      return AUDIOENGINE_FMT_S24NE4MSB;
+    case AE_FMT_S24BE3:
+      return AUDIOENGINE_FMT_S24BE3;
+    case AE_FMT_S24LE3:
+      return AUDIOENGINE_FMT_S24LE3;
+    case AE_FMT_S24NE3:
+      return AUDIOENGINE_FMT_S24NE3;
+    case AE_FMT_DOUBLE:
+      return AUDIOENGINE_FMT_DOUBLE;
+    case AE_FMT_FLOAT:
+      return AUDIOENGINE_FMT_FLOAT;
+    case AE_FMT_RAW:
+      return AUDIOENGINE_FMT_RAW;
+    case AE_FMT_U8P:
+      return AUDIOENGINE_FMT_U8P;
+    case AE_FMT_S16NEP:
+      return AUDIOENGINE_FMT_S16NEP;
+    case AE_FMT_S32NEP:
+      return AUDIOENGINE_FMT_S32NEP;
+    case AE_FMT_S24NE4P:
+      return AUDIOENGINE_FMT_S24NE4P;
+    case AE_FMT_S24NE4MSBP:
+      return AUDIOENGINE_FMT_S24NE4MSBP;
+    case AE_FMT_S24NE3P:
+      return AUDIOENGINE_FMT_S24NE3P;
+    case AE_FMT_DOUBLEP:
+      return AUDIOENGINE_FMT_DOUBLEP;
+    case AE_FMT_FLOATP:
+      return AUDIOENGINE_FMT_FLOATP;
+    case AE_FMT_MAX:
+      return AUDIOENGINE_FMT_MAX;
+    case AE_FMT_INVALID:
+    default:
+      return AUDIOENGINE_FMT_INVALID;
+  }
+}
+
 AEStreamHandle* Interface_AudioEngine::audioengine_make_stream(void* kodiBase, AUDIO_ENGINE_FORMAT* streamFormat, unsigned int options)
 {
   if (!kodiBase || !streamFormat)
@@ -79,10 +310,18 @@ AEStreamHandle* Interface_AudioEngine::audioengine_make_stream(void* kodiBase, A
   if (!engine)
     return nullptr;
 
+  CAEChannelInfo layout;
+  for (unsigned int ch = 0; ch < AUDIOENGINE_CH_MAX; ++ch)
+  {
+    if (streamFormat->m_channels[ch] == AUDIOENGINE_CH_NULL)
+      break;
+    layout += TranslateAEChannelToKodi(streamFormat->m_channels[ch]);
+  }
+
   AEAudioFormat format;
-  format.m_dataFormat = streamFormat->m_dataFormat;
+  format.m_channelLayout = layout;
+  format.m_dataFormat = TranslateAEFormatToKodi(streamFormat->m_dataFormat);
   format.m_sampleRate = streamFormat->m_sampleRate;
-  format.m_channelLayout = streamFormat->m_channels;
 
   /* Translate addon options to kodi's options */
   int kodiOption = 0;
@@ -132,16 +371,15 @@ bool Interface_AudioEngine::audioengine_get_current_sink_format(void* kodiBase,
     return false;
   }
 
-  format->m_channelCount = sinkFormat.m_channelLayout.Count();
-  for (unsigned int ch = 0; ch < format->m_channelCount; ++ch)
-  {
-    format->m_channels[ch] = sinkFormat.m_channelLayout[ch];
-  }
-
-  format->m_dataFormat = sinkFormat.m_dataFormat;
+  format->m_dataFormat = TranslateAEFormatToAddon(sinkFormat.m_dataFormat);
   format->m_sampleRate = sinkFormat.m_sampleRate;
   format->m_frames = sinkFormat.m_frames;
   format->m_frameSize = sinkFormat.m_frameSize;
+  format->m_channelCount = sinkFormat.m_channelLayout.Count();
+  for (unsigned int ch = 0; ch < format->m_channelCount && ch < AUDIOENGINE_CH_MAX; ++ch)
+  {
+    format->m_channels[ch] = TranslateAEChannelToAddon(sinkFormat.m_channelLayout[ch]);
+  }
 
   return true;
 }
@@ -450,20 +688,20 @@ unsigned int Interface_AudioEngine::aestream_get_sample_rate(void* kodiBase, AES
   return static_cast<IAEStream*>(streamHandle)->GetSampleRate();
 }
 
-AEDataFormat Interface_AudioEngine::aestream_get_data_format(void* kodiBase, AEStreamHandle* streamHandle)
+AudioEngineDataFormat Interface_AudioEngine::aestream_get_data_format(void* kodiBase, AEStreamHandle* streamHandle)
 {
   if (!kodiBase || !streamHandle)
   {
     CLog::Log(LOGERROR,
               "Interface_AudioEngine::{} - invalid stream data (kodiBase='{}', streamHandle='{}')",
               __FUNCTION__, kodiBase, static_cast<void*>(streamHandle));
-    return AE_FMT_INVALID;
+    return AUDIOENGINE_FMT_INVALID;
   }
 
   if (!CServiceBroker::GetActiveAE())
-    return AE_FMT_INVALID;
+    return AUDIOENGINE_FMT_INVALID;
 
-  return static_cast<IAEStream*>(streamHandle)->GetDataFormat();
+  return TranslateAEFormatToAddon(static_cast<IAEStream*>(streamHandle)->GetDataFormat());
 }
 
 double Interface_AudioEngine::aestream_get_resample_ratio(void* kodiBase, AEStreamHandle* streamHandle)
diff --git a/xbmc/addons/interfaces/AudioEngine.h b/xbmc/addons/interfaces/AudioEngine.h
index d181c579636b..f7e9ab281499 100644
--- a/xbmc/addons/interfaces/AudioEngine.h
+++ b/xbmc/addons/interfaces/AudioEngine.h
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h"
+#include "cores/AudioEngine/Utils/AEChannelData.h"
 
 extern "C"
 {
@@ -20,6 +21,20 @@ struct Interface_AudioEngine
   static void Init(AddonGlobalInterface* addonInterface);
   static void DeInit(AddonGlobalInterface* addonInterface);
 
+  /**
+   * @brief Translation functions to separate Kodi and addons
+   *
+   * This thought to make it more safe for cases as something changed inside
+   * Kodi, addons overseen and breaks API, further to have on addons a better
+   * documentation about this parts.
+   */
+  //@{
+  static AEChannel TranslateAEChannelToKodi(AudioEngineChannel channel);
+  static AudioEngineChannel TranslateAEChannelToAddon(AEChannel channel);
+  static AEDataFormat TranslateAEFormatToKodi(AudioEngineDataFormat format);
+  static AudioEngineDataFormat TranslateAEFormatToAddon(AEDataFormat format);
+  //@}
+
   /**
    * Creates and returns a new handle to an IAEStream in the format specified, this function should never fail
    * @param[in] streamFormat Format to use for stream
@@ -173,7 +188,8 @@ struct Interface_AudioEngine
    * Return the data format the stream has been configured with
    * @return The stream's data format (eg, AE_FMT_S16LE)
    */
-  static AEDataFormat aestream_get_data_format(void* kodiBase, AEStreamHandle* streamHandle);
+  static AudioEngineDataFormat aestream_get_data_format(void* kodiBase,
+                                                        AEStreamHandle* streamHandle);
 
   /**
    * Return the resample ratio
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
index 5e15a916851c..25d0acf1a10c 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
@@ -10,12 +10,6 @@
 
 #include "AddonBase.h"
 
-#ifdef BUILD_KODI_ADDON
-#include "AEChannelData.h"
-#else
-#include "cores/AudioEngine/Utils/AEChannelData.h"
-#endif
-
 //==============================================================================
 ///
 /// \defgroup cpp_kodi_audioengine  Interface - kodi::audioengine
@@ -56,10 +50,92 @@ typedef enum AudioEngineStreamOptions
 } AudioEngineStreamOptions;
 //----------------------------------------------------------------------------
 
+//============================================================================
+/// \ingroup cpp_kodi_audioengine_Defs
+/// @brief The possible channels
+///
+enum AudioEngineChannel
+{
+  AUDIOENGINE_CH_NULL = -1,
+  AUDIOENGINE_CH_RAW,
+
+  AUDIOENGINE_CH_FL,
+  AUDIOENGINE_CH_FR,
+  AUDIOENGINE_CH_FC,
+  AUDIOENGINE_CH_LFE,
+  AUDIOENGINE_CH_BL,
+  AUDIOENGINE_CH_BR,
+  AUDIOENGINE_CH_FLOC,
+  AUDIOENGINE_CH_FROC,
+  AUDIOENGINE_CH_BC,
+  AUDIOENGINE_CH_SL,
+  AUDIOENGINE_CH_SR,
+  AUDIOENGINE_CH_TFL,
+  AUDIOENGINE_CH_TFR,
+  AUDIOENGINE_CH_TFC,
+  AUDIOENGINE_CH_TC,
+  AUDIOENGINE_CH_TBL,
+  AUDIOENGINE_CH_TBR,
+  AUDIOENGINE_CH_TBC,
+  AUDIOENGINE_CH_BLOC,
+  AUDIOENGINE_CH_BROC,
+
+  AUDIOENGINE_CH_MAX
+};
+
+//============================================================================
+/// \ingroup cpp_kodi_audioengine_Defs
+/// @brief The various data formats
+///
+/// LE = Little Endian, BE = Big Endian, NE = Native Endian
+/// @note This is ordered from the worst to best preferred formats
+///
+enum AudioEngineDataFormat
+{
+  AUDIOENGINE_FMT_INVALID = -1,
+
+  AUDIOENGINE_FMT_U8,
+
+  AUDIOENGINE_FMT_S16BE,
+  AUDIOENGINE_FMT_S16LE,
+  AUDIOENGINE_FMT_S16NE,
+
+  AUDIOENGINE_FMT_S32BE,
+  AUDIOENGINE_FMT_S32LE,
+  AUDIOENGINE_FMT_S32NE,
+
+  AUDIOENGINE_FMT_S24BE4,
+  AUDIOENGINE_FMT_S24LE4,
+  AUDIOENGINE_FMT_S24NE4, // 24 bits in lower 3 bytes
+  AUDIOENGINE_FMT_S24NE4MSB, // S32 with bits_per_sample < 32
+
+  AUDIOENGINE_FMT_S24BE3,
+  AUDIOENGINE_FMT_S24LE3,
+  AUDIOENGINE_FMT_S24NE3, /* S24 in 3 bytes */
+
+  AUDIOENGINE_FMT_DOUBLE,
+  AUDIOENGINE_FMT_FLOAT,
+
+  // Bitstream
+  AUDIOENGINE_FMT_RAW,
+
+  /* planar formats */
+  AUDIOENGINE_FMT_U8P,
+  AUDIOENGINE_FMT_S16NEP,
+  AUDIOENGINE_FMT_S32NEP,
+  AUDIOENGINE_FMT_S24NE4P,
+  AUDIOENGINE_FMT_S24NE4MSBP,
+  AUDIOENGINE_FMT_S24NE3P,
+  AUDIOENGINE_FMT_DOUBLEP,
+  AUDIOENGINE_FMT_FLOATP,
+
+  AUDIOENGINE_FMT_MAX
+};
+
 struct AUDIO_ENGINE_FORMAT
 {
-  /// The stream's data format (eg, AE_FMT_S16LE)
-  enum AEDataFormat m_dataFormat;
+  /// The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
+  enum AudioEngineDataFormat m_dataFormat;
 
   /// The stream's sample rate (eg, 48000)
   unsigned int m_sampleRate;
@@ -71,7 +147,7 @@ struct AUDIO_ENGINE_FORMAT
   unsigned int m_channelCount;
 
   /// The stream's channel layout
-  enum AEChannel m_channels[AE_CH_MAX];
+  enum AudioEngineChannel m_channels[AUDIOENGINE_CH_MAX];
 
   /// The number of frames per period
   unsigned int m_frames;
@@ -115,7 +191,7 @@ typedef struct AddonToKodiFuncTable_kodi_audioengine
   unsigned int (*aestream_get_frame_size)(void *kodiBase, AEStreamHandle *handle);
   unsigned int (*aestream_get_channel_count)(void *kodiBase, AEStreamHandle *handle);
   unsigned int (*aestream_get_sample_rate)(void *kodiBase, AEStreamHandle *handle);
-  enum AEDataFormat (*aestream_get_data_format)(void *kodiBase, AEStreamHandle *handle);
+  enum AudioEngineDataFormat (*aestream_get_data_format)(void* kodiBase, AEStreamHandle* handle);
   double (*aestream_get_resample_ratio)(void *kodiBase, AEStreamHandle *handle);
   void (*aestream_set_resample_ratio)(void *kodiBase, AEStreamHandle *handle, double ratio);
 } AddonToKodiFuncTable_kodi_audioengine;
@@ -140,24 +216,24 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
 public:
   AudioEngineFormat()
   {
-    m_cStructure->m_dataFormat = AE_FMT_INVALID;
+    m_cStructure->m_dataFormat = AUDIOENGINE_FMT_INVALID;
     m_cStructure->m_sampleRate = 0;
     m_cStructure->m_encodedRate = 0;
     m_cStructure->m_frames = 0;
     m_cStructure->m_frameSize = 0;
     m_cStructure->m_channelCount = 0;
 
-    for (size_t ch = 0; ch < AE_CH_MAX; ++ch)
-      m_cStructure->m_channels[ch] = AE_CH_NULL;
+    for (size_t ch = 0; ch < AUDIOENGINE_CH_MAX; ++ch)
+      m_cStructure->m_channels[ch] = AUDIOENGINE_CH_NULL;
   }
   AudioEngineFormat(const AudioEngineFormat& channel) : CStructHdl(channel) {}
   AudioEngineFormat(const AUDIO_ENGINE_FORMAT* channel) : CStructHdl(channel) {}
   AudioEngineFormat(AUDIO_ENGINE_FORMAT* channel) : CStructHdl(channel) {}
 
-  /// The stream's data format (eg, AE_FMT_S16LE)
-  void SetDataFormat(enum AEDataFormat format) { m_cStructure->m_dataFormat = format; }
+  /// The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
+  void SetDataFormat(enum AudioEngineDataFormat format) { m_cStructure->m_dataFormat = format; }
 
-  enum AEDataFormat GetDataFormat() const { return m_cStructure->m_dataFormat; }
+  enum AudioEngineDataFormat GetDataFormat() const { return m_cStructure->m_dataFormat; }
 
   /// The stream's sample rate (eg, 48000)
   void SetSampleRate(unsigned int rate) { m_cStructure->m_sampleRate = rate; }
@@ -169,26 +245,26 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
 
   unsigned int GetEncodedRate() const { return m_cStructure->m_encodedRate; }
 
-  /// The amount of used speaker channels
-  void SetChannelCount(unsigned int count) { m_cStructure->m_channelCount = count; }
-
-  unsigned int GetChannelCount() const { return m_cStructure->m_channelCount; }
-
   /// The stream's channel layout
-  void SetChannelLayout(const std::vector<enum AEChannel>& layout)
+  void SetChannelLayout(const std::vector<enum AudioEngineChannel>& layout)
   {
-    // Reset first all to empty values to AE_CH_NULL, in case given list is empty
-    for (size_t ch = 0; ch < AE_CH_MAX; ++ch)
-      m_cStructure->m_channels[ch] = AE_CH_NULL;
-    for (size_t ch = 0; ch < layout.size() && ch < AE_CH_MAX-1; ++ch)
+    // Reset first all to empty values to AUDIOENGINE_CH_NULL, in case given list is empty
+    m_cStructure->m_channelCount = 0;
+    for (size_t ch = 0; ch < AUDIOENGINE_CH_MAX; ++ch)
+      m_cStructure->m_channels[ch] = AUDIOENGINE_CH_NULL;
+
+    for (size_t ch = 0; ch < layout.size() && ch < AUDIOENGINE_CH_MAX; ++ch)
+    {
       m_cStructure->m_channels[ch] = layout[ch];
+      m_cStructure->m_channelCount++;
+    }
   }
-  std::vector<enum AEChannel> GetChannelLayout() const
+  std::vector<enum AudioEngineChannel> GetChannelLayout() const
   {
-    std::vector<enum AEChannel> channels;
-    for (size_t ch = 0; ch < AE_CH_MAX; ++ch)
+    std::vector<enum AudioEngineChannel> channels;
+    for (size_t ch = 0; ch < AUDIOENGINE_CH_MAX; ++ch)
     {
-      if (m_cStructure->m_channels[ch] == AE_CH_NULL)
+      if (m_cStructure->m_channels[ch] == AUDIOENGINE_CH_NULL)
         break;
 
       channels.push_back(m_cStructure->m_channels[ch]);
@@ -224,7 +300,7 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
       return false;
     }
 
-    for (unsigned int ch = 0; ch < AE_CH_MAX; ++ch)
+    for (unsigned int ch = 0; ch < AUDIOENGINE_CH_MAX; ++ch)
     {
       if (fmt->m_cStructure->m_channels[ch] != m_cStructure->m_channels[ch])
       {
@@ -257,7 +333,7 @@ class CAddonAEStream
   /// @brief Contructs new class to an Kodi IAEStream in the format specified.
   ///
   /// @param[in] format       The data format the incoming audio will be in
-  ///                         (e.g. \ref AE_FMT_S16LE)
+  ///                         (e.g. \ref AUDIOENGINE_FMT_S16LE)
   /// @param[in] options      [opt] A bit field of stream options (see: enum \ref AudioEngineStreamOptions)
   ///
   ///
@@ -586,7 +662,7 @@ class CAddonAEStream
   ///
   /// @return The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
   ///
-  AEDataFormat GetDataFormat() const
+  AudioEngineDataFormat GetDataFormat() const
   {
     return m_cb->aestream_get_data_format(m_kodiBase, m_StreamHandle);
   }

From 0ecea05fd2d3a14ee6919195c9198bcee70d78e1 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Wed, 15 Apr 2020 03:10:35 +0200
Subject: [PATCH 04/10] [addons][audioengine] clang code style cleanup

This cleanup the code to match complete the clang style.
---
 xbmc/addons/interfaces/AudioEngine.cpp        |  60 ++-
 xbmc/addons/interfaces/AudioEngine.h          |   2 +-
 .../include/kodi/AudioEngine.h                | 390 ++++++++----------
 3 files changed, 224 insertions(+), 228 deletions(-)

diff --git a/xbmc/addons/interfaces/AudioEngine.cpp b/xbmc/addons/interfaces/AudioEngine.cpp
index 70f9593eaaf9..a908d6652c29 100644
--- a/xbmc/addons/interfaces/AudioEngine.cpp
+++ b/xbmc/addons/interfaces/AudioEngine.cpp
@@ -23,12 +23,12 @@ namespace ADDON
 
 void Interface_AudioEngine::Init(AddonGlobalInterface* addonInterface)
 {
-  addonInterface->toKodi->kodi_audioengine = static_cast<AddonToKodiFuncTable_kodi_audioengine*>(malloc(sizeof(AddonToKodiFuncTable_kodi_audioengine)));
+  addonInterface->toKodi->kodi_audioengine = new AddonToKodiFuncTable_kodi_audioengine();
 
   // write KODI audio DSP specific add-on function addresses to callback table
   addonInterface->toKodi->kodi_audioengine->make_stream = audioengine_make_stream;
   addonInterface->toKodi->kodi_audioengine->free_stream = audioengine_free_stream;
-  addonInterface->toKodi->kodi_audioengine->get_current_sink_format = audioengine_get_current_sink_format;
+  addonInterface->toKodi->kodi_audioengine->get_current_sink_format = get_current_sink_format;
 
   // AEStream add-on function callback table
   addonInterface->toKodi->kodi_audioengine->aestream_get_space = aestream_get_space;
@@ -51,15 +51,17 @@ void Interface_AudioEngine::Init(AddonGlobalInterface* addonInterface)
   addonInterface->toKodi->kodi_audioengine->aestream_get_channel_count = aestream_get_channel_count;
   addonInterface->toKodi->kodi_audioengine->aestream_get_sample_rate = aestream_get_sample_rate;
   addonInterface->toKodi->kodi_audioengine->aestream_get_data_format = aestream_get_data_format;
-  addonInterface->toKodi->kodi_audioengine->aestream_get_resample_ratio = aestream_get_resample_ratio;
-  addonInterface->toKodi->kodi_audioengine->aestream_set_resample_ratio = aestream_set_resample_ratio;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_resample_ratio =
+      aestream_get_resample_ratio;
+  addonInterface->toKodi->kodi_audioengine->aestream_set_resample_ratio =
+      aestream_set_resample_ratio;
 }
 
 void Interface_AudioEngine::DeInit(AddonGlobalInterface* addonInterface)
 {
   if (addonInterface->toKodi) /* <-- Safe check, needed so long old addon way is present */
   {
-    free(addonInterface->toKodi->kodi_audioengine);
+    delete addonInterface->toKodi->kodi_audioengine;
     addonInterface->toKodi->kodi_audioengine = nullptr;
   }
 }
@@ -296,7 +298,9 @@ AudioEngineDataFormat Interface_AudioEngine::TranslateAEFormatToAddon(AEDataForm
   }
 }
 
-AEStreamHandle* Interface_AudioEngine::audioengine_make_stream(void* kodiBase, AUDIO_ENGINE_FORMAT* streamFormat, unsigned int options)
+AEStreamHandle* Interface_AudioEngine::audioengine_make_stream(void* kodiBase,
+                                                               AUDIO_ENGINE_FORMAT* streamFormat,
+                                                               unsigned int options)
 {
   if (!kodiBase || !streamFormat)
   {
@@ -350,7 +354,7 @@ void Interface_AudioEngine::audioengine_free_stream(void* kodiBase, AEStreamHand
     engine->FreeStream(static_cast<IAEStream*>(streamHandle), true);
 }
 
-bool Interface_AudioEngine::audioengine_get_current_sink_format(void* kodiBase, AUDIO_ENGINE_FORMAT *format)
+bool Interface_AudioEngine::get_current_sink_format(void* kodiBase, AUDIO_ENGINE_FORMAT* format)
 {
   if (!kodiBase || !format)
   {
@@ -367,7 +371,8 @@ bool Interface_AudioEngine::audioengine_get_current_sink_format(void* kodiBase,
   AEAudioFormat sinkFormat;
   if (!engine->GetCurrentSinkFormat(sinkFormat))
   {
-    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - failed to get current sink format from AE!", __FUNCTION__);
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - failed to get current sink format from AE!",
+              __FUNCTION__);
     return false;
   }
 
@@ -397,8 +402,13 @@ unsigned int Interface_AudioEngine::aestream_get_space(void* kodiBase, AEStreamH
   return static_cast<IAEStream*>(streamHandle)->GetSpace();
 }
 
-unsigned int Interface_AudioEngine::aestream_add_data(void* kodiBase, AEStreamHandle* streamHandle, uint8_t* const *data,
-                                                      unsigned int offset, unsigned int frames, double pts, bool hasDownmix,
+unsigned int Interface_AudioEngine::aestream_add_data(void* kodiBase,
+                                                      AEStreamHandle* streamHandle,
+                                                      uint8_t* const* data,
+                                                      unsigned int offset,
+                                                      unsigned int frames,
+                                                      double pts,
+                                                      bool hasDownmix,
                                                       double centerMixLevel)
 {
   if (!kodiBase || !streamHandle)
@@ -592,7 +602,9 @@ float Interface_AudioEngine::aestream_get_volume(void* kodiBase, AEStreamHandle*
   return static_cast<IAEStream*>(streamHandle)->GetVolume();
 }
 
-void  Interface_AudioEngine::aestream_set_volume(void* kodiBase, AEStreamHandle* streamHandle, float volume)
+void Interface_AudioEngine::aestream_set_volume(void* kodiBase,
+                                                AEStreamHandle* streamHandle,
+                                                float volume)
 {
   if (!kodiBase || !streamHandle)
   {
@@ -608,7 +620,8 @@ void  Interface_AudioEngine::aestream_set_volume(void* kodiBase, AEStreamHandle*
   static_cast<IAEStream*>(streamHandle)->SetVolume(volume);
 }
 
-float Interface_AudioEngine::aestream_get_amplification(void* kodiBase, AEStreamHandle* streamHandle)
+float Interface_AudioEngine::aestream_get_amplification(void* kodiBase,
+                                                        AEStreamHandle* streamHandle)
 {
   if (!kodiBase || !streamHandle)
   {
@@ -624,7 +637,9 @@ float Interface_AudioEngine::aestream_get_amplification(void* kodiBase, AEStream
   return static_cast<IAEStream*>(streamHandle)->GetAmplification();
 }
 
-void Interface_AudioEngine::aestream_set_amplification(void* kodiBase, AEStreamHandle* streamHandle, float amplify)
+void Interface_AudioEngine::aestream_set_amplification(void* kodiBase,
+                                                       AEStreamHandle* streamHandle,
+                                                       float amplify)
 {
   if (!kodiBase || !streamHandle)
   {
@@ -640,7 +655,8 @@ void Interface_AudioEngine::aestream_set_amplification(void* kodiBase, AEStreamH
   static_cast<IAEStream*>(streamHandle)->SetAmplification(amplify);
 }
 
-unsigned int Interface_AudioEngine::aestream_get_frame_size(void* kodiBase, AEStreamHandle* streamHandle)
+unsigned int Interface_AudioEngine::aestream_get_frame_size(void* kodiBase,
+                                                            AEStreamHandle* streamHandle)
 {
   if (!kodiBase || !streamHandle)
   {
@@ -656,7 +672,8 @@ unsigned int Interface_AudioEngine::aestream_get_frame_size(void* kodiBase, AESt
   return static_cast<IAEStream*>(streamHandle)->GetFrameSize();
 }
 
-unsigned int Interface_AudioEngine::aestream_get_channel_count(void* kodiBase, AEStreamHandle* streamHandle)
+unsigned int Interface_AudioEngine::aestream_get_channel_count(void* kodiBase,
+                                                               AEStreamHandle* streamHandle)
 {
   if (!kodiBase || !streamHandle)
   {
@@ -672,7 +689,8 @@ unsigned int Interface_AudioEngine::aestream_get_channel_count(void* kodiBase, A
   return static_cast<IAEStream*>(streamHandle)->GetChannelCount();
 }
 
-unsigned int Interface_AudioEngine::aestream_get_sample_rate(void* kodiBase, AEStreamHandle* streamHandle)
+unsigned int Interface_AudioEngine::aestream_get_sample_rate(void* kodiBase,
+                                                             AEStreamHandle* streamHandle)
 {
   if (!kodiBase || !streamHandle)
   {
@@ -688,7 +706,8 @@ unsigned int Interface_AudioEngine::aestream_get_sample_rate(void* kodiBase, AES
   return static_cast<IAEStream*>(streamHandle)->GetSampleRate();
 }
 
-AudioEngineDataFormat Interface_AudioEngine::aestream_get_data_format(void* kodiBase, AEStreamHandle* streamHandle)
+AudioEngineDataFormat Interface_AudioEngine::aestream_get_data_format(void* kodiBase,
+                                                                      AEStreamHandle* streamHandle)
 {
   if (!kodiBase || !streamHandle)
   {
@@ -704,7 +723,8 @@ AudioEngineDataFormat Interface_AudioEngine::aestream_get_data_format(void* kodi
   return TranslateAEFormatToAddon(static_cast<IAEStream*>(streamHandle)->GetDataFormat());
 }
 
-double Interface_AudioEngine::aestream_get_resample_ratio(void* kodiBase, AEStreamHandle* streamHandle)
+double Interface_AudioEngine::aestream_get_resample_ratio(void* kodiBase,
+                                                          AEStreamHandle* streamHandle)
 {
   if (!kodiBase || !streamHandle)
   {
@@ -720,7 +740,9 @@ double Interface_AudioEngine::aestream_get_resample_ratio(void* kodiBase, AEStre
   return static_cast<IAEStream*>(streamHandle)->GetResampleRatio();
 }
 
-void Interface_AudioEngine::aestream_set_resample_ratio(void* kodiBase, AEStreamHandle* streamHandle, double ratio)
+void Interface_AudioEngine::aestream_set_resample_ratio(void* kodiBase,
+                                                        AEStreamHandle* streamHandle,
+                                                        double ratio)
 {
   if (!kodiBase || !streamHandle)
   {
diff --git a/xbmc/addons/interfaces/AudioEngine.h b/xbmc/addons/interfaces/AudioEngine.h
index f7e9ab281499..0d8356ceb905 100644
--- a/xbmc/addons/interfaces/AudioEngine.h
+++ b/xbmc/addons/interfaces/AudioEngine.h
@@ -58,7 +58,7 @@ struct Interface_AudioEngine
    * @param[in] sinkFormat sink data format. For more details see AUDIO_ENGINE_FORMAT.
    * @return Returns true on success, else false.
    */
-  static bool audioengine_get_current_sink_format(void* kodiBase, AUDIO_ENGINE_FORMAT* sinkFormat);
+  static bool get_current_sink_format(void* kodiBase, AUDIO_ENGINE_FORMAT* sinkFormat);
 
   /**
    * Returns the amount of space available in the stream
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
index 25d0acf1a10c..cd6dbc5495b0 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
@@ -35,166 +35,173 @@ extern "C"
 {
 #endif /* __cplusplus */
 
-//============================================================================
-/// \ingroup cpp_kodi_audioengine_Defs
-/// @brief Bit options to pass to CAddonAEStream
-///
-typedef enum AudioEngineStreamOptions
-{
-  /// force resample even if rates match
-  AUDIO_STREAM_FORCE_RESAMPLE = 1 << 0,
-  /// create the stream paused
-  AUDIO_STREAM_PAUSED         = 1 << 1,
-  /// autostart the stream when enough data is buffered
-  AUDIO_STREAM_AUTOSTART      = 1 << 2,
-} AudioEngineStreamOptions;
-//----------------------------------------------------------------------------
-
-//============================================================================
-/// \ingroup cpp_kodi_audioengine_Defs
-/// @brief The possible channels
-///
-enum AudioEngineChannel
-{
-  AUDIOENGINE_CH_NULL = -1,
-  AUDIOENGINE_CH_RAW,
-
-  AUDIOENGINE_CH_FL,
-  AUDIOENGINE_CH_FR,
-  AUDIOENGINE_CH_FC,
-  AUDIOENGINE_CH_LFE,
-  AUDIOENGINE_CH_BL,
-  AUDIOENGINE_CH_BR,
-  AUDIOENGINE_CH_FLOC,
-  AUDIOENGINE_CH_FROC,
-  AUDIOENGINE_CH_BC,
-  AUDIOENGINE_CH_SL,
-  AUDIOENGINE_CH_SR,
-  AUDIOENGINE_CH_TFL,
-  AUDIOENGINE_CH_TFR,
-  AUDIOENGINE_CH_TFC,
-  AUDIOENGINE_CH_TC,
-  AUDIOENGINE_CH_TBL,
-  AUDIOENGINE_CH_TBR,
-  AUDIOENGINE_CH_TBC,
-  AUDIOENGINE_CH_BLOC,
-  AUDIOENGINE_CH_BROC,
-
-  AUDIOENGINE_CH_MAX
-};
-
-//============================================================================
-/// \ingroup cpp_kodi_audioengine_Defs
-/// @brief The various data formats
-///
-/// LE = Little Endian, BE = Big Endian, NE = Native Endian
-/// @note This is ordered from the worst to best preferred formats
-///
-enum AudioEngineDataFormat
-{
-  AUDIOENGINE_FMT_INVALID = -1,
+  //============================================================================
+  /// \ingroup cpp_kodi_audioengine_Defs
+  /// @brief Bit options to pass to CAddonAEStream
+  ///
+  typedef enum AudioEngineStreamOptions
+  {
+    /// force resample even if rates match
+    AUDIO_STREAM_FORCE_RESAMPLE = 1 << 0,
+    /// create the stream paused
+    AUDIO_STREAM_PAUSED = 1 << 1,
+    /// autostart the stream when enough data is buffered
+    AUDIO_STREAM_AUTOSTART = 1 << 2,
+  } AudioEngineStreamOptions;
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// \ingroup cpp_kodi_audioengine_Defs
+  /// @brief The possible channels
+  ///
+  enum AudioEngineChannel
+  {
+    AUDIOENGINE_CH_NULL = -1,
+    AUDIOENGINE_CH_RAW,
+
+    AUDIOENGINE_CH_FL,
+    AUDIOENGINE_CH_FR,
+    AUDIOENGINE_CH_FC,
+    AUDIOENGINE_CH_LFE,
+    AUDIOENGINE_CH_BL,
+    AUDIOENGINE_CH_BR,
+    AUDIOENGINE_CH_FLOC,
+    AUDIOENGINE_CH_FROC,
+    AUDIOENGINE_CH_BC,
+    AUDIOENGINE_CH_SL,
+    AUDIOENGINE_CH_SR,
+    AUDIOENGINE_CH_TFL,
+    AUDIOENGINE_CH_TFR,
+    AUDIOENGINE_CH_TFC,
+    AUDIOENGINE_CH_TC,
+    AUDIOENGINE_CH_TBL,
+    AUDIOENGINE_CH_TBR,
+    AUDIOENGINE_CH_TBC,
+    AUDIOENGINE_CH_BLOC,
+    AUDIOENGINE_CH_BROC,
+
+    AUDIOENGINE_CH_MAX
+  };
+
+  //============================================================================
+  /// \ingroup cpp_kodi_audioengine_Defs
+  /// @brief The various data formats
+  ///
+  /// LE = Little Endian, BE = Big Endian, NE = Native Endian
+  /// @note This is ordered from the worst to best preferred formats
+  ///
+  enum AudioEngineDataFormat
+  {
+    AUDIOENGINE_FMT_INVALID = -1,
 
-  AUDIOENGINE_FMT_U8,
+    AUDIOENGINE_FMT_U8,
 
-  AUDIOENGINE_FMT_S16BE,
-  AUDIOENGINE_FMT_S16LE,
-  AUDIOENGINE_FMT_S16NE,
+    AUDIOENGINE_FMT_S16BE,
+    AUDIOENGINE_FMT_S16LE,
+    AUDIOENGINE_FMT_S16NE,
 
-  AUDIOENGINE_FMT_S32BE,
-  AUDIOENGINE_FMT_S32LE,
-  AUDIOENGINE_FMT_S32NE,
+    AUDIOENGINE_FMT_S32BE,
+    AUDIOENGINE_FMT_S32LE,
+    AUDIOENGINE_FMT_S32NE,
 
-  AUDIOENGINE_FMT_S24BE4,
-  AUDIOENGINE_FMT_S24LE4,
-  AUDIOENGINE_FMT_S24NE4, // 24 bits in lower 3 bytes
-  AUDIOENGINE_FMT_S24NE4MSB, // S32 with bits_per_sample < 32
+    AUDIOENGINE_FMT_S24BE4,
+    AUDIOENGINE_FMT_S24LE4,
+    AUDIOENGINE_FMT_S24NE4, // 24 bits in lower 3 bytes
+    AUDIOENGINE_FMT_S24NE4MSB, // S32 with bits_per_sample < 32
 
-  AUDIOENGINE_FMT_S24BE3,
-  AUDIOENGINE_FMT_S24LE3,
-  AUDIOENGINE_FMT_S24NE3, /* S24 in 3 bytes */
+    AUDIOENGINE_FMT_S24BE3,
+    AUDIOENGINE_FMT_S24LE3,
+    AUDIOENGINE_FMT_S24NE3, /* S24 in 3 bytes */
 
-  AUDIOENGINE_FMT_DOUBLE,
-  AUDIOENGINE_FMT_FLOAT,
+    AUDIOENGINE_FMT_DOUBLE,
+    AUDIOENGINE_FMT_FLOAT,
 
-  // Bitstream
-  AUDIOENGINE_FMT_RAW,
+    // Bitstream
+    AUDIOENGINE_FMT_RAW,
 
-  /* planar formats */
-  AUDIOENGINE_FMT_U8P,
-  AUDIOENGINE_FMT_S16NEP,
-  AUDIOENGINE_FMT_S32NEP,
-  AUDIOENGINE_FMT_S24NE4P,
-  AUDIOENGINE_FMT_S24NE4MSBP,
-  AUDIOENGINE_FMT_S24NE3P,
-  AUDIOENGINE_FMT_DOUBLEP,
-  AUDIOENGINE_FMT_FLOATP,
+    /* planar formats */
+    AUDIOENGINE_FMT_U8P,
+    AUDIOENGINE_FMT_S16NEP,
+    AUDIOENGINE_FMT_S32NEP,
+    AUDIOENGINE_FMT_S24NE4P,
+    AUDIOENGINE_FMT_S24NE4MSBP,
+    AUDIOENGINE_FMT_S24NE3P,
+    AUDIOENGINE_FMT_DOUBLEP,
+    AUDIOENGINE_FMT_FLOATP,
 
-  AUDIOENGINE_FMT_MAX
-};
+    AUDIOENGINE_FMT_MAX
+  };
 
-struct AUDIO_ENGINE_FORMAT
-{
-  /// The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
-  enum AudioEngineDataFormat m_dataFormat;
+  struct AUDIO_ENGINE_FORMAT
+  {
+    /// The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
+    enum AudioEngineDataFormat m_dataFormat;
 
-  /// The stream's sample rate (eg, 48000)
-  unsigned int m_sampleRate;
+    /// The stream's sample rate (eg, 48000)
+    unsigned int m_sampleRate;
 
-  /// The encoded streams sample rate if a bitstream, otherwise undefined
-  unsigned int m_encodedRate;
+    /// The encoded streams sample rate if a bitstream, otherwise undefined
+    unsigned int m_encodedRate;
 
-  /// The amount of used speaker channels
-  unsigned int m_channelCount;
+    /// The amount of used speaker channels
+    unsigned int m_channelCount;
 
-  /// The stream's channel layout
-  enum AudioEngineChannel m_channels[AUDIOENGINE_CH_MAX];
+    /// The stream's channel layout
+    enum AudioEngineChannel m_channels[AUDIOENGINE_CH_MAX];
 
-  /// The number of frames per period
-  unsigned int m_frames;
+    /// The number of frames per period
+    unsigned int m_frames;
 
-  /// The size of one frame in bytes
-  unsigned int m_frameSize;
-};
+    /// The size of one frame in bytes
+    unsigned int m_frameSize;
+  };
 
-/* A stream handle pointer, which is only used internally by the addon stream handle */
-typedef void AEStreamHandle;
+  /* A stream handle pointer, which is only used internally by the addon stream handle */
+  typedef void AEStreamHandle;
 
-/*
-  * Function address structure, not need to visible on dev kit doxygen
-  * documentation
-  */
-typedef struct AddonToKodiFuncTable_kodi_audioengine
-{
-  AEStreamHandle* (*make_stream)(void *kodiBase, struct AUDIO_ENGINE_FORMAT* format, unsigned int options);
-  void (*free_stream)(void *kodiBase, AEStreamHandle *stream);
-  bool (*get_current_sink_format)(void *kodiBase, struct AUDIO_ENGINE_FORMAT* sink_format);
-
-  // Audio Engine Stream definitions
-  unsigned int (*aestream_get_space)(void *kodiBase, AEStreamHandle *handle);
-  unsigned int (*aestream_add_data)(void *kodiBase, AEStreamHandle *handle, uint8_t* const *data,
-                                    unsigned int offset, unsigned int frames, double pts, bool hasDownmix,
-                                    double centerMixLevel);
-  double (*aestream_get_delay)(void *kodiBase, AEStreamHandle *handle);
-  bool (*aestream_is_buffering)(void *kodiBase, AEStreamHandle *handle);
-  double (*aestream_get_cache_time)(void *kodiBase, AEStreamHandle *handle);
-  double (*aestream_get_cache_total)(void *kodiBase, AEStreamHandle *handle);
-  void (*aestream_pause)(void *kodiBase, AEStreamHandle *handle);
-  void (*aestream_resume)(void *kodiBase, AEStreamHandle *handle);
-  void (*aestream_drain)(void *kodiBase, AEStreamHandle *handle, bool wait);
-  bool (*aestream_is_draining)(void *kodiBase, AEStreamHandle *handle);
-  bool (*aestream_is_drained)(void *kodiBase, AEStreamHandle *handle);
-  void (*aestream_flush)(void *kodiBase, AEStreamHandle *handle);
-  float (*aestream_get_volume)(void *kodiBase, AEStreamHandle *handle);
-  void (*aestream_set_volume)(void *kodiBase, AEStreamHandle *handle, float volume);
-  float (*aestream_get_amplification)(void *kodiBase, AEStreamHandle *handle);
-  void (*aestream_set_amplification)(void *kodiBase, AEStreamHandle *handle, float amplify);
-  unsigned int (*aestream_get_frame_size)(void *kodiBase, AEStreamHandle *handle);
-  unsigned int (*aestream_get_channel_count)(void *kodiBase, AEStreamHandle *handle);
-  unsigned int (*aestream_get_sample_rate)(void *kodiBase, AEStreamHandle *handle);
-  enum AudioEngineDataFormat (*aestream_get_data_format)(void* kodiBase, AEStreamHandle* handle);
-  double (*aestream_get_resample_ratio)(void *kodiBase, AEStreamHandle *handle);
-  void (*aestream_set_resample_ratio)(void *kodiBase, AEStreamHandle *handle, double ratio);
-} AddonToKodiFuncTable_kodi_audioengine;
+  /*
+   * Function address structure, not need to visible on dev kit doxygen
+   * documentation
+   */
+  typedef struct AddonToKodiFuncTable_kodi_audioengine
+  {
+    AEStreamHandle* (*make_stream)(void* kodiBase,
+                                   struct AUDIO_ENGINE_FORMAT* format,
+                                   unsigned int options);
+    void (*free_stream)(void* kodiBase, AEStreamHandle* stream);
+    bool (*get_current_sink_format)(void* kodiBase, struct AUDIO_ENGINE_FORMAT* sink_format);
+
+    // Audio Engine Stream definitions
+    unsigned int (*aestream_get_space)(void* kodiBase, AEStreamHandle* handle);
+    unsigned int (*aestream_add_data)(void* kodiBase,
+                                      AEStreamHandle* handle,
+                                      uint8_t* const* data,
+                                      unsigned int offset,
+                                      unsigned int frames,
+                                      double pts,
+                                      bool hasDownmix,
+                                      double centerMixLevel);
+    double (*aestream_get_delay)(void* kodiBase, AEStreamHandle* handle);
+    bool (*aestream_is_buffering)(void* kodiBase, AEStreamHandle* handle);
+    double (*aestream_get_cache_time)(void* kodiBase, AEStreamHandle* handle);
+    double (*aestream_get_cache_total)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_pause)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_resume)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_drain)(void* kodiBase, AEStreamHandle* handle, bool wait);
+    bool (*aestream_is_draining)(void* kodiBase, AEStreamHandle* handle);
+    bool (*aestream_is_drained)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_flush)(void* kodiBase, AEStreamHandle* handle);
+    float (*aestream_get_volume)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_set_volume)(void* kodiBase, AEStreamHandle* handle, float volume);
+    float (*aestream_get_amplification)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_set_amplification)(void* kodiBase, AEStreamHandle* handle, float amplify);
+    unsigned int (*aestream_get_frame_size)(void* kodiBase, AEStreamHandle* handle);
+    unsigned int (*aestream_get_channel_count)(void* kodiBase, AEStreamHandle* handle);
+    unsigned int (*aestream_get_sample_rate)(void* kodiBase, AEStreamHandle* handle);
+    enum AudioEngineDataFormat (*aestream_get_data_format)(void* kodiBase, AEStreamHandle* handle);
+    double (*aestream_get_resample_ratio)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_set_resample_ratio)(void* kodiBase, AEStreamHandle* handle, double ratio);
+  } AddonToKodiFuncTable_kodi_audioengine;
 
 #ifdef __cplusplus
 } /* extern "C" */
@@ -283,19 +290,19 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
   unsigned int GetFrameSize() const { return m_cStructure->m_frameSize; }
 
   /// Function to compare the format structure with another
-  bool CompareFormat(const AudioEngineFormat *fmt)
+  bool CompareFormat(const AudioEngineFormat* fmt)
   {
     if (!fmt)
     {
       return false;
     }
 
-    if (m_cStructure->m_dataFormat    != fmt->m_cStructure->m_dataFormat    ||
-        m_cStructure->m_sampleRate    != fmt->m_cStructure->m_sampleRate    ||
-        m_cStructure->m_encodedRate   != fmt->m_cStructure->m_encodedRate   ||
-        m_cStructure->m_frames        != fmt->m_cStructure->m_frames        ||
-        m_cStructure->m_frameSize     != fmt->m_cStructure->m_frameSize     ||
-        m_cStructure->m_channelCount  != fmt->m_cStructure->m_channelCount)
+    if (m_cStructure->m_dataFormat != fmt->m_cStructure->m_dataFormat ||
+        m_cStructure->m_sampleRate != fmt->m_cStructure->m_sampleRate ||
+        m_cStructure->m_encodedRate != fmt->m_cStructure->m_encodedRate ||
+        m_cStructure->m_frames != fmt->m_cStructure->m_frames ||
+        m_cStructure->m_frameSize != fmt->m_cStructure->m_frameSize ||
+        m_cStructure->m_channelCount != fmt->m_cStructure->m_channelCount)
     {
       return false;
     }
@@ -429,10 +436,7 @@ class CAddonAEStream
   ///
   /// @return                 The number of bytes AddData will consume
   ///
-  unsigned int GetSpace()
-  {
-    return m_cb->aestream_get_space(m_kodiBase, m_StreamHandle);
-  }
+  unsigned int GetSpace() { return m_cb->aestream_get_space(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
@@ -447,10 +451,15 @@ class CAddonAEStream
   /// @param[in] centerMixLevel [opt] level to mix left and right to center default is 1.0
   /// @return                   The number of frames consumed
   ///
-  unsigned int AddData(uint8_t* const *data, unsigned int offset, unsigned int frames,
-                        double pts = 0, bool hasDownmix = false, double centerMixLevel = 1.0)
+  unsigned int AddData(uint8_t* const* data,
+                       unsigned int offset,
+                       unsigned int frames,
+                       double pts = 0,
+                       bool hasDownmix = false,
+                       double centerMixLevel = 1.0)
   {
-    return m_cb->aestream_add_data(m_kodiBase, m_StreamHandle, data, offset, frames, pts, hasDownmix, centerMixLevel);
+    return m_cb->aestream_add_data(m_kodiBase, m_StreamHandle, data, offset, frames, pts,
+                                   hasDownmix, centerMixLevel);
   }
   //--------------------------------------------------------------------------
 
@@ -461,10 +470,7 @@ class CAddonAEStream
   ///
   /// @return seconds
   ///
-  double GetDelay()
-  {
-    return m_cb->aestream_get_delay(m_kodiBase, m_StreamHandle);
-  }
+  double GetDelay() { return m_cb->aestream_get_delay(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
@@ -473,10 +479,7 @@ class CAddonAEStream
   ///
   /// @return True if the stream is buffering
   ///
-  bool IsBuffering()
-  {
-    return m_cb->aestream_is_buffering(m_kodiBase, m_StreamHandle);
-  }
+  bool IsBuffering() { return m_cb->aestream_is_buffering(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
@@ -486,10 +489,7 @@ class CAddonAEStream
   ///
   /// @return seconds
   ///
-  double GetCacheTime()
-  {
-    return m_cb->aestream_get_cache_time(m_kodiBase, m_StreamHandle);
-  }
+  double GetCacheTime() { return m_cb->aestream_get_cache_time(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
@@ -498,30 +498,21 @@ class CAddonAEStream
   ///
   /// @return seconds
   ///
-  double GetCacheTotal()
-  {
-    return m_cb->aestream_get_cache_total(m_kodiBase, m_StreamHandle);
-  }
+  double GetCacheTotal() { return m_cb->aestream_get_cache_total(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAddonAEStream
   /// @brief Pauses the stream playback
   ///
-  void Pause()
-  {
-    return m_cb->aestream_pause(m_kodiBase, m_StreamHandle);
-  }
+  void Pause() { return m_cb->aestream_pause(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAddonAEStream
   /// @brief Resumes the stream after pausing
   ///
-  void Resume()
-  {
-    return m_cb->aestream_resume(m_kodiBase, m_StreamHandle);
-  }
+  void Resume() { return m_cb->aestream_resume(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
@@ -533,40 +524,28 @@ class CAddonAEStream
   ///
   /// @note Once called AddData will not consume more data.
   ///
-  void Drain(bool wait = true)
-  {
-    return m_cb->aestream_drain(m_kodiBase, m_StreamHandle, wait);
-  }
+  void Drain(bool wait = true) { return m_cb->aestream_drain(m_kodiBase, m_StreamHandle, wait); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAddonAEStream
   /// @brief Returns true if the is stream draining
   ///
-  bool IsDraining()
-  {
-    return m_cb->aestream_is_draining(m_kodiBase, m_StreamHandle);
-  }
+  bool IsDraining() { return m_cb->aestream_is_draining(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAddonAEStream
   /// @brief Returns true if the is stream has finished draining
   ///
-  bool IsDrained()
-  {
-    return m_cb->aestream_is_drained(m_kodiBase, m_StreamHandle);
-  }
+  bool IsDrained() { return m_cb->aestream_is_drained(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAddonAEStream
   /// @brief Flush all buffers dropping the audio data
   ///
-  void Flush()
-  {
-    return m_cb->aestream_flush(m_kodiBase, m_StreamHandle);
-  }
+  void Flush() { return m_cb->aestream_flush(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
@@ -575,10 +554,7 @@ class CAddonAEStream
   ///
   /// @return The volume level between 0.0 and 1.0
   ///
-  float GetVolume()
-  {
-    return m_cb->aestream_get_volume(m_kodiBase, m_StreamHandle);
-  }
+  float GetVolume() { return m_cb->aestream_get_volume(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
@@ -599,10 +575,7 @@ class CAddonAEStream
   ///
   /// @return The volume amplification factor between 1.0 and 1000.0
   ///
-  float GetAmplification()
-  {
-    return m_cb->aestream_get_amplification(m_kodiBase, m_StreamHandle);
-  }
+  float GetAmplification() { return m_cb->aestream_get_amplification(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
@@ -701,7 +674,7 @@ class CAddonAEStream
 private:
   void* m_kodiBase;
   AddonToKodiFuncTable_kodi_audioengine* m_cb;
-  AEStreamHandle  *m_StreamHandle;
+  AEStreamHandle* m_StreamHandle;
 };
 
 //============================================================================
@@ -714,10 +687,11 @@ class CAddonAEStream
 inline bool GetCurrentSinkFormat(AudioEngineFormat& format)
 {
   using namespace kodi::addon;
-  return CAddonBase::m_interface->toKodi->kodi_audioengine->get_current_sink_format(CAddonBase::m_interface->toKodi->kodiBase, format);
+  return CAddonBase::m_interface->toKodi->kodi_audioengine->get_current_sink_format(
+      CAddonBase::m_interface->toKodi->kodiBase, format);
 }
 //----------------------------------------------------------------------------
 
-} /* audioengine */
-} /* kodi */
+} // namespace audioengine
+} // namespace kodi
 #endif /* __cplusplus */

From e1f2c32a626df835e5cb7844404a8458e3431b82 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Tue, 14 Apr 2020 14:19:26 +0200
Subject: [PATCH 05/10] [addons][audioengine] rename CAddonAEStream to
 CAEStream

This thought to reduce his string length and the "Addon" inside not needed,
this is already in a namespace kodi::audioengine and as this can nowhere
else used as on addon, can it be leaved away.
---
 .../include/kodi/AudioEngine.h                | 60 +++++++++----------
 1 file changed, 30 insertions(+), 30 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
index cd6dbc5495b0..441c39207aee 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
@@ -37,7 +37,7 @@ extern "C"
 
   //============================================================================
   /// \ingroup cpp_kodi_audioengine_Defs
-  /// @brief Bit options to pass to CAddonAEStream
+  /// @brief Bit options to pass to CAEStream
   ///
   typedef enum AudioEngineStreamOptions
   {
@@ -323,7 +323,7 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
 
 //============================================================================
 ///
-/// \defgroup cpp_kodi_audioengine_CAddonAEStream class CAddonAEStream
+/// \defgroup cpp_kodi_audioengine_CAEStream class CAEStream
 /// \ingroup cpp_kodi_audioengine
 /// @brief **Audio Engine Stream Class**
 ///
@@ -332,11 +332,11 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
 /// included to enjoy it.
 ///
 //----------------------------------------------------------------------------
-class CAddonAEStream
+class CAEStream
 {
 public:
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Contructs new class to an Kodi IAEStream in the format specified.
   ///
   /// @param[in] format       The data format the incoming audio will be in
@@ -404,23 +404,23 @@ class CAddonAEStream
   ///
   /// ~~~~~~~~~~~~~
   ///
-  CAddonAEStream(AudioEngineFormat& format, unsigned int options = 0)
+  CAEStream(AudioEngineFormat& format, unsigned int options = 0)
     : m_kodiBase(::kodi::addon::CAddonBase::m_interface->toKodi->kodiBase),
       m_cb(::kodi::addon::CAddonBase::m_interface->toKodi->kodi_audioengine)
   {
     m_StreamHandle = m_cb->make_stream(m_kodiBase, format, options);
     if (m_StreamHandle == nullptr)
     {
-      kodi::Log(ADDON_LOG_FATAL, "CAddonAEStream: make_stream failed!");
+      kodi::Log(ADDON_LOG_FATAL, "CAEStream: make_stream failed!");
     }
   }
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Class destructor
   ///
-  ~CAddonAEStream()
+  ~CAEStream()
   {
     if (m_StreamHandle)
     {
@@ -431,7 +431,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns the amount of space available in the stream
   ///
   /// @return                 The number of bytes AddData will consume
@@ -440,7 +440,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Add planar or interleaved PCM data to the stream
   ///
   /// @param[in] data           array of pointers to the planes
@@ -464,7 +464,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns the time in seconds that it will take for the next added
   /// packet to be heard from the speakers.
   ///
@@ -474,7 +474,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns if the stream is buffering
   ///
   /// @return True if the stream is buffering
@@ -483,7 +483,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns the time in seconds of the stream's cached audio samples.
   /// Engine buffers excluded.
   ///
@@ -493,7 +493,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns the total time in seconds of the cache
   ///
   /// @return seconds
@@ -502,21 +502,21 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Pauses the stream playback
   ///
   void Pause() { return m_cb->aestream_pause(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Resumes the stream after pausing
   ///
   void Resume() { return m_cb->aestream_resume(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Start draining the stream
   ///
   /// @param[in] wait         [opt] Wait until drain is finished if set to
@@ -528,28 +528,28 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns true if the is stream draining
   ///
   bool IsDraining() { return m_cb->aestream_is_draining(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns true if the is stream has finished draining
   ///
   bool IsDrained() { return m_cb->aestream_is_drained(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Flush all buffers dropping the audio data
   ///
   void Flush() { return m_cb->aestream_flush(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Return the stream's current volume level
   ///
   /// @return The volume level between 0.0 and 1.0
@@ -558,7 +558,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Set the stream's volume level
   ///
   /// @param[in] volume               The new volume level between 0.0 and 1.0
@@ -570,7 +570,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Gets the stream's volume amplification in linear units.
   ///
   /// @return The volume amplification factor between 1.0 and 1000.0
@@ -579,7 +579,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Sets the stream's volume amplification in linear units.
   ///
   /// @param[in] amplify              The volume amplification factor between
@@ -592,7 +592,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns the size of one audio frame in bytes (channelCount * resolution)
   ///
   /// @return The size in bytes of one frame
@@ -604,7 +604,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns the number of channels the stream is configured to accept
   ///
   /// @return The channel count
@@ -616,7 +616,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns the stream's sample rate, if the stream is using a dynamic
   /// sample rate, this value will NOT reflect any changes made by calls to
   /// SetResampleRatio()
@@ -630,7 +630,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Return the data format the stream has been configured with
   ///
   /// @return The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
@@ -642,7 +642,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Return the resample ratio
   ///
   /// @note This will return an undefined value if the stream is not resampling
@@ -656,7 +656,7 @@ class CAddonAEStream
   //--------------------------------------------------------------------------
 
   //==========================================================================
-  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Sets the resample ratio
   ///
   /// @note This function may return false if the stream is not resampling, if

From c8a8571820b8a3ee18a0f876d6929dd3acf0ca82 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Tue, 5 May 2020 23:53:05 +0200
Subject: [PATCH 06/10] [addons][doxygen] update doc views

There is a fix about " on python macros, further is the menu width increased
and the defines are not shows in summary view (looks ugly).
---
 xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile          | 6 +++---
 xbmc/addons/kodi-addon-dev-kit/doxygen/DoxygenLayout.xml | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile b/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
index e220e895eeae..195616a3b759 100644
--- a/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
+++ b/xbmc/addons/kodi-addon-dev-kit/doxygen/Doxyfile
@@ -245,9 +245,9 @@ ALIASES                = "table_start=<table width=\"100%\" style=\"border\" bgc
                          "table_h3{3}=<tr bgcolor=576f9f><th width=30% align=left valign=middle><b>\1</b></th><th width=10% align=left valign=middle><b>\2</b></th><th width=60% align=left valign=middle><span><b>\3</b></span></th></tr>" \
                          "table_row3{3}=\htmlonly<tr bgcolor=white><td width= 30% align=left>\endhtmlonly\1\htmlonly</td><td width= 10% align=left>\endhtmlonly\2\htmlonly</td><td width= 60% align=left>\endhtmlonly\3\htmlonly</td></tr>\endhtmlonly" \
                          "python_func{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
-                         "python_func_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
+                         "python_func_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Function: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style=\"float:right;\"><small>\2</small></span></h4> \endhtmlonly" \
                          "python_class{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
-                         "python_class_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style="float:right;"><small>\2</small></span></h4> \endhtmlonly" \
+                         "python_class_with_rev{2}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code><span style=\"float:right;\"><small>\2</small></span></h4> \endhtmlonly" \
                          "python_removed_function{3}=\htmlonly <dl class=\"reflist\"><dt>Member <a class=\"el\" href=\"\2\">\1</a> (...)</dt><dd>\3</dd></dl>\endhtmlonly" \
                          "cpp_class{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Class: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
                          "cpp_namespace{1}=\htmlonly <h4><code><span style=\"font-style: italic;\">Namespace: </span><span style=\"font-style: bold;\"><font color=31363b><big>\1</big></font></span></code></h4> \endhtmlonly" \
@@ -1606,7 +1606,7 @@ ENUM_VALUES_PER_LINE   = 4
 # Minimum value: 0, maximum value: 1500, default value: 250.
 # This tag requires that the tag GENERATE_HTML is set to YES.
 
-TREEVIEW_WIDTH         = 250
+TREEVIEW_WIDTH         = 350
 
 # If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
 # external symbols imported via tag files in a separate window.
diff --git a/xbmc/addons/kodi-addon-dev-kit/doxygen/DoxygenLayout.xml b/xbmc/addons/kodi-addon-dev-kit/doxygen/DoxygenLayout.xml
index b6a6b2c7a71f..a1f0c67dfd01 100644
--- a/xbmc/addons/kodi-addon-dev-kit/doxygen/DoxygenLayout.xml
+++ b/xbmc/addons/kodi-addon-dev-kit/doxygen/DoxygenLayout.xml
@@ -156,7 +156,7 @@
       <files visible="yes" title=""/>
       <namespaces visible="yes" title=""/>
 <!--      <classes visible="yes" title=""/> -->
-      <defines title=""/>
+<!--       <defines title=""/> -->
       <typedefs title=""/>
 <!--      <enums title=""/> -->
       <enumvalues title=""/>

From 0d56ddb3d5c7fc2438c7f71c4d2136e6c10e0dbb Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Wed, 6 May 2020 03:46:44 +0200
Subject: [PATCH 07/10] [addons] fix CStructHdl use by copy class to class

Before has in case the "C" structure to left from Kodi by a copy from right on
addon not worked and Kodi not becomed wanted data.

Further was on blank "C" structure use no 0 set inside.
---
 .../include/kodi/AddonBase.h                  | 34 +++++++++++++------
 1 file changed, 24 insertions(+), 10 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AddonBase.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AddonBase.h
index 59eca04f6d8d..aaefb904fd69 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AddonBase.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AddonBase.h
@@ -341,7 +341,7 @@ class CStructHdl
 {
 public:
   CStructHdl()
-    : m_cStructure(new C_STRUCT)
+    : m_cStructure(new C_STRUCT())
     , m_owner(true)
   {
   }
@@ -353,7 +353,7 @@ class CStructHdl
   }
 
   CStructHdl(const C_STRUCT* cStructure)
-    : m_cStructure(new C_STRUCT({*cStructure}))
+    : m_cStructure(new C_STRUCT(*cStructure))
     , m_owner(true)
   {
   }
@@ -367,20 +367,34 @@ class CStructHdl
   const CStructHdl& operator=(const CStructHdl& right)
   {
     assert(&right.m_cStructure);
-    if (m_owner)
-      delete m_cStructure;
-    m_owner = true;
-    m_cStructure = new C_STRUCT(*right.m_cStructure);
+    if (m_cStructure && !m_owner)
+    {
+      memcpy(m_cStructure, right.m_cStructure, sizeof(C_STRUCT));
+    }
+    else
+    {
+      if (m_owner)
+        delete m_cStructure;
+      m_owner = true;
+      m_cStructure = new C_STRUCT(*right.m_cStructure);
+    }
     return *this;
   }
 
   const CStructHdl& operator=(const C_STRUCT& right)
   {
     assert(&right);
-    if (m_owner)
-      delete m_cStructure;
-    m_owner = true;
-    m_cStructure = new C_STRUCT(*right);
+    if (m_cStructure && !m_owner)
+    {
+      memcpy(m_cStructure, &right, sizeof(C_STRUCT));
+    }
+    else
+    {
+      if (m_owner)
+        delete m_cStructure;
+      m_owner = true;
+      m_cStructure = new C_STRUCT(*right);
+    }
     return *this;
   }
 

From fdef4a4b9921720881ebb1641fa2327a84ac6849 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Fri, 8 May 2020 20:38:44 +0200
Subject: [PATCH 08/10] [addons][audioengine] update documentation

This cleanup and update the addon audioengine documentation.
---
 .../include/kodi/AudioEngine.h                | 470 +++++++++++++-----
 1 file changed, 345 insertions(+), 125 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
index 441c39207aee..bcf603e5cb18 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
@@ -10,35 +10,32 @@
 
 #include "AddonBase.h"
 
-//==============================================================================
-///
-/// \defgroup cpp_kodi_audioengine  Interface - kodi::audioengine
-/// \ingroup cpp
-/// @brief **Audio engine functions**
-///
-///
-/// It has the header \ref AudioEngine.h "#include <kodi/AudioEngine.h>" be included
-/// to enjoy it.
-///
-//------------------------------------------------------------------------------
-
-//==============================================================================
-///
-/// \defgroup cpp_kodi_audioengine_Defs Definitions, structures and enumerators
-/// \ingroup cpp_kodi_audioengine
-/// @brief **Library definition values**
-///
-//------------------------------------------------------------------------------
-
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //
+  // "C" Definitions, structures and enumerators of audio engine
+  //{{{
+
   //============================================================================
-  /// \ingroup cpp_kodi_audioengine_Defs
-  /// @brief Bit options to pass to CAEStream
+  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineStreamOptions enum AudioEngineStreamOptions
+  /// @ingroup cpp_kodi_audioengine_Defs
+  /// @brief **Bit options to pass to CAEStream**\n
+  /// A bit field of stream options.
+  ///
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Usage example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// // Here only as minimal, "format" must be set to wanted types
+  /// kodi::audioengine::AudioEngineFormat format;
+  /// m_audioengine = new kodi::audioengine::CAEStream(format, AUDIO_STREAM_FORCE_RESAMPLE | AUDIO_STREAM_AUTOSTART);
+  /// ~~~~~~~~~~~~~
   ///
+  //@{
   typedef enum AudioEngineStreamOptions
   {
     /// force resample even if rates match
@@ -48,117 +45,218 @@ extern "C"
     /// autostart the stream when enough data is buffered
     AUDIO_STREAM_AUTOSTART = 1 << 2,
   } AudioEngineStreamOptions;
+  //@}
   //----------------------------------------------------------------------------
 
   //============================================================================
-  /// \ingroup cpp_kodi_audioengine_Defs
-  /// @brief The possible channels
+  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineChannel enum AudioEngineChannel
+  /// @ingroup cpp_kodi_audioengine_Defs
+  /// @brief **The possible channels**\n
+  /// Used to set available or used channels on stream.
+  ///
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Usage example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::audioengine::AudioEngineFormat format;
+  /// format.SetChannelLayout(std::vector<AudioEngineChannel>(AUDIOENGINE_CH_FL, AUDIOENGINE_CH_FR));
+  /// ~~~~~~~~~~~~~
   ///
+  //@{
   enum AudioEngineChannel
   {
+    /// Used inside to indicate the end of a list and not for addon use directly.
     AUDIOENGINE_CH_NULL = -1,
+    /// RAW Audio format
     AUDIOENGINE_CH_RAW,
-
+    /// Front left
     AUDIOENGINE_CH_FL,
+    /// Front right
     AUDIOENGINE_CH_FR,
+    /// Front center
     AUDIOENGINE_CH_FC,
+    /// LFE / Subwoofer
     AUDIOENGINE_CH_LFE,
+    /// Back left
     AUDIOENGINE_CH_BL,
+    /// Back right
     AUDIOENGINE_CH_BR,
+    /// Front left over center
     AUDIOENGINE_CH_FLOC,
+    /// Front right over center
     AUDIOENGINE_CH_FROC,
+    /// Back center
     AUDIOENGINE_CH_BC,
+    /// Side left
     AUDIOENGINE_CH_SL,
+    /// Side right
     AUDIOENGINE_CH_SR,
+    /// Top front left
     AUDIOENGINE_CH_TFL,
+    /// Top front right
     AUDIOENGINE_CH_TFR,
+    /// Top front center
     AUDIOENGINE_CH_TFC,
+    /// Top center
     AUDIOENGINE_CH_TC,
+    /// Top back left
     AUDIOENGINE_CH_TBL,
+    /// Top back right
     AUDIOENGINE_CH_TBR,
+    /// Top back center
     AUDIOENGINE_CH_TBC,
+    /// Back left over center
     AUDIOENGINE_CH_BLOC,
+    /// Back right over center
     AUDIOENGINE_CH_BROC,
-
+    /// Maximum possible value, to use e.g. as size inside list
     AUDIOENGINE_CH_MAX
   };
+  //@}
+  //----------------------------------------------------------------------------
 
   //============================================================================
-  /// \ingroup cpp_kodi_audioengine_Defs
-  /// @brief The various data formats
+  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineDataFormat enum AudioEngineDataFormat
+  /// @ingroup cpp_kodi_audioengine_Defs
+  /// @brief **Audio sample formats**\n
+  /// The bit layout of the audio data.
   ///
   /// LE = Little Endian, BE = Big Endian, NE = Native Endian
+  ///
+  /// For planar sample formats, each audio channel is in a separate data plane,
+  /// and linesize is the buffer size, in bytes, for a single plane. All data
+  /// planes must be the same size. For packed sample formats, only the first
+  /// data plane is used, and samples for each channel are interleaved. In this
+  /// case, linesize is the buffer size, in bytes, for the 1 plane.
+  ///
   /// @note This is ordered from the worst to best preferred formats
   ///
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Usage example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::audioengine::AudioEngineFormat format;
+  /// format.SetDataFormat(AUDIOENGINE_FMT_FLOATP);
+  /// ~~~~~~~~~~~~~
+  ///
+  //@{
   enum AudioEngineDataFormat
   {
+    /// To define format as invalid
     AUDIOENGINE_FMT_INVALID = -1,
 
+    /// Unsigned integer 8 bit
     AUDIOENGINE_FMT_U8,
 
+    /// Big Endian signed integer 16 bit
     AUDIOENGINE_FMT_S16BE,
+    /// Little Endian signed integer 16 bit
     AUDIOENGINE_FMT_S16LE,
+    /// Native Endian signed integer 16 bit
     AUDIOENGINE_FMT_S16NE,
 
+    /// Big Endian signed integer 32 bit
     AUDIOENGINE_FMT_S32BE,
+    /// Little Endian signed integer 32 bit
     AUDIOENGINE_FMT_S32LE,
+    /// Native Endian signed integer 32 bit
     AUDIOENGINE_FMT_S32NE,
 
+    /// Big Endian signed integer 24 bit (in 4 bytes)
     AUDIOENGINE_FMT_S24BE4,
+    /// Little Endian signed integer 24 bit (in 4 bytes)
     AUDIOENGINE_FMT_S24LE4,
-    AUDIOENGINE_FMT_S24NE4, // 24 bits in lower 3 bytes
-    AUDIOENGINE_FMT_S24NE4MSB, // S32 with bits_per_sample < 32
+    /// Native Endian signed integer 24 bit (in 4 bytes)
+    AUDIOENGINE_FMT_S24NE4,
+    /// S32 with bits_per_sample < 32
+    AUDIOENGINE_FMT_S24NE4MSB,
 
+    /// Big Endian signed integer 24 bit (3 bytes)
     AUDIOENGINE_FMT_S24BE3,
+    /// Little Endian signed integer 24 bit (3 bytes)
     AUDIOENGINE_FMT_S24LE3,
-    AUDIOENGINE_FMT_S24NE3, /* S24 in 3 bytes */
+     /// Native Endian signed integer 24 bit (3 bytes)
+    AUDIOENGINE_FMT_S24NE3,
 
+    /// Double floating point
     AUDIOENGINE_FMT_DOUBLE,
+    /// Floating point
     AUDIOENGINE_FMT_FLOAT,
 
-    // Bitstream
+    /// **Bitstream**\n
+    /// RAW Audio format
     AUDIOENGINE_FMT_RAW,
 
-    /* planar formats */
+    /// **Planar format**\n
+    /// Unsigned byte
     AUDIOENGINE_FMT_U8P,
+    /// **Planar format**\n
+    /// Native Endian signed 16 bit
     AUDIOENGINE_FMT_S16NEP,
+    /// **Planar format**\n
+    /// Native Endian signed 32 bit
     AUDIOENGINE_FMT_S32NEP,
+    /// **Planar format**\n
+    /// Native Endian signed integer 24 bit (in 4 bytes)
     AUDIOENGINE_FMT_S24NE4P,
+    /// **Planar format**\n
+    /// S32 with bits_per_sample < 32
     AUDIOENGINE_FMT_S24NE4MSBP,
+    /// **Planar format**\n
+    /// Native Endian signed integer 24 bit (in 3 bytes)
     AUDIOENGINE_FMT_S24NE3P,
+    /// **Planar format**\n
+    /// Double floating point
     AUDIOENGINE_FMT_DOUBLEP,
+    /// **Planar format**\n
+    /// Floating point
     AUDIOENGINE_FMT_FLOATP,
 
+    /// Amount of sample formats.
     AUDIOENGINE_FMT_MAX
   };
+  //@}
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief Internal API structure which are used for data exchange between
+   * Kodi and addon.
+   */
   struct AUDIO_ENGINE_FORMAT
   {
-    /// The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
+    /*! The stream's data format (eg, AUDIOENGINE_FMT_S16LE) */
     enum AudioEngineDataFormat m_dataFormat;
 
-    /// The stream's sample rate (eg, 48000)
+    /*! The stream's sample rate (eg, 48000) */
     unsigned int m_sampleRate;
 
-    /// The encoded streams sample rate if a bitstream, otherwise undefined
+    /*! The encoded streams sample rate if a bitstream, otherwise undefined */
     unsigned int m_encodedRate;
 
-    /// The amount of used speaker channels
+    /*! The amount of used speaker channels */
     unsigned int m_channelCount;
 
-    /// The stream's channel layout
+    /*! The stream's channel layout */
     enum AudioEngineChannel m_channels[AUDIOENGINE_CH_MAX];
 
-    /// The number of frames per period
+    /*! The number of frames per period */
     unsigned int m_frames;
 
-    /// The size of one frame in bytes
+    /*! The size of one frame in bytes */
     unsigned int m_frameSize;
   };
 
   /* A stream handle pointer, which is only used internally by the addon stream handle */
   typedef void AEStreamHandle;
 
+  //}}}
+
+  //
+  // "C" Internal interface tables for intercommunications between addon and kodi
+  //{{{
+
   /*
    * Function address structure, not need to visible on dev kit doxygen
    * documentation
@@ -203,24 +301,106 @@ extern "C"
     void (*aestream_set_resample_ratio)(void* kodiBase, AEStreamHandle* handle, double ratio);
   } AddonToKodiFuncTable_kodi_audioengine;
 
+  //}}}
+
+#ifdef __cplusplus
+}
+#endif
+
+//
+
 #ifdef __cplusplus
-} /* extern "C" */
 
 namespace kodi
 {
 namespace audioengine
 {
 
-//============================================================================
-/// \defgroup cpp_kodi_audioengine_Defs_AudioEngineFormat struct AudioEngineFormat
-/// \ingroup cpp_kodi_audioengine_Defs
-/// @brief The audio format structure that fully defines a stream's audio
-/// information
+//
+// Main page text for audio engine group by Doxygen.
+//{{{
+
+//==============================================================================
+///
+/// @defgroup cpp_kodi_audioengine  Interface - kodi::audioengine
+/// @ingroup cpp
+/// @brief **Audio engine functions**\n
+/// This interface contains auxiliary functions and classes which allow an addon
+/// to play their own individual audio stream in Kodi.
+///
+/// Using @ref cpp_kodi_audioengine_CAEStream "kodi::audioengine::CAEStream",
+/// a class can be created in this regard, about which the necessary stream data and
+/// information are given to Kodi.
+///
+/// Via @ref kodi::audioengine::GetCurrentSinkFormat(), the audio formats currently
+/// processed in Kodi can be called up beforehand in order to adapt your own stream
+/// to them.
+///
+/// However, the created stream can also differ from this because Kodi changes
+/// it to suit it.
+///
+///
+/// ------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.cpp}
+///
+/// #include <kodi/AudioEngine.h>
+///
+/// ...
+///
+/// kodi::audioengine::AudioEngineFormat format;
+/// if (!kodi::audioengine::GetCurrentSinkFormat(format))
+///   return false;
+///
+/// format.SetDataFormat(AUDIOENGINE_FMT_FLOATP);
+/// format.SetChannelLayout(std::vector<AudioEngineChannel>(AUDIOENGINE_CH_FL, AUDIOENGINE_CH_FR));
+///
+/// unsigned int myUsedSampleRate = format.GetSampleRate();
+///
+/// ...
+///
+/// kodi::audioengine::CAEStream* stream = new kodi::audioengine::CAEStream(format, AUDIO_STREAM_AUTOSTART);
+///
+/// ~~~~~~~~~~~~~
+///
+/// ------------------------------------------------------------------------
+///
+/// It has the header \ref AudioEngine.h "#include <kodi/AudioEngine.h>" be included
+/// to enjoy it.
+///
+//------------------------------------------------------------------------------
+
+//==============================================================================
+///
+/// @defgroup cpp_kodi_audioengine_Defs Definitions, structures and enumerators
+/// @ingroup cpp_kodi_audioengine
+/// @brief **Library definition values**\n
+/// All audio engine functions associated data structures.
+///
+//------------------------------------------------------------------------------
+
+//}}}
+
+//
+// "C++" related audio engine definitions
+//{{{
+
+//==============================================================================
+/// @defgroup cpp_kodi_audioengine_Defs_AudioEngineFormat class AudioEngineFormat
+/// @ingroup cpp_kodi_audioengine_Defs
+/// @brief **Audio format structure**\n
+/// The audio format structure that fully defines a stream's audio
+/// information.
+///
+/// With the help of this format information, Kodi adjusts its processing
+/// accordingly.
 ///
 //@{
 class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGINE_FORMAT>
 {
 public:
+  /*! \cond PRIVATE */
   AudioEngineFormat()
   {
     m_cStructure->m_dataFormat = AUDIOENGINE_FMT_INVALID;
@@ -236,23 +416,48 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
   AudioEngineFormat(const AudioEngineFormat& channel) : CStructHdl(channel) {}
   AudioEngineFormat(const AUDIO_ENGINE_FORMAT* channel) : CStructHdl(channel) {}
   AudioEngineFormat(AUDIO_ENGINE_FORMAT* channel) : CStructHdl(channel) {}
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineFormat_Help *Value Help*
+  /// @ingroup cpp_kodi_audioengine_Defs_AudioEngineFormat
+  /// ----------------------------------------------------------------------------
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_audioengine_Defs_AudioEngineFormat :</b>
+  /// | Name | Type | Set call | Get call
+  /// |------|------|----------|----------
+  /// | **Data format**, see @ref AudioEngineDataFormat for available types | enum | @ref AudioEngineFormat::SetDataFormat "SetDataFormat" | @ref AudioEngineFormat::GetDataFormat "GetDataFormat"
+  /// | **Sample rate** | unsigned int | @ref AudioEngineFormat::SetSampleRate "SetSampleRate" | @ref AudioEngineFormat::GetSampleRate "GetSampleRate"
+  /// | **Encoded rate** | unsigned int | @ref AudioEngineFormat::SetEncodedRate "SetEncodedRate" | @ref AudioEngineFormat::GetEncodedRate "GetEncodedRate"
+  /// | **Channel layout**, see @ref AudioEngineChannel for available types | std::vector<enum AudioEngineChannel> | @ref AudioEngineFormat::SetChannelLayout "SetChannelLayout" | @ref AudioEngineFormat::GetChannelLayout "GetChannelLayout"
+  /// | **Frames amount** | unsigned int | @ref AudioEngineFormat::SetFramesAmount "SetFramesAmount" | @ref AudioEngineFormat::GetFramesAmount "GetFramesAmount"
+  /// | **Frame size** | unsigned int | @ref AudioEngineFormat::SetFrameSize "SetFrameSize" | @ref AudioEngineFormat::GetFrameSize "GetFrameSize"
+  ///
+  /// Further is @ref AudioEngineFormat::CompareFormat "CompareFormat" included to compare this class with another.
+  ///
+
+  /// @addtogroup cpp_kodi_audioengine_Defs_AudioEngineFormat
+  /// @copydetails cpp_kodi_audioengine_Defs_AudioEngineFormat_Help
+  //@{
 
-  /// The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
+  /// @brief The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
   void SetDataFormat(enum AudioEngineDataFormat format) { m_cStructure->m_dataFormat = format; }
 
+  /// @brief To get with @ref SetDataFormat changed values.
   enum AudioEngineDataFormat GetDataFormat() const { return m_cStructure->m_dataFormat; }
 
-  /// The stream's sample rate (eg, 48000)
+  /// @brief The stream's sample rate (eg, 48000)
   void SetSampleRate(unsigned int rate) { m_cStructure->m_sampleRate = rate; }
 
+  /// @brief To get with @ref SetSampleRate changed values.
   unsigned int GetSampleRate() const { return m_cStructure->m_sampleRate; }
 
-  /// The encoded streams sample rate if a bitstream, otherwise undefined
+  /// @brief The encoded streams sample rate if a bitstream, otherwise undefined
   void SetEncodedRate(unsigned int rate) { m_cStructure->m_encodedRate = rate; }
 
+  /// @brief To get with @ref SetEncodedRate changed values.
   unsigned int GetEncodedRate() const { return m_cStructure->m_encodedRate; }
 
-  /// The stream's channel layout
+  /// @brief The stream's channel layout
   void SetChannelLayout(const std::vector<enum AudioEngineChannel>& layout)
   {
     // Reset first all to empty values to AUDIOENGINE_CH_NULL, in case given list is empty
@@ -266,6 +471,8 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
       m_cStructure->m_channelCount++;
     }
   }
+
+  /// @brief To get with @ref SetChannelLayout changed values.
   std::vector<enum AudioEngineChannel> GetChannelLayout() const
   {
     std::vector<enum AudioEngineChannel> channels;
@@ -279,17 +486,19 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
     return channels;
   }
 
-  /// The number of frames per period
+  /// @brief The number of frames per period
   void SetFramesAmount(unsigned int frames) { m_cStructure->m_frames = frames; }
 
+  /// @brief To get with @ref SetFramesAmount changed values.
   unsigned int GetFramesAmount() const { return m_cStructure->m_frames; }
 
-  /// The size of one frame in bytes
+  /// @brief The size of one frame in bytes
   void SetFrameSize(unsigned int frameSize) { m_cStructure->m_frameSize = frameSize; }
 
+  /// @brief To get with @ref SetFrameSize changed values.
   unsigned int GetFrameSize() const { return m_cStructure->m_frameSize; }
 
-  /// Function to compare the format structure with another
+  /// @brief Function to compare the format structure with another
   bool CompareFormat(const AudioEngineFormat* fmt)
   {
     if (!fmt)
@@ -321,14 +530,24 @@ class AudioEngineFormat : public addon::CStructHdl<AudioEngineFormat, AUDIO_ENGI
 //@}
 //----------------------------------------------------------------------------
 
+//}}}
+
+//
+// "C++" AudioEngine addon interface
+//{{{
+
 //============================================================================
 ///
-/// \defgroup cpp_kodi_audioengine_CAEStream class CAEStream
-/// \ingroup cpp_kodi_audioengine
-/// @brief **Audio Engine Stream Class**
+/// @defgroup cpp_kodi_audioengine_CAEStream class CAEStream
+/// @ingroup cpp_kodi_audioengine
+/// @brief **Audio Engine Stream Class**\n
+/// Class that can be created by the addon in order to be able to transfer
+/// audiostream data processed on the addon to Kodi and output it audibly.
 ///
+/// This can create individually several times and performed in different
+/// processes simultaneously.
 ///
-/// It has the header \ref AudioEngine.h "#include <kodi/AudioEngine.h>" be
+/// It has the header @ref AudioEngine.h "#include <kodi/AudioEngine.h>" be
 /// included to enjoy it.
 ///
 //----------------------------------------------------------------------------
@@ -347,31 +566,11 @@ class CAEStream
   /// ------------------------------------------------------------------------
   ///
   /// **Audio engine format information:**
-  /// @code
-  /// /*
-  ///  * Audio engine format information
-  ///  *
-  ///  * Only as example shown here! See always the original structure on related header.
-  ///  */
-  /// typedef struct AudioEngineFormat
-  /// {
-  ///   enum AEDataFormat    m_dataFormat;             /* The stream's data format (eg, AE_FMT_S16LE) */
-  ///   unsigned int         m_sampleRate;             /* The stream's sample rate (eg, 48000) */
-  ///   unsigned int         m_encodedRate;            /* The encoded streams sample rate if a bitstream, otherwise undefined */
-  ///   unsigned int         m_channelCount;           /* The amount of used speaker channels */
-  ///   enum AEChannel       m_channels[AE_CH_MAX];    /* The stream's channel layout */
-  ///   unsigned int         m_frames;                 /* The number of frames per period */
-  ///   unsigned int         m_frameSamples;           /* The number of samples in one frame */
-  ///   unsigned int         m_frameSize;              /* The size of one frame in bytes */
-  ///
-  ///   /* Function to compare the format structure with another */
-  ///   bool compareFormat(const AudioEngineFormat *fmt);
-  /// } AudioEngineFormat;
-  /// @endcode
+  /// @copydetails cpp_kodi_audioengine_Defs_AudioEngineFormat_Help
   ///
   /// ------------------------------------------------------------------------
   ///
-  /// **Bit options to pass to CAELib_Stream (on Kodi by <c>IAE::MakeStream</c>)**
+  /// **Bit options to pass (on Kodi by <c>IAE::MakeStream</c>)**
   ///
   /// | enum AEStreamOptions        | Value: | Description:
   /// |----------------------------:|:------:|:-----------------------------------
@@ -387,20 +586,17 @@ class CAEStream
   ///
   /// #include <kodi/AudioEngine.h>
   ///
-  /// using namespace kodi::audioengine;
-  ///
   /// ...
   ///
-  /// AudioEngineFormat format;
-  /// format.m_dataFormat = AE_FMT_FLOAT;
-  /// format.m_channelCount = 2;
-  /// format.m_channels[0] = AE_CH_FL;
-  /// format.m_channels[1] = AE_CH_FR;
-  /// format.m_channels[2] = AE_CH_NULL;
-  /// format.m_sampleRate = 48000;
-  /// format.m_frameSize = sizeof(float)*format.m_channelCount;
-  /// format.m_frames = 512;
-  /// CAddonAEStream* stream = new CAddonAEStream(format, AE_STREAM_AUTOSTART);
+  /// kodi::audioengine::AudioEngineFormat format;
+  ///
+  /// format.SetDataFormat(AUDIOENGINE_FMT_FLOATP); /* The stream's data format (eg, AUDIOENGINE_FMT_S16LE) */
+  /// format.SetChannelLayout(std::vector<AudioEngineChannel>(AUDIOENGINE_CH_FL, AUDIOENGINE_CH_FR)); /* The stream's channel layout */
+  /// format.SetSampleRate(48000); /* The stream's sample rate (eg, 48000) */
+  /// format.SetFrameSize(sizeof(float)*2); /* The size of one frame in bytes */
+  /// format.SetFramesAmount(882); /* The number of samples in one frame */
+  ///
+  /// kodi::audioengine::CAEStream* stream = new kodi::audioengine::CAEStream(format, AUDIO_STREAM_AUTOSTART);
   ///
   /// ~~~~~~~~~~~~~
   ///
@@ -418,7 +614,7 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Class destructor
+  /// @brief Class destructor.
   ///
   ~CAEStream()
   {
@@ -432,24 +628,24 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Returns the amount of space available in the stream
+  /// @brief Returns the amount of space available in the stream.
   ///
-  /// @return                 The number of bytes AddData will consume
+  /// @return The number of bytes AddData will consume
   ///
   unsigned int GetSpace() { return m_cb->aestream_get_space(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Add planar or interleaved PCM data to the stream
+  /// @brief Add planar or interleaved PCM data to the stream.
   ///
-  /// @param[in] data           array of pointers to the planes
-  /// @param[in] offset         to frame in frames
-  /// @param[in] frames         number of frames
-  /// @param[in] pts            [opt] presentation timestamp, default is 0
-  /// @param[in] hasDownmix     [opt] set true if downmix is present, default is false
+  /// @param[in] data array of pointers to the planes
+  /// @param[in] offset to frame in frames
+  /// @param[in] frames number of frames
+  /// @param[in] pts [opt] presentation timestamp, default is 0
+  /// @param[in] hasDownmix [opt] set true if downmix is present, default is false
   /// @param[in] centerMixLevel [opt] level to mix left and right to center default is 1.0
-  /// @return                   The number of frames consumed
+  /// @return The number of frames consumed
   ///
   unsigned int AddData(uint8_t* const* data,
                        unsigned int offset,
@@ -475,7 +671,7 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Returns if the stream is buffering
+  /// @brief Returns if the stream is buffering.
   ///
   /// @return True if the stream is buffering
   ///
@@ -494,7 +690,7 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Returns the total time in seconds of the cache
+  /// @brief Returns the total time in seconds of the cache.
   ///
   /// @return seconds
   ///
@@ -503,7 +699,7 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Pauses the stream playback
+  /// @brief Pauses the stream playback.
   ///
   void Pause() { return m_cb->aestream_pause(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
@@ -517,10 +713,10 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Start draining the stream
+  /// @brief Start draining the stream.
   ///
-  /// @param[in] wait         [opt] Wait until drain is finished if set to
-  ///                         true, otherwise it returns direct
+  /// @param[in] wait [opt] Wait until drain is finished if set to true,
+  ///                 otherwise it returns direct
   ///
   /// @note Once called AddData will not consume more data.
   ///
@@ -529,28 +725,28 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Returns true if the is stream draining
+  /// @brief Returns true if the is stream draining.
   ///
   bool IsDraining() { return m_cb->aestream_is_draining(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Returns true if the is stream has finished draining
+  /// @brief Returns true if the is stream has finished draining.
   ///
   bool IsDrained() { return m_cb->aestream_is_drained(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Flush all buffers dropping the audio data
+  /// @brief Flush all buffers dropping the audio data.
   ///
   void Flush() { return m_cb->aestream_flush(m_kodiBase, m_StreamHandle); }
   //--------------------------------------------------------------------------
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Return the stream's current volume level
+  /// @brief Return the stream's current volume level.
   ///
   /// @return The volume level between 0.0 and 1.0
   ///
@@ -559,7 +755,7 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Set the stream's volume level
+  /// @brief Set the stream's volume level.
   ///
   /// @param[in] volume               The new volume level between 0.0 and 1.0
   ///
@@ -582,8 +778,7 @@ class CAEStream
   /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Sets the stream's volume amplification in linear units.
   ///
-  /// @param[in] amplify              The volume amplification factor between
-  ///                                 1.0 and 1000.0
+  /// @param[in] amplify The volume amplification factor between 1.0 and 1000.0
   ///
   void SetAmplification(float amplify)
   {
@@ -593,7 +788,7 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Returns the size of one audio frame in bytes (channelCount * resolution)
+  /// @brief Returns the size of one audio frame in bytes (channelCount * resolution).
   ///
   /// @return The size in bytes of one frame
   ///
@@ -605,7 +800,7 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Returns the number of channels the stream is configured to accept
+  /// @brief Returns the number of channels the stream is configured to accept.
   ///
   /// @return The channel count
   ///
@@ -619,7 +814,7 @@ class CAEStream
   /// @ingroup cpp_kodi_audioengine_CAEStream
   /// @brief Returns the stream's sample rate, if the stream is using a dynamic
   /// sample rate, this value will NOT reflect any changes made by calls to
-  /// SetResampleRatio()
+  /// SetResampleRatio().
   ///
   /// @return The stream's sample rate (eg, 48000)
   ///
@@ -631,7 +826,7 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Return the data format the stream has been configured with
+  /// @brief Return the data format the stream has been configured with.
   ///
   /// @return The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
   ///
@@ -643,9 +838,9 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Return the resample ratio
+  /// @brief Return the resample ratio.
   ///
-  /// @note This will return an undefined value if the stream is not resampling
+  /// @note This will return an undefined value if the stream is not resampling.
   ///
   /// @return the current resample ratio or undefined if the stream is not resampling
   ///
@@ -657,13 +852,13 @@ class CAEStream
 
   //==========================================================================
   /// @ingroup cpp_kodi_audioengine_CAEStream
-  /// @brief Sets the resample ratio
+  /// @brief Sets the resample ratio.
   ///
   /// @note This function may return false if the stream is not resampling, if
-  /// you wish to use this be sure to set the AESTREAM_FORCE_RESAMPLE option
+  /// you wish to use this be sure to set the AESTREAM_FORCE_RESAMPLE option.
   ///
-  /// @param[in] ratio         the new sample rate ratio, calculated by
-  ///                          ((double)desiredRate / (double)GetSampleRate())
+  /// @param[in] ratio the new sample rate ratio, calculated by
+  ///                  ((double)desiredRate / (double)GetSampleRate())
   ///
   void SetResampleRatio(double ratio)
   {
@@ -676,14 +871,36 @@ class CAEStream
   AddonToKodiFuncTable_kodi_audioengine* m_cb;
   AEStreamHandle* m_StreamHandle;
 };
+//----------------------------------------------------------------------------
 
 //============================================================================
 /// @ingroup cpp_kodi_audioengine
-/// @brief Get the current sink data format
+/// @brief Get the current sink data format.
 ///
 /// @param[in] format Current sink data format. For more details see AudioEngineFormat.
 /// @return Returns true on success, else false.
 ///
+///
+/// ------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.cpp}
+///
+/// #include <kodi/AudioEngine.h>
+///
+/// ...
+///
+/// kodi::audioengine::AudioEngineFormat format;
+/// if (!kodi::audioengine::GetCurrentSinkFormat(format))
+///   return false;
+///
+/// std::vector<AudioEngineChannel> layout = format.GetChannelLayout();
+///
+/// ...
+/// return true;
+///
+/// ~~~~~~~~~~~~~
+///
 inline bool GetCurrentSinkFormat(AudioEngineFormat& format)
 {
   using namespace kodi::addon;
@@ -692,6 +909,9 @@ inline bool GetCurrentSinkFormat(AudioEngineFormat& format)
 }
 //----------------------------------------------------------------------------
 
+//}}}
+
 } // namespace audioengine
 } // namespace kodi
+
 #endif /* __cplusplus */

From 3f067ca4acef2775854f3c5be90d3e4256418376 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Fri, 8 May 2020 20:14:41 +0200
Subject: [PATCH 09/10] [addons][audioengine] separate "C" and "C++" parts of
 headers

By them becomes the "C" part placed in own header to see better what language
is where and to make easier for other languages.
---
 .../include/kodi/AudioEngine.h                | 300 +----------------
 .../include/kodi/c-api/CMakeLists.txt         |   3 +-
 .../include/kodi/c-api/audio_engine.h         | 308 ++++++++++++++++++
 .../include/kodi/versions.h                   |   3 +-
 4 files changed, 313 insertions(+), 301 deletions(-)
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/audio_engine.h

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
index bcf603e5cb18..464aba9f2a02 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
@@ -9,305 +9,7 @@
 #pragma once
 
 #include "AddonBase.h"
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif /* __cplusplus */
-
-  //
-  // "C" Definitions, structures and enumerators of audio engine
-  //{{{
-
-  //============================================================================
-  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineStreamOptions enum AudioEngineStreamOptions
-  /// @ingroup cpp_kodi_audioengine_Defs
-  /// @brief **Bit options to pass to CAEStream**\n
-  /// A bit field of stream options.
-  ///
-  ///
-  /// ------------------------------------------------------------------------
-  ///
-  /// **Usage example:**
-  /// ~~~~~~~~~~~~~{.cpp}
-  /// // Here only as minimal, "format" must be set to wanted types
-  /// kodi::audioengine::AudioEngineFormat format;
-  /// m_audioengine = new kodi::audioengine::CAEStream(format, AUDIO_STREAM_FORCE_RESAMPLE | AUDIO_STREAM_AUTOSTART);
-  /// ~~~~~~~~~~~~~
-  ///
-  //@{
-  typedef enum AudioEngineStreamOptions
-  {
-    /// force resample even if rates match
-    AUDIO_STREAM_FORCE_RESAMPLE = 1 << 0,
-    /// create the stream paused
-    AUDIO_STREAM_PAUSED = 1 << 1,
-    /// autostart the stream when enough data is buffered
-    AUDIO_STREAM_AUTOSTART = 1 << 2,
-  } AudioEngineStreamOptions;
-  //@}
-  //----------------------------------------------------------------------------
-
-  //============================================================================
-  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineChannel enum AudioEngineChannel
-  /// @ingroup cpp_kodi_audioengine_Defs
-  /// @brief **The possible channels**\n
-  /// Used to set available or used channels on stream.
-  ///
-  ///
-  /// ------------------------------------------------------------------------
-  ///
-  /// **Usage example:**
-  /// ~~~~~~~~~~~~~{.cpp}
-  /// kodi::audioengine::AudioEngineFormat format;
-  /// format.SetChannelLayout(std::vector<AudioEngineChannel>(AUDIOENGINE_CH_FL, AUDIOENGINE_CH_FR));
-  /// ~~~~~~~~~~~~~
-  ///
-  //@{
-  enum AudioEngineChannel
-  {
-    /// Used inside to indicate the end of a list and not for addon use directly.
-    AUDIOENGINE_CH_NULL = -1,
-    /// RAW Audio format
-    AUDIOENGINE_CH_RAW,
-    /// Front left
-    AUDIOENGINE_CH_FL,
-    /// Front right
-    AUDIOENGINE_CH_FR,
-    /// Front center
-    AUDIOENGINE_CH_FC,
-    /// LFE / Subwoofer
-    AUDIOENGINE_CH_LFE,
-    /// Back left
-    AUDIOENGINE_CH_BL,
-    /// Back right
-    AUDIOENGINE_CH_BR,
-    /// Front left over center
-    AUDIOENGINE_CH_FLOC,
-    /// Front right over center
-    AUDIOENGINE_CH_FROC,
-    /// Back center
-    AUDIOENGINE_CH_BC,
-    /// Side left
-    AUDIOENGINE_CH_SL,
-    /// Side right
-    AUDIOENGINE_CH_SR,
-    /// Top front left
-    AUDIOENGINE_CH_TFL,
-    /// Top front right
-    AUDIOENGINE_CH_TFR,
-    /// Top front center
-    AUDIOENGINE_CH_TFC,
-    /// Top center
-    AUDIOENGINE_CH_TC,
-    /// Top back left
-    AUDIOENGINE_CH_TBL,
-    /// Top back right
-    AUDIOENGINE_CH_TBR,
-    /// Top back center
-    AUDIOENGINE_CH_TBC,
-    /// Back left over center
-    AUDIOENGINE_CH_BLOC,
-    /// Back right over center
-    AUDIOENGINE_CH_BROC,
-    /// Maximum possible value, to use e.g. as size inside list
-    AUDIOENGINE_CH_MAX
-  };
-  //@}
-  //----------------------------------------------------------------------------
-
-  //============================================================================
-  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineDataFormat enum AudioEngineDataFormat
-  /// @ingroup cpp_kodi_audioengine_Defs
-  /// @brief **Audio sample formats**\n
-  /// The bit layout of the audio data.
-  ///
-  /// LE = Little Endian, BE = Big Endian, NE = Native Endian
-  ///
-  /// For planar sample formats, each audio channel is in a separate data plane,
-  /// and linesize is the buffer size, in bytes, for a single plane. All data
-  /// planes must be the same size. For packed sample formats, only the first
-  /// data plane is used, and samples for each channel are interleaved. In this
-  /// case, linesize is the buffer size, in bytes, for the 1 plane.
-  ///
-  /// @note This is ordered from the worst to best preferred formats
-  ///
-  ///
-  /// ------------------------------------------------------------------------
-  ///
-  /// **Usage example:**
-  /// ~~~~~~~~~~~~~{.cpp}
-  /// kodi::audioengine::AudioEngineFormat format;
-  /// format.SetDataFormat(AUDIOENGINE_FMT_FLOATP);
-  /// ~~~~~~~~~~~~~
-  ///
-  //@{
-  enum AudioEngineDataFormat
-  {
-    /// To define format as invalid
-    AUDIOENGINE_FMT_INVALID = -1,
-
-    /// Unsigned integer 8 bit
-    AUDIOENGINE_FMT_U8,
-
-    /// Big Endian signed integer 16 bit
-    AUDIOENGINE_FMT_S16BE,
-    /// Little Endian signed integer 16 bit
-    AUDIOENGINE_FMT_S16LE,
-    /// Native Endian signed integer 16 bit
-    AUDIOENGINE_FMT_S16NE,
-
-    /// Big Endian signed integer 32 bit
-    AUDIOENGINE_FMT_S32BE,
-    /// Little Endian signed integer 32 bit
-    AUDIOENGINE_FMT_S32LE,
-    /// Native Endian signed integer 32 bit
-    AUDIOENGINE_FMT_S32NE,
-
-    /// Big Endian signed integer 24 bit (in 4 bytes)
-    AUDIOENGINE_FMT_S24BE4,
-    /// Little Endian signed integer 24 bit (in 4 bytes)
-    AUDIOENGINE_FMT_S24LE4,
-    /// Native Endian signed integer 24 bit (in 4 bytes)
-    AUDIOENGINE_FMT_S24NE4,
-    /// S32 with bits_per_sample < 32
-    AUDIOENGINE_FMT_S24NE4MSB,
-
-    /// Big Endian signed integer 24 bit (3 bytes)
-    AUDIOENGINE_FMT_S24BE3,
-    /// Little Endian signed integer 24 bit (3 bytes)
-    AUDIOENGINE_FMT_S24LE3,
-     /// Native Endian signed integer 24 bit (3 bytes)
-    AUDIOENGINE_FMT_S24NE3,
-
-    /// Double floating point
-    AUDIOENGINE_FMT_DOUBLE,
-    /// Floating point
-    AUDIOENGINE_FMT_FLOAT,
-
-    /// **Bitstream**\n
-    /// RAW Audio format
-    AUDIOENGINE_FMT_RAW,
-
-    /// **Planar format**\n
-    /// Unsigned byte
-    AUDIOENGINE_FMT_U8P,
-    /// **Planar format**\n
-    /// Native Endian signed 16 bit
-    AUDIOENGINE_FMT_S16NEP,
-    /// **Planar format**\n
-    /// Native Endian signed 32 bit
-    AUDIOENGINE_FMT_S32NEP,
-    /// **Planar format**\n
-    /// Native Endian signed integer 24 bit (in 4 bytes)
-    AUDIOENGINE_FMT_S24NE4P,
-    /// **Planar format**\n
-    /// S32 with bits_per_sample < 32
-    AUDIOENGINE_FMT_S24NE4MSBP,
-    /// **Planar format**\n
-    /// Native Endian signed integer 24 bit (in 3 bytes)
-    AUDIOENGINE_FMT_S24NE3P,
-    /// **Planar format**\n
-    /// Double floating point
-    AUDIOENGINE_FMT_DOUBLEP,
-    /// **Planar format**\n
-    /// Floating point
-    AUDIOENGINE_FMT_FLOATP,
-
-    /// Amount of sample formats.
-    AUDIOENGINE_FMT_MAX
-  };
-  //@}
-  //----------------------------------------------------------------------------
-
-  /*!
-   * @brief Internal API structure which are used for data exchange between
-   * Kodi and addon.
-   */
-  struct AUDIO_ENGINE_FORMAT
-  {
-    /*! The stream's data format (eg, AUDIOENGINE_FMT_S16LE) */
-    enum AudioEngineDataFormat m_dataFormat;
-
-    /*! The stream's sample rate (eg, 48000) */
-    unsigned int m_sampleRate;
-
-    /*! The encoded streams sample rate if a bitstream, otherwise undefined */
-    unsigned int m_encodedRate;
-
-    /*! The amount of used speaker channels */
-    unsigned int m_channelCount;
-
-    /*! The stream's channel layout */
-    enum AudioEngineChannel m_channels[AUDIOENGINE_CH_MAX];
-
-    /*! The number of frames per period */
-    unsigned int m_frames;
-
-    /*! The size of one frame in bytes */
-    unsigned int m_frameSize;
-  };
-
-  /* A stream handle pointer, which is only used internally by the addon stream handle */
-  typedef void AEStreamHandle;
-
-  //}}}
-
-  //
-  // "C" Internal interface tables for intercommunications between addon and kodi
-  //{{{
-
-  /*
-   * Function address structure, not need to visible on dev kit doxygen
-   * documentation
-   */
-  typedef struct AddonToKodiFuncTable_kodi_audioengine
-  {
-    AEStreamHandle* (*make_stream)(void* kodiBase,
-                                   struct AUDIO_ENGINE_FORMAT* format,
-                                   unsigned int options);
-    void (*free_stream)(void* kodiBase, AEStreamHandle* stream);
-    bool (*get_current_sink_format)(void* kodiBase, struct AUDIO_ENGINE_FORMAT* sink_format);
-
-    // Audio Engine Stream definitions
-    unsigned int (*aestream_get_space)(void* kodiBase, AEStreamHandle* handle);
-    unsigned int (*aestream_add_data)(void* kodiBase,
-                                      AEStreamHandle* handle,
-                                      uint8_t* const* data,
-                                      unsigned int offset,
-                                      unsigned int frames,
-                                      double pts,
-                                      bool hasDownmix,
-                                      double centerMixLevel);
-    double (*aestream_get_delay)(void* kodiBase, AEStreamHandle* handle);
-    bool (*aestream_is_buffering)(void* kodiBase, AEStreamHandle* handle);
-    double (*aestream_get_cache_time)(void* kodiBase, AEStreamHandle* handle);
-    double (*aestream_get_cache_total)(void* kodiBase, AEStreamHandle* handle);
-    void (*aestream_pause)(void* kodiBase, AEStreamHandle* handle);
-    void (*aestream_resume)(void* kodiBase, AEStreamHandle* handle);
-    void (*aestream_drain)(void* kodiBase, AEStreamHandle* handle, bool wait);
-    bool (*aestream_is_draining)(void* kodiBase, AEStreamHandle* handle);
-    bool (*aestream_is_drained)(void* kodiBase, AEStreamHandle* handle);
-    void (*aestream_flush)(void* kodiBase, AEStreamHandle* handle);
-    float (*aestream_get_volume)(void* kodiBase, AEStreamHandle* handle);
-    void (*aestream_set_volume)(void* kodiBase, AEStreamHandle* handle, float volume);
-    float (*aestream_get_amplification)(void* kodiBase, AEStreamHandle* handle);
-    void (*aestream_set_amplification)(void* kodiBase, AEStreamHandle* handle, float amplify);
-    unsigned int (*aestream_get_frame_size)(void* kodiBase, AEStreamHandle* handle);
-    unsigned int (*aestream_get_channel_count)(void* kodiBase, AEStreamHandle* handle);
-    unsigned int (*aestream_get_sample_rate)(void* kodiBase, AEStreamHandle* handle);
-    enum AudioEngineDataFormat (*aestream_get_data_format)(void* kodiBase, AEStreamHandle* handle);
-    double (*aestream_get_resample_ratio)(void* kodiBase, AEStreamHandle* handle);
-    void (*aestream_set_resample_ratio)(void* kodiBase, AEStreamHandle* handle, double ratio);
-  } AddonToKodiFuncTable_kodi_audioengine;
-
-  //}}}
-
-#ifdef __cplusplus
-}
-#endif
-
-//
+#include "c-api/audio_engine.h"
 
 #ifdef __cplusplus
 
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/CMakeLists.txt
index 6f2fff93299b..000444977ce0 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/CMakeLists.txt
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/CMakeLists.txt
@@ -1,4 +1,5 @@
-set(HEADERS network.h)
+set(HEADERS audio_engine.h
+            network.h)
 
 if(NOT ENABLE_STATIC_LIBS)
   core_add_library(addons_kodi-addon-dev-kit_include_kodi_c-api)
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/audio_engine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/audio_engine.h
new file mode 100644
index 000000000000..02e96ac5d56e
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/audio_engine.h
@@ -0,0 +1,308 @@
+/*
+ *  Copyright (C) 2005-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "stdint.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  //
+  // "C" Definitions, structures and enumerators of audio engine
+  //{{{
+
+  //============================================================================
+  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineStreamOptions enum AudioEngineStreamOptions
+  /// @ingroup cpp_kodi_audioengine_Defs
+  /// @brief **Bit options to pass to CAEStream**\n
+  /// A bit field of stream options.
+  ///
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Usage example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// // Here only as minimal, "format" must be set to wanted types
+  /// kodi::audioengine::AudioEngineFormat format;
+  /// m_audioengine = new kodi::audioengine::CAEStream(format, AUDIO_STREAM_FORCE_RESAMPLE | AUDIO_STREAM_AUTOSTART);
+  /// ~~~~~~~~~~~~~
+  ///
+  //@{
+  typedef enum AudioEngineStreamOptions
+  {
+    /// force resample even if rates match
+    AUDIO_STREAM_FORCE_RESAMPLE = 1 << 0,
+    /// create the stream paused
+    AUDIO_STREAM_PAUSED = 1 << 1,
+    /// autostart the stream when enough data is buffered
+    AUDIO_STREAM_AUTOSTART = 1 << 2,
+  } AudioEngineStreamOptions;
+  //@}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineChannel enum AudioEngineChannel
+  /// @ingroup cpp_kodi_audioengine_Defs
+  /// @brief **The possible channels**\n
+  /// Used to set available or used channels on stream.
+  ///
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Usage example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::audioengine::AudioEngineFormat format;
+  /// format.SetChannelLayout(std::vector<AudioEngineChannel>(AUDIOENGINE_CH_FL, AUDIOENGINE_CH_FR));
+  /// ~~~~~~~~~~~~~
+  ///
+  //@{
+  enum AudioEngineChannel
+  {
+    /// Used inside to indicate the end of a list and not for addon use directly.
+    AUDIOENGINE_CH_NULL = -1,
+    /// RAW Audio format
+    AUDIOENGINE_CH_RAW,
+    /// Front left
+    AUDIOENGINE_CH_FL,
+    /// Front right
+    AUDIOENGINE_CH_FR,
+    /// Front center
+    AUDIOENGINE_CH_FC,
+    /// LFE / Subwoofer
+    AUDIOENGINE_CH_LFE,
+    /// Back left
+    AUDIOENGINE_CH_BL,
+    /// Back right
+    AUDIOENGINE_CH_BR,
+    /// Front left over center
+    AUDIOENGINE_CH_FLOC,
+    /// Front right over center
+    AUDIOENGINE_CH_FROC,
+    /// Back center
+    AUDIOENGINE_CH_BC,
+    /// Side left
+    AUDIOENGINE_CH_SL,
+    /// Side right
+    AUDIOENGINE_CH_SR,
+    /// Top front left
+    AUDIOENGINE_CH_TFL,
+    /// Top front right
+    AUDIOENGINE_CH_TFR,
+    /// Top front center
+    AUDIOENGINE_CH_TFC,
+    /// Top center
+    AUDIOENGINE_CH_TC,
+    /// Top back left
+    AUDIOENGINE_CH_TBL,
+    /// Top back right
+    AUDIOENGINE_CH_TBR,
+    /// Top back center
+    AUDIOENGINE_CH_TBC,
+    /// Back left over center
+    AUDIOENGINE_CH_BLOC,
+    /// Back right over center
+    AUDIOENGINE_CH_BROC,
+    /// Maximum possible value, to use e.g. as size inside list
+    AUDIOENGINE_CH_MAX
+  };
+  //@}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @defgroup cpp_kodi_audioengine_Defs_AudioEngineDataFormat enum AudioEngineDataFormat
+  /// @ingroup cpp_kodi_audioengine_Defs
+  /// @brief **Audio sample formats**\n
+  /// The bit layout of the audio data.
+  ///
+  /// LE = Little Endian, BE = Big Endian, NE = Native Endian
+  ///
+  /// For planar sample formats, each audio channel is in a separate data plane,
+  /// and linesize is the buffer size, in bytes, for a single plane. All data
+  /// planes must be the same size. For packed sample formats, only the first
+  /// data plane is used, and samples for each channel are interleaved. In this
+  /// case, linesize is the buffer size, in bytes, for the 1 plane.
+  ///
+  /// @note This is ordered from the worst to best preferred formats
+  ///
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Usage example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::audioengine::AudioEngineFormat format;
+  /// format.SetDataFormat(AUDIOENGINE_FMT_FLOATP);
+  /// ~~~~~~~~~~~~~
+  ///
+  //@{
+  enum AudioEngineDataFormat
+  {
+    /// To define format as invalid
+    AUDIOENGINE_FMT_INVALID = -1,
+
+    /// Unsigned integer 8 bit
+    AUDIOENGINE_FMT_U8,
+
+    /// Big Endian signed integer 16 bit
+    AUDIOENGINE_FMT_S16BE,
+    /// Little Endian signed integer 16 bit
+    AUDIOENGINE_FMT_S16LE,
+    /// Native Endian signed integer 16 bit
+    AUDIOENGINE_FMT_S16NE,
+
+    /// Big Endian signed integer 32 bit
+    AUDIOENGINE_FMT_S32BE,
+    /// Little Endian signed integer 32 bit
+    AUDIOENGINE_FMT_S32LE,
+    /// Native Endian signed integer 32 bit
+    AUDIOENGINE_FMT_S32NE,
+
+    /// Big Endian signed integer 24 bit (in 4 bytes)
+    AUDIOENGINE_FMT_S24BE4,
+    /// Little Endian signed integer 24 bit (in 4 bytes)
+    AUDIOENGINE_FMT_S24LE4,
+    /// Native Endian signed integer 24 bit (in 4 bytes)
+    AUDIOENGINE_FMT_S24NE4,
+    /// S32 with bits_per_sample < 32
+    AUDIOENGINE_FMT_S24NE4MSB,
+
+    /// Big Endian signed integer 24 bit (3 bytes)
+    AUDIOENGINE_FMT_S24BE3,
+    /// Little Endian signed integer 24 bit (3 bytes)
+    AUDIOENGINE_FMT_S24LE3,
+     /// Native Endian signed integer 24 bit (3 bytes)
+    AUDIOENGINE_FMT_S24NE3,
+
+    /// Double floating point
+    AUDIOENGINE_FMT_DOUBLE,
+    /// Floating point
+    AUDIOENGINE_FMT_FLOAT,
+
+    /// **Bitstream**\n
+    /// RAW Audio format
+    AUDIOENGINE_FMT_RAW,
+
+    /// **Planar format**\n
+    /// Unsigned byte
+    AUDIOENGINE_FMT_U8P,
+    /// **Planar format**\n
+    /// Native Endian signed 16 bit
+    AUDIOENGINE_FMT_S16NEP,
+    /// **Planar format**\n
+    /// Native Endian signed 32 bit
+    AUDIOENGINE_FMT_S32NEP,
+    /// **Planar format**\n
+    /// Native Endian signed integer 24 bit (in 4 bytes)
+    AUDIOENGINE_FMT_S24NE4P,
+    /// **Planar format**\n
+    /// S32 with bits_per_sample < 32
+    AUDIOENGINE_FMT_S24NE4MSBP,
+    /// **Planar format**\n
+    /// Native Endian signed integer 24 bit (in 3 bytes)
+    AUDIOENGINE_FMT_S24NE3P,
+    /// **Planar format**\n
+    /// Double floating point
+    AUDIOENGINE_FMT_DOUBLEP,
+    /// **Planar format**\n
+    /// Floating point
+    AUDIOENGINE_FMT_FLOATP,
+
+    /// Amount of sample formats.
+    AUDIOENGINE_FMT_MAX
+  };
+  //@}
+  //----------------------------------------------------------------------------
+
+  /*!
+   * @brief Internal API structure which are used for data exchange between
+   * Kodi and addon.
+   */
+  struct AUDIO_ENGINE_FORMAT
+  {
+    /*! The stream's data format (eg, AUDIOENGINE_FMT_S16LE) */
+    enum AudioEngineDataFormat m_dataFormat;
+
+    /*! The stream's sample rate (eg, 48000) */
+    unsigned int m_sampleRate;
+
+    /*! The encoded streams sample rate if a bitstream, otherwise undefined */
+    unsigned int m_encodedRate;
+
+    /*! The amount of used speaker channels */
+    unsigned int m_channelCount;
+
+    /*! The stream's channel layout */
+    enum AudioEngineChannel m_channels[AUDIOENGINE_CH_MAX];
+
+    /*! The number of frames per period */
+    unsigned int m_frames;
+
+    /*! The size of one frame in bytes */
+    unsigned int m_frameSize;
+  };
+
+  /* A stream handle pointer, which is only used internally by the addon stream handle */
+  typedef void AEStreamHandle;
+
+  //}}}
+
+  //
+  // "C" Internal interface tables for intercommunications between addon and kodi
+  //{{{
+
+  /*
+   * Function address structure, not need to visible on dev kit doxygen
+   * documentation
+   */
+  typedef struct AddonToKodiFuncTable_kodi_audioengine
+  {
+    AEStreamHandle* (*make_stream)(void* kodiBase,
+                                   struct AUDIO_ENGINE_FORMAT* format,
+                                   unsigned int options);
+    void (*free_stream)(void* kodiBase, AEStreamHandle* stream);
+    bool (*get_current_sink_format)(void* kodiBase, struct AUDIO_ENGINE_FORMAT* sink_format);
+
+    // Audio Engine Stream definitions
+    unsigned int (*aestream_get_space)(void* kodiBase, AEStreamHandle* handle);
+    unsigned int (*aestream_add_data)(void* kodiBase,
+                                      AEStreamHandle* handle,
+                                      uint8_t* const* data,
+                                      unsigned int offset,
+                                      unsigned int frames,
+                                      double pts,
+                                      bool hasDownmix,
+                                      double centerMixLevel);
+    double (*aestream_get_delay)(void* kodiBase, AEStreamHandle* handle);
+    bool (*aestream_is_buffering)(void* kodiBase, AEStreamHandle* handle);
+    double (*aestream_get_cache_time)(void* kodiBase, AEStreamHandle* handle);
+    double (*aestream_get_cache_total)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_pause)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_resume)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_drain)(void* kodiBase, AEStreamHandle* handle, bool wait);
+    bool (*aestream_is_draining)(void* kodiBase, AEStreamHandle* handle);
+    bool (*aestream_is_drained)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_flush)(void* kodiBase, AEStreamHandle* handle);
+    float (*aestream_get_volume)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_set_volume)(void* kodiBase, AEStreamHandle* handle, float volume);
+    float (*aestream_get_amplification)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_set_amplification)(void* kodiBase, AEStreamHandle* handle, float amplify);
+    unsigned int (*aestream_get_frame_size)(void* kodiBase, AEStreamHandle* handle);
+    unsigned int (*aestream_get_channel_count)(void* kodiBase, AEStreamHandle* handle);
+    unsigned int (*aestream_get_sample_rate)(void* kodiBase, AEStreamHandle* handle);
+    enum AudioEngineDataFormat (*aestream_get_data_format)(void* kodiBase, AEStreamHandle* handle);
+    double (*aestream_get_resample_ratio)(void* kodiBase, AEStreamHandle* handle);
+    void (*aestream_set_resample_ratio)(void* kodiBase, AEStreamHandle* handle, double ratio);
+  } AddonToKodiFuncTable_kodi_audioengine;
+
+  //}}}
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index 1b3549d6187e..77a64693185a 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -52,7 +52,8 @@
 #define ADDON_GLOBAL_VERSION_AUDIOENGINE              "1.0.2"
 #define ADDON_GLOBAL_VERSION_AUDIOENGINE_MIN          "1.0.2"
 #define ADDON_GLOBAL_VERSION_AUDIOENGINE_XML_ID       "kodi.binary.global.audioengine"
-#define ADDON_GLOBAL_VERSION_AUDIOENGINE_DEPENDS      "AudioEngine.h"
+#define ADDON_GLOBAL_VERSION_AUDIOENGINE_DEPENDS      "AudioEngine.h" \
+                                                      "c-api/audio_engine.h"
 
 #define ADDON_GLOBAL_VERSION_FILESYSTEM               "1.0.3"
 #define ADDON_GLOBAL_VERSION_FILESYSTEM_MIN           "1.0.3"

From d15b60d99be3dc70fa33bea17bf928806ea9e681 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Wed, 15 Apr 2020 03:14:56 +0200
Subject: [PATCH 10/10] [addons][audioengine] increase API version to 1.1.0

---
 xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index 77a64693185a..38a5f53b1a8b 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -49,8 +49,8 @@
 #define ADDON_GLOBAL_VERSION_GUI_DEPENDS              "libKODI_guilib.h" \
                                                       "gui/"
 
-#define ADDON_GLOBAL_VERSION_AUDIOENGINE              "1.0.2"
-#define ADDON_GLOBAL_VERSION_AUDIOENGINE_MIN          "1.0.2"
+#define ADDON_GLOBAL_VERSION_AUDIOENGINE              "1.1.0"
+#define ADDON_GLOBAL_VERSION_AUDIOENGINE_MIN          "1.1.0"
 #define ADDON_GLOBAL_VERSION_AUDIOENGINE_XML_ID       "kodi.binary.global.audioengine"
 #define ADDON_GLOBAL_VERSION_AUDIOENGINE_DEPENDS      "AudioEngine.h" \
                                                       "c-api/audio_engine.h"
