From 045688b6d035776a4ed5a1911d63aa7217b14e22 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Sun, 3 May 2020 14:25:50 +0200
Subject: [PATCH 01/27] [addons][pvr] add instance pointer value to addon call
 functions

Needed to give on next steps the addon his class pointer.
---
 .../include/kodi/xbmc_pvr_dll.h               | 196 +++++++++++-------
 .../include/kodi/xbmc_pvr_types.h             | 153 +++++++-------
 xbmc/pvr/addons/PVRClient.cpp                 | 163 ++++++++-------
 3 files changed, 285 insertions(+), 227 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_dll.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_dll.h
index 72e26046e7b0..86f6f0543450 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_dll.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_dll.h
@@ -30,25 +30,26 @@ extern "C"
    * @return PVR_ERROR_NO_ERROR if the properties were fetched successfully.
    * @remarks Valid implementation required.
    */
-  PVR_ERROR GetCapabilities(PVR_ADDON_CAPABILITIES* pCapabilities);
+  PVR_ERROR GetCapabilities(const AddonInstance_PVR* instance,
+                            PVR_ADDON_CAPABILITIES* pCapabilities);
 
   /*!
    * @return The name reported by the backend that will be displayed in the UI.
    * @remarks Valid implementation required.
    */
-  const char* GetBackendName(void);
+  const char* GetBackendName(const AddonInstance_PVR* instance);
 
   /*!
    * @return The version string reported by the backend that will be displayed in the UI.
    * @remarks Valid implementation required.
    */
-  const char* GetBackendVersion(void);
+  const char* GetBackendVersion(const AddonInstance_PVR* instance);
 
   /*!
    * @return The connection string reported by the backend that will be displayed in the UI.
    * @remarks Valid implementation required.
    */
-  const char* GetConnectionString(void);
+  const char* GetConnectionString(const AddonInstance_PVR* instance);
 
   /*!
    * Get the disk space reported by the backend (if supported).
@@ -57,7 +58,7 @@ extern "C"
    * @return PVR_ERROR_NO_ERROR if the drive space has been fetched successfully.
    * @remarks Optional. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetDriveSpace(long long* iTotal, long long* iUsed);
+  PVR_ERROR GetDriveSpace(const AddonInstance_PVR* instance, long long* iTotal, long long* iUsed);
 
   /*!
    * Call one of the menu hooks (if supported).
@@ -67,7 +68,9 @@ extern "C"
    * @return PVR_ERROR_NO_ERROR if the hook was called successfully.
    * @remarks Optional. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR CallMenuHook(const PVR_MENUHOOK& menuhook, const PVR_MENUHOOK_DATA &item);
+  PVR_ERROR CallMenuHook(const AddonInstance_PVR* instance,
+                         const PVR_MENUHOOK& menuhook,
+                         const PVR_MENUHOOK_DATA& item);
   //@}
 
   /*! @name PVR EPG methods
@@ -85,7 +88,11 @@ extern "C"
    * @remarks Required if bSupportsEPG is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetEPGForChannel(ADDON_HANDLE handle, int iChannelUid, time_t iStart, time_t iEnd);
+  PVR_ERROR GetEPGForChannel(const AddonInstance_PVR* instance,
+                             ADDON_HANDLE handle,
+                             int iChannelUid,
+                             time_t iStart,
+                             time_t iEnd);
 
   /*
    * Check if the given EPG tag can be recorded.
@@ -94,7 +101,9 @@ extern "C"
    * @return PVR_ERROR_NO_ERROR if bIsRecordable has been set successfully.
    * @remarks Optional, return PVR_ERROR_NOT_IMPLEMENTED to let Kodi decide.
    */
-  PVR_ERROR IsEPGTagRecordable(const EPG_TAG* tag, bool* bIsRecordable);
+  PVR_ERROR IsEPGTagRecordable(const AddonInstance_PVR* instance,
+                               const EPG_TAG* tag,
+                               bool* bIsRecordable);
 
   /*
    * Check if the given EPG tag can be played.
@@ -104,7 +113,9 @@ extern "C"
    * @remarks Required if add-on supports playing epg tags.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR IsEPGTagPlayable(const EPG_TAG* tag, bool* bIsPlayable);
+  PVR_ERROR IsEPGTagPlayable(const AddonInstance_PVR* instance,
+                             const EPG_TAG* tag,
+                             bool* bIsPlayable);
 
   /*!
    * Retrieve the edit decision list (EDL) of an EPG tag on the backend.
@@ -115,7 +126,10 @@ extern "C"
    * @remarks Required if bSupportsEpgEdl is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetEPGTagEdl(const EPG_TAG* epgTag, PVR_EDL_ENTRY edl[], int *size);
+  PVR_ERROR GetEPGTagEdl(const AddonInstance_PVR* instance,
+                         const EPG_TAG* epgTag,
+                         PVR_EDL_ENTRY edl[],
+                         int* size);
 
   /*!
    * Get the stream properties for an epg tag from the backend.
@@ -127,7 +141,10 @@ extern "C"
    *          In this case your implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the epg tag.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetEPGTagStreamProperties(const EPG_TAG* tag, PVR_NAMED_VALUE* properties, unsigned int* iPropertiesCount);
+  PVR_ERROR GetEPGTagStreamProperties(const AddonInstance_PVR* instance,
+                                      const EPG_TAG* tag,
+                                      PVR_NAMED_VALUE* properties,
+                                      unsigned int* iPropertiesCount);
 
   //@}
 
@@ -143,7 +160,7 @@ extern "C"
    * @remarks Required if bSupportsChannelGroups is set to true.
    *          Return -1 if this add-on won't provide this function.
    */
-  int GetChannelGroupsAmount(void);
+  int GetChannelGroupsAmount(const AddonInstance_PVR* instance);
 
   /*!
    * Request the list of all channel groups from the backend if it supports channel groups.
@@ -154,7 +171,7 @@ extern "C"
    * @remarks Required if bSupportsChannelGroups is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetChannelGroups(ADDON_HANDLE handle, bool bRadio);
+  PVR_ERROR GetChannelGroups(const AddonInstance_PVR* instance, ADDON_HANDLE handle, bool bRadio);
 
   /*!
    * Request the list of all group members of a group from the backend if it supports channel groups.
@@ -165,7 +182,9 @@ extern "C"
    * @remarks Required if bSupportsChannelGroups is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetChannelGroupMembers(ADDON_HANDLE handle, const PVR_CHANNEL_GROUP& group);
+  PVR_ERROR GetChannelGroupMembers(const AddonInstance_PVR* instance,
+                                   ADDON_HANDLE handle,
+                                   const PVR_CHANNEL_GROUP& group);
   //@}
 
   /** @name PVR channel methods
@@ -181,13 +200,13 @@ extern "C"
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    * @note see libKODI_guilib.h about related parts
    */
-  PVR_ERROR OpenDialogChannelScan(void);
+  PVR_ERROR OpenDialogChannelScan(const AddonInstance_PVR* instance);
 
   /*!
    * @return The total amount of channels on the backend, or -1 on error.
    * @remarks Valid implementation required.
    */
-  int GetChannelsAmount(void);
+  int GetChannelsAmount(const AddonInstance_PVR* instance);
 
   /*!
    * Request the list of all channels from the backend.
@@ -199,7 +218,7 @@ extern "C"
    *          If bSupportsRadio is set to true, a valid result set needs to be provided for bRadio = true.
    *          At least one of these two must provide a valid result set.
    */
-  PVR_ERROR GetChannels(ADDON_HANDLE handle, bool bRadio);
+  PVR_ERROR GetChannels(const AddonInstance_PVR* instance, ADDON_HANDLE handle, bool bRadio);
 
   /*!
    * Delete a channel from the backend.
@@ -207,7 +226,7 @@ extern "C"
    * @return PVR_ERROR_NO_ERROR if the channel has been deleted successfully.
    * @remarks Required if bSupportsChannelSettings is set to true.
    */
-  PVR_ERROR DeleteChannel(const PVR_CHANNEL& channel);
+  PVR_ERROR DeleteChannel(const AddonInstance_PVR* instance, const PVR_CHANNEL& channel);
 
   /*!
    * Rename a channel on the backend.
@@ -216,7 +235,7 @@ extern "C"
    * @remarks Optional, and only used if bSupportsChannelSettings is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR RenameChannel(const PVR_CHANNEL& channel);
+  PVR_ERROR RenameChannel(const AddonInstance_PVR* instance, const PVR_CHANNEL& channel);
 
   /*!
    * Show the channel settings dialog, if supported by the backend.
@@ -225,7 +244,8 @@ extern "C"
    * @remarks Required if bSupportsChannelSettings is set to true.
    * @note see libKODI_guilib.h about related parts
    */
-  PVR_ERROR OpenDialogChannelSettings(const PVR_CHANNEL& channel);
+  PVR_ERROR OpenDialogChannelSettings(const AddonInstance_PVR* instance,
+                                      const PVR_CHANNEL& channel);
 
   /*!
    * Show the dialog to add a channel on the backend, if supported by the backend.
@@ -234,7 +254,7 @@ extern "C"
    * @remarks Required if bSupportsChannelSettings is set to true.
    * @note see libKODI_guilib.h about related parts
    */
-  PVR_ERROR OpenDialogChannelAdd(const PVR_CHANNEL& channel);
+  PVR_ERROR OpenDialogChannelAdd(const AddonInstance_PVR* instance, const PVR_CHANNEL& channel);
   //@}
 
   /** @name PVR recording methods
@@ -248,7 +268,7 @@ extern "C"
    * @param deleted if set return deleted recording (called if bSupportsRecordingsUndelete set to true)
    * @remarks Required if bSupportsRecordings is set to true. Return -1 if this add-on won't provide this function.
    */
-  int GetRecordingsAmount(bool deleted);
+  int GetRecordingsAmount(const AddonInstance_PVR* instance, bool deleted);
 
   /*!
    * Request the list of all recordings from the backend, if supported.
@@ -259,7 +279,7 @@ extern "C"
    * @remarks Required if bSupportsRecordings is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetRecordings(ADDON_HANDLE handle, bool deleted);
+  PVR_ERROR GetRecordings(const AddonInstance_PVR* instance, ADDON_HANDLE handle, bool deleted);
 
   /*!
    * Delete a recording on the backend.
@@ -268,7 +288,7 @@ extern "C"
    * @remarks Optional, and only used if bSupportsRecordings is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR DeleteRecording(const PVR_RECORDING& recording);
+  PVR_ERROR DeleteRecording(const AddonInstance_PVR* instance, const PVR_RECORDING& recording);
 
   /*!
    * Undelete a recording on the backend.
@@ -277,13 +297,13 @@ extern "C"
    * @remarks Optional, and only used if bSupportsRecordingsUndelete is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR UndeleteRecording(const PVR_RECORDING& recording);
+  PVR_ERROR UndeleteRecording(const AddonInstance_PVR* instance, const PVR_RECORDING& recording);
 
   /*!
    * @brief Delete all recordings permanent which in the deleted folder on the backend.
    * @return PVR_ERROR_NO_ERROR if the recordings has been deleted successfully.
    */
-  PVR_ERROR DeleteAllRecordingsFromTrash();
+  PVR_ERROR DeleteAllRecordingsFromTrash(const AddonInstance_PVR* instance);
 
   /*!
    * Rename a recording on the backend.
@@ -292,7 +312,7 @@ extern "C"
    * @remarks Optional, and only used if bSupportsRecordings is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR RenameRecording(const PVR_RECORDING& recording);
+  PVR_ERROR RenameRecording(const AddonInstance_PVR* instance, const PVR_RECORDING& recording);
 
   /*!
    * Set the lifetime of a recording on the backend.
@@ -301,7 +321,7 @@ extern "C"
    * @remarks Required if bSupportsRecordingsLifetimeChange is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR SetRecordingLifetime(const PVR_RECORDING* recording);
+  PVR_ERROR SetRecordingLifetime(const AddonInstance_PVR* instance, const PVR_RECORDING* recording);
 
   /*!
    * Set the play count of a recording on the backend.
@@ -311,7 +331,9 @@ extern "C"
    * @remarks Required if bSupportsRecordingPlayCount is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR SetRecordingPlayCount(const PVR_RECORDING& recording, int count);
+  PVR_ERROR SetRecordingPlayCount(const AddonInstance_PVR* instance,
+                                  const PVR_RECORDING& recording,
+                                  int count);
 
   /*!
    * Set the last watched position of a recording on the backend.
@@ -321,7 +343,9 @@ extern "C"
    * @remarks Required if bSupportsLastPlayedPosition is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR SetRecordingLastPlayedPosition(const PVR_RECORDING& recording, int lastplayedposition);
+  PVR_ERROR SetRecordingLastPlayedPosition(const AddonInstance_PVR* instance,
+                                           const PVR_RECORDING& recording,
+                                           int lastplayedposition);
 
   /*!
    * Retrieve the last watched position of a recording on the backend.
@@ -330,7 +354,8 @@ extern "C"
    * @remarks Required if bSupportsRecordingPlayCount is set to true.
    *          Return -1 if this add-on won't provide this function.
    */
-  int GetRecordingLastPlayedPosition(const PVR_RECORDING& recording);
+  int GetRecordingLastPlayedPosition(const AddonInstance_PVR* instance,
+                                     const PVR_RECORDING& recording);
 
   /*!
    * Retrieve the edit decision list (EDL) of a recording on the backend.
@@ -341,7 +366,10 @@ extern "C"
    * @remarks Required if bSupportsRecordingEdl is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetRecordingEdl(const PVR_RECORDING& recording, PVR_EDL_ENTRY edl[], int *size);
+  PVR_ERROR GetRecordingEdl(const AddonInstance_PVR* instance,
+                            const PVR_RECORDING& recording,
+                            PVR_EDL_ENTRY edl[],
+                            int* size);
 
   /*!
    * Retrieve the size of a recording on the backend.
@@ -351,7 +379,9 @@ extern "C"
    * @remarks Required if bSupportsRecordingSize is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetRecordingSize(const PVR_RECORDING* recording, int64_t* sizeInBytes);
+  PVR_ERROR GetRecordingSize(const AddonInstance_PVR* instance,
+                             const PVR_RECORDING* recording,
+                             int64_t* sizeInBytes);
 
   /*!
    * Retrieve the timer types supported by the backend.
@@ -361,7 +391,9 @@ extern "C"
    * @remarks Required if bSupportsTimers is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetTimerTypes(PVR_TIMER_TYPE types[], int *typesCount);
+  PVR_ERROR GetTimerTypes(const AddonInstance_PVR* instance,
+                          PVR_TIMER_TYPE types[],
+                          int* typesCount);
 
   //@}
   /** @name PVR timer methods
@@ -374,7 +406,7 @@ extern "C"
    * @return The total amount of timers on the backend or -1 on error.
    * @remarks Required if bSupportsTimers is set to true. Return -1 if this add-on won't provide this function.
    */
-  int GetTimersAmount(void);
+  int GetTimersAmount(const AddonInstance_PVR* instance);
 
   /*!
    * Request the list of all timers from the backend if supported.
@@ -384,7 +416,7 @@ extern "C"
    * @remarks Required if bSupportsTimers is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetTimers(ADDON_HANDLE handle);
+  PVR_ERROR GetTimers(const AddonInstance_PVR* instance, ADDON_HANDLE handle);
 
   /*!
    * Add a timer on the backend.
@@ -393,7 +425,7 @@ extern "C"
    * @remarks Required if bSupportsTimers is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR AddTimer(const PVR_TIMER& timer);
+  PVR_ERROR AddTimer(const AddonInstance_PVR* instance, const PVR_TIMER& timer);
 
   /*!
    * Delete a timer on the backend.
@@ -403,7 +435,9 @@ extern "C"
    * @remarks Required if bSupportsTimers is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR DeleteTimer(const PVR_TIMER& timer, bool bForceDelete);
+  PVR_ERROR DeleteTimer(const AddonInstance_PVR* instance,
+                        const PVR_TIMER& timer,
+                        bool bForceDelete);
 
   /*!
    * Update the timer information on the backend.
@@ -412,7 +446,7 @@ extern "C"
    * @remarks Required if bSupportsTimers is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR UpdateTimer(const PVR_TIMER& timer);
+  PVR_ERROR UpdateTimer(const AddonInstance_PVR* instance, const PVR_TIMER& timer);
 
   //@}
 
@@ -426,13 +460,13 @@ extern "C"
    *          CloseLiveStream() will always be called by Kodi prior to calling this function.
    *          Return false if this add-on won't provide this function.
    */
-  bool OpenLiveStream(const PVR_CHANNEL& channel);
+  bool OpenLiveStream(const AddonInstance_PVR* instance, const PVR_CHANNEL& channel);
 
   /*!
    * Close an open live stream.
    * @remarks Required if bHandlesInputStream or bHandlesDemuxing is set to true.
    */
-  void CloseLiveStream(void);
+  void CloseLiveStream(const AddonInstance_PVR* instance);
 
   /*!
    * Read from an open live stream.
@@ -442,7 +476,9 @@ extern "C"
    * @remarks Required if bHandlesInputStream is set to true.
    *          Return -1 if this add-on won't provide this function.
    */
-  int ReadLiveStream(unsigned char* pBuffer, unsigned int iBufferSize);
+  int ReadLiveStream(const AddonInstance_PVR* instance,
+                     unsigned char* pBuffer,
+                     unsigned int iBufferSize);
 
   /*!
    * Seek in a live stream on a backend that supports timeshifting.
@@ -452,7 +488,9 @@ extern "C"
    * @remarks Optional, and only used if bHandlesInputStream is set to true.
    *          Return -1 if this add-on won't provide this function.
    */
-  long long SeekLiveStream(long long iPosition, int iWhence = SEEK_SET);
+  long long SeekLiveStream(const AddonInstance_PVR* instance,
+                           long long iPosition,
+                           int iWhence = SEEK_SET);
 
   /*!
    * Obtain the length of a live stream.
@@ -460,7 +498,7 @@ extern "C"
    * @remarks Optional, and only used if bHandlesInputStream is set to true.
    *          Return -1 if this add-on won't provide this function.
    */
-  long long LengthLiveStream(void);
+  long long LengthLiveStream(const AddonInstance_PVR* instance);
 
   /*!
    * Get the signal status of the stream that's currently open.
@@ -470,7 +508,7 @@ extern "C"
    * @remarks Optional, and only used if PVR_ADDON_CAPABILITIES::bHandlesInputStream or PVR_ADDON_CAPABILITIES::bHandlesDemuxing is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetSignalStatus(int channelUid, PVR_SIGNAL_STATUS* signalStatus);
+  PVR_ERROR GetSignalStatus(const AddonInstance_PVR* instance, int channelUid, PVR_SIGNAL_STATUS* signalStatus);
 
   /*!
    * Get the descramble information of the stream that's currently open.
@@ -480,7 +518,8 @@ extern "C"
    * @remarks Optional, and only used if PVR_ADDON_CAPABILITIES::bSupportsDescrambleInfo is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetDescrambleInfo(int channelUid, PVR_DESCRAMBLE_INFO* descrambleInfo);
+  PVR_ERROR GetDescrambleInfo(const AddonInstance_PVR* instance, int channelUid,
+                              PVR_DESCRAMBLE_INFO* descrambleInfo);
 
   /*!
    * Get the stream properties for a channel from the backend.
@@ -492,7 +531,10 @@ extern "C"
    *          In this case the implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the channel.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetChannelStreamProperties(const PVR_CHANNEL* channel, PVR_NAMED_VALUE* properties, unsigned int* iPropertiesCount);
+  PVR_ERROR GetChannelStreamProperties(const AddonInstance_PVR* instance,
+                                       const PVR_CHANNEL* channel,
+                                       PVR_NAMED_VALUE* properties,
+                                       unsigned int* iPropertiesCount);
 
   /*!
    * Get the stream properties for a recording from the backend.
@@ -504,7 +546,10 @@ extern "C"
    *          In this case your implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the recording.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetRecordingStreamProperties(const PVR_RECORDING* recording, PVR_NAMED_VALUE* properties, unsigned int* iPropertiesCount);
+  PVR_ERROR GetRecordingStreamProperties(const AddonInstance_PVR* instance,
+                                         const PVR_RECORDING* recording,
+                                         PVR_NAMED_VALUE* properties,
+                                         unsigned int* iPropertiesCount);
 
   /*!
    * Get the stream properties of the stream that's currently being read.
@@ -513,7 +558,8 @@ extern "C"
    * @remarks Required if bHandlesDemuxing is set to true.
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR GetStreamProperties(PVR_STREAM_PROPERTIES* pProperties);
+  PVR_ERROR GetStreamProperties(const AddonInstance_PVR* instance,
+                                PVR_STREAM_PROPERTIES* pProperties);
   //@}
 
   /** @name PVR recording stream methods, used to open and close a stream to a recording, and perform read operations on the stream.
@@ -529,7 +575,7 @@ extern "C"
    *          PVR_ADDON_CAPABILITIES::bHandlesInputStream is true (=> ReadLiveStream).
    *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. In this case Kodi will decide on the chunk size to use.
    */
-  PVR_ERROR GetStreamReadChunkSize(int* chunksize);
+  PVR_ERROR GetStreamReadChunkSize(const AddonInstance_PVR* instance, int* chunksize);
 
   /*!
    * Open a stream to a recording on the backend.
@@ -539,13 +585,13 @@ extern "C"
    *          CloseRecordedStream() will always be called by Kodi prior to calling this function.
    *          Return false if this add-on won't provide this function.
    */
-  bool OpenRecordedStream(const PVR_RECORDING& recording);
+  bool OpenRecordedStream(const AddonInstance_PVR* instance, const PVR_RECORDING& recording);
 
   /*!
    * Close an open stream from a recording.
    * @remarks Optional, and only used if bSupportsRecordings is set to true.
    */
-  void CloseRecordedStream(void);
+  void CloseRecordedStream(const AddonInstance_PVR* instance);
 
   /*!
    * Read from a recording.
@@ -555,7 +601,9 @@ extern "C"
    * @remarks Optional, and only used if bSupportsRecordings is set to true, but required if OpenRecordedStream() is implemented.
    *          Return -1 if this add-on won't provide this function.
    */
-  int ReadRecordedStream(unsigned char* pBuffer, unsigned int iBufferSize);
+  int ReadRecordedStream(const AddonInstance_PVR* instance,
+                         unsigned char* pBuffer,
+                         unsigned int iBufferSize);
 
   /*!
    * Seek in a recorded stream.
@@ -565,7 +613,9 @@ extern "C"
    * @remarks Optional, and only used if bSupportsRecordings is set to true.
    *          Return -1 if this add-on won't provide this function.
    */
-  long long SeekRecordedStream(long long iPosition, int iWhence = SEEK_SET);
+  long long SeekRecordedStream(const AddonInstance_PVR* instance,
+                               long long iPosition,
+                               int iWhence = SEEK_SET);
 
   /*!
    * Obtain the length of a recorded stream.
@@ -573,7 +623,7 @@ extern "C"
    * @remarks Optional, and only used if bSupportsRecordings is set to true.
    *          Return -1 if this add-on won't provide this function.
    */
-  long long LengthRecordedStream(void);
+  long long LengthRecordedStream(const AddonInstance_PVR* instance);
 
   //@}
 
@@ -585,19 +635,19 @@ extern "C"
    * Reset the demultiplexer in the add-on.
    * @remarks Required if bHandlesDemuxing is set to true.
    */
-  void DemuxReset(void);
+  void DemuxReset(const AddonInstance_PVR* instance);
 
   /*!
    * Abort the demultiplexer thread in the add-on.
    * @remarks Required if bHandlesDemuxing is set to true.
    */
-  void DemuxAbort(void);
+  void DemuxAbort(const AddonInstance_PVR* instance);
 
   /*!
    * Flush all data that's currently in the demultiplexer buffer in the add-on.
    * @remarks Required if bHandlesDemuxing is set to true.
    */
-  void DemuxFlush(void);
+  void DemuxFlush(const AddonInstance_PVR* instance);
 
   /*!
    * Read the next packet from the demultiplexer, if there is one.
@@ -612,7 +662,7 @@ extern "C"
    * @remarks Required if bHandlesDemuxing is set to true.
    *          Return NULL if this add-on won't provide this function.
    */
-  DemuxPacket* DemuxRead(void);
+  DemuxPacket* DemuxRead(const AddonInstance_PVR* instance);
   //@}
 
   /*!
@@ -620,19 +670,19 @@ extern "C"
    * This will enable/disable the pause button in Kodi based on the return value
    * @return false if the PVR addon/backend does not support pausing, true if possible
    */
-  bool CanPauseStream();
+  bool CanPauseStream(const AddonInstance_PVR* instance);
 
   /*!
    * Check if the backend supports seeking for the currently playing stream
    * This will enable/disable the rewind/forward buttons in Kodi based on the return value
    * @return false if the PVR addon/backend does not support seeking, true if possible
    */
-  bool CanSeekStream();
+  bool CanSeekStream(const AddonInstance_PVR* instance);
 
   /*!
    * @brief Notify the pvr addon that Kodi (un)paused the currently playing stream
    */
-  void PauseStream(bool bPaused);
+  void PauseStream(const AddonInstance_PVR* instance, bool bPaused);
 
   /*!
    * Notify the pvr addon/demuxer that Kodi wishes to seek the stream by time
@@ -643,33 +693,33 @@ extern "C"
    * @remarks Optional, and only used if addon has its own demuxer.
    *          Return False if this add-on won't provide this function.
    */
-  bool SeekTime(double time, bool backwards, double *startpts);
+  bool SeekTime(const AddonInstance_PVR* instance, double time, bool backwards, double* startpts);
 
   /*!
    * Notify the pvr addon/demuxer that Kodi wishes to change playback speed
    * @param speed The requested playback speed
    * @remarks Optional, and only used if addon has its own demuxer.
    */
-  void SetSpeed(int speed);
+  void SetSpeed(const AddonInstance_PVR* instance, int speed);
 
   /*!
    * Notify the pvr addon/demuxer that Kodi wishes to fill demux queue
    * @param mode The requested filling mode
    * @remarks Optional, and only used if addon has its own demuxer.
    */
-  void FillBuffer(bool mode);
+  void FillBuffer(const AddonInstance_PVR* instance, bool mode);
 
   /*!
    *  Get the hostname of the pvr backend server
    *  @return hostname as ip address or alias. If backend does not utilize a server, return empty string.
    */
-  const char* GetBackendHostname();
+  const char* GetBackendHostname(const AddonInstance_PVR* instance);
 
   /*!
    *  Check for real-time streaming
    *  @return true if current stream is real-time
    */
-  bool IsRealTimeStream();
+  bool IsRealTimeStream(const AddonInstance_PVR* instance);
 
   /*!
    * Tell the client the time frame to use when notifying epg events back to Kodi. The client might push epg events asynchronously
@@ -680,22 +730,22 @@ extern "C"
    * @return PVR_ERROR_NO_ERROR if new value was successfully set.
    * @remarks Required if bSupportsEPG is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
    */
-  PVR_ERROR SetEPGTimeFrame(int iDays);
+  PVR_ERROR SetEPGTimeFrame(const AddonInstance_PVR* instance, int iDays);
 
   /*!
    * Notify the pvr addon for power management events
    */
-  void OnSystemSleep();
-  void OnSystemWake();
-  void OnPowerSavingActivated();
-  void OnPowerSavingDeactivated();
+  void OnSystemSleep(const AddonInstance_PVR* instance);
+  void OnSystemWake(const AddonInstance_PVR* instance);
+  void OnPowerSavingActivated(const AddonInstance_PVR* instance);
+  void OnPowerSavingDeactivated(const AddonInstance_PVR* instance);
 
   /*!
    * Get stream times.
    * @param times A pointer to the data to be filled by the implementation.
    * @return PVR_ERROR_NO_ERROR on success.
    */
-  PVR_ERROR GetStreamTimes(PVR_STREAM_TIMES *times);
+  PVR_ERROR GetStreamTimes(const AddonInstance_PVR* instance, PVR_STREAM_TIMES* times);
 
   /*!
    * Called by Kodi to assign the function pointers of this add-on to pClient.
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index 58ebbd5ab112..0af801593651 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -742,6 +742,8 @@ extern "C" {
     int64_t ptsEnd;   /*!< @brief latest pts player can seek forward. Value is in micro seconds, relative to ptsStart. For recordings, this must be the total length. For Live TV, this must be zero if not timeshifting and must point to end of the timeshift buffer, otherwise. */
   } ATTRIBUTE_PACKED PVR_STREAM_TIMES;
 
+  struct AddonInstance_PVR;
+
   typedef struct AddonToKodiFuncTable_PVR
   {
     // Pointer inside Kodi where used from him to find his class
@@ -807,116 +809,119 @@ extern "C" {
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // General interface functions
-    PVR_ERROR(__cdecl* GetCapabilities)(PVR_ADDON_CAPABILITIES*);
-    const char*(__cdecl* GetBackendName)(void);
-    const char*(__cdecl* GetBackendVersion)(void);
-    const char*(__cdecl* GetBackendHostname)(void);
-    const char*(__cdecl* GetConnectionString)(void);
-    PVR_ERROR(__cdecl* GetDriveSpace)(long long*, long long*);
-    PVR_ERROR(__cdecl* MenuHook)(const PVR_MENUHOOK&, const PVR_MENUHOOK_DATA&);
+    PVR_ERROR(__cdecl* GetCapabilities)(const AddonInstance_PVR*, PVR_ADDON_CAPABILITIES*);
+    const char*(__cdecl* GetBackendName)(const AddonInstance_PVR*);
+    const char*(__cdecl* GetBackendVersion)(const AddonInstance_PVR*);
+    const char*(__cdecl* GetBackendHostname)(const AddonInstance_PVR*);
+    const char*(__cdecl* GetConnectionString)(const AddonInstance_PVR*);
+    PVR_ERROR(__cdecl* GetDriveSpace)(const AddonInstance_PVR*, long long*, long long*);
+    PVR_ERROR(__cdecl* MenuHook)(const AddonInstance_PVR*, const PVR_MENUHOOK&, const PVR_MENUHOOK_DATA&);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel interface functions
 
-    int(__cdecl* GetChannelsAmount)(void);
-    PVR_ERROR(__cdecl* GetChannels)(ADDON_HANDLE, bool);
-    PVR_ERROR(__cdecl* GetChannelStreamProperties)(const PVR_CHANNEL*,
+    int(__cdecl* GetChannelsAmount)(const AddonInstance_PVR*);
+    PVR_ERROR(__cdecl* GetChannels)(const AddonInstance_PVR*, ADDON_HANDLE, bool);
+    PVR_ERROR(__cdecl* GetChannelStreamProperties)(const AddonInstance_PVR*,
+                                                   const PVR_CHANNEL*,
                                                    PVR_NAMED_VALUE*,
                                                    unsigned int*);
-    PVR_ERROR(__cdecl* GetSignalStatus)(int, PVR_SIGNAL_STATUS*);
-    PVR_ERROR(__cdecl* GetDescrambleInfo)(int, PVR_DESCRAMBLE_INFO*);
+    PVR_ERROR(__cdecl* GetSignalStatus)(const AddonInstance_PVR*, int, PVR_SIGNAL_STATUS*);
+    PVR_ERROR(__cdecl* GetDescrambleInfo)(const AddonInstance_PVR*, int, PVR_DESCRAMBLE_INFO*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel group interface functions
-    int(__cdecl* GetChannelGroupsAmount)(void);
-    PVR_ERROR(__cdecl* GetChannelGroups)(ADDON_HANDLE, bool);
-    PVR_ERROR(__cdecl* GetChannelGroupMembers)(ADDON_HANDLE, const PVR_CHANNEL_GROUP&);
+    int(__cdecl* GetChannelGroupsAmount)(const AddonInstance_PVR*);
+    PVR_ERROR(__cdecl* GetChannelGroups)(const AddonInstance_PVR*, ADDON_HANDLE, bool);
+    PVR_ERROR(__cdecl* GetChannelGroupMembers)(const AddonInstance_PVR*, ADDON_HANDLE, const PVR_CHANNEL_GROUP&);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel edit interface functions
-    PVR_ERROR(__cdecl* DeleteChannel)(const PVR_CHANNEL&);
-    PVR_ERROR(__cdecl* RenameChannel)(const PVR_CHANNEL&);
-    PVR_ERROR(__cdecl* OpenDialogChannelSettings)(const PVR_CHANNEL&);
-    PVR_ERROR(__cdecl* OpenDialogChannelAdd)(const PVR_CHANNEL&);
-    PVR_ERROR(__cdecl* OpenDialogChannelScan)(void);
+    PVR_ERROR(__cdecl* DeleteChannel)(const AddonInstance_PVR*, const PVR_CHANNEL&);
+    PVR_ERROR(__cdecl* RenameChannel)(const AddonInstance_PVR*, const PVR_CHANNEL&);
+    PVR_ERROR(__cdecl* OpenDialogChannelSettings)(const AddonInstance_PVR*, const PVR_CHANNEL&);
+    PVR_ERROR(__cdecl* OpenDialogChannelAdd)(const AddonInstance_PVR*, const PVR_CHANNEL&);
+    PVR_ERROR(__cdecl* OpenDialogChannelScan)(const AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // EPG interface functions
-    PVR_ERROR(__cdecl* GetEPGForChannel)(ADDON_HANDLE, int, time_t, time_t);
-    PVR_ERROR(__cdecl* IsEPGTagRecordable)(const EPG_TAG*, bool*);
-    PVR_ERROR(__cdecl* IsEPGTagPlayable)(const EPG_TAG*, bool*);
-    PVR_ERROR(__cdecl* GetEPGTagEdl)(const EPG_TAG*, PVR_EDL_ENTRY[], int*);
-    PVR_ERROR(__cdecl* GetEPGTagStreamProperties)(const EPG_TAG*, PVR_NAMED_VALUE*, unsigned int*);
-    PVR_ERROR(__cdecl* SetEPGTimeFrame)(int);
+    PVR_ERROR(__cdecl* GetEPGForChannel)(const AddonInstance_PVR*, ADDON_HANDLE, int, time_t, time_t);
+    PVR_ERROR(__cdecl* IsEPGTagRecordable)(const AddonInstance_PVR*, const EPG_TAG*, bool*);
+    PVR_ERROR(__cdecl* IsEPGTagPlayable)(const AddonInstance_PVR*, const EPG_TAG*, bool*);
+    PVR_ERROR(__cdecl* GetEPGTagEdl)(const AddonInstance_PVR*, const EPG_TAG*, PVR_EDL_ENTRY[], int*);
+    PVR_ERROR(__cdecl* GetEPGTagStreamProperties)(const AddonInstance_PVR*, const EPG_TAG*, PVR_NAMED_VALUE*, unsigned int*);
+    PVR_ERROR(__cdecl* SetEPGTimeFrame)(const AddonInstance_PVR*, int);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Recording interface functions
-    int(__cdecl* GetRecordingsAmount)(bool);
-    PVR_ERROR(__cdecl* GetRecordings)(ADDON_HANDLE, bool);
-    PVR_ERROR(__cdecl* DeleteRecording)(const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* UndeleteRecording)(const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* DeleteAllRecordingsFromTrash)(void);
-    PVR_ERROR(__cdecl* RenameRecording)(const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* SetRecordingLifetime)(const PVR_RECORDING*);
-    PVR_ERROR(__cdecl* SetRecordingPlayCount)(const PVR_RECORDING&, int);
-    PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const PVR_RECORDING&, int);
-    int(__cdecl* GetRecordingLastPlayedPosition)(const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* GetRecordingEdl)(const PVR_RECORDING&, PVR_EDL_ENTRY[], int*);
-    PVR_ERROR(__cdecl* GetRecordingSize)(const PVR_RECORDING*, int64_t*);
-    PVR_ERROR(__cdecl* GetRecordingStreamProperties)
-    (const PVR_RECORDING*, PVR_NAMED_VALUE*, unsigned int*);
+    int(__cdecl* GetRecordingsAmount)(const AddonInstance_PVR*, bool);
+    PVR_ERROR(__cdecl* GetRecordings)(const AddonInstance_PVR*, ADDON_HANDLE, bool);
+    PVR_ERROR(__cdecl* DeleteRecording)(const AddonInstance_PVR*, const PVR_RECORDING&);
+    PVR_ERROR(__cdecl* UndeleteRecording)(const AddonInstance_PVR*, const PVR_RECORDING&);
+    PVR_ERROR(__cdecl* DeleteAllRecordingsFromTrash)(const AddonInstance_PVR*);
+    PVR_ERROR(__cdecl* RenameRecording)(const AddonInstance_PVR*, const PVR_RECORDING&);
+    PVR_ERROR(__cdecl* SetRecordingLifetime)(const AddonInstance_PVR*, const PVR_RECORDING*);
+    PVR_ERROR(__cdecl* SetRecordingPlayCount)(const AddonInstance_PVR*, const PVR_RECORDING&, int);
+    PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const AddonInstance_PVR*, const PVR_RECORDING&, int);
+    int(__cdecl* GetRecordingLastPlayedPosition)(const AddonInstance_PVR*, const PVR_RECORDING&);
+    PVR_ERROR(__cdecl* GetRecordingEdl)(const AddonInstance_PVR*, const PVR_RECORDING&, PVR_EDL_ENTRY[], int*);
+    PVR_ERROR(__cdecl* GetRecordingSize)(const AddonInstance_PVR*, const PVR_RECORDING*, int64_t*);
+    PVR_ERROR(__cdecl* GetRecordingStreamProperties)(const AddonInstance_PVR*,
+                                                     const PVR_RECORDING*,
+                                                     PVR_NAMED_VALUE*,
+                                                     unsigned int*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Timer interface functions
-    PVR_ERROR(__cdecl* GetTimerTypes)(PVR_TIMER_TYPE[], int*);
-    int(__cdecl* GetTimersAmount)(void);
-    PVR_ERROR(__cdecl* GetTimers)(ADDON_HANDLE);
-    PVR_ERROR(__cdecl* AddTimer)(const PVR_TIMER&);
-    PVR_ERROR(__cdecl* DeleteTimer)(const PVR_TIMER&, bool);
-    PVR_ERROR(__cdecl* UpdateTimer)(const PVR_TIMER&);
+    PVR_ERROR(__cdecl* GetTimerTypes)(const AddonInstance_PVR*, PVR_TIMER_TYPE[], int*);
+    int(__cdecl* GetTimersAmount)(const AddonInstance_PVR*);
+    PVR_ERROR(__cdecl* GetTimers)(const AddonInstance_PVR*, ADDON_HANDLE);
+    PVR_ERROR(__cdecl* AddTimer)(const AddonInstance_PVR*, const PVR_TIMER&);
+    PVR_ERROR(__cdecl* DeleteTimer)(const AddonInstance_PVR*, const PVR_TIMER&, bool);
+    PVR_ERROR(__cdecl* UpdateTimer)(const AddonInstance_PVR*, const PVR_TIMER&);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Powersaving interface functions
-    void(__cdecl* OnSystemSleep)(void);
-    void(__cdecl* OnSystemWake)(void);
-    void(__cdecl* OnPowerSavingActivated)(void);
-    void(__cdecl* OnPowerSavingDeactivated)(void);
+    void(__cdecl* OnSystemSleep)(const AddonInstance_PVR*);
+    void(__cdecl* OnSystemWake)(const AddonInstance_PVR*);
+    void(__cdecl* OnPowerSavingActivated)(const AddonInstance_PVR*);
+    void(__cdecl* OnPowerSavingDeactivated)(const AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Live stream read interface functions
-    bool(__cdecl* OpenLiveStream)(const PVR_CHANNEL&);
-    void(__cdecl* CloseLiveStream)(void);
-    int(__cdecl* ReadLiveStream)(unsigned char*, unsigned int);
-    long long(__cdecl* SeekLiveStream)(long long, int);
-    long long(__cdecl* LengthLiveStream)(void);
+    bool(__cdecl* OpenLiveStream)(const AddonInstance_PVR*, const PVR_CHANNEL&);
+    void(__cdecl* CloseLiveStream)(const AddonInstance_PVR*);
+    int(__cdecl* ReadLiveStream)(const AddonInstance_PVR*, unsigned char*, unsigned int);
+    long long(__cdecl* SeekLiveStream)(const AddonInstance_PVR*, long long, int);
+    long long(__cdecl* LengthLiveStream)(const AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Recording stream read interface functions
-    bool(__cdecl* OpenRecordedStream)(const PVR_RECORDING&);
-    void(__cdecl* CloseRecordedStream)(void);
-    int(__cdecl* ReadRecordedStream)(unsigned char*, unsigned int);
-    long long(__cdecl* SeekRecordedStream)(long long, int);
-    long long(__cdecl* LengthRecordedStream)(void);
+    bool(__cdecl* OpenRecordedStream)(const AddonInstance_PVR*, const PVR_RECORDING&);
+    void(__cdecl* CloseRecordedStream)(const AddonInstance_PVR*);
+    int(__cdecl* ReadRecordedStream)(const AddonInstance_PVR*, unsigned char*, unsigned int);
+    long long(__cdecl* SeekRecordedStream)(const AddonInstance_PVR*, long long, int);
+    long long(__cdecl* LengthRecordedStream)(const AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Stream demux interface functions
-    PVR_ERROR(__cdecl* GetStreamProperties)(PVR_STREAM_PROPERTIES*);
-    DemuxPacket*(__cdecl* DemuxRead)(void);
-    void(__cdecl* DemuxReset)(void);
-    void(__cdecl* DemuxAbort)(void);
-    void(__cdecl* DemuxFlush)(void);
-    void(__cdecl* SetSpeed)(int);
-    void(__cdecl* FillBuffer)(bool);
-    bool(__cdecl* SeekTime)(double, bool, double*);
+    PVR_ERROR(__cdecl* GetStreamProperties)(const AddonInstance_PVR*, PVR_STREAM_PROPERTIES*);
+    DemuxPacket*(__cdecl* DemuxRead)(const AddonInstance_PVR*);
+    void(__cdecl* DemuxReset)(const AddonInstance_PVR*);
+    void(__cdecl* DemuxAbort)(const AddonInstance_PVR*);
+    void(__cdecl* DemuxFlush)(const AddonInstance_PVR*);
+    void(__cdecl* SetSpeed)(const AddonInstance_PVR*, int);
+    void(__cdecl* FillBuffer)(const AddonInstance_PVR*, bool);
+    bool(__cdecl* SeekTime)(const AddonInstance_PVR*, double, bool, double*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // General stream interface functions
-    bool(__cdecl* CanPauseStream)(void);
-    void(__cdecl* PauseStream)(bool);
-    bool(__cdecl* CanSeekStream)(void);
-    bool(__cdecl* IsRealTimeStream)(void);
-    PVR_ERROR(__cdecl* GetStreamTimes)(PVR_STREAM_TIMES*);
-    PVR_ERROR(__cdecl* GetStreamReadChunkSize)(int*);
+    bool(__cdecl* CanPauseStream)(const AddonInstance_PVR*);
+    void(__cdecl* PauseStream)(const AddonInstance_PVR*, bool);
+    bool(__cdecl* CanSeekStream)(const AddonInstance_PVR*);
+    bool(__cdecl* IsRealTimeStream)(const AddonInstance_PVR*);
+    PVR_ERROR(__cdecl* GetStreamTimes)(const AddonInstance_PVR*, PVR_STREAM_TIMES*);
+    PVR_ERROR(__cdecl* GetStreamReadChunkSize)(const AddonInstance_PVR*, int*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // New functions becomes added below and can be on another API change (where
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index eaf1fc2f3799..c81812454303 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -392,7 +392,7 @@ bool CPVRClient::GetAddonProperties()
 
   /* get the capabilities */
   PVR_ERROR retVal = DoAddonCall(__FUNCTION__, [&addonCapabilities](const AddonInstance* addon) {
-    return addon->toAddon->GetCapabilities(&addonCapabilities);
+    return addon->toAddon->GetCapabilities(addon, &addonCapabilities);
   }, true, false);
 
   if (retVal != PVR_ERROR_NO_ERROR)
@@ -400,13 +400,13 @@ bool CPVRClient::GetAddonProperties()
 
   /* get the name of the backend */
   DoAddonCall(__FUNCTION__, [&strBackendName](const AddonInstance* addon) {
-    strBackendName = addon->toAddon->GetBackendName();
+    strBackendName = addon->toAddon->GetBackendName(addon);
     return PVR_ERROR_NO_ERROR;
   }, true, false);
 
   /* get the connection string */
   DoAddonCall(__FUNCTION__, [&strConnectionString](const AddonInstance* addon) {
-    strConnectionString = addon->toAddon->GetConnectionString();
+    strConnectionString = addon->toAddon->GetConnectionString(addon);
     return PVR_ERROR_NO_ERROR;
   }, true, false);
 
@@ -415,13 +415,13 @@ bool CPVRClient::GetAddonProperties()
 
   /* backend version number */
   DoAddonCall(__FUNCTION__, [&strBackendVersion](const AddonInstance* addon) {
-    strBackendVersion = addon->toAddon->GetBackendVersion();
+    strBackendVersion = addon->toAddon->GetBackendVersion(addon);
     return PVR_ERROR_NO_ERROR;
   }, true, false);
 
   /* backend hostname */
   DoAddonCall(__FUNCTION__, [&strBackendHostname](const AddonInstance* addon) {
-    strBackendHostname = addon->toAddon->GetBackendHostname();
+    strBackendHostname = addon->toAddon->GetBackendHostname(addon);
     return PVR_ERROR_NO_ERROR;
   }, true, false);
 
@@ -430,7 +430,7 @@ bool CPVRClient::GetAddonProperties()
     std::unique_ptr<PVR_TIMER_TYPE[]> types_array(new PVR_TIMER_TYPE[PVR_ADDON_TIMERTYPE_ARRAY_SIZE]);
     int size = PVR_ADDON_TIMERTYPE_ARRAY_SIZE;
 
-    PVR_ERROR retval = addon->toAddon->GetTimerTypes(types_array.get(), &size);
+    PVR_ERROR retval = addon->toAddon->GetTimerTypes(addon, types_array.get(), &size);
 
     if (retval == PVR_ERROR_NOT_IMPLEMENTED)
     {
@@ -560,7 +560,7 @@ PVR_ERROR CPVRClient::GetDriveSpace(long long& iTotal, long long& iUsed)
   return DoAddonCall(__FUNCTION__, [&iTotal, &iUsed](const AddonInstance* addon) {
     long long iTotalSpace = 0;
     long long iUsedSpace = 0;
-    PVR_ERROR error = addon->toAddon->GetDriveSpace(&iTotalSpace, &iUsedSpace);
+    PVR_ERROR error = addon->toAddon->GetDriveSpace(addon, &iTotalSpace, &iUsedSpace);
     if (error == PVR_ERROR_NO_ERROR)
     {
       iTotal = iTotalSpace;
@@ -573,7 +573,7 @@ PVR_ERROR CPVRClient::GetDriveSpace(long long& iTotal, long long& iUsed)
 PVR_ERROR CPVRClient::StartChannelScan()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    return addon->toAddon->OpenDialogChannelScan();
+    return addon->toAddon->OpenDialogChannelScan(addon);
   }, m_clientCapabilities.SupportsChannelScan());
 }
 
@@ -582,7 +582,7 @@ PVR_ERROR CPVRClient::OpenDialogChannelAdd(const std::shared_ptr<CPVRChannel>& c
   return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
     PVR_CHANNEL addonChannel;
     WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->OpenDialogChannelAdd(addonChannel);
+    return addon->toAddon->OpenDialogChannelAdd(addon, addonChannel);
   }, m_clientCapabilities.SupportsChannelSettings());
 }
 
@@ -591,7 +591,7 @@ PVR_ERROR CPVRClient::OpenDialogChannelSettings(const std::shared_ptr<CPVRChanne
   return DoAddonCall(__FUNCTION__, [channel] (const AddonInstance* addon){
     PVR_CHANNEL addonChannel;
     WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->OpenDialogChannelSettings(addonChannel);
+    return addon->toAddon->OpenDialogChannelSettings(addon, addonChannel);
   }, m_clientCapabilities.SupportsChannelSettings());
 }
 
@@ -600,7 +600,7 @@ PVR_ERROR CPVRClient::DeleteChannel(const std::shared_ptr<CPVRChannel>& channel)
   return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
     PVR_CHANNEL addonChannel;
     WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->DeleteChannel(addonChannel);
+    return addon->toAddon->DeleteChannel(addon, addonChannel);
   }, m_clientCapabilities.SupportsChannelSettings());
 }
 
@@ -609,7 +609,7 @@ PVR_ERROR CPVRClient::RenameChannel(const std::shared_ptr<CPVRChannel>& channel)
   return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
     PVR_CHANNEL addonChannel;
     WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->RenameChannel(addonChannel);
+    return addon->toAddon->RenameChannel(addon, addonChannel);
   }, m_clientCapabilities.SupportsChannelSettings());
 }
 
@@ -623,7 +623,7 @@ PVR_ERROR CPVRClient::GetEPGForChannel(int iChannelUid, CPVREpg* epg, time_t sta
 
     int iPVRTimeCorrection = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_iPVRTimeCorrection;
 
-    return addon->toAddon->GetEPGForChannel(&handle, iChannelUid,
+    return addon->toAddon->GetEPGForChannel(addon, &handle, iChannelUid,
                                             start ? start - iPVRTimeCorrection : 0,
                                             end ? end - iPVRTimeCorrection : 0);
   }, m_clientCapabilities.SupportsEPG());
@@ -632,7 +632,7 @@ PVR_ERROR CPVRClient::GetEPGForChannel(int iChannelUid, CPVREpg* epg, time_t sta
 PVR_ERROR CPVRClient::SetEPGTimeFrame(int iDays)
 {
   return DoAddonCall(__FUNCTION__, [iDays](const AddonInstance* addon) {
-    return addon->toAddon->SetEPGTimeFrame(iDays);
+    return addon->toAddon->SetEPGTimeFrame(addon, iDays);
   }, m_clientCapabilities.SupportsEPG());
 }
 
@@ -718,7 +718,7 @@ PVR_ERROR CPVRClient::IsRecordable(const std::shared_ptr<const CPVREpgInfoTag>&
 {
   return DoAddonCall(__FUNCTION__, [tag, &bIsRecordable](const AddonInstance* addon) {
     CAddonEpgTag addonTag(tag);
-    return addon->toAddon->IsEPGTagRecordable(&addonTag, &bIsRecordable);
+    return addon->toAddon->IsEPGTagRecordable(addon, &addonTag, &bIsRecordable);
   }, m_clientCapabilities.SupportsRecordings() && m_clientCapabilities.SupportsEPG());
 }
 
@@ -726,7 +726,7 @@ PVR_ERROR CPVRClient::IsPlayable(const std::shared_ptr<const CPVREpgInfoTag>& ta
 {
   return DoAddonCall(__FUNCTION__, [tag, &bIsPlayable](const AddonInstance* addon) {
     CAddonEpgTag addonTag(tag);
-    return addon->toAddon->IsEPGTagPlayable(&addonTag, &bIsPlayable);
+    return addon->toAddon->IsEPGTagPlayable(addon, &addonTag, &bIsPlayable);
   }, m_clientCapabilities.SupportsEPG());
 }
 
@@ -747,8 +747,8 @@ PVR_ERROR CPVRClient::GetEpgTagStreamProperties(const std::shared_ptr<CPVREpgInf
     std::unique_ptr<PVR_NAMED_VALUE[]> properties(new PVR_NAMED_VALUE[iPropertyCount]);
     memset(properties.get(), 0, iPropertyCount * sizeof(PVR_NAMED_VALUE));
 
-    PVR_ERROR error =
-        addon->toAddon->GetEPGTagStreamProperties(&addonTag, properties.get(), &iPropertyCount);
+    PVR_ERROR error = addon->toAddon->GetEPGTagStreamProperties(addon, &addonTag, properties.get(),
+                                                                &iPropertyCount);
     if (error ==  PVR_ERROR_NO_ERROR)
       WriteStreamProperties(properties.get(), iPropertyCount, props);
 
@@ -764,7 +764,7 @@ PVR_ERROR CPVRClient::GetEpgTagEdl(const std::shared_ptr<const CPVREpgInfoTag>&
 
     PVR_EDL_ENTRY edl_array[PVR_ADDON_EDL_LENGTH];
     int size = PVR_ADDON_EDL_LENGTH;
-    PVR_ERROR error = addon->toAddon->GetEPGTagEdl(&addonTag, edl_array, &size);
+    PVR_ERROR error = addon->toAddon->GetEPGTagEdl(addon, &addonTag, edl_array, &size);
     if (error == PVR_ERROR_NO_ERROR)
     {
       edls.reserve(size);
@@ -779,7 +779,7 @@ PVR_ERROR CPVRClient::GetChannelGroupsAmount(int& iGroups)
 {
   iGroups = -1;
   return DoAddonCall(__FUNCTION__, [&iGroups](const AddonInstance* addon) {
-    iGroups = addon->toAddon->GetChannelGroupsAmount();
+    iGroups = addon->toAddon->GetChannelGroupsAmount(addon);
     return (iGroups == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   }, m_clientCapabilities.SupportsChannelGroups());
 }
@@ -790,7 +790,7 @@ PVR_ERROR CPVRClient::GetChannelGroups(CPVRChannelGroups* groups)
     ADDON_HANDLE_STRUCT handle = {0};
     handle.callerAddress = this;
     handle.dataAddress = groups;
-    return addon->toAddon->GetChannelGroups(&handle, groups->IsRadio());
+    return addon->toAddon->GetChannelGroups(addon, &handle, groups->IsRadio());
   }, m_clientCapabilities.SupportsChannelGroups());
 }
 
@@ -803,7 +803,7 @@ PVR_ERROR CPVRClient::GetChannelGroupMembers(CPVRChannelGroup* group)
 
     PVR_CHANNEL_GROUP tag;
     WriteClientGroupInfo(*group, tag);
-    return addon->toAddon->GetChannelGroupMembers(&handle, tag);
+    return addon->toAddon->GetChannelGroupMembers(addon, &handle, tag);
   }, m_clientCapabilities.SupportsChannelGroups());
 }
 
@@ -811,7 +811,7 @@ PVR_ERROR CPVRClient::GetChannelsAmount(int& iChannels)
 {
   iChannels = -1;
   return DoAddonCall(__FUNCTION__, [&iChannels](const AddonInstance* addon) {
-    iChannels = addon->toAddon->GetChannelsAmount();
+    iChannels = addon->toAddon->GetChannelsAmount(addon);
     return (iChannels == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
 }
@@ -822,7 +822,7 @@ PVR_ERROR CPVRClient::GetChannels(CPVRChannelGroup& channels, bool radio)
     ADDON_HANDLE_STRUCT handle = {0};
     handle.callerAddress = this;
     handle.dataAddress = &channels;
-    return addon->toAddon->GetChannels(&handle, radio);
+    return addon->toAddon->GetChannels(addon, &handle, radio);
   }, (radio && m_clientCapabilities.SupportsRadio()) || (!radio && m_clientCapabilities.SupportsTV()));
 }
 
@@ -830,18 +830,19 @@ PVR_ERROR CPVRClient::GetRecordingsAmount(bool deleted, int& iRecordings)
 {
   iRecordings = -1;
   return DoAddonCall(__FUNCTION__, [deleted, &iRecordings](const AddonInstance* addon) {
-    iRecordings = addon->toAddon->GetRecordingsAmount(deleted);
+    iRecordings = addon->toAddon->GetRecordingsAmount(addon, deleted);
     return (iRecordings == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   }, m_clientCapabilities.SupportsRecordings() && (!deleted || m_clientCapabilities.SupportsRecordingsUndelete()));
 }
 
-PVR_ERROR CPVRClient::GetRecordings(CPVRRecordings* results, bool deleted) {
+PVR_ERROR CPVRClient::GetRecordings(CPVRRecordings *results, bool deleted)
+{
   return DoAddonCall(__FUNCTION__, [this, results, deleted](const AddonInstance* addon)
   {
     ADDON_HANDLE_STRUCT handle = {0};
     handle.callerAddress = this;
     handle.dataAddress = results;
-    return addon->toAddon->GetRecordings(&handle, deleted);
+    return addon->toAddon->GetRecordings(addon, &handle, deleted);
   }, m_clientCapabilities.SupportsRecordings() && (!deleted || m_clientCapabilities.SupportsRecordingsUndelete()));
 }
 
@@ -850,7 +851,7 @@ PVR_ERROR CPVRClient::DeleteRecording(const CPVRRecording& recording)
   return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->DeleteRecording(tag);
+    return addon->toAddon->DeleteRecording(addon, tag);
   }, m_clientCapabilities.SupportsRecordings());
 }
 
@@ -859,14 +860,14 @@ PVR_ERROR CPVRClient::UndeleteRecording(const CPVRRecording& recording)
   return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->UndeleteRecording(tag);
+    return addon->toAddon->UndeleteRecording(addon, tag);
   }, m_clientCapabilities.SupportsRecordingsUndelete());
 }
 
 PVR_ERROR CPVRClient::DeleteAllRecordingsFromTrash()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    return addon->toAddon->DeleteAllRecordingsFromTrash();
+    return addon->toAddon->DeleteAllRecordingsFromTrash(addon);
   }, m_clientCapabilities.SupportsRecordingsUndelete());
 }
 
@@ -875,7 +876,7 @@ PVR_ERROR CPVRClient::RenameRecording(const CPVRRecording& recording)
   return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->RenameRecording(tag);
+    return addon->toAddon->RenameRecording(addon, tag);
   }, m_clientCapabilities.SupportsRecordings());
 }
 
@@ -884,7 +885,7 @@ PVR_ERROR CPVRClient::SetRecordingLifetime(const CPVRRecording& recording)
   return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->SetRecordingLifetime(&tag);
+    return addon->toAddon->SetRecordingLifetime(addon, &tag);
   }, m_clientCapabilities.SupportsRecordingsLifetimeChange());
 }
 
@@ -893,7 +894,7 @@ PVR_ERROR CPVRClient::SetRecordingPlayCount(const CPVRRecording& recording, int
   return DoAddonCall(__FUNCTION__, [&recording, count](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->SetRecordingPlayCount(tag, count);
+    return addon->toAddon->SetRecordingPlayCount(addon, tag, count);
   }, m_clientCapabilities.SupportsRecordingsPlayCount());
 }
 
@@ -902,7 +903,7 @@ PVR_ERROR CPVRClient::SetRecordingLastPlayedPosition(const CPVRRecording& record
   return DoAddonCall(__FUNCTION__, [&recording, lastplayedposition](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->SetRecordingLastPlayedPosition(tag, lastplayedposition);
+    return addon->toAddon->SetRecordingLastPlayedPosition(addon, tag, lastplayedposition);
   }, m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
  }
 
@@ -912,7 +913,7 @@ PVR_ERROR CPVRClient::GetRecordingLastPlayedPosition(const CPVRRecording& record
   return DoAddonCall(__FUNCTION__, [&recording, &iPosition](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    iPosition = addon->toAddon->GetRecordingLastPlayedPosition(tag);
+    iPosition = addon->toAddon->GetRecordingLastPlayedPosition(addon, tag);
     return (iPosition == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   }, m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
 }
@@ -926,7 +927,7 @@ PVR_ERROR CPVRClient::GetRecordingEdl(const CPVRRecording& recording, std::vecto
 
     PVR_EDL_ENTRY edl_array[PVR_ADDON_EDL_LENGTH];
     int size = PVR_ADDON_EDL_LENGTH;
-    PVR_ERROR error = addon->toAddon->GetRecordingEdl(tag, edl_array, &size);
+    PVR_ERROR error = addon->toAddon->GetRecordingEdl(addon, tag, edl_array, &size);
     if (error == PVR_ERROR_NO_ERROR)
     {
       edls.reserve(size);
@@ -942,7 +943,7 @@ PVR_ERROR CPVRClient::GetRecordingSize(const CPVRRecording& recording, int64_t&
   return DoAddonCall(__FUNCTION__, [&recording, &sizeInBytes](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->GetRecordingSize(&tag, &sizeInBytes);
+    return addon->toAddon->GetRecordingSize(addon, &tag, &sizeInBytes);
   }, m_clientCapabilities.SupportsRecordingsSize());
 }
 
@@ -950,7 +951,7 @@ PVR_ERROR CPVRClient::GetTimersAmount(int& iTimers)
 {
   iTimers = -1;
   return DoAddonCall(__FUNCTION__, [&iTimers](const AddonInstance* addon) {
-    iTimers = addon->toAddon->GetTimersAmount();
+    iTimers = addon->toAddon->GetTimersAmount(addon);
     return (iTimers == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   }, m_clientCapabilities.SupportsTimers());
 }
@@ -961,7 +962,7 @@ PVR_ERROR CPVRClient::GetTimers(CPVRTimersContainer* results)
     ADDON_HANDLE_STRUCT handle = {0};
     handle.callerAddress = this;
     handle.dataAddress = results;
-    return addon->toAddon->GetTimers(&handle);
+    return addon->toAddon->GetTimers(addon, &handle);
   }, m_clientCapabilities.SupportsTimers());
 }
 
@@ -970,7 +971,7 @@ PVR_ERROR CPVRClient::AddTimer(const CPVRTimerInfoTag& timer)
   return DoAddonCall(__FUNCTION__, [&timer](const AddonInstance* addon) {
     PVR_TIMER tag;
     WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->AddTimer(tag);
+    return addon->toAddon->AddTimer(addon, tag);
   }, m_clientCapabilities.SupportsTimers());
 }
 
@@ -979,7 +980,7 @@ PVR_ERROR CPVRClient::DeleteTimer(const CPVRTimerInfoTag& timer, bool bForce /*
   return DoAddonCall(__FUNCTION__, [&timer, bForce](const AddonInstance* addon) {
     PVR_TIMER tag;
     WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->DeleteTimer(tag, bForce);
+    return addon->toAddon->DeleteTimer(addon, tag, bForce);
   }, m_clientCapabilities.SupportsTimers());
 }
 
@@ -988,7 +989,7 @@ PVR_ERROR CPVRClient::UpdateTimer(const CPVRTimerInfoTag& timer)
   return DoAddonCall(__FUNCTION__, [&timer](const AddonInstance* addon) {
     PVR_TIMER tag;
     WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->UpdateTimer(tag);
+    return addon->toAddon->UpdateTimer(addon, tag);
   }, m_clientCapabilities.SupportsTimers());
 }
 
@@ -1002,7 +1003,7 @@ PVR_ERROR CPVRClient::GetTimerTypes(std::vector<std::shared_ptr<CPVRTimerType>>&
 PVR_ERROR CPVRClient::GetStreamReadChunkSize(int& iChunkSize)
 {
   return DoAddonCall(__FUNCTION__, [&iChunkSize](const AddonInstance* addon) {
-    return addon->toAddon->GetStreamReadChunkSize(&iChunkSize);
+    return addon->toAddon->GetStreamReadChunkSize(addon, &iChunkSize);
   }, m_clientCapabilities.SupportsRecordings() || m_clientCapabilities.HandlesInputStream());
 }
 
@@ -1010,7 +1011,7 @@ PVR_ERROR CPVRClient::ReadLiveStream(void* lpBuf, int64_t uiBufSize, int& iRead)
 {
   iRead = -1;
   return DoAddonCall(__FUNCTION__, [&lpBuf, uiBufSize, &iRead](const AddonInstance* addon) {
-    iRead = addon->toAddon->ReadLiveStream(static_cast<unsigned char*>(lpBuf),
+    iRead = addon->toAddon->ReadLiveStream(addon, static_cast<unsigned char*>(lpBuf),
                                            static_cast<int>(uiBufSize));
     return (iRead == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
@@ -1020,7 +1021,7 @@ PVR_ERROR CPVRClient::ReadRecordedStream(void* lpBuf, int64_t uiBufSize, int& iR
 {
   iRead = -1;
   return DoAddonCall(__FUNCTION__, [&lpBuf, uiBufSize, &iRead](const AddonInstance* addon) {
-    iRead = addon->toAddon->ReadRecordedStream(static_cast<unsigned char*>(lpBuf),
+    iRead = addon->toAddon->ReadRecordedStream(addon, static_cast<unsigned char*>(lpBuf),
                                                static_cast<int>(uiBufSize));
     return (iRead == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
@@ -1030,7 +1031,7 @@ PVR_ERROR CPVRClient::SeekLiveStream(int64_t iFilePosition, int iWhence, int64_t
 {
   iPosition = -1;
   return DoAddonCall(__FUNCTION__, [iFilePosition, iWhence, &iPosition](const AddonInstance* addon) {
-    iPosition = addon->toAddon->SeekLiveStream(iFilePosition, iWhence);
+    iPosition = addon->toAddon->SeekLiveStream(addon, iFilePosition, iWhence);
     return (iPosition == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
 }
@@ -1039,7 +1040,7 @@ PVR_ERROR CPVRClient::SeekRecordedStream(int64_t iFilePosition, int iWhence, int
 {
   iPosition = -1;
   return DoAddonCall(__FUNCTION__, [iFilePosition, iWhence, &iPosition](const AddonInstance* addon) {
-    iPosition = addon->toAddon->SeekRecordedStream(iFilePosition, iWhence);
+    iPosition = addon->toAddon->SeekRecordedStream(addon, iFilePosition, iWhence);
     return (iPosition == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
 }
@@ -1047,8 +1048,8 @@ PVR_ERROR CPVRClient::SeekRecordedStream(int64_t iFilePosition, int iWhence, int
 PVR_ERROR CPVRClient::SeekTime(double time, bool backwards, double* startpts)
 {
   return DoAddonCall(__FUNCTION__, [time, backwards, &startpts](const AddonInstance* addon) {
-    return addon->toAddon->SeekTime(time, backwards, startpts) ? PVR_ERROR_NO_ERROR
-                                                               : PVR_ERROR_NOT_IMPLEMENTED;
+    return addon->toAddon->SeekTime(addon, time, backwards, startpts) ? PVR_ERROR_NO_ERROR
+                                                                      : PVR_ERROR_NOT_IMPLEMENTED;
   });
 }
 
@@ -1056,7 +1057,7 @@ PVR_ERROR CPVRClient::GetLiveStreamLength(int64_t& iLength)
 {
   iLength = -1;
   return DoAddonCall(__FUNCTION__, [&iLength](const AddonInstance* addon) {
-    iLength = addon->toAddon->LengthLiveStream();
+    iLength = addon->toAddon->LengthLiveStream(addon);
     return (iLength == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
 }
@@ -1065,7 +1066,7 @@ PVR_ERROR CPVRClient::GetRecordedStreamLength(int64_t& iLength)
 {
   iLength = -1;
   return DoAddonCall(__FUNCTION__, [&iLength](const AddonInstance* addon) {
-    iLength = addon->toAddon->LengthRecordedStream();
+    iLength = addon->toAddon->LengthRecordedStream(addon);
     return (iLength == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
 }
@@ -1073,14 +1074,14 @@ PVR_ERROR CPVRClient::GetRecordedStreamLength(int64_t& iLength)
 PVR_ERROR CPVRClient::SignalQuality(int channelUid, PVR_SIGNAL_STATUS& qualityinfo)
 {
   return DoAddonCall(__FUNCTION__, [channelUid, &qualityinfo](const AddonInstance* addon) {
-    return addon->toAddon->GetSignalStatus(channelUid, &qualityinfo);
+    return addon->toAddon->GetSignalStatus(addon, channelUid, &qualityinfo);
   });
 }
 
 PVR_ERROR CPVRClient::GetDescrambleInfo(int channelUid, PVR_DESCRAMBLE_INFO& descrambleinfo) const
 {
   return DoAddonCall(__FUNCTION__, [channelUid, &descrambleinfo](const AddonInstance* addon) {
-    return addon->toAddon->GetDescrambleInfo(channelUid, &descrambleinfo);
+    return addon->toAddon->GetDescrambleInfo(addon, channelUid, &descrambleinfo);
   }, m_clientCapabilities.SupportsDescrambleInfo());
 }
 
@@ -1098,7 +1099,7 @@ PVR_ERROR CPVRClient::GetChannelStreamProperties(const std::shared_ptr<CPVRChann
     memset(properties.get(), 0, iPropertyCount * sizeof(PVR_NAMED_VALUE));
 
     PVR_ERROR error =
-        addon->toAddon->GetChannelStreamProperties(&tag, properties.get(), &iPropertyCount);
+        addon->toAddon->GetChannelStreamProperties(addon, &tag, properties.get(), &iPropertyCount);
     if (error == PVR_ERROR_NO_ERROR)
       WriteStreamProperties(properties.get(), iPropertyCount, props);
 
@@ -1120,7 +1121,7 @@ PVR_ERROR CPVRClient::GetRecordingStreamProperties(const std::shared_ptr<CPVRRec
     memset(properties.get(), 0, iPropertyCount * sizeof(PVR_NAMED_VALUE));
 
     PVR_ERROR error =
-        addon->toAddon->GetRecordingStreamProperties(&tag, properties.get(), &iPropertyCount);
+        addon->toAddon->GetRecordingStreamProperties(addon, &tag, properties.get(), &iPropertyCount);
     if (error == PVR_ERROR_NO_ERROR)
       WriteStreamProperties(properties.get(), iPropertyCount, props);
 
@@ -1131,14 +1132,14 @@ PVR_ERROR CPVRClient::GetRecordingStreamProperties(const std::shared_ptr<CPVRRec
 PVR_ERROR CPVRClient::GetStreamProperties(PVR_STREAM_PROPERTIES* props)
 {
   return DoAddonCall(__FUNCTION__, [&props](const AddonInstance* addon) {
-    return addon->toAddon->GetStreamProperties(props);
+    return addon->toAddon->GetStreamProperties(addon, props);
   });
 }
 
 PVR_ERROR CPVRClient::DemuxReset()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->DemuxReset();
+    addon->toAddon->DemuxReset(addon);
     return PVR_ERROR_NO_ERROR;
   }, m_clientCapabilities.HandlesDemuxing());
 }
@@ -1146,7 +1147,7 @@ PVR_ERROR CPVRClient::DemuxReset()
 PVR_ERROR CPVRClient::DemuxAbort()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->DemuxAbort();
+    addon->toAddon->DemuxAbort(addon);
     return PVR_ERROR_NO_ERROR;
   }, m_clientCapabilities.HandlesDemuxing());
 }
@@ -1154,7 +1155,7 @@ PVR_ERROR CPVRClient::DemuxAbort()
 PVR_ERROR CPVRClient::DemuxFlush()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->DemuxFlush();
+    addon->toAddon->DemuxFlush(addon);
     return PVR_ERROR_NO_ERROR;
   }, m_clientCapabilities.HandlesDemuxing());
 }
@@ -1162,7 +1163,7 @@ PVR_ERROR CPVRClient::DemuxFlush()
 PVR_ERROR CPVRClient::DemuxRead(DemuxPacket* &packet)
 {
   return DoAddonCall(__FUNCTION__, [&packet](const AddonInstance* addon) {
-    packet = addon->toAddon->DemuxRead();
+    packet = addon->toAddon->DemuxRead(addon);
     return packet ? PVR_ERROR_NO_ERROR : PVR_ERROR_NOT_IMPLEMENTED;
   }, m_clientCapabilities.HandlesDemuxing());
 }
@@ -1242,7 +1243,8 @@ PVR_ERROR CPVRClient::OpenLiveStream(const std::shared_ptr<CPVRChannel>& channel
       CLog::LogFC(LOGDEBUG, LOGPVR, "Opening live stream for channel '%s'", channel->ChannelName().c_str());
       PVR_CHANNEL tag;
       WriteClientChannelInfo(channel, tag);
-      return addon->toAddon->OpenLiveStream(tag) ? PVR_ERROR_NO_ERROR : PVR_ERROR_NOT_IMPLEMENTED;
+      return addon->toAddon->OpenLiveStream(addon, tag) ? PVR_ERROR_NO_ERROR
+                                                        : PVR_ERROR_NOT_IMPLEMENTED;
     }
   });
 }
@@ -1258,14 +1260,15 @@ PVR_ERROR CPVRClient::OpenRecordedStream(const std::shared_ptr<CPVRRecording>& r
     PVR_RECORDING tag;
     WriteClientRecordingInfo(*recording, tag);
     CLog::LogFC(LOGDEBUG, LOGPVR, "Opening stream for recording '%s'", recording->m_strTitle.c_str());
-    return addon->toAddon->OpenRecordedStream(tag) ? PVR_ERROR_NO_ERROR : PVR_ERROR_NOT_IMPLEMENTED;
+    return addon->toAddon->OpenRecordedStream(addon, tag) ? PVR_ERROR_NO_ERROR
+                                                          : PVR_ERROR_NOT_IMPLEMENTED;
   }, m_clientCapabilities.SupportsRecordings());
 }
 
 PVR_ERROR CPVRClient::CloseLiveStream()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->CloseLiveStream();
+    addon->toAddon->CloseLiveStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1273,7 +1276,7 @@ PVR_ERROR CPVRClient::CloseLiveStream()
 PVR_ERROR CPVRClient::CloseRecordedStream()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->CloseRecordedStream();
+    addon->toAddon->CloseRecordedStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1281,7 +1284,7 @@ PVR_ERROR CPVRClient::CloseRecordedStream()
 PVR_ERROR CPVRClient::PauseStream(bool bPaused)
 {
   return DoAddonCall(__FUNCTION__, [bPaused](const AddonInstance* addon) {
-    addon->toAddon->PauseStream(bPaused);
+    addon->toAddon->PauseStream(addon, bPaused);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1289,7 +1292,7 @@ PVR_ERROR CPVRClient::PauseStream(bool bPaused)
 PVR_ERROR CPVRClient::SetSpeed(int speed)
 {
   return DoAddonCall(__FUNCTION__, [speed](const AddonInstance* addon) {
-    addon->toAddon->SetSpeed(speed);
+    addon->toAddon->SetSpeed(addon, speed);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1297,7 +1300,7 @@ PVR_ERROR CPVRClient::SetSpeed(int speed)
 PVR_ERROR CPVRClient::FillBuffer(bool mode)
 {
   return DoAddonCall(__FUNCTION__, [mode](const AddonInstance* addon) {
-    addon->toAddon->FillBuffer(mode);
+    addon->toAddon->FillBuffer(addon, mode);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1306,7 +1309,7 @@ PVR_ERROR CPVRClient::CanPauseStream(bool& bCanPause) const
 {
   bCanPause = false;
   return DoAddonCall(__FUNCTION__, [&bCanPause](const AddonInstance* addon) {
-    bCanPause = addon->toAddon->CanPauseStream();
+    bCanPause = addon->toAddon->CanPauseStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1315,7 +1318,7 @@ PVR_ERROR CPVRClient::CanSeekStream(bool& bCanSeek) const
 {
   bCanSeek = false;
   return DoAddonCall(__FUNCTION__, [&bCanSeek](const AddonInstance* addon) {
-    bCanSeek = addon->toAddon->CanSeekStream();
+    bCanSeek = addon->toAddon->CanSeekStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1323,7 +1326,7 @@ PVR_ERROR CPVRClient::CanSeekStream(bool& bCanSeek) const
 PVR_ERROR CPVRClient::GetStreamTimes(PVR_STREAM_TIMES* times)
 {
   return DoAddonCall(__FUNCTION__, [&times](const AddonInstance* addon) {
-    return addon->toAddon->GetStreamTimes(times);
+    return addon->toAddon->GetStreamTimes(addon, times);
   });
 }
 
@@ -1331,7 +1334,7 @@ PVR_ERROR CPVRClient::IsRealTimeStream(bool& bRealTime) const
 {
   bRealTime = false;
   return DoAddonCall(__FUNCTION__, [&bRealTime](const AddonInstance* addon) {
-    bRealTime = addon->toAddon->IsRealTimeStream();
+    bRealTime = addon->toAddon->IsRealTimeStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1339,7 +1342,7 @@ PVR_ERROR CPVRClient::IsRealTimeStream(bool& bRealTime) const
 PVR_ERROR CPVRClient::OnSystemSleep()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->OnSystemSleep();
+    addon->toAddon->OnSystemSleep(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1347,7 +1350,7 @@ PVR_ERROR CPVRClient::OnSystemSleep()
 PVR_ERROR CPVRClient::OnSystemWake()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->OnSystemWake();
+    addon->toAddon->OnSystemWake(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1355,7 +1358,7 @@ PVR_ERROR CPVRClient::OnSystemWake()
 PVR_ERROR CPVRClient::OnPowerSavingActivated()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->OnPowerSavingActivated();
+    addon->toAddon->OnPowerSavingActivated(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1363,7 +1366,7 @@ PVR_ERROR CPVRClient::OnPowerSavingActivated()
 PVR_ERROR CPVRClient::OnPowerSavingDeactivated()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->OnPowerSavingDeactivated();
+    addon->toAddon->OnPowerSavingDeactivated(addon);
     return PVR_ERROR_NO_ERROR;
   });
 }
@@ -1388,7 +1391,7 @@ PVR_ERROR CPVRClient::CallEpgTagMenuHook(const CPVRClientMenuHook& hook, const s
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, menuHook, hookData);
   });
 }
 
@@ -1404,7 +1407,7 @@ PVR_ERROR CPVRClient::CallChannelMenuHook(const CPVRClientMenuHook& hook, const
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, menuHook, hookData);
   });
 }
 
@@ -1420,7 +1423,7 @@ PVR_ERROR CPVRClient::CallRecordingMenuHook(const CPVRClientMenuHook& hook, cons
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, menuHook, hookData);
   });
 }
 
@@ -1436,7 +1439,7 @@ PVR_ERROR CPVRClient::CallTimerMenuHook(const CPVRClientMenuHook& hook, const st
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, menuHook, hookData);
   });
 }
 
@@ -1451,7 +1454,7 @@ PVR_ERROR CPVRClient::CallSettingsMenuHook(const CPVRClientMenuHook& hook)
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, menuHook, hookData);
   });
 }
 

From 53de3a7f3d68e7169b76721d982e0322398aa8b9 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Thu, 30 Apr 2020 17:29:24 +0200
Subject: [PATCH 02/27] [addons][pvr] remove temp. all docs on xbmc_pvr_types.h
 and clang cleanup

This done to have the following commits cleaner and to add on last request
commit a final documentation.
---
 .../include/kodi/xbmc_pvr_types.h             | 872 +++++++-----------
 1 file changed, 339 insertions(+), 533 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index 0af801593651..f46fb7d90911 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -16,10 +16,6 @@
 #include "cores/VideoPlayer/Interface/Addon/InputStreamConstants.h"
 #endif
 
-/*! @note Define "USE_DEMUX" at compile time if demuxing in the PVR add-on is used.
- *        Also, "DVDDemuxPacket.h" file must be in the include path of the add-on,
- *        and the add-on should set bHandlesDemuxing to true.
- */
 #ifdef USE_DEMUX
 #include "DemuxPacket.h"
 #else
@@ -30,71 +26,30 @@ struct DemuxPacket;
 #include <stdio.h>
 #include <string.h>
 
-#define PVR_ADDON_NAME_STRING_LENGTH          1024
-#define PVR_ADDON_URL_STRING_LENGTH           1024
-#define PVR_ADDON_DESC_STRING_LENGTH          1024
-#define PVR_ADDON_INPUT_FORMAT_STRING_LENGTH  32
-#define PVR_ADDON_EDL_LENGTH                  32
-#define PVR_ADDON_TIMERTYPE_ARRAY_SIZE        32
+#define PVR_ADDON_NAME_STRING_LENGTH 1024
+#define PVR_ADDON_URL_STRING_LENGTH 1024
+#define PVR_ADDON_DESC_STRING_LENGTH 1024
+#define PVR_ADDON_INPUT_FORMAT_STRING_LENGTH 32
+#define PVR_ADDON_EDL_LENGTH 32
+#define PVR_ADDON_TIMERTYPE_ARRAY_SIZE 32
 #define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE 512
 #define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL 128
-#define PVR_ADDON_TIMERTYPE_STRING_LENGTH     128
-#define PVR_ADDON_ATTRIBUTE_DESC_LENGTH       128
+#define PVR_ADDON_TIMERTYPE_STRING_LENGTH 128
+#define PVR_ADDON_ATTRIBUTE_DESC_LENGTH 128
 #define PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE 512
 #define PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH 64
-#define PVR_ADDON_DATE_STRING_LENGTH          32
-
-#define XBMC_INVALID_CODEC_ID   0
-#define XBMC_INVALID_CODEC      { XBMC_CODEC_TYPE_UNKNOWN, XBMC_INVALID_CODEC_ID }
-
-//============================================================================
-/// @brief **PVR related stream property values**
-///
-/// This is used to pass additional data to Kodi on a given PVR stream.
-///
-/// Then transferred to livestream, recordings or EPG Tag stream using the
-/// properties.
-///
-//@{
-
-/// @brief the URL of the stream that should be played.
-///
-#define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
+#define PVR_ADDON_DATE_STRING_LENGTH 32
 
-/// @brief To define in stream properties the name of the inputstream add-on
-/// that should be used.
-///
-/// Leave blank to use Kodi's built-in playing capabilities or to allow ffmpeg
-/// to handle directly set to @ref PVR_STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG.
-///
-#define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
+#define XBMC_INVALID_CODEC_ID 0
+#define XBMC_INVALID_CODEC { XBMC_CODEC_TYPE_UNKNOWN, XBMC_INVALID_CODEC_ID }
 
-/// @brief the MIME type of the stream that should be played.
-///
+#define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
+#define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
 #define PVR_STREAM_PROPERTY_MIMETYPE "mimetype"
-
-/// @brief "true" to denote that the stream that should be played is a realtime
-/// stream.
-///
-/// Any other value indicates that this is no realtime stream.
-///
 #define PVR_STREAM_PROPERTY_ISREALTIMESTREAM STREAM_PROPERTY_ISREALTIMESTREAM
-
-/// @brief "true" to denote that if the stream is from an EPG tag.
-///
-/// It should be played is a live stream. Otherwise if it's a EPG tag it will
-/// play as normal video.
-///
 #define PVR_STREAM_PROPERTY_EPGPLAYBACKASLIVE "epgplaybackaslive"
-
-/// @brief Special value for @ref PVR_STREAM_PROPERTY_INPUTSTREAM to use
-/// ffmpeg to directly play a stream URL.
 #define PVR_STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG
 
-//@}
-//-------------------------------------------------------------------------------
-
-/* using the default avformat's MAX_STREAMS value to be safe */
 #define PVR_STREAM_MAX_STREAMS 20
 
 #ifdef __cplusplus
@@ -105,13 +60,13 @@ extern "C" {
 
   typedef enum
   {
-      XBMC_CODEC_TYPE_UNKNOWN = -1,
-      XBMC_CODEC_TYPE_VIDEO,
-      XBMC_CODEC_TYPE_AUDIO,
-      XBMC_CODEC_TYPE_DATA,
-      XBMC_CODEC_TYPE_SUBTITLE,
-      XBMC_CODEC_TYPE_RDS,
-      XBMC_CODEC_TYPE_NB
+    XBMC_CODEC_TYPE_UNKNOWN = -1,
+    XBMC_CODEC_TYPE_VIDEO,
+    XBMC_CODEC_TYPE_AUDIO,
+    XBMC_CODEC_TYPE_DATA,
+    XBMC_CODEC_TYPE_SUBTITLE,
+    XBMC_CODEC_TYPE_RDS,
+    XBMC_CODEC_TYPE_NB
   } xbmc_codec_type_t;
 
   typedef struct
@@ -120,14 +75,6 @@ extern "C" {
     xbmc_codec_id_t   codec_id;
   } xbmc_codec_t;
 
-  //--==----==----==----==----==----==----==----==----==----==----==----==----==
-  //                             PVR EPG "C" definitions
-
-  /*! @name EPG entry content event types */
-  //@{
-  /* These IDs come from the DVB-SI EIT table "content descriptor"
-   * Also known under the name "E-book genre assignments"
-   */
   typedef enum
   {
     EPG_EVENT_CONTENTMASK_UNDEFINED = 0x00,
@@ -144,145 +91,97 @@ extern "C" {
     EPG_EVENT_CONTENTMASK_SPECIAL = 0xB0,
     EPG_EVENT_CONTENTMASK_USERDEFINED = 0xF0
   } EPG_EVENT_CONTENTMASK;
-  //@}
 
-  /* Set EPGTAG.iGenreType or EPGTAG.iGenreSubType to EPG_GENRE_USE_STRING to transfer genre strings to Kodi */
   #define EPG_GENRE_USE_STRING 0x100
-
-  /* Separator to use in strings containing different tokens, for example writers, directors, actors of an event. */
   #define EPG_STRING_TOKEN_SEPARATOR ","
 
-  /* EPG_TAG.iFlags values */
-  const unsigned int EPG_TAG_FLAG_UNDEFINED   = 0x00000000; /*!< nothing special to say about this entry */
-  const unsigned int EPG_TAG_FLAG_IS_SERIES   = 0x00000001; /*!< this EPG entry is part of a series */
-  const unsigned int EPG_TAG_FLAG_IS_NEW      = 0x00000002; /*!< this EPG entry will be flagged as new */
-  const unsigned int EPG_TAG_FLAG_IS_PREMIERE = 0x00000004; /*!< this EPG entry will be flagged as a premiere */
-  const unsigned int EPG_TAG_FLAG_IS_FINALE   = 0x00000008; /*!< this EPG entry will be flagged as a finale */
-  const unsigned int EPG_TAG_FLAG_IS_LIVE     = 0x00000010; /*!< this EPG entry will be flagged as live */
-
-  /* Special EPG_TAG.iUniqueBroadcastId value */
+  const unsigned int EPG_TAG_FLAG_UNDEFINED = 0x00000000;
+  const unsigned int EPG_TAG_FLAG_IS_SERIES = 0x00000001;
+  const unsigned int EPG_TAG_FLAG_IS_NEW = 0x00000002;
+  const unsigned int EPG_TAG_FLAG_IS_PREMIERE = 0x00000004;
+  const unsigned int EPG_TAG_FLAG_IS_FINALE = 0x00000008;
+  const unsigned int EPG_TAG_FLAG_IS_LIVE = 0x00000010;
 
-  /*!
-   * @brief special EPG_TAG.iUniqueBroadcastId value to indicate that a tag has not a valid EPG event uid.
-   */
   const unsigned int EPG_TAG_INVALID_UID = 0;
 
-  /*!
-   * @brief special EPG_TAG.iSeriesNumber, EPG_TAG.iEpisodeNumber and EPG_TAG.iEpisodePartNumber value to indicate it is not to be used
-   */
   const int EPG_TAG_INVALID_SERIES_EPISODE = -1;
 
-  /*!
-   * @brief EPG event states. Used with EpgEventStateChange callback.
-   */
   typedef enum
   {
-    EPG_EVENT_CREATED = 0,  /*!< event created */
-    EPG_EVENT_UPDATED = 1,  /*!< event updated */
-    EPG_EVENT_DELETED = 2,  /*!< event deleted */
+    EPG_EVENT_CREATED = 0,
+    EPG_EVENT_UPDATED = 1,
+    EPG_EVENT_DELETED = 2,
   } EPG_EVENT_STATE;
 
-  /*!
-   * @brief Representation of an EPG event.
-   */
   typedef struct EPG_TAG
   {
-    unsigned int  iUniqueBroadcastId;  /*!< (required) identifier for this event. Event uids must be unique for a channel. Valid uids must be greater than EPG_TAG_INVALID_UID. */
-    unsigned int  iUniqueChannelId;    /*!< (required) unique identifier of the channel this event belongs to. */
-    const char *  strTitle;            /*!< (required) this event's title */
-    time_t        startTime;           /*!< (required) start time in UTC */
-    time_t        endTime;             /*!< (required) end time in UTC */
-    const char *  strPlotOutline;      /*!< (optional) plot outline */
-    const char *  strPlot;             /*!< (optional) plot */
-    const char *  strOriginalTitle;    /*!< (optional) originaltitle */
-    const char *  strCast;             /*!< (optional) cast. Use EPG_STRING_TOKEN_SEPARATOR to separate different persons. */
-    const char *  strDirector;         /*!< (optional) director(s). Use EPG_STRING_TOKEN_SEPARATOR to separate different persons. */
-    const char *  strWriter;           /*!< (optional) writer(s). Use EPG_STRING_TOKEN_SEPARATOR to separate different persons. */
-    int           iYear;               /*!< (optional) year */
-    const char *  strIMDBNumber;       /*!< (optional) IMDBNumber */
-    const char *  strIconPath;         /*!< (optional) icon path */
-    int           iGenreType;          /*!< (optional) genre type */
-    int           iGenreSubType;       /*!< (optional) genre sub type */
-    const char *  strGenreDescription; /*!< (optional) genre. Will be used only when iGenreType == EPG_GENRE_USE_STRING or iGenreSubType == EPG_GENRE_USE_STRING. Use EPG_STRING_TOKEN_SEPARATOR to separate different genres. */
-    const char *  strFirstAired;       /*!< (optional) first aired date of the event. Used only for display purposes. Specify in W3C date format "YYYY-MM-DD". */
-    int           iParentalRating;     /*!< (optional) parental rating */
-    int           iStarRating;         /*!< (optional) star rating */
-    int           iSeriesNumber;       /*!< (optional) series number. Set to "0" for specials/pilot. For 'invalid' set to EPG_TAG_INVALID_SERIES_EPISODE */
-    int           iEpisodeNumber;      /*!< (optional) episode number. For 'invalid' set to EPG_TAG_INVALID_SERIES_EPISODE */
-    int           iEpisodePartNumber;  /*!< (optional) episode part number. For 'invalid' set to EPG_TAG_INVALID_SERIES_EPISODE */
-    const char *  strEpisodeName;      /*!< (optional) episode name */
-    unsigned int  iFlags;              /*!< (optional) bit field of independent flags associated with the EPG entry */
-    const char *  strSeriesLink;       /*!< (optional) series link for this event */
+    unsigned int iUniqueBroadcastId;
+    unsigned int iUniqueChannelId;
+    const char* strTitle;
+    time_t startTime;
+    time_t endTime;
+    const char* strPlotOutline;
+    const char* strPlot;
+    const char* strOriginalTitle;
+    const char* strCast;
+    const char* strDirector;
+    const char* strWriter;
+    int iYear;
+    const char* strIMDBNumber;
+    const char* strIconPath;
+    int iGenreType;
+    int iGenreSubType;
+    const char* strGenreDescription;
+    const char* strFirstAired;
+    int iParentalRating;
+    int iStarRating;
+    int iSeriesNumber;
+    int iEpisodeNumber;
+    int iEpisodePartNumber;
+    const char* strEpisodeName;
+    unsigned int iFlags;
+    const char* strSeriesLink;
   } ATTRIBUTE_PACKED EPG_TAG;
 
-  //--==----==----==----==----==----==----==----==----==----==----==----==----==
-  //                            PVR timers "C" definitions
-
-  /*!
-   * @brief numeric PVR timer type definitions (PVR_TIMER.iTimerType values)
-   */
-  const unsigned int PVR_TIMER_TYPE_NONE = 0; /*!< @brief "Null" value for a numeric timer type. */
+  const unsigned int PVR_TIMER_TYPE_NONE = 0;
+  const unsigned int PVR_TIMER_NO_CLIENT_INDEX = 0;
+  const unsigned int PVR_TIMER_NO_PARENT = PVR_TIMER_NO_CLIENT_INDEX;
+  const unsigned int PVR_TIMER_NO_EPG_UID = EPG_TAG_INVALID_UID;
+  const int PVR_TIMER_ANY_CHANNEL = -1;
+
+  const unsigned int PVR_TIMER_TYPE_ATTRIBUTE_NONE = 0x00000000;
+
+  const unsigned int PVR_TIMER_TYPE_IS_MANUAL = 0x00000001;
+  const unsigned int PVR_TIMER_TYPE_IS_REPEATING = 0x00000002;
+  const unsigned int PVR_TIMER_TYPE_IS_READONLY = 0x00000004;
+  const unsigned int PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES = 0x00000008;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE = 0x00000010;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_CHANNELS = 0x00000020;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_TIME = 0x00000040;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH = 0x00000080;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH = 0x00000100;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY = 0x00000200;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS = 0x00000400;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES = 0x00000800;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN = 0x00001000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_PRIORITY = 0x00002000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_LIFETIME = 0x00004000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS = 0x00008000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP = 0x00010000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_TIME = 0x00020000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME = 0x00040000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME = 0x00080000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS = 0x00100000;
+  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE = 0x00200000;
+  const unsigned int PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE = 0x00400000;
+  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE = 0x00800000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL = 0x01000000;
+  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE = 0x02000000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE = 0x04000000;
+  const unsigned int PVR_TIMER_TYPE_IS_REMINDER = 0x08000000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_MARGIN = 0x10000000;
+  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_MARGIN = 0x20000000;
 
-  /*!
-   * @brief special PVR_TIMER.iClientIndex value to indicate that a timer has not (yet) a valid client index.
-   */
-  const unsigned int PVR_TIMER_NO_CLIENT_INDEX = 0; /*!< @brief timer has not (yet) a valid client index. */
-
-  /*!
-   * @brief special PVR_TIMER.iParentClientIndex value to indicate that a timer has no parent.
-   */
-  const unsigned int PVR_TIMER_NO_PARENT = PVR_TIMER_NO_CLIENT_INDEX; /*!< @brief timer has no parent; it was not scheduled by a repeating timer. */
-
-  /*!
-   * @brief special PVR_TIMER.iEpgUid value to indicate that a timer has no EPG event uid.
-   */
-  const unsigned int PVR_TIMER_NO_EPG_UID = EPG_TAG_INVALID_UID; /*!< @brief timer has no EPG event uid. */
-
-  /*!
-   * @brief special PVR_TIMER.iClientChannelUid value to indicate "any channel". Useful for some repeating timer types.
-   */
-  const int PVR_TIMER_ANY_CHANNEL = -1; /*!< @brief denotes "any channel", not a specific one. */
-
-  /*!
-   * @brief PVR timer type attributes (PVR_TIMER_TYPE.iAttributes values)
-   */
-  const unsigned int PVR_TIMER_TYPE_ATTRIBUTE_NONE                    = 0x00000000;
-
-  const unsigned int PVR_TIMER_TYPE_IS_MANUAL                         = 0x00000001; /*!< @brief defines whether this is a type for manual (time-based) or epg-based timers */
-  const unsigned int PVR_TIMER_TYPE_IS_REPEATING                      = 0x00000002; /*!< @brief defines whether this is a type for repeating or one-shot timers */
-  const unsigned int PVR_TIMER_TYPE_IS_READONLY                       = 0x00000004; /*!< @brief timers of this type must not be edited by Kodi */
-  const unsigned int PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES             = 0x00000008; /*!< @brief timers of this type must not be created by Kodi. All other operations are allowed, though */
-
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE           = 0x00000010; /*!< @brief this type supports enabling/disabling of the timer (PVR_TIMER.state SCHEDULED|DISABLED) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_CHANNELS                 = 0x00000020; /*!< @brief this type supports channels (PVR_TIMER.iClientChannelUid) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_TIME               = 0x00000040; /*!< @brief this type supports a recording start time (PVR_TIMER.startTime) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH          = 0x00000080; /*!< @brief this type supports matching epg episode title using PVR_TIMER.strEpgSearchString */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH       = 0x00000100; /*!< @brief this type supports matching "more" epg data (not just episode title) using PVR_TIMER.strEpgSearchString. Setting FULLTEXT_EPG_MATCH implies TITLE_EPG_MATCH */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY                = 0x00000200; /*!< @brief this type supports a first day the timer gets active (PVR_TIMER.firstday) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS                 = 0x00000400; /*!< @brief this type supports weekdays for defining the recording schedule (PVR_TIMER.iWeekdays) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES = 0x00000800; /*!< @brief this type supports the "record only new episodes" feature (PVR_TIMER.iPreventDuplicateEpisodes) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN         = 0x00001000; /*!< @brief this type supports pre and post record time (PVR_TIMER.iMarginStart, PVR_TIMER.iMarginEnd) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_PRIORITY                 = 0x00002000; /*!< @brief this type supports recording priority (PVR_TIMER.iPriority) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_LIFETIME                 = 0x00004000; /*!< @brief this type supports recording lifetime (PVR_TIMER.iLifetime) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS        = 0x00008000; /*!< @brief this type supports placing recordings in user defined folders (PVR_TIMER.strDirectory) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP          = 0x00010000; /*!< @brief this type supports a list of recording groups (PVR_TIMER.iRecordingGroup) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_TIME                 = 0x00020000; /*!< @brief this type supports a recording end time (PVR_TIMER.endTime) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME            = 0x00040000; /*!< @brief enables an 'Any Time' over-ride option for startTime (using PVR_TIMER.bStartAnyTime) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME              = 0x00080000; /*!< @brief enables a separate 'Any Time' over-ride for endTime (using PVR_TIMER.bEndAnyTime) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS           = 0x00100000; /*!< @brief this type supports specifying a maximum recordings setting' (PVR_TIMER.iMaxRecordings) */
-  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE        = 0x00200000; /*!< @brief this type should not appear on any create menus which don't provide an associated EPG tag */
-  const unsigned int PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE         = 0x00400000; /*!< @brief this type should not appear on any create menus which provide an associated EPG tag */
-  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE     = 0x00800000; /*!< @brief this type should not appear on any create menus unless associated with an EPG tag with 'series' attributes (EPG_TAG.iFlags & EPG_TAG_FLAG_IS_SERIES || EPG_TAG.iSeriesNumber >= 0 || EPG_TAG.iEpisodeNumber >= 0 || EPG_TAG.iEpisodePartNumber >= 0). Implies PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL              = 0x01000000; /*!< @brief this type supports 'any channel', for example when defining a timer rule that should match any channel instaed of a particular channel */
-  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE = 0x02000000; /*!< @brief this type should not appear on any create menus which don't provide an associated EPG tag with a series link */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE          = 0x04000000; /*!< @brief this type allows deletion of an otherwise read-only timer */
-  const unsigned int PVR_TIMER_TYPE_IS_REMINDER                       = 0x08000000; /*!< @brief timers of this type do trigger a reminder if time is up by calling the Kodi callback 'ReminderNotification'. */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_MARGIN             = 0x10000000; /*!< @brief this type supports pre record time (PVR_TIMER.iMarginStart) */
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_MARGIN               = 0x20000000; /*!< @brief this type supports post record time (PVR_TIMER.iMarginEnd) */
-
-  /*!
-   * @brief PVR timer weekdays (PVR_TIMER.iWeekdays values)
-   */
   const unsigned int PVR_WEEKDAY_NONE      = 0x00;
   const unsigned int PVR_WEEKDAY_MONDAY    = 0x01;
   const unsigned int PVR_WEEKDAY_TUESDAY   = 0x02;
@@ -295,431 +194,322 @@ extern "C" {
                                              PVR_WEEKDAY_THURSDAY | PVR_WEEKDAY_FRIDAY  | PVR_WEEKDAY_SATURDAY  |
                                              PVR_WEEKDAY_SUNDAY;
 
-  /*!
-   * @brief timeframe value for use with SetEPGTimeFrame function to indicate "no timeframe".
-   */
-  const int EPG_TIMEFRAME_UNLIMITED = -1;
-
-  /*!
-   * @brief special PVR_TIMER.iClientChannelUid and PVR_RECORDING.iChannelUid value to indicate that no channel uid is available.
-   */
-  const int PVR_CHANNEL_INVALID_UID = -1; /*!< @brief denotes that no channel uid is available. */
 
-  /*!
-   * @brief special PVR_DESCRAMBLE_INFO value to indicate that a struct member's value is not available.
-   */
+  const int EPG_TIMEFRAME_UNLIMITED = -1;
+  const int PVR_CHANNEL_INVALID_UID = -1;
   const int PVR_DESCRAMBLE_INFO_NOT_AVAILABLE = -1;
 
-  /*!
-   * @brief PVR add-on error codes
-   */
   typedef enum
   {
-    PVR_ERROR_NO_ERROR           = 0,  /*!< @brief no error occurred */
-    PVR_ERROR_UNKNOWN            = -1, /*!< @brief an unknown error occurred */
-    PVR_ERROR_NOT_IMPLEMENTED    = -2, /*!< @brief the method that Kodi called is not implemented by the add-on */
-    PVR_ERROR_SERVER_ERROR       = -3, /*!< @brief the backend reported an error, or the add-on isn't connected */
-    PVR_ERROR_SERVER_TIMEOUT     = -4, /*!< @brief the command was sent to the backend, but the response timed out */
-    PVR_ERROR_REJECTED           = -5, /*!< @brief the command was rejected by the backend */
-    PVR_ERROR_ALREADY_PRESENT    = -6, /*!< @brief the requested item can not be added, because it's already present */
-    PVR_ERROR_INVALID_PARAMETERS = -7, /*!< @brief the parameters of the method that was called are invalid for this operation */
-    PVR_ERROR_RECORDING_RUNNING  = -8, /*!< @brief a recording is running, so the timer can't be deleted without doing a forced delete */
-    PVR_ERROR_FAILED             = -9, /*!< @brief the command failed */
+    PVR_ERROR_NO_ERROR = 0,
+    PVR_ERROR_UNKNOWN = -1,
+    PVR_ERROR_NOT_IMPLEMENTED = -2,
+    PVR_ERROR_SERVER_ERROR = -3,
+    PVR_ERROR_SERVER_TIMEOUT = -4,
+    PVR_ERROR_REJECTED = -5,
+    PVR_ERROR_ALREADY_PRESENT = -6,
+    PVR_ERROR_INVALID_PARAMETERS = -7,
+    PVR_ERROR_RECORDING_RUNNING = -8,
+    PVR_ERROR_FAILED = -9,
   } PVR_ERROR;
 
-  /*!
-   * @brief PVR timer states
-   */
   typedef enum
   {
-    PVR_TIMER_STATE_NEW          = 0, /*!< @brief the timer was just created on the backend and is not yet active. This state must not be used for timers just created on the client side. */
-    PVR_TIMER_STATE_SCHEDULED    = 1, /*!< @brief the timer is scheduled for recording */
-    PVR_TIMER_STATE_RECORDING    = 2, /*!< @brief the timer is currently recordings */
-    PVR_TIMER_STATE_COMPLETED    = 3, /*!< @brief the recording completed successfully */
-    PVR_TIMER_STATE_ABORTED      = 4, /*!< @brief recording started, but was aborted */
-    PVR_TIMER_STATE_CANCELLED    = 5, /*!< @brief the timer was scheduled, but was canceled */
-    PVR_TIMER_STATE_CONFLICT_OK  = 6, /*!< @brief the scheduled timer conflicts with another one, but will be recorded */
-    PVR_TIMER_STATE_CONFLICT_NOK = 7, /*!< @brief the scheduled timer conflicts with another one and won't be recorded */
-    PVR_TIMER_STATE_ERROR        = 8, /*!< @brief the timer is scheduled, but can't be recorded for some reason */
-    PVR_TIMER_STATE_DISABLED     = 9, /*!< @brief the timer was disabled by the user, can be enabled via setting the state to PVR_TIMER_STATE_SCHEDULED */
+    PVR_TIMER_STATE_NEW = 0,
+    PVR_TIMER_STATE_SCHEDULED = 1,
+    PVR_TIMER_STATE_RECORDING = 2,
+    PVR_TIMER_STATE_COMPLETED = 3,
+    PVR_TIMER_STATE_ABORTED = 4,
+    PVR_TIMER_STATE_CANCELLED = 5,
+    PVR_TIMER_STATE_CONFLICT_OK = 6,
+    PVR_TIMER_STATE_CONFLICT_NOK = 7,
+    PVR_TIMER_STATE_ERROR = 8,
+    PVR_TIMER_STATE_DISABLED = 9,
   } PVR_TIMER_STATE;
 
-  /*!
-   * @brief PVR menu hook categories
-   */
   typedef enum
   {
-    PVR_MENUHOOK_UNKNOWN           =-1, /*!< @brief unknown menu hook */
-    PVR_MENUHOOK_ALL               = 0, /*!< @brief all categories */
-    PVR_MENUHOOK_CHANNEL           = 1, /*!< @brief for channels */
-    PVR_MENUHOOK_TIMER             = 2, /*!< @brief for timers */
-    PVR_MENUHOOK_EPG               = 3, /*!< @brief for EPG */
-    PVR_MENUHOOK_RECORDING         = 4, /*!< @brief for recordings */
-    PVR_MENUHOOK_DELETED_RECORDING = 5, /*!< @brief for deleted recordings */
-    PVR_MENUHOOK_SETTING           = 6, /*!< @brief for settings */
+    PVR_MENUHOOK_UNKNOWN = -1,
+    PVR_MENUHOOK_ALL = 0,
+    PVR_MENUHOOK_CHANNEL = 1,
+    PVR_MENUHOOK_TIMER = 2,
+    PVR_MENUHOOK_EPG = 3,
+    PVR_MENUHOOK_RECORDING = 4,
+    PVR_MENUHOOK_DELETED_RECORDING = 5,
+    PVR_MENUHOOK_SETTING = 6,
   } PVR_MENUHOOK_CAT;
 
-  /*!
-   * @brief PVR backend connection states. Used with ConnectionStateChange callback.
-   */
   typedef enum
   {
-    PVR_CONNECTION_STATE_UNKNOWN            = 0,  /*!< @brief unknown state (e.g. not yet tried to connect) */
-    PVR_CONNECTION_STATE_SERVER_UNREACHABLE = 1,  /*!< @brief backend server is not reachable (e.g. server not existing or network down)*/
-    PVR_CONNECTION_STATE_SERVER_MISMATCH    = 2,  /*!< @brief backend server is reachable, but there is not the expected type of server running (e.g. HTSP required, but FTP running at given server:port) */
-    PVR_CONNECTION_STATE_VERSION_MISMATCH   = 3,  /*!< @brief backend server is reachable, but server version does not match client requirements */
-    PVR_CONNECTION_STATE_ACCESS_DENIED      = 4,  /*!< @brief backend server is reachable, but denies client access (e.g. due to wrong credentials) */
-    PVR_CONNECTION_STATE_CONNECTED          = 5,  /*!< @brief connection to backend server is established */
-    PVR_CONNECTION_STATE_DISCONNECTED       = 6,  /*!< @brief no connection to backend server (e.g. due to network errors or client initiated disconnect)*/
-    PVR_CONNECTION_STATE_CONNECTING         = 7,  /*!< @brief connecting to backend */
+    PVR_CONNECTION_STATE_UNKNOWN = 0,
+    PVR_CONNECTION_STATE_SERVER_UNREACHABLE = 1,
+    PVR_CONNECTION_STATE_SERVER_MISMATCH = 2,
+    PVR_CONNECTION_STATE_VERSION_MISMATCH = 3,
+    PVR_CONNECTION_STATE_ACCESS_DENIED = 4,
+    PVR_CONNECTION_STATE_CONNECTED = 5,
+    PVR_CONNECTION_STATE_DISCONNECTED = 6,
+    PVR_CONNECTION_STATE_CONNECTING = 7,
   } PVR_CONNECTION_STATE;
 
-  /*!
-   * @brief PVR recording channel types
-   */
   typedef enum
   {
-    PVR_RECORDING_CHANNEL_TYPE_UNKNOWN = 0, /*!< @brief unknown */
-    PVR_RECORDING_CHANNEL_TYPE_TV      = 1, /*!< @brief TV channel */
-    PVR_RECORDING_CHANNEL_TYPE_RADIO   = 2, /*!< @brief radio channel */
+    PVR_RECORDING_CHANNEL_TYPE_UNKNOWN = 0,
+    PVR_RECORDING_CHANNEL_TYPE_TV = 1,
+    PVR_RECORDING_CHANNEL_TYPE_RADIO = 2,
   } PVR_RECORDING_CHANNEL_TYPE;
 
-  /*!
-   * @brief Representation of a named value
-   */
   typedef struct PVR_NAMED_VALUE {
-    char  strName[PVR_ADDON_NAME_STRING_LENGTH];  /*!< @brief (required) name */
-    char  strValue[PVR_ADDON_NAME_STRING_LENGTH]; /*!< @brief (required) value */
+    char strName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strValue[PVR_ADDON_NAME_STRING_LENGTH];
   } ATTRIBUTE_PACKED PVR_NAMED_VALUE;
 
-  /*!
-   * @brief Properties passed to the Create() method of an add-on.
-   */
   typedef struct AddonProperties_PVR
   {
-    const char* strUserPath;           /*!< @brief path to the user profile */
-    const char* strClientPath;         /*!< @brief path to this add-on */
-    int iEpgMaxDays;                   /*!< @brief if > EPG_TIMEFRAME_UNLIMITED, in async epg mode, deliver only events in the range from 'end time > now' to 'start time < now + iEpgMaxDays. EPG_TIMEFRAME_UNLIMITED, notify all events. */
+    const char* strUserPath;
+    const char* strClientPath;
+    int iEpgMaxDays;
   } AddonProperties_PVR;
 
-  /*!
-   * @brief Representation of a general attribute integer value.
-   */
   typedef struct PVR_ATTRIBUTE_INT_VALUE
   {
-    int iValue;                                           /*!< @brief (required) an integer value for a certain attribute */
-    char strDescription[PVR_ADDON_ATTRIBUTE_DESC_LENGTH]; /*!< @brief (optional) a localized string describing the value. If left blank, Kodi will generate a suitable representation (like the integer value as string) */
+    int iValue;
+    char strDescription[PVR_ADDON_ATTRIBUTE_DESC_LENGTH];
   } ATTRIBUTE_PACKED PVR_ATTRIBUTE_INT_VALUE;
 
-  /*!
-   * @brief PVR add-on capabilities. All capabilities are set to "false" or 0 as default
-   * If a capability is set to true, then the corresponding methods from xbmc_pvr_dll.h need to be implemented.
-   */
   typedef struct PVR_ADDON_CAPABILITIES
   {
-    bool bSupportsEPG;                  /*!< @brief true if the add-on provides EPG information */
-    bool bSupportsEPGEdl;               /*!< @brief true if the backend supports retrieving an edit decision list for an EPG tag. */
-    bool bSupportsTV;                   /*!< @brief true if this add-on provides TV channels */
-    bool bSupportsRadio;                /*!< @brief true if this add-on supports radio channels */
-    bool bSupportsRecordings;           /*!< @brief true if this add-on supports playback of recordings stored on the backend */
-    bool bSupportsRecordingsUndelete;   /*!< @brief true if this add-on supports undelete of recordings stored on the backend */
-    bool bSupportsTimers;               /*!< @brief true if this add-on supports the creation and editing of timers */
-    bool bSupportsChannelGroups;        /*!< @brief true if this add-on supports channel groups */
-    bool bSupportsChannelScan;          /*!< @brief true if this add-on support scanning for new channels on the backend */
-    bool bSupportsChannelSettings;      /*!< @brief true if this add-on supports the following functions: DeleteChannel, RenameChannel, DialogChannelSettings and DialogAddChannel */
-    bool bHandlesInputStream;           /*!< @brief true if this add-on provides an input stream. false if Kodi handles the stream. */
-    bool bHandlesDemuxing;              /*!< @brief true if this add-on demultiplexes packets. */
-    bool bSupportsRecordingPlayCount;   /*!< @brief true if the backend supports play count for recordings. */
-    bool bSupportsLastPlayedPosition;   /*!< @brief true if the backend supports store/retrieve of last played position for recordings. */
-    bool bSupportsRecordingEdl;         /*!< @brief true if the backend supports retrieving an edit decision list for recordings. */
-    bool bSupportsRecordingsRename;     /*!< @brief true if the backend supports renaming recordings. */
-    bool bSupportsRecordingsLifetimeChange; /*!< @brief true if the backend supports changing lifetime for recordings. */
-    bool bSupportsDescrambleInfo;       /*!< @brief true if the backend supports descramble information for playing channels. */
-    bool bSupportsAsyncEPGTransfer;     /*!< @brief true if this addon-on supports asynchronous transfer of epg events to Kodi using the callback function EpgEventStateChange. */
-    bool bSupportsRecordingSize;        /*!< @brief true if this addon-on supports retrieving size of recordings. */
-
-    unsigned int iRecordingsLifetimesSize; /*!< @brief (required) Count of possible values for PVR_RECORDING.iLifetime. 0 means lifetime is not supported for recordings or no own value definition wanted, but to use Kodi defaults of 1..365. */
-    PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE]; /*!< @brief (optional) Array containing the possible values for PVR_RECORDING.iLifetime. Must be filled if iLifetimesSize > 0 */
+    bool bSupportsEPG;
+    bool bSupportsEPGEdl;
+    bool bSupportsTV;
+    bool bSupportsRadio;
+    bool bSupportsRecordings;
+    bool bSupportsRecordingsUndelete;
+    bool bSupportsTimers;
+    bool bSupportsChannelGroups;
+    bool bSupportsChannelScan;
+    bool bSupportsChannelSettings;
+    bool bHandlesInputStream;
+    bool bHandlesDemuxing;
+    bool bSupportsRecordingPlayCount;
+    bool bSupportsLastPlayedPosition;
+    bool bSupportsRecordingEdl;
+    bool bSupportsRecordingsRename;
+    bool bSupportsRecordingsLifetimeChange;
+    bool bSupportsDescrambleInfo;
+    bool bSupportsAsyncEPGTransfer;
+    bool bSupportsRecordingSize;
+
+    unsigned int iRecordingsLifetimesSize;
+    PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE];
   } ATTRIBUTE_PACKED PVR_ADDON_CAPABILITIES;
 
-  /*!
-   * @brief PVR stream properties
-   */
   typedef struct PVR_STREAM_PROPERTIES
   {
     unsigned int iStreamCount;
     struct PVR_STREAM
     {
-      unsigned int      iPID;               /*!< @brief (required) PID */
-      xbmc_codec_type_t iCodecType;         /*!< @brief (required) codec type this stream */
-      xbmc_codec_id_t   iCodecId;           /*!< @brief (required) codec id of this stream */
-      char              strLanguage[4];     /*!< @brief (required) language id */
-      int               iSubtitleInfo;      /*!< @brief (required) Subtitle Info */
-      int               iFPSScale;          /*!< @brief (required) scale of 1000 and a rate of 29970 will result in 29.97 fps */
-      int               iFPSRate;           /*!< @brief (required) FPS rate */
-      int               iHeight;            /*!< @brief (required) height of the stream reported by the demuxer */
-      int               iWidth;             /*!< @brief (required) width of the stream reported by the demuxer */
-      float             fAspect;            /*!< @brief (required) display aspect ratio of the stream */
-      int               iChannels;          /*!< @brief (required) amount of channels */
-      int               iSampleRate;        /*!< @brief (required) sample rate */
-      int               iBlockAlign;        /*!< @brief (required) block alignment */
-      int               iBitRate;           /*!< @brief (required) bit rate */
-      int               iBitsPerSample;     /*!< @brief (required) bits per sample */
-    } stream[PVR_STREAM_MAX_STREAMS];       /*!< @brief (required) the streams */
+      unsigned int iPID;
+      xbmc_codec_type_t iCodecType;
+      xbmc_codec_id_t iCodecId;
+      char strLanguage[4];
+      int iSubtitleInfo;
+      int iFPSScale;
+      int iFPSRate;
+      int iHeight;
+      int iWidth;
+      float fAspect;
+      int iChannels;
+      int iSampleRate;
+      int iBlockAlign;
+      int iBitRate;
+      int iBitsPerSample;
+    } stream[PVR_STREAM_MAX_STREAMS];
   } ATTRIBUTE_PACKED PVR_STREAM_PROPERTIES;
 
-  /*!
-   * @brief Signal status information
-   */
   typedef struct PVR_SIGNAL_STATUS
   {
-    char   strAdapterName[PVR_ADDON_NAME_STRING_LENGTH];   /*!< @brief (optional) name of the adapter that's being used */
-    char   strAdapterStatus[PVR_ADDON_NAME_STRING_LENGTH]; /*!< @brief (optional) status of the adapter that's being used */
-    char   strServiceName[PVR_ADDON_NAME_STRING_LENGTH];   /*!< @brief (optional) name of the current service */
-    char   strProviderName[PVR_ADDON_NAME_STRING_LENGTH];  /*!< @brief (optional) name of the current service's provider */
-    char   strMuxName[PVR_ADDON_NAME_STRING_LENGTH];       /*!< @brief (optional) name of the current mux */
-    int    iSNR;                                           /*!< @brief (optional) signal/noise ratio */
-    int    iSignal;                                        /*!< @brief (optional) signal strength */
-    long   iBER;                                           /*!< @brief (optional) bit error rate */
-    long   iUNC;                                           /*!< @brief (optional) uncorrected blocks */
+    char strAdapterName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strAdapterStatus[PVR_ADDON_NAME_STRING_LENGTH];
+    char strServiceName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strProviderName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strMuxName[PVR_ADDON_NAME_STRING_LENGTH];
+    int iSNR;
+    int iSignal;
+    long iBER;
+    long iUNC;
   } ATTRIBUTE_PACKED PVR_SIGNAL_STATUS;
 
-  /*!
-   * @brief descramble information
-   */
   typedef struct PVR_DESCRAMBLE_INFO
   {
-    int iPid;     /*!< @brief (optional) pid; PVR_DESCRAMBLE_INFO_NOT_AVAILABLE if not available */
-    int iCaid;    /*!< @brief (optional) caid; PVR_DESCRAMBLE_INFO_NOT_AVAILABLE if not available */
-    int iProvid;  /*!< @brief (optional) provid; PVR_DESCRAMBLE_INFO_NOT_AVAILABLE if not available */
-    int iEcmTime; /*!< @brief (optional) ecm time; PVR_DESCRAMBLE_INFO_NOT_AVAILABLE if not available */
-    int iHops;    /*!< @brief (optional) hops; PVR_DESCRAMBLE_INFO_NOT_AVAILABLE if not available */
-    char strCardSystem[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];  /*!< @brief (optional); empty string if not available */
-    char strReader[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];      /*!< @brief (optional); empty string if not available */
-    char strFrom[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];        /*!< @brief (optional); empty string if not available */
-    char strProtocol[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];    /*!< @brief (optional); empty string if not available */
+    int iPid;
+    int iCaid;
+    int iProvid;
+    int iEcmTime;
+    int iHops;
+    char strCardSystem[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
+    char strReader[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
+    char strFrom[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
+    char strProtocol[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
   } ATTRIBUTE_PACKED PVR_DESCRAMBLE_INFO;
 
-  /*!
-   * @brief Menu hooks that are available in the context menus while playing a stream via this add-on.
-   * And in the Live TV settings dialog
-   */
   typedef struct PVR_MENUHOOK
   {
-    unsigned int     iHookId;              /*!< @brief (required) this hook's identifier */
-    unsigned int     iLocalizedStringId;   /*!< @brief (required) the id of the label for this hook in g_localizeStrings */
-    PVR_MENUHOOK_CAT category;             /*!< @brief (required) category of menu hook */
+    unsigned int iHookId;
+    unsigned int iLocalizedStringId;
+    PVR_MENUHOOK_CAT category;
   } ATTRIBUTE_PACKED PVR_MENUHOOK;
 
-  /*!
-   * @brief special PVR_CHANNEL.iOrder and PVR_CHANNEL_GROUP_MEMBER.iOrder value to indicate this channel has an unknown order
-   */
-  const int PVR_CHANNEL_UNKNOWN_ORDER = 0; /*!< @brief channel has an unknown order. */
+  const int PVR_CHANNEL_UNKNOWN_ORDER = 0;
 
-  /*!
-   * @brief Representation of a TV or radio channel.
-   */
   typedef struct PVR_CHANNEL
   {
-    unsigned int iUniqueId;                                            /*!< @brief (required) unique identifier for this channel */
-    bool         bIsRadio;                                             /*!< @brief (required) true if this is a radio channel, false if it's a TV channel */
-    unsigned int iChannelNumber;                                       /*!< @brief (optional) channel number of this channel on the backend */
-    unsigned int iSubChannelNumber;                                    /*!< @brief (optional) sub channel number of this channel on the backend (ATSC) */
-    char         strChannelName[PVR_ADDON_NAME_STRING_LENGTH];         /*!< @brief (optional) channel name given to this channel */
-    char         strInputFormat[PVR_ADDON_INPUT_FORMAT_STRING_LENGTH]; /*!< @brief (optional) input format type. types can be found in ffmpeg/libavformat/allformats.c
-                                                                                   leave empty if unknown */
-    unsigned int iEncryptionSystem;                                    /*!< @brief (optional) the encryption ID or CaID of this channel */
-    char         strIconPath[PVR_ADDON_URL_STRING_LENGTH];             /*!< @brief (optional) path to the channel icon (if present) */
-    bool         bIsHidden;                                            /*!< @brief (optional) true if this channel is marked as hidden */
-    bool         bHasArchive;                                          /*!< @brief (optional) true if this channel has a server-side back buffer */
-    int          iOrder;                                               /*!< @brief (optional) The value denoting the order of this channel in the 'All channels' group */
+    unsigned int iUniqueId;
+    bool bIsRadio;
+    unsigned int iChannelNumber;
+    unsigned int iSubChannelNumber;
+    char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strInputFormat[PVR_ADDON_INPUT_FORMAT_STRING_LENGTH];
+    unsigned int iEncryptionSystem;
+    char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
+    bool bIsHidden;
+    bool bHasArchive;
+    int iOrder;
   } ATTRIBUTE_PACKED PVR_CHANNEL;
 
   typedef struct PVR_CHANNEL_GROUP
   {
-    char         strGroupName[PVR_ADDON_NAME_STRING_LENGTH]; /*!< @brief (required) name of this channel group */
-    bool         bIsRadio;                                   /*!< @brief (required) true if this is a radio channel group, false otherwise. */
-    unsigned int iPosition;                                  /*!< @brief (optional) sort position of the group (0 indicates that the backend doesn't support sorting of groups) */
+    char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
+    bool bIsRadio;
+    unsigned int iPosition;
   } ATTRIBUTE_PACKED PVR_CHANNEL_GROUP;
 
   typedef struct PVR_CHANNEL_GROUP_MEMBER
   {
-    char         strGroupName[PVR_ADDON_NAME_STRING_LENGTH]; /*!< @brief (required) name of the channel group to add the channel to */
-    unsigned int iChannelUniqueId;                           /*!< @brief (required) unique id of the member */
-    unsigned int iChannelNumber;                             /*!< @brief (optional) channel number within the group */
-    unsigned int iSubChannelNumber;                          /*!< @brief (optional) sub channel number within the group (ATSC) */
-    int          iOrder;                                     /*!< @brief (optional) The value denoting the order of this channel in this group */
+    char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
+    unsigned int iChannelUniqueId;
+    unsigned int iChannelNumber;
+    unsigned int iSubChannelNumber;
+    int iOrder;
   } ATTRIBUTE_PACKED PVR_CHANNEL_GROUP_MEMBER;
 
-  /*!
-   * @brief Representation of a timer type's attribute integer value.
-   */
   typedef PVR_ATTRIBUTE_INT_VALUE PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE;
 
-  /*!
-   * @brief Representation of a timer type.
-   */
   typedef struct PVR_TIMER_TYPE
   {
-    unsigned int iId;                                       /*!< @brief (required) this type's identifier. Ids must be > PVR_TIMER_TYPE_NONE. */
-    unsigned int iAttributes;                               /*!< @brief (required) defines the attributes for this type (PVR_TIMER_TYPE_* constants). */
-    char strDescription[PVR_ADDON_TIMERTYPE_STRING_LENGTH]; /*!< @brief (optional) a short localized string describing the purpose of the type. (e.g.
-                                                              "Any time at this channel if title matches"). If left blank, Kodi will generate a
-                                                              description based on the attributes REPEATING and MANUAL. (e.g. "Repeating EPG-based." */
-    /* priority value definitions */
-    unsigned int iPrioritiesSize;                           /*!< @brief (required) Count of possible values for PVR_TMER.iPriority. 0 means priority
-                                                              is not supported by this timer type or no own value definition wanted, but to use Kodi defaults
-                                                              of 1..100. */
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE
-      priorities[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];    /*!< @brief (optional) Array containing the possible values for PVR_TMER.iPriority. Must be
-                                                              filled if iPrioritiesSize > 0 */
-    int          iPrioritiesDefault;                        /*!< @brief (optional) The default value for PVR_TMER.iPriority. Must be filled if iPrioritiesSize > 0 */
-
-    /* lifetime value definitions */
-    unsigned int iLifetimesSize;                            /*!< @brief (required) Count of possible values for PVR_TMER.iLifetime. 0 means lifetime
-                                                              is not supported by this timer type or no own value definition wanted, but to use Kodi defaults
-                                                              of 1..365. */
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE
-      lifetimes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];     /*!< @brief (optional) Array containing the possible values for PVR_TMER.iLifetime. Must be
-                                                              filled if iLifetimesSize > 0 */
-    int          iLifetimesDefault;                         /*!< @brief (optional) The default value for PVR_TMER.iLifetime. Must be filled if iLifetimesSize > 0 */
-
-    /* prevent duplicate episodes value definitions */
-    unsigned int iPreventDuplicateEpisodesSize;             /*!< @brief (required) Count of possible values for PVR_TMER.iPreventDuplicateEpisodes. 0 means duplicate
-                                                              episodes prevention is not supported by this timer type or no own value definition wanted, but to use
-                                                              Kodi defaults. */
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE
-      preventDuplicateEpisodes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-                                                            /*!< @brief (optional) Array containing the possible values for PVR_TMER.iPreventDuplicateEpisodes.. Must
-                                                              be filled if iPreventDuplicateEpisodesSize > 0 */
-    unsigned int iPreventDuplicateEpisodesDefault;          /*!< @brief (optional) The default value for PVR_TMER.iPreventDuplicateEpisodesSize. Must be filled if iPreventDuplicateEpisodesSize > 0 */
+    unsigned int iId;
+    unsigned int iAttributes;
+    char strDescription[PVR_ADDON_TIMERTYPE_STRING_LENGTH];
 
-    /* recording folder list value definitions */
-    unsigned int iRecordingGroupSize;                       /*!< @brief (required) Count of possible values of PVR_TIMER.iRecordingGroup. 0 means folder lists are not supported by this timer type */
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE
-      recordingGroup[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-                                                            /*!< @brief (optional) Array containing the possible values of PVR_TMER.iRecordingGroup. Must be filled if iRecordingGroupSize > 0 */
-    unsigned int iRecordingGroupDefault;                    /*!< @brief (optional) The default value for PVR_TIMER.iRecordingGroup. Must be filled in if PVR_TIMER.iRecordingGroupSize > 0 */
+    unsigned int iPrioritiesSize;
+    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE priorities[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    int iPrioritiesDefault;
+
+    unsigned int iLifetimesSize;
+    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE lifetimes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    int iLifetimesDefault;
 
-    /* max recordings value definitions */
-    unsigned int iMaxRecordingsSize;                        /*!< @brief (required) Count of possible values of PVR_TIMER.iMaxRecordings. 0 means max recordings are not supported by this timer type */
+    unsigned int iPreventDuplicateEpisodesSize;
     PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE
-      maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
-                                                            /*!< @brief (optional) Array containing the possible values of PVR_TMER.iMaxRecordings. */
-    int iMaxRecordingsDefault;                              /*!< @brief (optional) The default value for PVR_TIMER.iMaxRecordings. Must be filled in if PVR_TIMER.iMaxRecordingsSize > 0 */
+    preventDuplicateEpisodes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    unsigned int iPreventDuplicateEpisodesDefault;
+
+    unsigned int iRecordingGroupSize;
+    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE recordingGroup[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    unsigned int iRecordingGroupDefault;
 
+    unsigned int iMaxRecordingsSize;
+    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
+    int iMaxRecordingsDefault;
   } ATTRIBUTE_PACKED PVR_TIMER_TYPE;
 
-  /*!
-   * @brief Representation of a timer event.
-   */
   typedef struct PVR_TIMER {
-    unsigned int    iClientIndex;                              /*!< @brief (required) the index of this timer given by the client. PVR_TIMER_NO_CLIENT_INDEX indicates that the index was not yet set by the client, for example for new timers created by
-                                                                    Kodi and passed the first time to the client. A valid index must be greater than PVR_TIMER_NO_CLIENT_INDEX. */
-    unsigned int    iParentClientIndex;                        /*!< @brief (optional) for timers scheduled by a repeating timer, the index of the repeating timer that scheduled this timer (it's PVR_TIMER.iClientIndex value). Use PVR_TIMER_NO_PARENT
-                                                                    to indicate that this timer was no scheduled by a repeating timer. */
-    int             iClientChannelUid;                         /*!< @brief (optional) unique identifier of the channel to record on. PVR_TIMER_ANY_CHANNEL will denote "any channel", not a specific one. PVR_CHANNEL_INVALID_UID denotes that channel uid is not available.*/
-    time_t          startTime;                                 /*!< @brief (optional) start time of the recording in UTC. Instant timers that are sent to the add-on by Kodi will have this value set to 0.*/
-    time_t          endTime;                                   /*!< @brief (optional) end time of the recording in UTC. */
-    bool            bStartAnyTime;                             /*!< @brief (optional) for EPG based (not Manual) timers indicates startTime does not apply. Default = false */
-    bool            bEndAnyTime;                               /*!< @brief (optional) for EPG based (not Manual) timers indicates endTime does not apply. Default = false */
-    PVR_TIMER_STATE state;                                     /*!< @brief (required) the state of this timer */
-    unsigned int    iTimerType;                                /*!< @brief (required) the type of this timer. It is private to the addon and can be freely defined by the addon. The value must be greater than PVR_TIMER_TYPE_NONE.
-                                                                    Kodi does not interpret this value (except for checking for PVR_TIMER_TYPE_NONE), but will pass the right id to the addon with every PVR_TIMER instance, thus the addon easily can determine
-                                                                    the timer type. */
-    char            strTitle[PVR_ADDON_NAME_STRING_LENGTH];    /*!< @brief (required) a title for this timer */
-    char            strEpgSearchString[PVR_ADDON_NAME_STRING_LENGTH]; /*!< @brief (optional) a string used to search epg data for repeating epg-based timers. Format is backend-dependent, for example regexp */
-    bool            bFullTextEpgSearch;                        /*!< @brief (optional) indicates, whether strEpgSearchString is to match against the epg episode title only or also against "other" epg data (backend-dependent) */
-    char            strDirectory[PVR_ADDON_URL_STRING_LENGTH]; /*!< @brief (optional) the (relative) directory where the recording will be stored in */
-    char            strSummary[PVR_ADDON_DESC_STRING_LENGTH];  /*!< @brief (optional) the summary for this timer */
-    int             iPriority;                                 /*!< @brief (optional) the priority of this timer */
-    int             iLifetime;                                 /*!< @brief (optional) lifetime of recordings created by this timer. > 0 days after which recordings will be deleted by the backend, < 0 addon defined integer list reference, == 0 disabled */
-    int             iMaxRecordings;                            /*!< @brief (optional) maximum number of recordings this timer shall create. > 0 number of recordings, < 0 addon defined integer list reference, == 0 disabled */
-    unsigned int    iRecordingGroup;                           /*!< @brief (optional) integer ref to addon/backend defined list of recording groups*/
-    time_t          firstDay;                                  /*!< @brief (optional) the first day this timer is active, for repeating timers */
-    unsigned int    iWeekdays;                                 /*!< @brief (optional) week days, for repeating timers (see PVR_WEEKDAY_* constant values) */
-    unsigned int    iPreventDuplicateEpisodes;                 /*!< @brief (optional) 1 if backend should only record new episodes in case of a repeating epg-based timer, 0 if all episodes shall be recorded (no duplicate detection). Actual algorithm for
-                                                                    duplicate detection is defined by the backend. Addons may define own values for different duplicate detection algorithms, thus this is not just a bool.*/
-    unsigned int    iEpgUid;                                   /*!< @brief (optional) EPG event id associated with this timer. Event ids must be unique for a channel. Valid ids must be greater than EPG_TAG_INVALID_UID. */
-    unsigned int    iMarginStart;                              /*!< @brief (optional) if set, the backend starts the recording iMarginStart minutes before startTime. */
-    unsigned int    iMarginEnd;                                /*!< @brief (optional) if set, the backend ends the recording iMarginEnd minutes after endTime. */
-    int             iGenreType;                                /*!< @brief (optional) genre type */
-    int             iGenreSubType;                             /*!< @brief (optional) genre sub type */
-    char            strSeriesLink[PVR_ADDON_URL_STRING_LENGTH]; /*!< @brief (optional) series link for this timer. If set for an epg-based timer rule, matching events will be found by checking strSeriesLink instead of strTitle (and bFullTextEpgSearch) */
+    unsigned int iClientIndex;
+    unsigned int iParentClientIndex;
+    int iClientChannelUid;
+    time_t startTime;
+    time_t endTime;
+    bool bStartAnyTime;
+    bool bEndAnyTime;
+    PVR_TIMER_STATE state;
+    unsigned int iTimerType;
+    char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
+    char strEpgSearchString[PVR_ADDON_NAME_STRING_LENGTH];
+    bool bFullTextEpgSearch;
+    char strDirectory[PVR_ADDON_URL_STRING_LENGTH];
+    char strSummary[PVR_ADDON_DESC_STRING_LENGTH];
+    int iPriority;
+    int iLifetime;
+    int iMaxRecordings;
+    unsigned int iRecordingGroup;
+    time_t firstDay;
+    unsigned int iWeekdays;
+    unsigned int iPreventDuplicateEpisodes;
+    unsigned int iEpgUid;
+    unsigned int iMarginStart;
+    unsigned int iMarginEnd;
+    int iGenreType;
+    int iGenreSubType;
+    char strSeriesLink[PVR_ADDON_URL_STRING_LENGTH];
 
   } ATTRIBUTE_PACKED PVR_TIMER;
 
   /* PVR_RECORDING.iFlags values */
-  const unsigned int PVR_RECORDING_FLAG_UNDEFINED   = 0x00000000; /*!< @brief nothing special to say about this recording */
-  const unsigned int PVR_RECORDING_FLAG_IS_SERIES   = 0x00000001; /*!< @brief this recording is part of a series */
-  const unsigned int PVR_RECORDING_FLAG_IS_NEW      = 0x00000002; /*!< @brief this recording will be flagged as new */
-  const unsigned int PVR_RECORDING_FLAG_IS_PREMIERE = 0x00000004; /*!< @brief this recording will be flagged as a premiere */
-  const unsigned int PVR_RECORDING_FLAG_IS_FINALE   = 0x00000008; /*!< @brief this recording will be flagged as a finale */
-  const unsigned int PVR_RECORDING_FLAG_IS_LIVE     = 0x00000010; /*!< @brief this recording will be flagged as live */
+  const unsigned int PVR_RECORDING_FLAG_UNDEFINED = 0x00000000;
+  const unsigned int PVR_RECORDING_FLAG_IS_SERIES = 0x00000001;
+  const unsigned int PVR_RECORDING_FLAG_IS_NEW = 0x00000002;
+  const unsigned int PVR_RECORDING_FLAG_IS_PREMIERE = 0x00000004;
+  const unsigned int PVR_RECORDING_FLAG_IS_FINALE = 0x00000008;
+  const unsigned int PVR_RECORDING_FLAG_IS_LIVE = 0x00000010;
 
-  /*!
-   * @brief special PVR_RECORDING.iSeriesNumber and PVR_RECORDING.iEpisodeNumber value to indicate it is not to be used
-   * 
-   * Used if recording has no valid season and/or episode info.
-   */
   const unsigned int PVR_RECORDING_INVALID_SERIES_EPISODE = EPG_TAG_INVALID_SERIES_EPISODE;
 
-  /*!
-   * @brief Representation of a recording.
-   */
   typedef struct PVR_RECORDING {
-    char   strRecordingId[PVR_ADDON_NAME_STRING_LENGTH];  /*!< @brief (required) unique id of the recording on the client. */
-    char   strTitle[PVR_ADDON_NAME_STRING_LENGTH];        /*!< @brief (required) the title of this recording */
-    char   strEpisodeName[PVR_ADDON_NAME_STRING_LENGTH];  /*!< @brief (optional) episode name (also known as subtitle) */
-    int    iSeriesNumber;                                 /*!< @brief (optional) series number (usually called season). Set to "0" for specials/pilot. For 'invalid' set to PVR_RECORDING_INVALID_SERIES_EPISODE */
-    int    iEpisodeNumber;                                /*!< @brief (optional) episode number within the "iSeriesNumber" season. For 'invalid' set to PVR_RECORDING_INVALID_SERIES_EPISODE */
-    int    iYear;                                         /*!< @brief (optional) year of first release (use to identify a specific movie re-make) / first airing for TV shows. Set to '0' for invalid. */
-    char   strDirectory[PVR_ADDON_URL_STRING_LENGTH];     /*!< @brief (optional) directory of this recording on the client */
-    char   strPlotOutline[PVR_ADDON_DESC_STRING_LENGTH];  /*!< @brief (optional) plot outline */
-    char   strPlot[PVR_ADDON_DESC_STRING_LENGTH];         /*!< @brief (optional) plot */
-    char   strGenreDescription[PVR_ADDON_DESC_STRING_LENGTH]; /*!< @brief (optional) genre. Will be used only when iGenreType = EPG_GENRE_USE_STRING or iGenreSubType = EPG_GENRE_USE_STRING */
-    char   strChannelName[PVR_ADDON_NAME_STRING_LENGTH];  /*!< @brief (optional) channel name */
-    char   strIconPath[PVR_ADDON_URL_STRING_LENGTH];      /*!< @brief (optional) channel logo (icon) path */
-    char   strThumbnailPath[PVR_ADDON_URL_STRING_LENGTH]; /*!< @brief (optional) thumbnail path */
-    char   strFanartPath[PVR_ADDON_URL_STRING_LENGTH];    /*!< @brief (optional) fanart path */
-    time_t recordingTime;                                 /*!< @brief (optional) start time of the recording */
-    int    iDuration;                                     /*!< @brief (optional) duration of the recording in seconds */
-    int    iPriority;                                     /*!< @brief (optional) priority of this recording (from 0 - 100) */
-    int    iLifetime;                                     /*!< @brief (optional) life time in days of this recording */
-    int    iGenreType;                                    /*!< @brief (optional) genre type */
-    int    iGenreSubType;                                 /*!< @brief (optional) genre sub type */
-    int    iPlayCount;                                    /*!< @brief (optional) play count of this recording on the client */
-    int    iLastPlayedPosition;                           /*!< @brief (optional) last played position of this recording on the client */
-    bool   bIsDeleted;                                    /*!< @brief (optional) shows this recording is deleted and can be undelete */
-    unsigned int iEpgEventId;                             /*!< @brief (optional) EPG event id associated with this recording. Valid ids must be greater than EPG_TAG_INVALID_UID. */
-    int    iChannelUid;                                   /*!< @brief (optional) unique identifier of the channel for this recording. PVR_CHANNEL_INVALID_UID denotes that channel uid is not available. */
-    PVR_RECORDING_CHANNEL_TYPE channelType;               /*!< @brief (optional) channel type. Set to PVR_RECORDING_CHANNEL_TYPE_UNKNOWN if the type cannot be determined. */
-    char   strFirstAired[PVR_ADDON_DATE_STRING_LENGTH];   /*!< @brief (optional) first aired date of this recording. Used only for display purposes. Specify in W3C date format "YYYY-MM-DD". */
-    unsigned int iFlags;                                  /*!< @brief (optional) bit field of independent flags associated with the recording */
-    int64_t sizeInBytes;                                  /*!< @brief (optional) size of the recording in bytes */
+    char strRecordingId[PVR_ADDON_NAME_STRING_LENGTH];
+    char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
+    char strEpisodeName[PVR_ADDON_NAME_STRING_LENGTH];
+    int iSeriesNumber;
+    int iEpisodeNumber;
+    int iYear;
+    char strDirectory[PVR_ADDON_URL_STRING_LENGTH];
+    char strPlotOutline[PVR_ADDON_DESC_STRING_LENGTH];
+    char strPlot[PVR_ADDON_DESC_STRING_LENGTH];
+    char strGenreDescription[PVR_ADDON_DESC_STRING_LENGTH];
+    char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
+    char strThumbnailPath[PVR_ADDON_URL_STRING_LENGTH];
+    char strFanartPath[PVR_ADDON_URL_STRING_LENGTH];
+    time_t recordingTime;
+    int iDuration;
+    int iPriority;
+    int iLifetime;
+    int iGenreType;
+    int iGenreSubType;
+    int iPlayCount;
+    int iLastPlayedPosition;
+    bool bIsDeleted;
+    unsigned int iEpgEventId;
+    int iChannelUid;
+    PVR_RECORDING_CHANNEL_TYPE channelType;
+    char strFirstAired[PVR_ADDON_DATE_STRING_LENGTH];
+    unsigned int iFlags;
+    int64_t sizeInBytes;
   } ATTRIBUTE_PACKED PVR_RECORDING;
 
-  /*!
-   * @brief Edit definition list (EDL)
-   */
   typedef enum
   {
-    PVR_EDL_TYPE_CUT      = 0, /*!< @brief cut (completely remove content) */
-    PVR_EDL_TYPE_MUTE     = 1, /*!< @brief mute audio */
-    PVR_EDL_TYPE_SCENE    = 2, /*!< @brief scene markers (chapter seeking) */
-    PVR_EDL_TYPE_COMBREAK = 3  /*!< @brief commercial breaks */
+    PVR_EDL_TYPE_CUT = 0,
+    PVR_EDL_TYPE_MUTE = 1,
+    PVR_EDL_TYPE_SCENE = 2,
+    PVR_EDL_TYPE_COMBREAK = 3
   } PVR_EDL_TYPE;
 
   typedef struct PVR_EDL_ENTRY
   {
-    int64_t start;     // ms
-    int64_t end;       // ms
+    int64_t start;
+    int64_t end;
     PVR_EDL_TYPE type;
   } ATTRIBUTE_PACKED PVR_EDL_ENTRY;
 
-  /*!
-   * @brief PVR menu hook data
-   */
   typedef struct PVR_MENUHOOK_DATA
   {
     PVR_MENUHOOK_CAT cat;
@@ -731,15 +521,12 @@ extern "C" {
     } data;
   } ATTRIBUTE_PACKED PVR_MENUHOOK_DATA;
 
-  /*!
-   * @brief times of playing stream (Live TV and recordings)
-   */
   typedef struct PVR_STREAM_TIMES
   {
-    time_t startTime; /*!< @brief For recordings, this must be zero. For Live TV, this is a reference time in units of time_t (UTC) from which time elapsed starts. Ideally start of tv show, but can be any other value. */
-    int64_t ptsStart; /*!< @brief the pts of startTime */
-    int64_t ptsBegin; /*!< @brief earliest pts player can seek back. Value is in micro seconds, relative to ptsStart. For recordings, this must be zero. For Live TV, this must be zero if not timeshifting and must point to begin of the timeshift buffer, otherwise. */
-    int64_t ptsEnd;   /*!< @brief latest pts player can seek forward. Value is in micro seconds, relative to ptsStart. For recordings, this must be the total length. For Live TV, this must be zero if not timeshifting and must point to end of the timeshift buffer, otherwise. */
+    time_t startTime;
+    int64_t ptsStart;
+    int64_t ptsBegin;
+    int64_t ptsEnd;
   } ATTRIBUTE_PACKED PVR_STREAM_TIMES;
 
   struct AddonInstance_PVR;
@@ -815,7 +602,9 @@ extern "C" {
     const char*(__cdecl* GetBackendHostname)(const AddonInstance_PVR*);
     const char*(__cdecl* GetConnectionString)(const AddonInstance_PVR*);
     PVR_ERROR(__cdecl* GetDriveSpace)(const AddonInstance_PVR*, long long*, long long*);
-    PVR_ERROR(__cdecl* MenuHook)(const AddonInstance_PVR*, const PVR_MENUHOOK&, const PVR_MENUHOOK_DATA&);
+    PVR_ERROR(__cdecl* MenuHook)(const AddonInstance_PVR*,
+                                 const PVR_MENUHOOK&,
+                                 const PVR_MENUHOOK_DATA&);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel interface functions
@@ -833,7 +622,9 @@ extern "C" {
     // Channel group interface functions
     int(__cdecl* GetChannelGroupsAmount)(const AddonInstance_PVR*);
     PVR_ERROR(__cdecl* GetChannelGroups)(const AddonInstance_PVR*, ADDON_HANDLE, bool);
-    PVR_ERROR(__cdecl* GetChannelGroupMembers)(const AddonInstance_PVR*, ADDON_HANDLE, const PVR_CHANNEL_GROUP&);
+    PVR_ERROR(__cdecl* GetChannelGroupMembers)(const AddonInstance_PVR*,
+                                               ADDON_HANDLE,
+                                               const PVR_CHANNEL_GROUP&);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel edit interface functions
@@ -845,11 +636,21 @@ extern "C" {
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // EPG interface functions
-    PVR_ERROR(__cdecl* GetEPGForChannel)(const AddonInstance_PVR*, ADDON_HANDLE, int, time_t, time_t);
+    PVR_ERROR(__cdecl* GetEPGForChannel)(const AddonInstance_PVR*,
+                                         ADDON_HANDLE,
+                                         int,
+                                         time_t,
+                                         time_t);
     PVR_ERROR(__cdecl* IsEPGTagRecordable)(const AddonInstance_PVR*, const EPG_TAG*, bool*);
     PVR_ERROR(__cdecl* IsEPGTagPlayable)(const AddonInstance_PVR*, const EPG_TAG*, bool*);
-    PVR_ERROR(__cdecl* GetEPGTagEdl)(const AddonInstance_PVR*, const EPG_TAG*, PVR_EDL_ENTRY[], int*);
-    PVR_ERROR(__cdecl* GetEPGTagStreamProperties)(const AddonInstance_PVR*, const EPG_TAG*, PVR_NAMED_VALUE*, unsigned int*);
+    PVR_ERROR(__cdecl* GetEPGTagEdl)(const AddonInstance_PVR*,
+                                     const EPG_TAG*,
+                                     PVR_EDL_ENTRY[],
+                                     int*);
+    PVR_ERROR(__cdecl* GetEPGTagStreamProperties)(const AddonInstance_PVR*,
+                                                  const EPG_TAG*,
+                                                  PVR_NAMED_VALUE*,
+                                                  unsigned int*);
     PVR_ERROR(__cdecl* SetEPGTimeFrame)(const AddonInstance_PVR*, int);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
@@ -862,9 +663,14 @@ extern "C" {
     PVR_ERROR(__cdecl* RenameRecording)(const AddonInstance_PVR*, const PVR_RECORDING&);
     PVR_ERROR(__cdecl* SetRecordingLifetime)(const AddonInstance_PVR*, const PVR_RECORDING*);
     PVR_ERROR(__cdecl* SetRecordingPlayCount)(const AddonInstance_PVR*, const PVR_RECORDING&, int);
-    PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const AddonInstance_PVR*, const PVR_RECORDING&, int);
+    PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const AddonInstance_PVR*,
+                                                       const PVR_RECORDING&,
+                                                       int);
     int(__cdecl* GetRecordingLastPlayedPosition)(const AddonInstance_PVR*, const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* GetRecordingEdl)(const AddonInstance_PVR*, const PVR_RECORDING&, PVR_EDL_ENTRY[], int*);
+    PVR_ERROR(__cdecl* GetRecordingEdl)(const AddonInstance_PVR*,
+                                        const PVR_RECORDING&,
+                                        PVR_EDL_ENTRY[],
+                                        int*);
     PVR_ERROR(__cdecl* GetRecordingSize)(const AddonInstance_PVR*, const PVR_RECORDING*, int64_t*);
     PVR_ERROR(__cdecl* GetRecordingStreamProperties)(const AddonInstance_PVR*,
                                                      const PVR_RECORDING*,

From a0a881378d2748e84ad68b6f651f649db6f1ac2b Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Thu, 30 Apr 2020 18:27:59 +0200
Subject: [PATCH 03/27] [addons][pvr] rework xbmc_pvr_types.h to have "C"
 compatible

This thought for next changes to have one half in "C" only and the another in
"C++", further to have a 100% (+ minus 10% as DemuxPacket still C++) conform
safe interface and allow in future also "C" alone.
---
 .../include/kodi/xbmc_pvr_types.h             | 449 ++++++++++--------
 xbmc/pvr/addons/PVRClient.cpp                 |  48 +-
 2 files changed, 268 insertions(+), 229 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index f46fb7d90911..36b647d545bf 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -22,9 +22,11 @@
 struct DemuxPacket;
 #endif
 
+#include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <string.h>
+#include <time.h>
 
 #define PVR_ADDON_NAME_STRING_LENGTH 1024
 #define PVR_ADDON_URL_STRING_LENGTH 1024
@@ -41,7 +43,10 @@ struct DemuxPacket;
 #define PVR_ADDON_DATE_STRING_LENGTH 32
 
 #define XBMC_INVALID_CODEC_ID 0
-#define XBMC_INVALID_CODEC { XBMC_CODEC_TYPE_UNKNOWN, XBMC_INVALID_CODEC_ID }
+#define XBMC_INVALID_CODEC \
+  { \
+    XBMC_CODEC_TYPE_UNKNOWN, XBMC_INVALID_CODEC_ID \
+  }
 
 #define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
 #define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
@@ -58,7 +63,7 @@ extern "C" {
 
   typedef unsigned int xbmc_codec_id_t;
 
-  typedef enum
+  typedef enum xbmc_codec_type_t
   {
     XBMC_CODEC_TYPE_UNKNOWN = -1,
     XBMC_CODEC_TYPE_VIDEO,
@@ -69,13 +74,13 @@ extern "C" {
     XBMC_CODEC_TYPE_NB
   } xbmc_codec_type_t;
 
-  typedef struct
+  typedef struct xbmc_codec_t
   {
-    xbmc_codec_type_t codec_type;
-    xbmc_codec_id_t   codec_id;
+    enum xbmc_codec_type_t codec_type;
+    xbmc_codec_id_t codec_id;
   } xbmc_codec_t;
 
-  typedef enum
+  typedef enum EPG_EVENT_CONTENTMASK
   {
     EPG_EVENT_CONTENTMASK_UNDEFINED = 0x00,
     EPG_EVENT_CONTENTMASK_MOVIEDRAMA = 0x10,
@@ -95,18 +100,18 @@ extern "C" {
   #define EPG_GENRE_USE_STRING 0x100
   #define EPG_STRING_TOKEN_SEPARATOR ","
 
-  const unsigned int EPG_TAG_FLAG_UNDEFINED = 0x00000000;
-  const unsigned int EPG_TAG_FLAG_IS_SERIES = 0x00000001;
-  const unsigned int EPG_TAG_FLAG_IS_NEW = 0x00000002;
-  const unsigned int EPG_TAG_FLAG_IS_PREMIERE = 0x00000004;
-  const unsigned int EPG_TAG_FLAG_IS_FINALE = 0x00000008;
-  const unsigned int EPG_TAG_FLAG_IS_LIVE = 0x00000010;
+  #define EPG_TAG_FLAG_UNDEFINED 0x00000000
+  #define EPG_TAG_FLAG_IS_SERIES 0x00000001
+  #define EPG_TAG_FLAG_IS_NEW 0x00000002
+  #define EPG_TAG_FLAG_IS_PREMIERE 0x00000004
+  #define EPG_TAG_FLAG_IS_FINALE 0x00000008
+  #define EPG_TAG_FLAG_IS_LIVE 0x00000010
 
-  const unsigned int EPG_TAG_INVALID_UID = 0;
+  #define EPG_TAG_INVALID_UID 0
 
-  const int EPG_TAG_INVALID_SERIES_EPISODE = -1;
+  #define EPG_TAG_INVALID_SERIES_EPISODE -1
 
-  typedef enum
+  typedef enum EPG_EVENT_STATE
   {
     EPG_EVENT_CREATED = 0,
     EPG_EVENT_UPDATED = 1,
@@ -143,63 +148,65 @@ extern "C" {
     const char* strSeriesLink;
   } ATTRIBUTE_PACKED EPG_TAG;
 
-  const unsigned int PVR_TIMER_TYPE_NONE = 0;
-  const unsigned int PVR_TIMER_NO_CLIENT_INDEX = 0;
-  const unsigned int PVR_TIMER_NO_PARENT = PVR_TIMER_NO_CLIENT_INDEX;
-  const unsigned int PVR_TIMER_NO_EPG_UID = EPG_TAG_INVALID_UID;
-  const int PVR_TIMER_ANY_CHANNEL = -1;
-
-  const unsigned int PVR_TIMER_TYPE_ATTRIBUTE_NONE = 0x00000000;
-
-  const unsigned int PVR_TIMER_TYPE_IS_MANUAL = 0x00000001;
-  const unsigned int PVR_TIMER_TYPE_IS_REPEATING = 0x00000002;
-  const unsigned int PVR_TIMER_TYPE_IS_READONLY = 0x00000004;
-  const unsigned int PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES = 0x00000008;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE = 0x00000010;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_CHANNELS = 0x00000020;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_TIME = 0x00000040;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH = 0x00000080;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH = 0x00000100;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY = 0x00000200;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS = 0x00000400;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES = 0x00000800;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN = 0x00001000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_PRIORITY = 0x00002000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_LIFETIME = 0x00004000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS = 0x00008000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP = 0x00010000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_TIME = 0x00020000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME = 0x00040000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME = 0x00080000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS = 0x00100000;
-  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE = 0x00200000;
-  const unsigned int PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE = 0x00400000;
-  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE = 0x00800000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL = 0x01000000;
-  const unsigned int PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE = 0x02000000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE = 0x04000000;
-  const unsigned int PVR_TIMER_TYPE_IS_REMINDER = 0x08000000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_START_MARGIN = 0x10000000;
-  const unsigned int PVR_TIMER_TYPE_SUPPORTS_END_MARGIN = 0x20000000;
-
-  const unsigned int PVR_WEEKDAY_NONE      = 0x00;
-  const unsigned int PVR_WEEKDAY_MONDAY    = 0x01;
-  const unsigned int PVR_WEEKDAY_TUESDAY   = 0x02;
-  const unsigned int PVR_WEEKDAY_WEDNESDAY = 0x04;
-  const unsigned int PVR_WEEKDAY_THURSDAY  = 0x08;
-  const unsigned int PVR_WEEKDAY_FRIDAY    = 0x10;
-  const unsigned int PVR_WEEKDAY_SATURDAY  = 0x20;
-  const unsigned int PVR_WEEKDAY_SUNDAY    = 0x40;
-  const unsigned int PVR_WEEKDAY_ALLDAYS   = PVR_WEEKDAY_MONDAY   | PVR_WEEKDAY_TUESDAY | PVR_WEEKDAY_WEDNESDAY |
-                                             PVR_WEEKDAY_THURSDAY | PVR_WEEKDAY_FRIDAY  | PVR_WEEKDAY_SATURDAY  |
-                                             PVR_WEEKDAY_SUNDAY;
-
-
-  const int EPG_TIMEFRAME_UNLIMITED = -1;
-  const int PVR_CHANNEL_INVALID_UID = -1;
-  const int PVR_DESCRAMBLE_INFO_NOT_AVAILABLE = -1;
-
-  typedef enum
+  #define PVR_TIMER_TYPE_NONE 0
+  #define PVR_TIMER_NO_CLIENT_INDEX 0
+  #define PVR_TIMER_NO_PARENT PVR_TIMER_NO_CLIENT_INDEX
+  #define PVR_TIMER_NO_EPG_UID EPG_TAG_INVALID_UID
+  #define PVR_TIMER_ANY_CHANNEL -1
+
+  #define PVR_TIMER_TYPE_ATTRIBUTE_NONE 0x00000000
+
+  #define PVR_TIMER_TYPE_IS_MANUAL 0x00000001
+  #define PVR_TIMER_TYPE_IS_REPEATING 0x00000002
+  #define PVR_TIMER_TYPE_IS_READONLY 0x00000004
+  #define PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES 0x00000008
+  #define PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE 0x00000010
+  #define PVR_TIMER_TYPE_SUPPORTS_CHANNELS 0x00000020
+  #define PVR_TIMER_TYPE_SUPPORTS_START_TIME 0x00000040
+  #define PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH 0x00000080
+  #define PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH 0x00000100
+  #define PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY 0x00000200
+  #define PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS 0x00000400
+  #define PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES 0x00000800
+  #define PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN 0x00001000
+  #define PVR_TIMER_TYPE_SUPPORTS_PRIORITY 0x00002000
+  #define PVR_TIMER_TYPE_SUPPORTS_LIFETIME 0x00004000
+  #define PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS 0x00008000
+  #define PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP 0x00010000
+  #define PVR_TIMER_TYPE_SUPPORTS_END_TIME 0x00020000
+  #define PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME 0x00040000
+  #define PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME 0x00080000
+  #define PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS 0x00100000
+  #define PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE 0x00200000
+  #define PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE 0x00400000
+  #define PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE 0x00800000
+  #define PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL 0x01000000
+  #define PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE 0x02000000
+  #define PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE 0x04000000
+  #define PVR_TIMER_TYPE_IS_REMINDER 0x08000000
+  #define PVR_TIMER_TYPE_SUPPORTS_START_MARGIN 0x10000000
+  #define PVR_TIMER_TYPE_SUPPORTS_END_MARGIN 0x20000000
+
+  #define PVR_WEEKDAY_NONE 0x00
+  #define PVR_WEEKDAY_MONDAY 0x01
+  #define PVR_WEEKDAY_TUESDAY 0x02
+  #define PVR_WEEKDAY_WEDNESDAY 0x04
+  #define PVR_WEEKDAY_THURSDAY 0x08
+  #define PVR_WEEKDAY_FRIDAY 0x10
+  #define PVR_WEEKDAY_SATURDAY 0x20
+  #define PVR_WEEKDAY_SUNDAY 0x40
+  #define PVR_WEEKDAY_ALLDAYS \
+    ( \
+      PVR_WEEKDAY_MONDAY | PVR_WEEKDAY_TUESDAY | PVR_WEEKDAY_WEDNESDAY | PVR_WEEKDAY_THURSDAY | \
+      PVR_WEEKDAY_FRIDAY | PVR_WEEKDAY_SATURDAY | PVR_WEEKDAY_SUNDAY \
+    )
+
+
+  #define EPG_TIMEFRAME_UNLIMITED -1
+  #define PVR_CHANNEL_INVALID_UID -1
+  #define PVR_DESCRAMBLE_INFO_NOT_AVAILABLE -1
+
+  typedef enum PVR_ERROR
   {
     PVR_ERROR_NO_ERROR = 0,
     PVR_ERROR_UNKNOWN = -1,
@@ -213,7 +220,7 @@ extern "C" {
     PVR_ERROR_FAILED = -9,
   } PVR_ERROR;
 
-  typedef enum
+  typedef enum PVR_TIMER_STATE
   {
     PVR_TIMER_STATE_NEW = 0,
     PVR_TIMER_STATE_SCHEDULED = 1,
@@ -227,7 +234,7 @@ extern "C" {
     PVR_TIMER_STATE_DISABLED = 9,
   } PVR_TIMER_STATE;
 
-  typedef enum
+  typedef enum PVR_MENUHOOK_CAT
   {
     PVR_MENUHOOK_UNKNOWN = -1,
     PVR_MENUHOOK_ALL = 0,
@@ -239,7 +246,7 @@ extern "C" {
     PVR_MENUHOOK_SETTING = 6,
   } PVR_MENUHOOK_CAT;
 
-  typedef enum
+  typedef enum PVR_CONNECTION_STATE
   {
     PVR_CONNECTION_STATE_UNKNOWN = 0,
     PVR_CONNECTION_STATE_SERVER_UNREACHABLE = 1,
@@ -251,14 +258,15 @@ extern "C" {
     PVR_CONNECTION_STATE_CONNECTING = 7,
   } PVR_CONNECTION_STATE;
 
-  typedef enum
+  typedef enum PVR_RECORDING_CHANNEL_TYPE
   {
     PVR_RECORDING_CHANNEL_TYPE_UNKNOWN = 0,
     PVR_RECORDING_CHANNEL_TYPE_TV = 1,
     PVR_RECORDING_CHANNEL_TYPE_RADIO = 2,
   } PVR_RECORDING_CHANNEL_TYPE;
 
-  typedef struct PVR_NAMED_VALUE {
+  typedef struct PVR_NAMED_VALUE
+  {
     char strName[PVR_ADDON_NAME_STRING_LENGTH];
     char strValue[PVR_ADDON_NAME_STRING_LENGTH];
   } ATTRIBUTE_PACKED PVR_NAMED_VALUE;
@@ -356,10 +364,10 @@ extern "C" {
   {
     unsigned int iHookId;
     unsigned int iLocalizedStringId;
-    PVR_MENUHOOK_CAT category;
+    enum PVR_MENUHOOK_CAT category;
   } ATTRIBUTE_PACKED PVR_MENUHOOK;
 
-  const int PVR_CHANNEL_UNKNOWN_ORDER = 0;
+  #define PVR_CHANNEL_UNKNOWN_ORDER 0
 
   typedef struct PVR_CHANNEL
   {
@@ -422,7 +430,8 @@ extern "C" {
     int iMaxRecordingsDefault;
   } ATTRIBUTE_PACKED PVR_TIMER_TYPE;
 
-  typedef struct PVR_TIMER {
+  typedef struct PVR_TIMER
+  {
     unsigned int iClientIndex;
     unsigned int iParentClientIndex;
     int iClientChannelUid;
@@ -430,7 +439,7 @@ extern "C" {
     time_t endTime;
     bool bStartAnyTime;
     bool bEndAnyTime;
-    PVR_TIMER_STATE state;
+    enum PVR_TIMER_STATE state;
     unsigned int iTimerType;
     char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
     char strEpgSearchString[PVR_ADDON_NAME_STRING_LENGTH];
@@ -450,20 +459,20 @@ extern "C" {
     int iGenreType;
     int iGenreSubType;
     char strSeriesLink[PVR_ADDON_URL_STRING_LENGTH];
-
   } ATTRIBUTE_PACKED PVR_TIMER;
 
   /* PVR_RECORDING.iFlags values */
-  const unsigned int PVR_RECORDING_FLAG_UNDEFINED = 0x00000000;
-  const unsigned int PVR_RECORDING_FLAG_IS_SERIES = 0x00000001;
-  const unsigned int PVR_RECORDING_FLAG_IS_NEW = 0x00000002;
-  const unsigned int PVR_RECORDING_FLAG_IS_PREMIERE = 0x00000004;
-  const unsigned int PVR_RECORDING_FLAG_IS_FINALE = 0x00000008;
-  const unsigned int PVR_RECORDING_FLAG_IS_LIVE = 0x00000010;
+  #define PVR_RECORDING_FLAG_UNDEFINED 0x00000000
+  #define PVR_RECORDING_FLAG_IS_SERIES 0x00000001
+  #define PVR_RECORDING_FLAG_IS_NEW 0x00000002
+  #define PVR_RECORDING_FLAG_IS_PREMIERE 0x00000004
+  #define PVR_RECORDING_FLAG_IS_FINALE 0x00000008
+  #define PVR_RECORDING_FLAG_IS_LIVE 0x00000010
 
-  const unsigned int PVR_RECORDING_INVALID_SERIES_EPISODE = EPG_TAG_INVALID_SERIES_EPISODE;
+  #define PVR_RECORDING_INVALID_SERIES_EPISODE EPG_TAG_INVALID_SERIES_EPISODE
 
-  typedef struct PVR_RECORDING {
+  typedef struct PVR_RECORDING
+  {
     char strRecordingId[PVR_ADDON_NAME_STRING_LENGTH];
     char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
     char strEpisodeName[PVR_ADDON_NAME_STRING_LENGTH];
@@ -495,7 +504,7 @@ extern "C" {
     int64_t sizeInBytes;
   } ATTRIBUTE_PACKED PVR_RECORDING;
 
-  typedef enum
+  typedef enum PVR_EDL_TYPE
   {
     PVR_EDL_TYPE_CUT = 0,
     PVR_EDL_TYPE_MUTE = 1,
@@ -507,17 +516,17 @@ extern "C" {
   {
     int64_t start;
     int64_t end;
-    PVR_EDL_TYPE type;
+    enum PVR_EDL_TYPE type;
   } ATTRIBUTE_PACKED PVR_EDL_ENTRY;
 
   typedef struct PVR_MENUHOOK_DATA
   {
-    PVR_MENUHOOK_CAT cat;
+    enum PVR_MENUHOOK_CAT cat;
     union data {
       int iEpgUid;
-      PVR_CHANNEL channel;
-      PVR_TIMER timer;
-      PVR_RECORDING recording;
+      struct PVR_CHANNEL channel;
+      struct PVR_TIMER timer;
+      struct PVR_RECORDING recording;
     } data;
   } ATTRIBUTE_PACKED PVR_MENUHOOK_DATA;
 
@@ -542,30 +551,32 @@ extern "C" {
     void (*Recording)(void* kodiInstance, const char* Name, const char* FileName, bool On);
     void (*ConnectionStateChange)(void* kodiInstance,
                                   const char* strConnectionString,
-                                  PVR_CONNECTION_STATE newState,
+                                  enum PVR_CONNECTION_STATE newState,
                                   const char* strMessage);
-    void (*EpgEventStateChange)(void* kodiInstance, EPG_TAG* tag, EPG_EVENT_STATE newState);
+    void (*EpgEventStateChange)(void* kodiInstance,
+                                struct EPG_TAG* tag,
+                                enum EPG_EVENT_STATE newState);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Transfer functions where give data back to Kodi, e.g. GetChannels calls TransferChannelEntry
     void (*TransferChannelEntry)(void* kodiInstance,
                                  const ADDON_HANDLE handle,
-                                 const PVR_CHANNEL* chan);
+                                 const struct PVR_CHANNEL* chan);
     void (*TransferChannelGroup)(void* kodiInstance,
                                  const ADDON_HANDLE handle,
-                                 const PVR_CHANNEL_GROUP* group);
+                                 const struct PVR_CHANNEL_GROUP* group);
     void (*TransferChannelGroupMember)(void* kodiInstance,
                                        const ADDON_HANDLE handle,
-                                       const PVR_CHANNEL_GROUP_MEMBER* member);
+                                       const struct PVR_CHANNEL_GROUP_MEMBER* member);
     void (*TransferEpgEntry)(void* kodiInstance,
                              const ADDON_HANDLE handle,
-                             const EPG_TAG* epgentry);
+                             const struct EPG_TAG* epgentry);
     void (*TransferRecordingEntry)(void* kodiInstance,
                                    const ADDON_HANDLE handle,
-                                   const PVR_RECORDING* recording);
+                                   const struct PVR_RECORDING* recording);
     void (*TransferTimerEntry)(void* kodiInstance,
                                const ADDON_HANDLE handle,
-                               const PVR_TIMER* timer);
+                               const struct PVR_TIMER* timer);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Kodi inform interface functions
@@ -577,9 +588,9 @@ extern "C" {
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Stream demux interface functions
-    void (*FreeDemuxPacket)(void* kodiInstance, DemuxPacket* pPacket);
-    DemuxPacket* (*AllocateDemuxPacket)(void* kodiInstance, int iDataSize);
-    xbmc_codec_t (*GetCodecByName)(const void* kodiInstance, const char* strCodecName);
+    void (*FreeDemuxPacket)(void* kodiInstance, struct DemuxPacket* pPacket);
+    struct DemuxPacket* (*AllocateDemuxPacket)(void* kodiInstance, int iDataSize);
+    struct xbmc_codec_t (*GetCodecByName)(const void* kodiInstance, const char* strCodecName);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // New functions becomes added below and can be on another API change (where
@@ -596,138 +607,166 @@ extern "C" {
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // General interface functions
-    PVR_ERROR(__cdecl* GetCapabilities)(const AddonInstance_PVR*, PVR_ADDON_CAPABILITIES*);
-    const char*(__cdecl* GetBackendName)(const AddonInstance_PVR*);
-    const char*(__cdecl* GetBackendVersion)(const AddonInstance_PVR*);
-    const char*(__cdecl* GetBackendHostname)(const AddonInstance_PVR*);
-    const char*(__cdecl* GetConnectionString)(const AddonInstance_PVR*);
-    PVR_ERROR(__cdecl* GetDriveSpace)(const AddonInstance_PVR*, long long*, long long*);
-    PVR_ERROR(__cdecl* MenuHook)(const AddonInstance_PVR*,
-                                 const PVR_MENUHOOK&,
-                                 const PVR_MENUHOOK_DATA&);
+    enum PVR_ERROR(__cdecl* GetCapabilities)(const struct AddonInstance_PVR*,
+                                             struct PVR_ADDON_CAPABILITIES*);
+    const char*(__cdecl* GetBackendName)(const struct AddonInstance_PVR*);
+    const char*(__cdecl* GetBackendVersion)(const struct AddonInstance_PVR*);
+    const char*(__cdecl* GetBackendHostname)(const struct AddonInstance_PVR*);
+    const char*(__cdecl* GetConnectionString)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetDriveSpace)(const struct AddonInstance_PVR*, long long*, long long*);
+    enum PVR_ERROR(__cdecl* MenuHook)(const struct AddonInstance_PVR*,
+                                      const struct PVR_MENUHOOK*,
+                                      const struct PVR_MENUHOOK_DATA*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel interface functions
 
-    int(__cdecl* GetChannelsAmount)(const AddonInstance_PVR*);
-    PVR_ERROR(__cdecl* GetChannels)(const AddonInstance_PVR*, ADDON_HANDLE, bool);
-    PVR_ERROR(__cdecl* GetChannelStreamProperties)(const AddonInstance_PVR*,
-                                                   const PVR_CHANNEL*,
-                                                   PVR_NAMED_VALUE*,
-                                                   unsigned int*);
-    PVR_ERROR(__cdecl* GetSignalStatus)(const AddonInstance_PVR*, int, PVR_SIGNAL_STATUS*);
-    PVR_ERROR(__cdecl* GetDescrambleInfo)(const AddonInstance_PVR*, int, PVR_DESCRAMBLE_INFO*);
+    int(__cdecl* GetChannelsAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetChannels)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
+    enum PVR_ERROR(__cdecl* GetChannelStreamProperties)(const struct AddonInstance_PVR*,
+                                                        const struct PVR_CHANNEL*,
+                                                        struct PVR_NAMED_VALUE*,
+                                                        unsigned int*);
+    enum PVR_ERROR(__cdecl* GetSignalStatus)(const struct AddonInstance_PVR*,
+                                             int,
+                                             struct PVR_SIGNAL_STATUS*);
+    enum PVR_ERROR(__cdecl* GetDescrambleInfo)(const struct AddonInstance_PVR*,
+                                               int,
+                                               struct PVR_DESCRAMBLE_INFO*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel group interface functions
-    int(__cdecl* GetChannelGroupsAmount)(const AddonInstance_PVR*);
-    PVR_ERROR(__cdecl* GetChannelGroups)(const AddonInstance_PVR*, ADDON_HANDLE, bool);
-    PVR_ERROR(__cdecl* GetChannelGroupMembers)(const AddonInstance_PVR*,
-                                               ADDON_HANDLE,
-                                               const PVR_CHANNEL_GROUP&);
+    int(__cdecl* GetChannelGroupsAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetChannelGroups)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
+    enum PVR_ERROR(__cdecl* GetChannelGroupMembers)(const struct AddonInstance_PVR*,
+                                                    ADDON_HANDLE,
+                                                    const struct PVR_CHANNEL_GROUP*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel edit interface functions
-    PVR_ERROR(__cdecl* DeleteChannel)(const AddonInstance_PVR*, const PVR_CHANNEL&);
-    PVR_ERROR(__cdecl* RenameChannel)(const AddonInstance_PVR*, const PVR_CHANNEL&);
-    PVR_ERROR(__cdecl* OpenDialogChannelSettings)(const AddonInstance_PVR*, const PVR_CHANNEL&);
-    PVR_ERROR(__cdecl* OpenDialogChannelAdd)(const AddonInstance_PVR*, const PVR_CHANNEL&);
-    PVR_ERROR(__cdecl* OpenDialogChannelScan)(const AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* DeleteChannel)(const struct AddonInstance_PVR*,
+                                           const struct PVR_CHANNEL*);
+    enum PVR_ERROR(__cdecl* RenameChannel)(const struct AddonInstance_PVR*,
+                                           const struct PVR_CHANNEL*);
+    enum PVR_ERROR(__cdecl* OpenDialogChannelSettings)(const struct AddonInstance_PVR*,
+                                                       const struct PVR_CHANNEL*);
+    enum PVR_ERROR(__cdecl* OpenDialogChannelAdd)(const struct AddonInstance_PVR*,
+                                                  const struct PVR_CHANNEL*);
+    enum PVR_ERROR(__cdecl* OpenDialogChannelScan)(const struct AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // EPG interface functions
-    PVR_ERROR(__cdecl* GetEPGForChannel)(const AddonInstance_PVR*,
-                                         ADDON_HANDLE,
-                                         int,
-                                         time_t,
-                                         time_t);
-    PVR_ERROR(__cdecl* IsEPGTagRecordable)(const AddonInstance_PVR*, const EPG_TAG*, bool*);
-    PVR_ERROR(__cdecl* IsEPGTagPlayable)(const AddonInstance_PVR*, const EPG_TAG*, bool*);
-    PVR_ERROR(__cdecl* GetEPGTagEdl)(const AddonInstance_PVR*,
-                                     const EPG_TAG*,
-                                     PVR_EDL_ENTRY[],
-                                     int*);
-    PVR_ERROR(__cdecl* GetEPGTagStreamProperties)(const AddonInstance_PVR*,
-                                                  const EPG_TAG*,
-                                                  PVR_NAMED_VALUE*,
-                                                  unsigned int*);
-    PVR_ERROR(__cdecl* SetEPGTimeFrame)(const AddonInstance_PVR*, int);
+    enum PVR_ERROR(__cdecl* GetEPGForChannel)(const struct AddonInstance_PVR*,
+                                              ADDON_HANDLE,
+                                              int,
+                                              time_t,
+                                              time_t);
+    enum PVR_ERROR(__cdecl* IsEPGTagRecordable)(const struct AddonInstance_PVR*,
+                                                const struct EPG_TAG*,
+                                                bool*);
+    enum PVR_ERROR(__cdecl* IsEPGTagPlayable)(const struct AddonInstance_PVR*,
+                                              const struct EPG_TAG*,
+                                              bool*);
+    enum PVR_ERROR(__cdecl* GetEPGTagEdl)(const struct AddonInstance_PVR*,
+                                          const struct EPG_TAG*,
+                                          struct PVR_EDL_ENTRY[],
+                                          int*);
+    enum PVR_ERROR(__cdecl* GetEPGTagStreamProperties)(const struct AddonInstance_PVR*,
+                                                       const struct EPG_TAG*,
+                                                       struct PVR_NAMED_VALUE*,
+                                                       unsigned int*);
+    enum PVR_ERROR(__cdecl* SetEPGTimeFrame)(const struct AddonInstance_PVR*, int);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Recording interface functions
-    int(__cdecl* GetRecordingsAmount)(const AddonInstance_PVR*, bool);
-    PVR_ERROR(__cdecl* GetRecordings)(const AddonInstance_PVR*, ADDON_HANDLE, bool);
-    PVR_ERROR(__cdecl* DeleteRecording)(const AddonInstance_PVR*, const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* UndeleteRecording)(const AddonInstance_PVR*, const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* DeleteAllRecordingsFromTrash)(const AddonInstance_PVR*);
-    PVR_ERROR(__cdecl* RenameRecording)(const AddonInstance_PVR*, const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* SetRecordingLifetime)(const AddonInstance_PVR*, const PVR_RECORDING*);
-    PVR_ERROR(__cdecl* SetRecordingPlayCount)(const AddonInstance_PVR*, const PVR_RECORDING&, int);
-    PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const AddonInstance_PVR*,
-                                                       const PVR_RECORDING&,
-                                                       int);
-    int(__cdecl* GetRecordingLastPlayedPosition)(const AddonInstance_PVR*, const PVR_RECORDING&);
-    PVR_ERROR(__cdecl* GetRecordingEdl)(const AddonInstance_PVR*,
-                                        const PVR_RECORDING&,
-                                        PVR_EDL_ENTRY[],
-                                        int*);
-    PVR_ERROR(__cdecl* GetRecordingSize)(const AddonInstance_PVR*, const PVR_RECORDING*, int64_t*);
-    PVR_ERROR(__cdecl* GetRecordingStreamProperties)(const AddonInstance_PVR*,
-                                                     const PVR_RECORDING*,
-                                                     PVR_NAMED_VALUE*,
-                                                     unsigned int*);
+    int(__cdecl* GetRecordingsAmount)(const struct AddonInstance_PVR*, bool);
+    enum PVR_ERROR(__cdecl* GetRecordings)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
+    enum PVR_ERROR(__cdecl* DeleteRecording)(const struct AddonInstance_PVR*,
+                                             const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* UndeleteRecording)(const struct AddonInstance_PVR*,
+                                               const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* DeleteAllRecordingsFromTrash)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* RenameRecording)(const struct AddonInstance_PVR*,
+                                             const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* SetRecordingLifetime)(const struct AddonInstance_PVR*,
+                                                  const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* SetRecordingPlayCount)(const struct AddonInstance_PVR*,
+                                                   const struct PVR_RECORDING*,
+                                                   int);
+    enum PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
+                                                            const struct PVR_RECORDING*,
+                                                            int);
+    int(__cdecl* GetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
+                                                 const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* GetRecordingEdl)(const struct AddonInstance_PVR*,
+                                             const struct PVR_RECORDING*,
+                                             struct PVR_EDL_ENTRY[],
+                                             int*);
+    enum PVR_ERROR(__cdecl* GetRecordingSize)(const struct AddonInstance_PVR*,
+                                              const PVR_RECORDING*,
+                                              int64_t*);
+    enum PVR_ERROR(__cdecl* GetRecordingStreamProperties)(const struct AddonInstance_PVR*,
+                                                          const struct PVR_RECORDING*,
+                                                          struct PVR_NAMED_VALUE*,
+                                                          unsigned int*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Timer interface functions
-    PVR_ERROR(__cdecl* GetTimerTypes)(const AddonInstance_PVR*, PVR_TIMER_TYPE[], int*);
-    int(__cdecl* GetTimersAmount)(const AddonInstance_PVR*);
-    PVR_ERROR(__cdecl* GetTimers)(const AddonInstance_PVR*, ADDON_HANDLE);
-    PVR_ERROR(__cdecl* AddTimer)(const AddonInstance_PVR*, const PVR_TIMER&);
-    PVR_ERROR(__cdecl* DeleteTimer)(const AddonInstance_PVR*, const PVR_TIMER&, bool);
-    PVR_ERROR(__cdecl* UpdateTimer)(const AddonInstance_PVR*, const PVR_TIMER&);
+    enum PVR_ERROR(__cdecl* GetTimerTypes)(const struct AddonInstance_PVR*,
+                                           struct PVR_TIMER_TYPE[],
+                                           int*);
+    int(__cdecl* GetTimersAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetTimers)(const struct AddonInstance_PVR*, ADDON_HANDLE);
+    enum PVR_ERROR(__cdecl* AddTimer)(const struct AddonInstance_PVR*, const struct PVR_TIMER*);
+    enum PVR_ERROR(__cdecl* DeleteTimer)(const struct AddonInstance_PVR*,
+                                         const struct PVR_TIMER*,
+                                         bool);
+    enum PVR_ERROR(__cdecl* UpdateTimer)(const struct AddonInstance_PVR*, const struct PVR_TIMER*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Powersaving interface functions
-    void(__cdecl* OnSystemSleep)(const AddonInstance_PVR*);
-    void(__cdecl* OnSystemWake)(const AddonInstance_PVR*);
-    void(__cdecl* OnPowerSavingActivated)(const AddonInstance_PVR*);
-    void(__cdecl* OnPowerSavingDeactivated)(const AddonInstance_PVR*);
+    void(__cdecl* OnSystemSleep)(const struct AddonInstance_PVR*);
+    void(__cdecl* OnSystemWake)(const struct AddonInstance_PVR*);
+    void(__cdecl* OnPowerSavingActivated)(const struct AddonInstance_PVR*);
+    void(__cdecl* OnPowerSavingDeactivated)(const struct AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Live stream read interface functions
-    bool(__cdecl* OpenLiveStream)(const AddonInstance_PVR*, const PVR_CHANNEL&);
-    void(__cdecl* CloseLiveStream)(const AddonInstance_PVR*);
-    int(__cdecl* ReadLiveStream)(const AddonInstance_PVR*, unsigned char*, unsigned int);
-    long long(__cdecl* SeekLiveStream)(const AddonInstance_PVR*, long long, int);
-    long long(__cdecl* LengthLiveStream)(const AddonInstance_PVR*);
+    bool(__cdecl* OpenLiveStream)(const struct AddonInstance_PVR*, const struct PVR_CHANNEL*);
+    void(__cdecl* CloseLiveStream)(const struct AddonInstance_PVR*);
+    int(__cdecl* ReadLiveStream)(const struct AddonInstance_PVR*, unsigned char*, unsigned int);
+    long long(__cdecl* SeekLiveStream)(const struct AddonInstance_PVR*, long long, int);
+    long long(__cdecl* LengthLiveStream)(const struct AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Recording stream read interface functions
-    bool(__cdecl* OpenRecordedStream)(const AddonInstance_PVR*, const PVR_RECORDING&);
-    void(__cdecl* CloseRecordedStream)(const AddonInstance_PVR*);
-    int(__cdecl* ReadRecordedStream)(const AddonInstance_PVR*, unsigned char*, unsigned int);
-    long long(__cdecl* SeekRecordedStream)(const AddonInstance_PVR*, long long, int);
-    long long(__cdecl* LengthRecordedStream)(const AddonInstance_PVR*);
+    bool(__cdecl* OpenRecordedStream)(const struct AddonInstance_PVR*, const struct PVR_RECORDING*);
+    void(__cdecl* CloseRecordedStream)(const struct AddonInstance_PVR*);
+    int(__cdecl* ReadRecordedStream)(const struct AddonInstance_PVR*, unsigned char*, unsigned int);
+    long long(__cdecl* SeekRecordedStream)(const struct AddonInstance_PVR*, long long, int);
+    long long(__cdecl* LengthRecordedStream)(const struct AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Stream demux interface functions
-    PVR_ERROR(__cdecl* GetStreamProperties)(const AddonInstance_PVR*, PVR_STREAM_PROPERTIES*);
-    DemuxPacket*(__cdecl* DemuxRead)(const AddonInstance_PVR*);
-    void(__cdecl* DemuxReset)(const AddonInstance_PVR*);
-    void(__cdecl* DemuxAbort)(const AddonInstance_PVR*);
-    void(__cdecl* DemuxFlush)(const AddonInstance_PVR*);
-    void(__cdecl* SetSpeed)(const AddonInstance_PVR*, int);
-    void(__cdecl* FillBuffer)(const AddonInstance_PVR*, bool);
-    bool(__cdecl* SeekTime)(const AddonInstance_PVR*, double, bool, double*);
+    enum PVR_ERROR(__cdecl* GetStreamProperties)(const struct AddonInstance_PVR*,
+                                                 struct PVR_STREAM_PROPERTIES*);
+    struct DemuxPacket*(__cdecl* DemuxRead)(const struct AddonInstance_PVR*);
+    void(__cdecl* DemuxReset)(const struct AddonInstance_PVR*);
+    void(__cdecl* DemuxAbort)(const struct AddonInstance_PVR*);
+    void(__cdecl* DemuxFlush)(const struct AddonInstance_PVR*);
+    void(__cdecl* SetSpeed)(const struct AddonInstance_PVR*, int);
+    void(__cdecl* FillBuffer)(const struct AddonInstance_PVR*, bool);
+    bool(__cdecl* SeekTime)(const struct AddonInstance_PVR*, double, bool, double*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // General stream interface functions
-    bool(__cdecl* CanPauseStream)(const AddonInstance_PVR*);
-    void(__cdecl* PauseStream)(const AddonInstance_PVR*, bool);
-    bool(__cdecl* CanSeekStream)(const AddonInstance_PVR*);
-    bool(__cdecl* IsRealTimeStream)(const AddonInstance_PVR*);
-    PVR_ERROR(__cdecl* GetStreamTimes)(const AddonInstance_PVR*, PVR_STREAM_TIMES*);
-    PVR_ERROR(__cdecl* GetStreamReadChunkSize)(const AddonInstance_PVR*, int*);
+    bool(__cdecl* CanPauseStream)(const struct AddonInstance_PVR*);
+    void(__cdecl* PauseStream)(const struct AddonInstance_PVR*, bool);
+    bool(__cdecl* CanSeekStream)(const struct AddonInstance_PVR*);
+    bool(__cdecl* IsRealTimeStream)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetStreamTimes)(const struct AddonInstance_PVR*,
+                                            struct PVR_STREAM_TIMES*);
+    enum PVR_ERROR(__cdecl* GetStreamReadChunkSize)(const struct AddonInstance_PVR*, int*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // New functions becomes added below and can be on another API change (where
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index c81812454303..e3896c7a326e 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -582,7 +582,7 @@ PVR_ERROR CPVRClient::OpenDialogChannelAdd(const std::shared_ptr<CPVRChannel>& c
   return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
     PVR_CHANNEL addonChannel;
     WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->OpenDialogChannelAdd(addon, addonChannel);
+    return addon->toAddon->OpenDialogChannelAdd(addon, &addonChannel);
   }, m_clientCapabilities.SupportsChannelSettings());
 }
 
@@ -591,7 +591,7 @@ PVR_ERROR CPVRClient::OpenDialogChannelSettings(const std::shared_ptr<CPVRChanne
   return DoAddonCall(__FUNCTION__, [channel] (const AddonInstance* addon){
     PVR_CHANNEL addonChannel;
     WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->OpenDialogChannelSettings(addon, addonChannel);
+    return addon->toAddon->OpenDialogChannelSettings(addon, &addonChannel);
   }, m_clientCapabilities.SupportsChannelSettings());
 }
 
@@ -600,7 +600,7 @@ PVR_ERROR CPVRClient::DeleteChannel(const std::shared_ptr<CPVRChannel>& channel)
   return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
     PVR_CHANNEL addonChannel;
     WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->DeleteChannel(addon, addonChannel);
+    return addon->toAddon->DeleteChannel(addon, &addonChannel);
   }, m_clientCapabilities.SupportsChannelSettings());
 }
 
@@ -609,7 +609,7 @@ PVR_ERROR CPVRClient::RenameChannel(const std::shared_ptr<CPVRChannel>& channel)
   return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
     PVR_CHANNEL addonChannel;
     WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->RenameChannel(addon, addonChannel);
+    return addon->toAddon->RenameChannel(addon, &addonChannel);
   }, m_clientCapabilities.SupportsChannelSettings());
 }
 
@@ -803,7 +803,7 @@ PVR_ERROR CPVRClient::GetChannelGroupMembers(CPVRChannelGroup* group)
 
     PVR_CHANNEL_GROUP tag;
     WriteClientGroupInfo(*group, tag);
-    return addon->toAddon->GetChannelGroupMembers(addon, &handle, tag);
+    return addon->toAddon->GetChannelGroupMembers(addon, &handle, &tag);
   }, m_clientCapabilities.SupportsChannelGroups());
 }
 
@@ -851,7 +851,7 @@ PVR_ERROR CPVRClient::DeleteRecording(const CPVRRecording& recording)
   return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->DeleteRecording(addon, tag);
+    return addon->toAddon->DeleteRecording(addon, &tag);
   }, m_clientCapabilities.SupportsRecordings());
 }
 
@@ -860,7 +860,7 @@ PVR_ERROR CPVRClient::UndeleteRecording(const CPVRRecording& recording)
   return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->UndeleteRecording(addon, tag);
+    return addon->toAddon->UndeleteRecording(addon, &tag);
   }, m_clientCapabilities.SupportsRecordingsUndelete());
 }
 
@@ -876,7 +876,7 @@ PVR_ERROR CPVRClient::RenameRecording(const CPVRRecording& recording)
   return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->RenameRecording(addon, tag);
+    return addon->toAddon->RenameRecording(addon, &tag);
   }, m_clientCapabilities.SupportsRecordings());
 }
 
@@ -894,7 +894,7 @@ PVR_ERROR CPVRClient::SetRecordingPlayCount(const CPVRRecording& recording, int
   return DoAddonCall(__FUNCTION__, [&recording, count](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->SetRecordingPlayCount(addon, tag, count);
+    return addon->toAddon->SetRecordingPlayCount(addon, &tag, count);
   }, m_clientCapabilities.SupportsRecordingsPlayCount());
 }
 
@@ -903,7 +903,7 @@ PVR_ERROR CPVRClient::SetRecordingLastPlayedPosition(const CPVRRecording& record
   return DoAddonCall(__FUNCTION__, [&recording, lastplayedposition](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->SetRecordingLastPlayedPosition(addon, tag, lastplayedposition);
+    return addon->toAddon->SetRecordingLastPlayedPosition(addon, &tag, lastplayedposition);
   }, m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
  }
 
@@ -913,7 +913,7 @@ PVR_ERROR CPVRClient::GetRecordingLastPlayedPosition(const CPVRRecording& record
   return DoAddonCall(__FUNCTION__, [&recording, &iPosition](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    iPosition = addon->toAddon->GetRecordingLastPlayedPosition(addon, tag);
+    iPosition = addon->toAddon->GetRecordingLastPlayedPosition(addon, &tag);
     return (iPosition == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   }, m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
 }
@@ -927,7 +927,7 @@ PVR_ERROR CPVRClient::GetRecordingEdl(const CPVRRecording& recording, std::vecto
 
     PVR_EDL_ENTRY edl_array[PVR_ADDON_EDL_LENGTH];
     int size = PVR_ADDON_EDL_LENGTH;
-    PVR_ERROR error = addon->toAddon->GetRecordingEdl(addon, tag, edl_array, &size);
+    PVR_ERROR error = addon->toAddon->GetRecordingEdl(addon, &tag, edl_array, &size);
     if (error == PVR_ERROR_NO_ERROR)
     {
       edls.reserve(size);
@@ -971,7 +971,7 @@ PVR_ERROR CPVRClient::AddTimer(const CPVRTimerInfoTag& timer)
   return DoAddonCall(__FUNCTION__, [&timer](const AddonInstance* addon) {
     PVR_TIMER tag;
     WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->AddTimer(addon, tag);
+    return addon->toAddon->AddTimer(addon, &tag);
   }, m_clientCapabilities.SupportsTimers());
 }
 
@@ -980,7 +980,7 @@ PVR_ERROR CPVRClient::DeleteTimer(const CPVRTimerInfoTag& timer, bool bForce /*
   return DoAddonCall(__FUNCTION__, [&timer, bForce](const AddonInstance* addon) {
     PVR_TIMER tag;
     WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->DeleteTimer(addon, tag, bForce);
+    return addon->toAddon->DeleteTimer(addon, &tag, bForce);
   }, m_clientCapabilities.SupportsTimers());
 }
 
@@ -989,7 +989,7 @@ PVR_ERROR CPVRClient::UpdateTimer(const CPVRTimerInfoTag& timer)
   return DoAddonCall(__FUNCTION__, [&timer](const AddonInstance* addon) {
     PVR_TIMER tag;
     WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->UpdateTimer(addon, tag);
+    return addon->toAddon->UpdateTimer(addon, &tag);
   }, m_clientCapabilities.SupportsTimers());
 }
 
@@ -1243,8 +1243,8 @@ PVR_ERROR CPVRClient::OpenLiveStream(const std::shared_ptr<CPVRChannel>& channel
       CLog::LogFC(LOGDEBUG, LOGPVR, "Opening live stream for channel '%s'", channel->ChannelName().c_str());
       PVR_CHANNEL tag;
       WriteClientChannelInfo(channel, tag);
-      return addon->toAddon->OpenLiveStream(addon, tag) ? PVR_ERROR_NO_ERROR
-                                                        : PVR_ERROR_NOT_IMPLEMENTED;
+      return addon->toAddon->OpenLiveStream(addon, &tag) ? PVR_ERROR_NO_ERROR
+                                                         : PVR_ERROR_NOT_IMPLEMENTED;
     }
   });
 }
@@ -1260,8 +1260,8 @@ PVR_ERROR CPVRClient::OpenRecordedStream(const std::shared_ptr<CPVRRecording>& r
     PVR_RECORDING tag;
     WriteClientRecordingInfo(*recording, tag);
     CLog::LogFC(LOGDEBUG, LOGPVR, "Opening stream for recording '%s'", recording->m_strTitle.c_str());
-    return addon->toAddon->OpenRecordedStream(addon, tag) ? PVR_ERROR_NO_ERROR
-                                                          : PVR_ERROR_NOT_IMPLEMENTED;
+    return addon->toAddon->OpenRecordedStream(addon, &tag) ? PVR_ERROR_NO_ERROR
+                                                           : PVR_ERROR_NOT_IMPLEMENTED;
   }, m_clientCapabilities.SupportsRecordings());
 }
 
@@ -1391,7 +1391,7 @@ PVR_ERROR CPVRClient::CallEpgTagMenuHook(const CPVRClientMenuHook& hook, const s
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
   });
 }
 
@@ -1407,7 +1407,7 @@ PVR_ERROR CPVRClient::CallChannelMenuHook(const CPVRClientMenuHook& hook, const
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
   });
 }
 
@@ -1423,7 +1423,7 @@ PVR_ERROR CPVRClient::CallRecordingMenuHook(const CPVRClientMenuHook& hook, cons
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
   });
 }
 
@@ -1439,7 +1439,7 @@ PVR_ERROR CPVRClient::CallTimerMenuHook(const CPVRClientMenuHook& hook, const st
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
   });
 }
 
@@ -1454,7 +1454,7 @@ PVR_ERROR CPVRClient::CallSettingsMenuHook(const CPVRClientMenuHook& hook)
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, menuHook, hookData);
+    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
   });
 }
 

From 081b608d27e73e698d3354605d1c864ff1e29215 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Thu, 30 Apr 2020 18:40:54 +0200
Subject: [PATCH 04/27] [addons][pvr] remove obsolete xbmc_pvr_dll.h

This done now to prevent edit here, as it no more used on reworked system.
Otherwise must be on following changes this edited too and make request
commits bigger.
---
 .../include/kodi/CMakeLists.txt               |   1 -
 .../include/kodi/versions.h                   |   3 +-
 .../include/kodi/xbmc_pvr_dll.h               | 847 ------------------
 .../include/kodi/xbmc_pvr_types.h             |   2 +-
 4 files changed, 2 insertions(+), 851 deletions(-)
 delete mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_dll.h

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
index 5296ead413de..c6c8fbf7f459 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
@@ -10,7 +10,6 @@ set(HEADERS AddonBase.h
             libXBMC_pvr.h
             versions.h
             xbmc_addon_dll.h
-            xbmc_pvr_dll.h
             xbmc_pvr_types.h)
 
 if(CORE_SYSTEM_NAME STREQUAL android)
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index fa79f5a28757..a2ef674e9363 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -113,8 +113,7 @@
 #define ADDON_INSTANCE_VERSION_PVR                    "6.5.2"
 #define ADDON_INSTANCE_VERSION_PVR_MIN                "6.5.1"
 #define ADDON_INSTANCE_VERSION_PVR_XML_ID             "kodi.binary.instance.pvr"
-#define ADDON_INSTANCE_VERSION_PVR_DEPENDS            "xbmc_pvr_dll.h" \
-                                                      "xbmc_pvr_types.h" \
+#define ADDON_INSTANCE_VERSION_PVR_DEPENDS            "xbmc_pvr_types.h" \
                                                       "libXBMC_pvr.h"
 
 #define ADDON_INSTANCE_VERSION_SCREENSAVER            "2.0.1"
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_dll.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_dll.h
deleted file mode 100644
index 86f6f0543450..000000000000
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_dll.h
+++ /dev/null
@@ -1,847 +0,0 @@
-/*
- *  Copyright (C) 2005-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include "xbmc_addon_dll.h"
-#include "xbmc_pvr_types.h"
-
-/*!
- * Functions that the PVR client add-on must implement, but some can be empty.
- *
- * The 'remarks' field indicates which methods should be implemented, and which ones are optional.
- */
-
-extern "C"
-{
-  /*! @name PVR add-on methods */
-  //@{
-  /*!
-   * Get the list of features that this add-on provides.
-   * Called by Kodi to query the add-on's capabilities.
-   * Used to check which options should be presented in the UI, which methods to call, etc.
-   * All capabilities that the add-on supports should be set to true.
-   * @param pCapabilities The add-on's capabilities.
-   * @return PVR_ERROR_NO_ERROR if the properties were fetched successfully.
-   * @remarks Valid implementation required.
-   */
-  PVR_ERROR GetCapabilities(const AddonInstance_PVR* instance,
-                            PVR_ADDON_CAPABILITIES* pCapabilities);
-
-  /*!
-   * @return The name reported by the backend that will be displayed in the UI.
-   * @remarks Valid implementation required.
-   */
-  const char* GetBackendName(const AddonInstance_PVR* instance);
-
-  /*!
-   * @return The version string reported by the backend that will be displayed in the UI.
-   * @remarks Valid implementation required.
-   */
-  const char* GetBackendVersion(const AddonInstance_PVR* instance);
-
-  /*!
-   * @return The connection string reported by the backend that will be displayed in the UI.
-   * @remarks Valid implementation required.
-   */
-  const char* GetConnectionString(const AddonInstance_PVR* instance);
-
-  /*!
-   * Get the disk space reported by the backend (if supported).
-   * @param iTotal The total disk space in bytes.
-   * @param iUsed The used disk space in bytes.
-   * @return PVR_ERROR_NO_ERROR if the drive space has been fetched successfully.
-   * @remarks Optional. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetDriveSpace(const AddonInstance_PVR* instance, long long* iTotal, long long* iUsed);
-
-  /*!
-   * Call one of the menu hooks (if supported).
-   * Supported PVR_MENUHOOK instances have to be added in ADDON_Create(), by calling AddMenuHook() on the callback.
-   * @param menuhook The hook to call.
-   * @param item The selected item for which the hook was called.
-   * @return PVR_ERROR_NO_ERROR if the hook was called successfully.
-   * @remarks Optional. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR CallMenuHook(const AddonInstance_PVR* instance,
-                         const PVR_MENUHOOK& menuhook,
-                         const PVR_MENUHOOK_DATA& item);
-  //@}
-
-  /*! @name PVR EPG methods
-   *  @remarks Only used by Kodi if bSupportsEPG is set to true.
-   */
-  //@{
-  /*!
-   * Request the EPG for a channel from the backend.
-   * EPG entries are added to Kodi by calling TransferEpgEntry() on the callback.
-   * @param handle Handle to pass to the callback method.
-   * @param iChannelUid The UID of the channel to get the EPG table for.
-   * @param iStart Get events after this time (UTC).
-   * @param iEnd Get events before this time (UTC).
-   * @return PVR_ERROR_NO_ERROR if the table has been fetched successfully.
-   * @remarks Required if bSupportsEPG is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetEPGForChannel(const AddonInstance_PVR* instance,
-                             ADDON_HANDLE handle,
-                             int iChannelUid,
-                             time_t iStart,
-                             time_t iEnd);
-
-  /*
-   * Check if the given EPG tag can be recorded.
-   * @param tag the epg tag to check.
-   * @param [out] bIsRecordable Set to true if the tag can be recorded.
-   * @return PVR_ERROR_NO_ERROR if bIsRecordable has been set successfully.
-   * @remarks Optional, return PVR_ERROR_NOT_IMPLEMENTED to let Kodi decide.
-   */
-  PVR_ERROR IsEPGTagRecordable(const AddonInstance_PVR* instance,
-                               const EPG_TAG* tag,
-                               bool* bIsRecordable);
-
-  /*
-   * Check if the given EPG tag can be played.
-   * @param tag the epg tag to check.
-   * @param [out] bIsPlayable Set to true if the tag can be played.
-   * @return PVR_ERROR_NO_ERROR if bIsPlayable has been set successfully.
-   * @remarks Required if add-on supports playing epg tags.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR IsEPGTagPlayable(const AddonInstance_PVR* instance,
-                             const EPG_TAG* tag,
-                             bool* bIsPlayable);
-
-  /*!
-   * Retrieve the edit decision list (EDL) of an EPG tag on the backend.
-   * @param epgTag The EPG tag.
-   * @param edl out: The function has to write the EDL into this array.
-   * @param size in: The maximum size of the EDL, out: the actual size of the EDL.
-   * @return PVR_ERROR_NO_ERROR if the EDL was successfully read or no EDL exists.
-   * @remarks Required if bSupportsEpgEdl is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetEPGTagEdl(const AddonInstance_PVR* instance,
-                         const EPG_TAG* epgTag,
-                         PVR_EDL_ENTRY edl[],
-                         int* size);
-
-  /*!
-   * Get the stream properties for an epg tag from the backend.
-   * @param[in] tag The epg tag to get the stream properties for.
-   * @param[inout] properties in: an array for the properties to return, out: the properties required to play the stream.
-   * @param[inout] iPropertiesCount in: the size of the properties array, out: the number of properties returned.
-   * @return PVR_ERROR_NO_ERROR if the stream is available.
-   * @remarks Required if add-on supports playing epg tags.
-   *          In this case your implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the epg tag.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetEPGTagStreamProperties(const AddonInstance_PVR* instance,
-                                      const EPG_TAG* tag,
-                                      PVR_NAMED_VALUE* properties,
-                                      unsigned int* iPropertiesCount);
-
-  //@}
-
-  /*! @name PVR channel group methods
-   *  @remarks Only used by Kodi if bSupportsChannelGroups is set to true.
-   *           If a group or one of the group members changes after the initial import, or if a new one was added, then the add-on
-   *           should call TriggerChannelGroupsUpdate()
-   */
-  //@{
-  /*!
-   * Get the total amount of channel groups on the backend if it supports channel groups.
-   * @return The amount of channels, or -1 on error.
-   * @remarks Required if bSupportsChannelGroups is set to true.
-   *          Return -1 if this add-on won't provide this function.
-   */
-  int GetChannelGroupsAmount(const AddonInstance_PVR* instance);
-
-  /*!
-   * Request the list of all channel groups from the backend if it supports channel groups.
-   * Channel group entries are added to Kodi by calling TransferChannelGroup() on the callback.
-   * @param handle Handle to pass to the callback method.
-   * @param bRadio True to get the radio channel groups, false to get the TV channel groups.
-   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-   * @remarks Required if bSupportsChannelGroups is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetChannelGroups(const AddonInstance_PVR* instance, ADDON_HANDLE handle, bool bRadio);
-
-  /*!
-   * Request the list of all group members of a group from the backend if it supports channel groups.
-   * Member entries are added to Kodi by calling TransferChannelGroupMember() on the callback.
-   * @param handle Handle to pass to the callback method.
-   * @param group The group to get the members for.
-   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-   * @remarks Required if bSupportsChannelGroups is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetChannelGroupMembers(const AddonInstance_PVR* instance,
-                                   ADDON_HANDLE handle,
-                                   const PVR_CHANNEL_GROUP& group);
-  //@}
-
-  /** @name PVR channel methods
-   *  @remarks Either bSupportsTV or bSupportsRadio is required to be set to true.
-   *           If a channel changes after the initial import, or if a new one was added, then the add-on
-   *           should call TriggerChannelUpdate()
-   */
-  //@{
-  /*!
-   * Show the channel scan dialog if this backend supports it.
-   * @return PVR_ERROR_NO_ERROR if the dialog was displayed successfully.
-   * @remarks Required if bSupportsChannelScan is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   * @note see libKODI_guilib.h about related parts
-   */
-  PVR_ERROR OpenDialogChannelScan(const AddonInstance_PVR* instance);
-
-  /*!
-   * @return The total amount of channels on the backend, or -1 on error.
-   * @remarks Valid implementation required.
-   */
-  int GetChannelsAmount(const AddonInstance_PVR* instance);
-
-  /*!
-   * Request the list of all channels from the backend.
-   * Channel entries are added to Kodi by calling TransferChannelEntry() on the callback.
-   * @param handle Handle to pass to the callback method.
-   * @param bRadio True to get the radio channels, false to get the TV channels.
-   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-   * @remarks If bSupportsTV is set to true, a valid result set needs to be provided for bRadio = false.
-   *          If bSupportsRadio is set to true, a valid result set needs to be provided for bRadio = true.
-   *          At least one of these two must provide a valid result set.
-   */
-  PVR_ERROR GetChannels(const AddonInstance_PVR* instance, ADDON_HANDLE handle, bool bRadio);
-
-  /*!
-   * Delete a channel from the backend.
-   * @param channel The channel to delete.
-   * @return PVR_ERROR_NO_ERROR if the channel has been deleted successfully.
-   * @remarks Required if bSupportsChannelSettings is set to true.
-   */
-  PVR_ERROR DeleteChannel(const AddonInstance_PVR* instance, const PVR_CHANNEL& channel);
-
-  /*!
-   * Rename a channel on the backend.
-   * @param channel The channel to rename, containing the new channel name.
-   * @return PVR_ERROR_NO_ERROR if the channel has been renamed successfully.
-   * @remarks Optional, and only used if bSupportsChannelSettings is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR RenameChannel(const AddonInstance_PVR* instance, const PVR_CHANNEL& channel);
-
-  /*!
-   * Show the channel settings dialog, if supported by the backend.
-   * @param channel The channel to show the dialog for.
-   * @return PVR_ERROR_NO_ERROR if the dialog has been displayed successfully.
-   * @remarks Required if bSupportsChannelSettings is set to true.
-   * @note see libKODI_guilib.h about related parts
-   */
-  PVR_ERROR OpenDialogChannelSettings(const AddonInstance_PVR* instance,
-                                      const PVR_CHANNEL& channel);
-
-  /*!
-   * Show the dialog to add a channel on the backend, if supported by the backend.
-   * @param channel The channel to add.
-   * @return PVR_ERROR_NO_ERROR if the channel has been added successfully.
-   * @remarks Required if bSupportsChannelSettings is set to true.
-   * @note see libKODI_guilib.h about related parts
-   */
-  PVR_ERROR OpenDialogChannelAdd(const AddonInstance_PVR* instance, const PVR_CHANNEL& channel);
-  //@}
-
-  /** @name PVR recording methods
-   *  @remarks Only used by Kodi if bSupportsRecordings is set to true.
-   *           If a recording changes after the initial import, or if a new one was added,
-   *           then the add-on should call TriggerRecordingUpdate()
-   */
-  //@{
-  /*!
-   * @return The total amount of recordings on the backend or -1 on error.
-   * @param deleted if set return deleted recording (called if bSupportsRecordingsUndelete set to true)
-   * @remarks Required if bSupportsRecordings is set to true. Return -1 if this add-on won't provide this function.
-   */
-  int GetRecordingsAmount(const AddonInstance_PVR* instance, bool deleted);
-
-  /*!
-   * Request the list of all recordings from the backend, if supported.
-   * Recording entries are added to Kodi by calling TransferRecordingEntry() on the callback.
-   * @param handle Handle to pass to the callback method.
-   * @param deleted if set return deleted recording (called if bSupportsRecordingsUndelete set to true)
-   * @return PVR_ERROR_NO_ERROR if the recordings have been fetched successfully.
-   * @remarks Required if bSupportsRecordings is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetRecordings(const AddonInstance_PVR* instance, ADDON_HANDLE handle, bool deleted);
-
-  /*!
-   * Delete a recording on the backend.
-   * @param recording The recording to delete.
-   * @return PVR_ERROR_NO_ERROR if the recording has been deleted successfully.
-   * @remarks Optional, and only used if bSupportsRecordings is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR DeleteRecording(const AddonInstance_PVR* instance, const PVR_RECORDING& recording);
-
-  /*!
-   * Undelete a recording on the backend.
-   * @param recording The recording to undelete.
-   * @return PVR_ERROR_NO_ERROR if the recording has been undeleted successfully.
-   * @remarks Optional, and only used if bSupportsRecordingsUndelete is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR UndeleteRecording(const AddonInstance_PVR* instance, const PVR_RECORDING& recording);
-
-  /*!
-   * @brief Delete all recordings permanent which in the deleted folder on the backend.
-   * @return PVR_ERROR_NO_ERROR if the recordings has been deleted successfully.
-   */
-  PVR_ERROR DeleteAllRecordingsFromTrash(const AddonInstance_PVR* instance);
-
-  /*!
-   * Rename a recording on the backend.
-   * @param recording The recording to rename, containing the new name.
-   * @return PVR_ERROR_NO_ERROR if the recording has been renamed successfully.
-   * @remarks Optional, and only used if bSupportsRecordings is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR RenameRecording(const AddonInstance_PVR* instance, const PVR_RECORDING& recording);
-
-  /*!
-   * Set the lifetime of a recording on the backend.
-   * @param recording The recording to change the lifetime for. recording.iLifetime contains the new lieftime value.
-   * @return PVR_ERROR_NO_ERROR if the recording's lifetime has been set successfully.
-   * @remarks Required if bSupportsRecordingsLifetimeChange is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR SetRecordingLifetime(const AddonInstance_PVR* instance, const PVR_RECORDING* recording);
-
-  /*!
-   * Set the play count of a recording on the backend.
-   * @param recording The recording to change the play count.
-   * @param count Play count.
-   * @return PVR_ERROR_NO_ERROR if the recording's play count has been set successfully.
-   * @remarks Required if bSupportsRecordingPlayCount is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR SetRecordingPlayCount(const AddonInstance_PVR* instance,
-                                  const PVR_RECORDING& recording,
-                                  int count);
-
-  /*!
-   * Set the last watched position of a recording on the backend.
-   * @param recording The recording.
-   * @param lastplayedposition The last watched position in seconds
-   * @return PVR_ERROR_NO_ERROR if the position has been stored successfully.
-   * @remarks Required if bSupportsLastPlayedPosition is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR SetRecordingLastPlayedPosition(const AddonInstance_PVR* instance,
-                                           const PVR_RECORDING& recording,
-                                           int lastplayedposition);
-
-  /*!
-   * Retrieve the last watched position of a recording on the backend.
-   * @param recording The recording.
-   * @return The last watched position in seconds or -1 on error
-   * @remarks Required if bSupportsRecordingPlayCount is set to true.
-   *          Return -1 if this add-on won't provide this function.
-   */
-  int GetRecordingLastPlayedPosition(const AddonInstance_PVR* instance,
-                                     const PVR_RECORDING& recording);
-
-  /*!
-   * Retrieve the edit decision list (EDL) of a recording on the backend.
-   * @param recording The recording.
-   * @param edl out: The function has to write the EDL into this array.
-   * @param size in: The maximum size of the EDL, out: the actual size of the EDL.
-   * @return PVR_ERROR_NO_ERROR if the EDL was successfully read or no EDL exists.
-   * @remarks Required if bSupportsRecordingEdl is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetRecordingEdl(const AddonInstance_PVR* instance,
-                            const PVR_RECORDING& recording,
-                            PVR_EDL_ENTRY edl[],
-                            int* size);
-
-  /*!
-   * Retrieve the size of a recording on the backend.
-   * @param[in] recording in: The recording to get the size in bytes for.
-   * @param[out] sizeInBytes out: The size in bytes of the recording
-   * @return PVR_ERROR_NO_ERROR if the recording's size has been set successfully.
-   * @remarks Required if bSupportsRecordingSize is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetRecordingSize(const AddonInstance_PVR* instance,
-                             const PVR_RECORDING* recording,
-                             int64_t* sizeInBytes);
-
-  /*!
-   * Retrieve the timer types supported by the backend.
-   * @param types out: The function has to write the definition of the supported timer types into this array.
-   * @param typesCount in: The maximum size of the list, out: the actual size of the list. default: PVR_ADDON_TIMERTYPE_ARRAY_SIZE
-   * @return PVR_ERROR_NO_ERROR if the types were successfully written to the array.
-   * @remarks Required if bSupportsTimers is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetTimerTypes(const AddonInstance_PVR* instance,
-                          PVR_TIMER_TYPE types[],
-                          int* typesCount);
-
-  //@}
-  /** @name PVR timer methods
-   *  @remarks Only used by Kodi if bSupportsTimers is set to true.
-   *           If a timer changes after the initial import, or if a new one was added,
-   *           then the add-on should call TriggerTimerUpdate()
-   */
-  //@{
-  /*!
-   * @return The total amount of timers on the backend or -1 on error.
-   * @remarks Required if bSupportsTimers is set to true. Return -1 if this add-on won't provide this function.
-   */
-  int GetTimersAmount(const AddonInstance_PVR* instance);
-
-  /*!
-   * Request the list of all timers from the backend if supported.
-   * Timer entries are added to Kodi by calling TransferTimerEntry() on the callback.
-   * @param handle Handle to pass to the callback method.
-   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-   * @remarks Required if bSupportsTimers is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetTimers(const AddonInstance_PVR* instance, ADDON_HANDLE handle);
-
-  /*!
-   * Add a timer on the backend.
-   * @param timer The timer to add.
-   * @return PVR_ERROR_NO_ERROR if the timer has been added successfully.
-   * @remarks Required if bSupportsTimers is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR AddTimer(const AddonInstance_PVR* instance, const PVR_TIMER& timer);
-
-  /*!
-   * Delete a timer on the backend.
-   * @param timer The timer to delete.
-   * @param bForceDelete Set to true to delete a timer that is currently recording a program.
-   * @return PVR_ERROR_NO_ERROR if the timer has been deleted successfully.
-   * @remarks Required if bSupportsTimers is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR DeleteTimer(const AddonInstance_PVR* instance,
-                        const PVR_TIMER& timer,
-                        bool bForceDelete);
-
-  /*!
-   * Update the timer information on the backend.
-   * @param timer The timer to update.
-   * @return PVR_ERROR_NO_ERROR if the timer has been updated successfully.
-   * @remarks Required if bSupportsTimers is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR UpdateTimer(const AddonInstance_PVR* instance, const PVR_TIMER& timer);
-
-  //@}
-
-  /** @name PVR live stream methods, used to open and close a stream to a channel, and optionally perform read operations on the stream */
-  //@{
-  /*!
-   * Open a live stream on the backend.
-   * @param channel The channel to stream.
-   * @return True if the stream has been opened successfully, false otherwise.
-   * @remarks Required if bHandlesInputStream or bHandlesDemuxing is set to true.
-   *          CloseLiveStream() will always be called by Kodi prior to calling this function.
-   *          Return false if this add-on won't provide this function.
-   */
-  bool OpenLiveStream(const AddonInstance_PVR* instance, const PVR_CHANNEL& channel);
-
-  /*!
-   * Close an open live stream.
-   * @remarks Required if bHandlesInputStream or bHandlesDemuxing is set to true.
-   */
-  void CloseLiveStream(const AddonInstance_PVR* instance);
-
-  /*!
-   * Read from an open live stream.
-   * @param pBuffer The buffer to store the data in.
-   * @param iBufferSize The amount of bytes to read.
-   * @return The amount of bytes that were actually read from the stream.
-   * @remarks Required if bHandlesInputStream is set to true.
-   *          Return -1 if this add-on won't provide this function.
-   */
-  int ReadLiveStream(const AddonInstance_PVR* instance,
-                     unsigned char* pBuffer,
-                     unsigned int iBufferSize);
-
-  /*!
-   * Seek in a live stream on a backend that supports timeshifting.
-   * @param iPosition The position to seek to.
-   * @param iWhence ?
-   * @return The new position.
-   * @remarks Optional, and only used if bHandlesInputStream is set to true.
-   *          Return -1 if this add-on won't provide this function.
-   */
-  long long SeekLiveStream(const AddonInstance_PVR* instance,
-                           long long iPosition,
-                           int iWhence = SEEK_SET);
-
-  /*!
-   * Obtain the length of a live stream.
-   * @return The total length of the stream that's currently being read.
-   * @remarks Optional, and only used if bHandlesInputStream is set to true.
-   *          Return -1 if this add-on won't provide this function.
-   */
-  long long LengthLiveStream(const AddonInstance_PVR* instance);
-
-  /*!
-   * Get the signal status of the stream that's currently open.
-   * @param channelUid Channel unique identifier
-   * @param signalStatus The signal status.
-   * @return PVR_ERROR_NO_ERROR if the signal status has been read successfully, false otherwise.
-   * @remarks Optional, and only used if PVR_ADDON_CAPABILITIES::bHandlesInputStream or PVR_ADDON_CAPABILITIES::bHandlesDemuxing is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetSignalStatus(const AddonInstance_PVR* instance, int channelUid, PVR_SIGNAL_STATUS* signalStatus);
-
-  /*!
-   * Get the descramble information of the stream that's currently open.
-   * @param channelUid Channel unique identifier
-   * @param [out] descrambleInfo The descramble information.
-   * @return PVR_ERROR_NO_ERROR if the descramble information has been read successfully, false otherwise.
-   * @remarks Optional, and only used if PVR_ADDON_CAPABILITIES::bSupportsDescrambleInfo is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetDescrambleInfo(const AddonInstance_PVR* instance, int channelUid,
-                              PVR_DESCRAMBLE_INFO* descrambleInfo);
-
-  /*!
-   * Get the stream properties for a channel from the backend.
-   * @param[in] channel The channel to get the stream properties for.
-   * @param[inout] properties in: an array for the properties to return, out: the properties required to play the stream.
-   * @param[inout] iPropertiesCount in: the size of the properties array, out: the number of properties returned.
-   * @return PVR_ERROR_NO_ERROR if the stream is available.
-   * @remarks Required if PVR_ADDON_CAPABILITIES::bSupportsTV or PVR_ADDON_CAPABILITIES::bSupportsRadio are set to true and PVR_ADDON_CAPABILITIES::bHandlesInputStream is set to false.
-   *          In this case the implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the channel.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetChannelStreamProperties(const AddonInstance_PVR* instance,
-                                       const PVR_CHANNEL* channel,
-                                       PVR_NAMED_VALUE* properties,
-                                       unsigned int* iPropertiesCount);
-
-  /*!
-   * Get the stream properties for a recording from the backend.
-   * @param[in] recording The recording to get the stream properties for.
-   * @param[inout] properties in: an array for the properties to return, out: the properties required to play the stream.
-   * @param[inout] iPropertiesCount in: the size of the properties array, out: the number of properties returned.
-   * @return PVR_ERROR_NO_ERROR if the stream is available.
-   * @remarks Required if PVR_ADDON_CAPABILITIES::bSupportsRecordings is set to true and the add-on does not implement recording stream functions (OpenRecordedStream, ...).
-   *          In this case your implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the recording.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetRecordingStreamProperties(const AddonInstance_PVR* instance,
-                                         const PVR_RECORDING* recording,
-                                         PVR_NAMED_VALUE* properties,
-                                         unsigned int* iPropertiesCount);
-
-  /*!
-   * Get the stream properties of the stream that's currently being read.
-   * @param pProperties The properties of the currently playing stream.
-   * @return PVR_ERROR_NO_ERROR if the properties have been fetched successfully.
-   * @remarks Required if bHandlesDemuxing is set to true.
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR GetStreamProperties(const AddonInstance_PVR* instance,
-                                PVR_STREAM_PROPERTIES* pProperties);
-  //@}
-
-  /** @name PVR recording stream methods, used to open and close a stream to a recording, and perform read operations on the stream.
-   *  @remarks This will only be used if the backend doesn't provide a direct URL in the recording tag.
-   */
-  //@{
-  /*!
-   * Obtain the chunk size to use when reading streams.
-   * @param chunksize must be filled with the chunk size in bytes.
-   * @return PVR_ERROR_NO_ERROR if the chunk size has been fetched successfully.
-   * @remarks Optional, and only used if not reading from demuxer (=> DemuxRead) and
-   *          PVR_ADDON_CAPABILITIES::bSupportsRecordings is true (=> ReadRecordedStream) or
-   *          PVR_ADDON_CAPABILITIES::bHandlesInputStream is true (=> ReadLiveStream).
-   *          Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. In this case Kodi will decide on the chunk size to use.
-   */
-  PVR_ERROR GetStreamReadChunkSize(const AddonInstance_PVR* instance, int* chunksize);
-
-  /*!
-   * Open a stream to a recording on the backend.
-   * @param recording The recording to open.
-   * @return True if the stream has been opened successfully, false otherwise.
-   * @remarks Optional, and only used if bSupportsRecordings is set to true.
-   *          CloseRecordedStream() will always be called by Kodi prior to calling this function.
-   *          Return false if this add-on won't provide this function.
-   */
-  bool OpenRecordedStream(const AddonInstance_PVR* instance, const PVR_RECORDING& recording);
-
-  /*!
-   * Close an open stream from a recording.
-   * @remarks Optional, and only used if bSupportsRecordings is set to true.
-   */
-  void CloseRecordedStream(const AddonInstance_PVR* instance);
-
-  /*!
-   * Read from a recording.
-   * @param pBuffer The buffer to store the data in.
-   * @param iBufferSize The amount of bytes to read.
-   * @return The amount of bytes that were actually read from the stream.
-   * @remarks Optional, and only used if bSupportsRecordings is set to true, but required if OpenRecordedStream() is implemented.
-   *          Return -1 if this add-on won't provide this function.
-   */
-  int ReadRecordedStream(const AddonInstance_PVR* instance,
-                         unsigned char* pBuffer,
-                         unsigned int iBufferSize);
-
-  /*!
-   * Seek in a recorded stream.
-   * @param iPosition The position to seek to.
-   * @param iWhence ?
-   * @return The new position.
-   * @remarks Optional, and only used if bSupportsRecordings is set to true.
-   *          Return -1 if this add-on won't provide this function.
-   */
-  long long SeekRecordedStream(const AddonInstance_PVR* instance,
-                               long long iPosition,
-                               int iWhence = SEEK_SET);
-
-  /*!
-   * Obtain the length of a recorded stream.
-   * @return The total length of the stream that's currently being read.
-   * @remarks Optional, and only used if bSupportsRecordings is set to true.
-   *          Return -1 if this add-on won't provide this function.
-   */
-  long long LengthRecordedStream(const AddonInstance_PVR* instance);
-
-  //@}
-
-  /** @name PVR demultiplexer methods
-   *  @remarks Only used by Kodi if bHandlesDemuxing is set to true.
-   */
-  //@{
-  /*!
-   * Reset the demultiplexer in the add-on.
-   * @remarks Required if bHandlesDemuxing is set to true.
-   */
-  void DemuxReset(const AddonInstance_PVR* instance);
-
-  /*!
-   * Abort the demultiplexer thread in the add-on.
-   * @remarks Required if bHandlesDemuxing is set to true.
-   */
-  void DemuxAbort(const AddonInstance_PVR* instance);
-
-  /*!
-   * Flush all data that's currently in the demultiplexer buffer in the add-on.
-   * @remarks Required if bHandlesDemuxing is set to true.
-   */
-  void DemuxFlush(const AddonInstance_PVR* instance);
-
-  /*!
-   * Read the next packet from the demultiplexer, if there is one.
-   * @return The next packet.
-   *         If there is no next packet, then the add-on should return the
-   *         packet created by calling AllocateDemuxPacket(0) on the callback.
-   *         If the stream changed and Kodi's player needs to be reinitialised,
-   *         then, the add-on should call AllocateDemuxPacket(0) on the
-   *         callback, and set the streamid to DMX_SPECIALID_STREAMCHANGE and
-   *         return the value.
-   *         The add-on should return NULL if an error occured.
-   * @remarks Required if bHandlesDemuxing is set to true.
-   *          Return NULL if this add-on won't provide this function.
-   */
-  DemuxPacket* DemuxRead(const AddonInstance_PVR* instance);
-  //@}
-
-  /*!
-   * Check if the backend support pausing the currently playing stream
-   * This will enable/disable the pause button in Kodi based on the return value
-   * @return false if the PVR addon/backend does not support pausing, true if possible
-   */
-  bool CanPauseStream(const AddonInstance_PVR* instance);
-
-  /*!
-   * Check if the backend supports seeking for the currently playing stream
-   * This will enable/disable the rewind/forward buttons in Kodi based on the return value
-   * @return false if the PVR addon/backend does not support seeking, true if possible
-   */
-  bool CanSeekStream(const AddonInstance_PVR* instance);
-
-  /*!
-   * @brief Notify the pvr addon that Kodi (un)paused the currently playing stream
-   */
-  void PauseStream(const AddonInstance_PVR* instance, bool bPaused);
-
-  /*!
-   * Notify the pvr addon/demuxer that Kodi wishes to seek the stream by time
-   * @param time The absolute time since stream start
-   * @param backwards True to seek to keyframe BEFORE time, else AFTER
-   * @param startpts can be updated to point to where display should start
-   * @return True if the seek operation was possible
-   * @remarks Optional, and only used if addon has its own demuxer.
-   *          Return False if this add-on won't provide this function.
-   */
-  bool SeekTime(const AddonInstance_PVR* instance, double time, bool backwards, double* startpts);
-
-  /*!
-   * Notify the pvr addon/demuxer that Kodi wishes to change playback speed
-   * @param speed The requested playback speed
-   * @remarks Optional, and only used if addon has its own demuxer.
-   */
-  void SetSpeed(const AddonInstance_PVR* instance, int speed);
-
-  /*!
-   * Notify the pvr addon/demuxer that Kodi wishes to fill demux queue
-   * @param mode The requested filling mode
-   * @remarks Optional, and only used if addon has its own demuxer.
-   */
-  void FillBuffer(const AddonInstance_PVR* instance, bool mode);
-
-  /*!
-   *  Get the hostname of the pvr backend server
-   *  @return hostname as ip address or alias. If backend does not utilize a server, return empty string.
-   */
-  const char* GetBackendHostname(const AddonInstance_PVR* instance);
-
-  /*!
-   *  Check for real-time streaming
-   *  @return true if current stream is real-time
-   */
-  bool IsRealTimeStream(const AddonInstance_PVR* instance);
-
-  /*!
-   * Tell the client the time frame to use when notifying epg events back to Kodi. The client might push epg events asynchronously
-   * to Kodi using the callback function EpgEventStateChange. To be able to only push events that are actually of interest for Kodi,
-   * client needs to know about the epg time frame Kodi uses. Kodi supplies the current epg time frame value in AddonProperties_PVR.iEpgMaxDays
-   * when creating the addon and calls SetEPGTimeFrame later whenever Kodi's epg time frame value changes.
-   * @param iDays number of days from "now". EPG_TIMEFRAME_UNLIMITED means that Kodi is interested in all epg events, regardless of event times.
-   * @return PVR_ERROR_NO_ERROR if new value was successfully set.
-   * @remarks Required if bSupportsEPG is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function.
-   */
-  PVR_ERROR SetEPGTimeFrame(const AddonInstance_PVR* instance, int iDays);
-
-  /*!
-   * Notify the pvr addon for power management events
-   */
-  void OnSystemSleep(const AddonInstance_PVR* instance);
-  void OnSystemWake(const AddonInstance_PVR* instance);
-  void OnPowerSavingActivated(const AddonInstance_PVR* instance);
-  void OnPowerSavingDeactivated(const AddonInstance_PVR* instance);
-
-  /*!
-   * Get stream times.
-   * @param times A pointer to the data to be filled by the implementation.
-   * @return PVR_ERROR_NO_ERROR on success.
-   */
-  PVR_ERROR GetStreamTimes(const AddonInstance_PVR* instance, PVR_STREAM_TIMES* times);
-
-  /*!
-   * Called by Kodi to assign the function pointers of this add-on to pClient.
-   * @param ptr The struct to assign the function pointers to.
-   */
-  void __declspec(dllexport) get_addon(void* ptr)
-  {
-    AddonInstance_PVR* pClient = static_cast<AddonInstance_PVR*>(ptr);
-
-    pClient->toAddon->addonInstance = nullptr; // used in future
-
-    pClient->toAddon->GetCapabilities = GetCapabilities;
-    pClient->toAddon->GetStreamProperties = GetStreamProperties;
-    pClient->toAddon->GetConnectionString = GetConnectionString;
-    pClient->toAddon->GetBackendName = GetBackendName;
-    pClient->toAddon->GetBackendVersion = GetBackendVersion;
-    pClient->toAddon->GetDriveSpace = GetDriveSpace;
-    pClient->toAddon->OpenDialogChannelScan = OpenDialogChannelScan;
-    pClient->toAddon->MenuHook = CallMenuHook;
-
-    pClient->toAddon->GetEPGForChannel = GetEPGForChannel;
-    pClient->toAddon->IsEPGTagRecordable = IsEPGTagRecordable;
-    pClient->toAddon->IsEPGTagPlayable = IsEPGTagPlayable;
-    pClient->toAddon->GetEPGTagEdl = GetEPGTagEdl;
-    pClient->toAddon->GetEPGTagStreamProperties = GetEPGTagStreamProperties;
-
-    pClient->toAddon->GetChannelGroupsAmount = GetChannelGroupsAmount;
-    pClient->toAddon->GetChannelGroups = GetChannelGroups;
-    pClient->toAddon->GetChannelGroupMembers = GetChannelGroupMembers;
-
-    pClient->toAddon->GetChannelsAmount = GetChannelsAmount;
-    pClient->toAddon->GetChannels = GetChannels;
-    pClient->toAddon->DeleteChannel = DeleteChannel;
-    pClient->toAddon->RenameChannel = RenameChannel;
-    pClient->toAddon->OpenDialogChannelSettings = OpenDialogChannelSettings;
-    pClient->toAddon->OpenDialogChannelAdd = OpenDialogChannelAdd;
-
-    pClient->toAddon->GetRecordingsAmount = GetRecordingsAmount;
-    pClient->toAddon->GetRecordings = GetRecordings;
-    pClient->toAddon->DeleteRecording = DeleteRecording;
-    pClient->toAddon->UndeleteRecording = UndeleteRecording;
-    pClient->toAddon->DeleteAllRecordingsFromTrash = DeleteAllRecordingsFromTrash;
-    pClient->toAddon->RenameRecording = RenameRecording;
-    pClient->toAddon->SetRecordingLifetime = SetRecordingLifetime;
-    pClient->toAddon->SetRecordingPlayCount = SetRecordingPlayCount;
-    pClient->toAddon->SetRecordingLastPlayedPosition = SetRecordingLastPlayedPosition;
-    pClient->toAddon->GetRecordingLastPlayedPosition = GetRecordingLastPlayedPosition;
-    pClient->toAddon->GetRecordingEdl = GetRecordingEdl;
-    pClient->toAddon->GetRecordingSize = GetRecordingSize;
-
-    pClient->toAddon->GetTimerTypes = GetTimerTypes;
-    pClient->toAddon->GetTimersAmount = GetTimersAmount;
-    pClient->toAddon->GetTimers = GetTimers;
-    pClient->toAddon->AddTimer = AddTimer;
-    pClient->toAddon->DeleteTimer = DeleteTimer;
-    pClient->toAddon->UpdateTimer = UpdateTimer;
-
-    pClient->toAddon->OpenLiveStream = OpenLiveStream;
-    pClient->toAddon->CloseLiveStream = CloseLiveStream;
-    pClient->toAddon->ReadLiveStream = ReadLiveStream;
-    pClient->toAddon->SeekLiveStream = SeekLiveStream;
-    pClient->toAddon->LengthLiveStream = LengthLiveStream;
-    pClient->toAddon->GetSignalStatus = GetSignalStatus;
-    pClient->toAddon->GetDescrambleInfo = GetDescrambleInfo;
-    pClient->toAddon->GetChannelStreamProperties = GetChannelStreamProperties;
-    pClient->toAddon->GetRecordingStreamProperties = GetRecordingStreamProperties;
-    pClient->toAddon->CanPauseStream = CanPauseStream;
-    pClient->toAddon->PauseStream = PauseStream;
-    pClient->toAddon->CanSeekStream = CanSeekStream;
-    pClient->toAddon->SeekTime = SeekTime;
-    pClient->toAddon->SetSpeed = SetSpeed;
-    pClient->toAddon->FillBuffer = FillBuffer;
-
-    pClient->toAddon->OpenRecordedStream = OpenRecordedStream;
-    pClient->toAddon->CloseRecordedStream = CloseRecordedStream;
-    pClient->toAddon->ReadRecordedStream = ReadRecordedStream;
-    pClient->toAddon->SeekRecordedStream = SeekRecordedStream;
-    pClient->toAddon->LengthRecordedStream = LengthRecordedStream;
-
-    pClient->toAddon->DemuxReset = DemuxReset;
-    pClient->toAddon->DemuxAbort = DemuxAbort;
-    pClient->toAddon->DemuxFlush = DemuxFlush;
-    pClient->toAddon->DemuxRead = DemuxRead;
-
-    pClient->toAddon->GetBackendHostname = GetBackendHostname;
-
-    pClient->toAddon->IsRealTimeStream = IsRealTimeStream;
-
-    pClient->toAddon->SetEPGTimeFrame = SetEPGTimeFrame;
-
-    pClient->toAddon->OnSystemSleep = OnSystemSleep;
-    pClient->toAddon->OnSystemWake = OnSystemWake;
-    pClient->toAddon->OnPowerSavingActivated = OnPowerSavingActivated;
-    pClient->toAddon->OnPowerSavingDeactivated = OnPowerSavingDeactivated;
-    pClient->toAddon->GetStreamTimes = GetStreamTimes;
-
-    pClient->toAddon->GetStreamReadChunkSize = GetStreamReadChunkSize;
-  };
-};
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index 36b647d545bf..485450d17443 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -598,7 +598,7 @@ extern "C" {
   } AddonToKodiFuncTable_PVR;
 
   /*!
-   * @brief Structure to transfer the methods from xbmc_pvr_dll.h to Kodi
+   * @brief Structure to transfer the methods from addon to Kodi
    */
   typedef struct KodiToAddonFuncTable_PVR
   {

From 6fa1f541e0143f07f4c869dab7d171c6bdf5406a Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Thu, 30 Apr 2020 20:26:01 +0200
Subject: [PATCH 05/27] [addons][pvr] separate menu hook calls and remove union
 use

This is thought to make the calls cleaner, with the union before
was it always a bit ugly and unsafe.

No have every type a own function where give his related data.
Further is on EPG menu hook the whole entry given.
---
 .../include/kodi/xbmc_pvr_types.h             | 30 +++++------
 xbmc/pvr/addons/PVRClient.cpp                 | 52 ++++++++-----------
 2 files changed, 37 insertions(+), 45 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index 485450d17443..6deb9085a135 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -519,17 +519,6 @@ extern "C" {
     enum PVR_EDL_TYPE type;
   } ATTRIBUTE_PACKED PVR_EDL_ENTRY;
 
-  typedef struct PVR_MENUHOOK_DATA
-  {
-    enum PVR_MENUHOOK_CAT cat;
-    union data {
-      int iEpgUid;
-      struct PVR_CHANNEL channel;
-      struct PVR_TIMER timer;
-      struct PVR_RECORDING recording;
-    } data;
-  } ATTRIBUTE_PACKED PVR_MENUHOOK_DATA;
-
   typedef struct PVR_STREAM_TIMES
   {
     time_t startTime;
@@ -547,7 +536,7 @@ extern "C" {
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // General callback functions
-    void (*AddMenuHook)(void* kodiInstance, PVR_MENUHOOK* hook);
+    void (*AddMenuHook)(void* kodiInstance, struct PVR_MENUHOOK* hook);
     void (*Recording)(void* kodiInstance, const char* Name, const char* FileName, bool On);
     void (*ConnectionStateChange)(void* kodiInstance,
                                   const char* strConnectionString,
@@ -614,9 +603,8 @@ extern "C" {
     const char*(__cdecl* GetBackendHostname)(const struct AddonInstance_PVR*);
     const char*(__cdecl* GetConnectionString)(const struct AddonInstance_PVR*);
     enum PVR_ERROR(__cdecl* GetDriveSpace)(const struct AddonInstance_PVR*, long long*, long long*);
-    enum PVR_ERROR(__cdecl* MenuHook)(const struct AddonInstance_PVR*,
-                                      const struct PVR_MENUHOOK*,
-                                      const struct PVR_MENUHOOK_DATA*);
+    enum PVR_ERROR(__cdecl* CallSettingsMenuHook)(const struct AddonInstance_PVR*,
+                                                  const struct PVR_MENUHOOK*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel interface functions
@@ -653,6 +641,9 @@ extern "C" {
     enum PVR_ERROR(__cdecl* OpenDialogChannelAdd)(const struct AddonInstance_PVR*,
                                                   const struct PVR_CHANNEL*);
     enum PVR_ERROR(__cdecl* OpenDialogChannelScan)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* CallChannelMenuHook)(const struct AddonInstance_PVR*,
+                                                 const PVR_MENUHOOK*,
+                                                 const PVR_CHANNEL*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // EPG interface functions
@@ -676,6 +667,9 @@ extern "C" {
                                                        struct PVR_NAMED_VALUE*,
                                                        unsigned int*);
     enum PVR_ERROR(__cdecl* SetEPGTimeFrame)(const struct AddonInstance_PVR*, int);
+    enum PVR_ERROR(__cdecl* CallEPGMenuHook)(const struct AddonInstance_PVR*,
+                                             const struct PVR_MENUHOOK*,
+                                             const struct EPG_TAG*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Recording interface functions
@@ -709,6 +703,9 @@ extern "C" {
                                                           const struct PVR_RECORDING*,
                                                           struct PVR_NAMED_VALUE*,
                                                           unsigned int*);
+    enum PVR_ERROR(__cdecl* CallRecordingMenuHook)(const struct AddonInstance_PVR*,
+                                                   const struct PVR_MENUHOOK*,
+                                                   const struct PVR_RECORDING*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Timer interface functions
@@ -722,6 +719,9 @@ extern "C" {
                                          const struct PVR_TIMER*,
                                          bool);
     enum PVR_ERROR(__cdecl* UpdateTimer)(const struct AddonInstance_PVR*, const struct PVR_TIMER*);
+    enum PVR_ERROR(__cdecl* CallTimerMenuHook)(const struct AddonInstance_PVR*,
+                                               const struct PVR_MENUHOOK*,
+                                               const struct PVR_TIMER*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Powersaving interface functions
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index e3896c7a326e..f2c2b43900b7 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -1382,79 +1382,71 @@ std::shared_ptr<CPVRClientMenuHooks> CPVRClient::GetMenuHooks()
 PVR_ERROR CPVRClient::CallEpgTagMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVREpgInfoTag>& tag)
 {
   return DoAddonCall(__FUNCTION__, [&hook, &tag](const AddonInstance* addon) {
-    PVR_MENUHOOK_DATA hookData = {};
-    hookData.cat = PVR_MENUHOOK_EPG;
-    hookData.data.iEpgUid = tag->UniqueBroadcastID();
+    CAddonEpgTag addonTag(tag);
 
-    PVR_MENUHOOK menuHook = {0};
-    menuHook.category = hookData.cat;
+    PVR_MENUHOOK menuHook;
+    menuHook.category = PVR_MENUHOOK_EPG;
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
+    return addon->toAddon->CallEPGMenuHook(addon, &menuHook, &addonTag);
   });
 }
 
 PVR_ERROR CPVRClient::CallChannelMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRChannel>& channel)
 {
   return DoAddonCall(__FUNCTION__, [&hook, &channel](const AddonInstance* addon) {
-    PVR_MENUHOOK_DATA hookData = {};
-    hookData.cat = PVR_MENUHOOK_CHANNEL;
-    WriteClientChannelInfo(channel, hookData.data.channel);
+    PVR_CHANNEL tag;
+    WriteClientChannelInfo(channel, tag);
 
-    PVR_MENUHOOK menuHook = {0};
-    menuHook.category = hookData.cat;
+    PVR_MENUHOOK menuHook;
+    menuHook.category = PVR_MENUHOOK_CHANNEL;
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
+    return addon->toAddon->CallChannelMenuHook(addon, &menuHook, &tag);
   });
 }
 
 PVR_ERROR CPVRClient::CallRecordingMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRRecording>& recording, bool bDeleted)
 {
   return DoAddonCall(__FUNCTION__, [&hook, &recording, &bDeleted](const AddonInstance* addon) {
-    PVR_MENUHOOK_DATA hookData = {};
-    hookData.cat = bDeleted ? PVR_MENUHOOK_DELETED_RECORDING : PVR_MENUHOOK_RECORDING;
-    WriteClientRecordingInfo(*recording, hookData.data.recording);
+    PVR_RECORDING tag;
+    WriteClientRecordingInfo(*recording, tag);
 
-    PVR_MENUHOOK menuHook = {0};
-    menuHook.category = hookData.cat;
+    PVR_MENUHOOK menuHook;
+    menuHook.category = bDeleted ? PVR_MENUHOOK_DELETED_RECORDING : PVR_MENUHOOK_RECORDING;
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
+    return addon->toAddon->CallRecordingMenuHook(addon, &menuHook, &tag);
   });
 }
 
 PVR_ERROR CPVRClient::CallTimerMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRTimerInfoTag>& timer)
 {
   return DoAddonCall(__FUNCTION__, [&hook, &timer](const AddonInstance* addon) {
-    PVR_MENUHOOK_DATA hookData = {};
-    hookData.cat = PVR_MENUHOOK_TIMER;
-    WriteClientTimerInfo(*timer, hookData.data.timer);
+    PVR_TIMER tag;
+    WriteClientTimerInfo(*timer, tag);
 
-    PVR_MENUHOOK menuHook = {0};
-    menuHook.category = hookData.cat;
+    PVR_MENUHOOK menuHook;
+    menuHook.category = PVR_MENUHOOK_TIMER;
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
+    return addon->toAddon->CallTimerMenuHook(addon, &menuHook, &tag);
   });
 }
 
 PVR_ERROR CPVRClient::CallSettingsMenuHook(const CPVRClientMenuHook& hook)
 {
   return DoAddonCall(__FUNCTION__, [&hook](const AddonInstance* addon) {
-    PVR_MENUHOOK_DATA hookData = {};
-    hookData.cat = PVR_MENUHOOK_SETTING;
-
-    PVR_MENUHOOK menuHook = {0};
-    menuHook.category = hookData.cat;
+    PVR_MENUHOOK menuHook;
+    menuHook.category = PVR_MENUHOOK_SETTING;
     menuHook.iHookId = hook.GetId();
     menuHook.iLocalizedStringId = hook.GetLabelId();
 
-    return addon->toAddon->MenuHook(addon, &menuHook, &hookData);
+    return addon->toAddon->CallSettingsMenuHook(addon, &menuHook);
   });
 }
 

From 0f277750c546d43d9908fd385fb73cc954b131ab Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 11 May 2020 22:20:05 +0200
Subject: [PATCH 06/27] [addons][pvr] cleanup and sort xbmc_pvr_types.h

This done do have a much better overview about his parts.
---
 .../include/kodi/xbmc_pvr_types.h             | 660 +++++++++---------
 1 file changed, 333 insertions(+), 327 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index 6deb9085a135..875a4b2e53c1 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -11,200 +11,48 @@
 #include "AddonBase.h"
 
 #ifdef BUILD_KODI_ADDON
+#include "DemuxPacket.h"
 #include "InputStreamConstants.h"
 #else
+#include "cores/VideoPlayer/Interface/Addon/DemuxPacket.h"
 #include "cores/VideoPlayer/Interface/Addon/InputStreamConstants.h"
 #endif
 
-#ifdef USE_DEMUX
-#include "DemuxPacket.h"
-#else
-struct DemuxPacket;
-#endif
-
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <string.h>
 #include <time.h>
 
-#define PVR_ADDON_NAME_STRING_LENGTH 1024
-#define PVR_ADDON_URL_STRING_LENGTH 1024
-#define PVR_ADDON_DESC_STRING_LENGTH 1024
-#define PVR_ADDON_INPUT_FORMAT_STRING_LENGTH 32
-#define PVR_ADDON_EDL_LENGTH 32
-#define PVR_ADDON_TIMERTYPE_ARRAY_SIZE 32
-#define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE 512
-#define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL 128
-#define PVR_ADDON_TIMERTYPE_STRING_LENGTH 128
-#define PVR_ADDON_ATTRIBUTE_DESC_LENGTH 128
-#define PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE 512
-#define PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH 64
-#define PVR_ADDON_DATE_STRING_LENGTH 32
-
-#define XBMC_INVALID_CODEC_ID 0
-#define XBMC_INVALID_CODEC \
-  { \
-    XBMC_CODEC_TYPE_UNKNOWN, XBMC_INVALID_CODEC_ID \
-  }
-
-#define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
-#define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
-#define PVR_STREAM_PROPERTY_MIMETYPE "mimetype"
-#define PVR_STREAM_PROPERTY_ISREALTIMESTREAM STREAM_PROPERTY_ISREALTIMESTREAM
-#define PVR_STREAM_PROPERTY_EPGPLAYBACKASLIVE "epgplaybackaslive"
-#define PVR_STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG
-
-#define PVR_STREAM_MAX_STREAMS 20
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-  typedef unsigned int xbmc_codec_id_t;
-
-  typedef enum xbmc_codec_type_t
-  {
-    XBMC_CODEC_TYPE_UNKNOWN = -1,
-    XBMC_CODEC_TYPE_VIDEO,
-    XBMC_CODEC_TYPE_AUDIO,
-    XBMC_CODEC_TYPE_DATA,
-    XBMC_CODEC_TYPE_SUBTITLE,
-    XBMC_CODEC_TYPE_RDS,
-    XBMC_CODEC_TYPE_NB
-  } xbmc_codec_type_t;
-
-  typedef struct xbmc_codec_t
-  {
-    enum xbmc_codec_type_t codec_type;
-    xbmc_codec_id_t codec_id;
-  } xbmc_codec_t;
-
-  typedef enum EPG_EVENT_CONTENTMASK
-  {
-    EPG_EVENT_CONTENTMASK_UNDEFINED = 0x00,
-    EPG_EVENT_CONTENTMASK_MOVIEDRAMA = 0x10,
-    EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS = 0x20,
-    EPG_EVENT_CONTENTMASK_SHOW = 0x30,
-    EPG_EVENT_CONTENTMASK_SPORTS = 0x40,
-    EPG_EVENT_CONTENTMASK_CHILDRENYOUTH = 0x50,
-    EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE = 0x60,
-    EPG_EVENT_CONTENTMASK_ARTSCULTURE = 0x70,
-    EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS = 0x80,
-    EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE = 0x90,
-    EPG_EVENT_CONTENTMASK_LEISUREHOBBIES = 0xA0,
-    EPG_EVENT_CONTENTMASK_SPECIAL = 0xB0,
-    EPG_EVENT_CONTENTMASK_USERDEFINED = 0xF0
-  } EPG_EVENT_CONTENTMASK;
-
-  #define EPG_GENRE_USE_STRING 0x100
-  #define EPG_STRING_TOKEN_SEPARATOR ","
-
-  #define EPG_TAG_FLAG_UNDEFINED 0x00000000
-  #define EPG_TAG_FLAG_IS_SERIES 0x00000001
-  #define EPG_TAG_FLAG_IS_NEW 0x00000002
-  #define EPG_TAG_FLAG_IS_PREMIERE 0x00000004
-  #define EPG_TAG_FLAG_IS_FINALE 0x00000008
-  #define EPG_TAG_FLAG_IS_LIVE 0x00000010
+  #define PVR_ADDON_NAME_STRING_LENGTH 1024
+  #define PVR_ADDON_URL_STRING_LENGTH 1024
+  #define PVR_ADDON_DESC_STRING_LENGTH 1024
+  #define PVR_ADDON_INPUT_FORMAT_STRING_LENGTH 32
+  #define PVR_ADDON_EDL_LENGTH 32
+  #define PVR_ADDON_TIMERTYPE_ARRAY_SIZE 32
+  #define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE 512
+  #define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL 128
+  #define PVR_ADDON_TIMERTYPE_STRING_LENGTH 128
+  #define PVR_ADDON_ATTRIBUTE_DESC_LENGTH 128
+  #define PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE 512
+  #define PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH 64
+  #define PVR_ADDON_DATE_STRING_LENGTH 32
 
-  #define EPG_TAG_INVALID_UID 0
-
-  #define EPG_TAG_INVALID_SERIES_EPISODE -1
-
-  typedef enum EPG_EVENT_STATE
+  typedef struct PVR_ATTRIBUTE_INT_VALUE
   {
-    EPG_EVENT_CREATED = 0,
-    EPG_EVENT_UPDATED = 1,
-    EPG_EVENT_DELETED = 2,
-  } EPG_EVENT_STATE;
+    int iValue;
+    char strDescription[PVR_ADDON_ATTRIBUTE_DESC_LENGTH];
+  } ATTRIBUTE_PACKED PVR_ATTRIBUTE_INT_VALUE;
 
-  typedef struct EPG_TAG
+  typedef struct PVR_NAMED_VALUE
   {
-    unsigned int iUniqueBroadcastId;
-    unsigned int iUniqueChannelId;
-    const char* strTitle;
-    time_t startTime;
-    time_t endTime;
-    const char* strPlotOutline;
-    const char* strPlot;
-    const char* strOriginalTitle;
-    const char* strCast;
-    const char* strDirector;
-    const char* strWriter;
-    int iYear;
-    const char* strIMDBNumber;
-    const char* strIconPath;
-    int iGenreType;
-    int iGenreSubType;
-    const char* strGenreDescription;
-    const char* strFirstAired;
-    int iParentalRating;
-    int iStarRating;
-    int iSeriesNumber;
-    int iEpisodeNumber;
-    int iEpisodePartNumber;
-    const char* strEpisodeName;
-    unsigned int iFlags;
-    const char* strSeriesLink;
-  } ATTRIBUTE_PACKED EPG_TAG;
-
-  #define PVR_TIMER_TYPE_NONE 0
-  #define PVR_TIMER_NO_CLIENT_INDEX 0
-  #define PVR_TIMER_NO_PARENT PVR_TIMER_NO_CLIENT_INDEX
-  #define PVR_TIMER_NO_EPG_UID EPG_TAG_INVALID_UID
-  #define PVR_TIMER_ANY_CHANNEL -1
-
-  #define PVR_TIMER_TYPE_ATTRIBUTE_NONE 0x00000000
-
-  #define PVR_TIMER_TYPE_IS_MANUAL 0x00000001
-  #define PVR_TIMER_TYPE_IS_REPEATING 0x00000002
-  #define PVR_TIMER_TYPE_IS_READONLY 0x00000004
-  #define PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES 0x00000008
-  #define PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE 0x00000010
-  #define PVR_TIMER_TYPE_SUPPORTS_CHANNELS 0x00000020
-  #define PVR_TIMER_TYPE_SUPPORTS_START_TIME 0x00000040
-  #define PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH 0x00000080
-  #define PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH 0x00000100
-  #define PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY 0x00000200
-  #define PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS 0x00000400
-  #define PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES 0x00000800
-  #define PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN 0x00001000
-  #define PVR_TIMER_TYPE_SUPPORTS_PRIORITY 0x00002000
-  #define PVR_TIMER_TYPE_SUPPORTS_LIFETIME 0x00004000
-  #define PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS 0x00008000
-  #define PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP 0x00010000
-  #define PVR_TIMER_TYPE_SUPPORTS_END_TIME 0x00020000
-  #define PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME 0x00040000
-  #define PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME 0x00080000
-  #define PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS 0x00100000
-  #define PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE 0x00200000
-  #define PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE 0x00400000
-  #define PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE 0x00800000
-  #define PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL 0x01000000
-  #define PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE 0x02000000
-  #define PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE 0x04000000
-  #define PVR_TIMER_TYPE_IS_REMINDER 0x08000000
-  #define PVR_TIMER_TYPE_SUPPORTS_START_MARGIN 0x10000000
-  #define PVR_TIMER_TYPE_SUPPORTS_END_MARGIN 0x20000000
-
-  #define PVR_WEEKDAY_NONE 0x00
-  #define PVR_WEEKDAY_MONDAY 0x01
-  #define PVR_WEEKDAY_TUESDAY 0x02
-  #define PVR_WEEKDAY_WEDNESDAY 0x04
-  #define PVR_WEEKDAY_THURSDAY 0x08
-  #define PVR_WEEKDAY_FRIDAY 0x10
-  #define PVR_WEEKDAY_SATURDAY 0x20
-  #define PVR_WEEKDAY_SUNDAY 0x40
-  #define PVR_WEEKDAY_ALLDAYS \
-    ( \
-      PVR_WEEKDAY_MONDAY | PVR_WEEKDAY_TUESDAY | PVR_WEEKDAY_WEDNESDAY | PVR_WEEKDAY_THURSDAY | \
-      PVR_WEEKDAY_FRIDAY | PVR_WEEKDAY_SATURDAY | PVR_WEEKDAY_SUNDAY \
-    )
-
-
-  #define EPG_TIMEFRAME_UNLIMITED -1
-  #define PVR_CHANNEL_INVALID_UID -1
-  #define PVR_DESCRAMBLE_INFO_NOT_AVAILABLE -1
+    char strName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strValue[PVR_ADDON_NAME_STRING_LENGTH];
+  } ATTRIBUTE_PACKED PVR_NAMED_VALUE;
 
   typedef enum PVR_ERROR
   {
@@ -220,32 +68,6 @@ extern "C" {
     PVR_ERROR_FAILED = -9,
   } PVR_ERROR;
 
-  typedef enum PVR_TIMER_STATE
-  {
-    PVR_TIMER_STATE_NEW = 0,
-    PVR_TIMER_STATE_SCHEDULED = 1,
-    PVR_TIMER_STATE_RECORDING = 2,
-    PVR_TIMER_STATE_COMPLETED = 3,
-    PVR_TIMER_STATE_ABORTED = 4,
-    PVR_TIMER_STATE_CANCELLED = 5,
-    PVR_TIMER_STATE_CONFLICT_OK = 6,
-    PVR_TIMER_STATE_CONFLICT_NOK = 7,
-    PVR_TIMER_STATE_ERROR = 8,
-    PVR_TIMER_STATE_DISABLED = 9,
-  } PVR_TIMER_STATE;
-
-  typedef enum PVR_MENUHOOK_CAT
-  {
-    PVR_MENUHOOK_UNKNOWN = -1,
-    PVR_MENUHOOK_ALL = 0,
-    PVR_MENUHOOK_CHANNEL = 1,
-    PVR_MENUHOOK_TIMER = 2,
-    PVR_MENUHOOK_EPG = 3,
-    PVR_MENUHOOK_RECORDING = 4,
-    PVR_MENUHOOK_DELETED_RECORDING = 5,
-    PVR_MENUHOOK_SETTING = 6,
-  } PVR_MENUHOOK_CAT;
-
   typedef enum PVR_CONNECTION_STATE
   {
     PVR_CONNECTION_STATE_UNKNOWN = 0,
@@ -258,32 +80,6 @@ extern "C" {
     PVR_CONNECTION_STATE_CONNECTING = 7,
   } PVR_CONNECTION_STATE;
 
-  typedef enum PVR_RECORDING_CHANNEL_TYPE
-  {
-    PVR_RECORDING_CHANNEL_TYPE_UNKNOWN = 0,
-    PVR_RECORDING_CHANNEL_TYPE_TV = 1,
-    PVR_RECORDING_CHANNEL_TYPE_RADIO = 2,
-  } PVR_RECORDING_CHANNEL_TYPE;
-
-  typedef struct PVR_NAMED_VALUE
-  {
-    char strName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strValue[PVR_ADDON_NAME_STRING_LENGTH];
-  } ATTRIBUTE_PACKED PVR_NAMED_VALUE;
-
-  typedef struct AddonProperties_PVR
-  {
-    const char* strUserPath;
-    const char* strClientPath;
-    int iEpgMaxDays;
-  } AddonProperties_PVR;
-
-  typedef struct PVR_ATTRIBUTE_INT_VALUE
-  {
-    int iValue;
-    char strDescription[PVR_ADDON_ATTRIBUTE_DESC_LENGTH];
-  } ATTRIBUTE_PACKED PVR_ATTRIBUTE_INT_VALUE;
-
   typedef struct PVR_ADDON_CAPABILITIES
   {
     bool bSupportsEPG;
@@ -311,28 +107,20 @@ extern "C" {
     PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE];
   } ATTRIBUTE_PACKED PVR_ADDON_CAPABILITIES;
 
-  typedef struct PVR_STREAM_PROPERTIES
+  typedef struct PVR_CHANNEL
   {
-    unsigned int iStreamCount;
-    struct PVR_STREAM
-    {
-      unsigned int iPID;
-      xbmc_codec_type_t iCodecType;
-      xbmc_codec_id_t iCodecId;
-      char strLanguage[4];
-      int iSubtitleInfo;
-      int iFPSScale;
-      int iFPSRate;
-      int iHeight;
-      int iWidth;
-      float fAspect;
-      int iChannels;
-      int iSampleRate;
-      int iBlockAlign;
-      int iBitRate;
-      int iBitsPerSample;
-    } stream[PVR_STREAM_MAX_STREAMS];
-  } ATTRIBUTE_PACKED PVR_STREAM_PROPERTIES;
+    unsigned int iUniqueId;
+    bool bIsRadio;
+    unsigned int iChannelNumber;
+    unsigned int iSubChannelNumber;
+    char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strInputFormat[PVR_ADDON_INPUT_FORMAT_STRING_LENGTH];
+    unsigned int iEncryptionSystem;
+    char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
+    bool bIsHidden;
+    bool bHasArchive;
+    int iOrder;
+  } ATTRIBUTE_PACKED PVR_CHANNEL;
 
   typedef struct PVR_SIGNAL_STATUS
   {
@@ -347,6 +135,8 @@ extern "C" {
     long iUNC;
   } ATTRIBUTE_PACKED PVR_SIGNAL_STATUS;
 
+  #define PVR_DESCRAMBLE_INFO_NOT_AVAILABLE -1
+
   typedef struct PVR_DESCRAMBLE_INFO
   {
     int iPid;
@@ -360,30 +150,6 @@ extern "C" {
     char strProtocol[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
   } ATTRIBUTE_PACKED PVR_DESCRAMBLE_INFO;
 
-  typedef struct PVR_MENUHOOK
-  {
-    unsigned int iHookId;
-    unsigned int iLocalizedStringId;
-    enum PVR_MENUHOOK_CAT category;
-  } ATTRIBUTE_PACKED PVR_MENUHOOK;
-
-  #define PVR_CHANNEL_UNKNOWN_ORDER 0
-
-  typedef struct PVR_CHANNEL
-  {
-    unsigned int iUniqueId;
-    bool bIsRadio;
-    unsigned int iChannelNumber;
-    unsigned int iSubChannelNumber;
-    char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strInputFormat[PVR_ADDON_INPUT_FORMAT_STRING_LENGTH];
-    unsigned int iEncryptionSystem;
-    char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
-    bool bIsHidden;
-    bool bHasArchive;
-    int iOrder;
-  } ATTRIBUTE_PACKED PVR_CHANNEL;
-
   typedef struct PVR_CHANNEL_GROUP
   {
     char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
@@ -400,77 +166,98 @@ extern "C" {
     int iOrder;
   } ATTRIBUTE_PACKED PVR_CHANNEL_GROUP_MEMBER;
 
-  typedef PVR_ATTRIBUTE_INT_VALUE PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE;
-
-  typedef struct PVR_TIMER_TYPE
+  typedef enum EPG_EVENT_CONTENTMASK
   {
-    unsigned int iId;
-    unsigned int iAttributes;
-    char strDescription[PVR_ADDON_TIMERTYPE_STRING_LENGTH];
+    EPG_EVENT_CONTENTMASK_UNDEFINED = 0x00,
+    EPG_EVENT_CONTENTMASK_MOVIEDRAMA = 0x10,
+    EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS = 0x20,
+    EPG_EVENT_CONTENTMASK_SHOW = 0x30,
+    EPG_EVENT_CONTENTMASK_SPORTS = 0x40,
+    EPG_EVENT_CONTENTMASK_CHILDRENYOUTH = 0x50,
+    EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE = 0x60,
+    EPG_EVENT_CONTENTMASK_ARTSCULTURE = 0x70,
+    EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS = 0x80,
+    EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE = 0x90,
+    EPG_EVENT_CONTENTMASK_LEISUREHOBBIES = 0xA0,
+    EPG_EVENT_CONTENTMASK_SPECIAL = 0xB0,
+    EPG_EVENT_CONTENTMASK_USERDEFINED = 0xF0,
+    EPG_GENRE_USE_STRING = 0x100
+  } EPG_EVENT_CONTENTMASK;
 
-    unsigned int iPrioritiesSize;
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE priorities[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-    int iPrioritiesDefault;
+  #define EPG_STRING_TOKEN_SEPARATOR ","
 
-    unsigned int iLifetimesSize;
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE lifetimes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-    int iLifetimesDefault;
+  typedef enum EPG_TAG_FLAG
+  {
+    EPG_TAG_FLAG_UNDEFINED = 0,
+    EPG_TAG_FLAG_IS_SERIES = (1 << 0),
+    EPG_TAG_FLAG_IS_NEW = (1 << 1),
+    EPG_TAG_FLAG_IS_PREMIERE = (1 << 2),
+    EPG_TAG_FLAG_IS_FINALE = (1 << 3),
+    EPG_TAG_FLAG_IS_LIVE = (1 << 4),
+  } EPG_TAG_FLAG;
 
-    unsigned int iPreventDuplicateEpisodesSize;
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE
-    preventDuplicateEpisodes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-    unsigned int iPreventDuplicateEpisodesDefault;
+  #define EPG_TAG_INVALID_UID 0
 
-    unsigned int iRecordingGroupSize;
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE recordingGroup[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-    unsigned int iRecordingGroupDefault;
+  #define EPG_TAG_INVALID_SERIES_EPISODE -1
 
-    unsigned int iMaxRecordingsSize;
-    PVR_TIMER_TYPE_ATTRIBUTE_INT_VALUE maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
-    int iMaxRecordingsDefault;
-  } ATTRIBUTE_PACKED PVR_TIMER_TYPE;
+  #define EPG_TIMEFRAME_UNLIMITED -1
 
-  typedef struct PVR_TIMER
+  typedef enum EPG_EVENT_STATE
   {
-    unsigned int iClientIndex;
-    unsigned int iParentClientIndex;
-    int iClientChannelUid;
+    EPG_EVENT_CREATED = 0,
+    EPG_EVENT_UPDATED = 1,
+    EPG_EVENT_DELETED = 2,
+  } EPG_EVENT_STATE;
+
+  typedef struct EPG_TAG
+  {
+    unsigned int iUniqueBroadcastId;
+    unsigned int iUniqueChannelId;
+    const char* strTitle;
     time_t startTime;
     time_t endTime;
-    bool bStartAnyTime;
-    bool bEndAnyTime;
-    enum PVR_TIMER_STATE state;
-    unsigned int iTimerType;
-    char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
-    char strEpgSearchString[PVR_ADDON_NAME_STRING_LENGTH];
-    bool bFullTextEpgSearch;
-    char strDirectory[PVR_ADDON_URL_STRING_LENGTH];
-    char strSummary[PVR_ADDON_DESC_STRING_LENGTH];
-    int iPriority;
-    int iLifetime;
-    int iMaxRecordings;
-    unsigned int iRecordingGroup;
-    time_t firstDay;
-    unsigned int iWeekdays;
-    unsigned int iPreventDuplicateEpisodes;
-    unsigned int iEpgUid;
-    unsigned int iMarginStart;
-    unsigned int iMarginEnd;
+    const char* strPlotOutline;
+    const char* strPlot;
+    const char* strOriginalTitle;
+    const char* strCast;
+    const char* strDirector;
+    const char* strWriter;
+    int iYear;
+    const char* strIMDBNumber;
+    const char* strIconPath;
     int iGenreType;
     int iGenreSubType;
-    char strSeriesLink[PVR_ADDON_URL_STRING_LENGTH];
-  } ATTRIBUTE_PACKED PVR_TIMER;
+    const char* strGenreDescription;
+    const char* strFirstAired;
+    int iParentalRating;
+    int iStarRating;
+    int iSeriesNumber;
+    int iEpisodeNumber;
+    int iEpisodePartNumber;
+    const char* strEpisodeName;
+    unsigned int iFlags;
+    const char* strSeriesLink;
+  } ATTRIBUTE_PACKED EPG_TAG;
 
-  /* PVR_RECORDING.iFlags values */
-  #define PVR_RECORDING_FLAG_UNDEFINED 0x00000000
-  #define PVR_RECORDING_FLAG_IS_SERIES 0x00000001
-  #define PVR_RECORDING_FLAG_IS_NEW 0x00000002
-  #define PVR_RECORDING_FLAG_IS_PREMIERE 0x00000004
-  #define PVR_RECORDING_FLAG_IS_FINALE 0x00000008
-  #define PVR_RECORDING_FLAG_IS_LIVE 0x00000010
+  typedef enum PVR_RECORDING_FLAG
+  {
+    PVR_RECORDING_FLAG_UNDEFINED = 0,
+    PVR_RECORDING_FLAG_IS_SERIES = (1 << 0),
+    PVR_RECORDING_FLAG_IS_NEW = (1 << 1),
+    PVR_RECORDING_FLAG_IS_PREMIERE = (1 << 2),
+    PVR_RECORDING_FLAG_IS_FINALE = (1 << 3),
+    PVR_RECORDING_FLAG_IS_LIVE = (1 << 4),
+  } PVR_RECORDING_FLAG;
 
   #define PVR_RECORDING_INVALID_SERIES_EPISODE EPG_TAG_INVALID_SERIES_EPISODE
 
+  typedef enum PVR_RECORDING_CHANNEL_TYPE
+  {
+    PVR_RECORDING_CHANNEL_TYPE_UNKNOWN = 0,
+    PVR_RECORDING_CHANNEL_TYPE_TV = 1,
+    PVR_RECORDING_CHANNEL_TYPE_RADIO = 2,
+  } PVR_RECORDING_CHANNEL_TYPE;
+
   typedef struct PVR_RECORDING
   {
     char strRecordingId[PVR_ADDON_NAME_STRING_LENGTH];
@@ -504,6 +291,153 @@ extern "C" {
     int64_t sizeInBytes;
   } ATTRIBUTE_PACKED PVR_RECORDING;
 
+  #define PVR_TIMER_TYPE_NONE 0
+  #define PVR_TIMER_NO_CLIENT_INDEX 0
+  #define PVR_TIMER_NO_PARENT PVR_TIMER_NO_CLIENT_INDEX
+  #define PVR_TIMER_NO_EPG_UID EPG_TAG_INVALID_UID
+  #define PVR_TIMER_ANY_CHANNEL -1
+
+  typedef enum PVR_TIMER_TYPES
+  {
+    PVR_TIMER_TYPE_ATTRIBUTE_NONE = 0,
+    PVR_TIMER_TYPE_IS_MANUAL = (1 << 0),
+    PVR_TIMER_TYPE_IS_REPEATING = (1 << 1),
+    PVR_TIMER_TYPE_IS_READONLY = (1 << 2),
+    PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES = (1 << 3),
+    PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE = (1 << 4),
+    PVR_TIMER_TYPE_SUPPORTS_CHANNELS = (1 << 5),
+    PVR_TIMER_TYPE_SUPPORTS_START_TIME = (1 << 6),
+    PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH = (1 << 7),
+    PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH = (1 << 8),
+    PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY = (1 << 9),
+    PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS = (1 << 10),
+    PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES = (1 << 11),
+    PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN = (1 << 12),
+    PVR_TIMER_TYPE_SUPPORTS_PRIORITY = (1 << 13),
+    PVR_TIMER_TYPE_SUPPORTS_LIFETIME = (1 << 14),
+    PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS = (1 << 15),
+    PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP = (1 << 16),
+    PVR_TIMER_TYPE_SUPPORTS_END_TIME = (1 << 17),
+    PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME = (1 << 18),
+    PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME = (1 << 19),
+    PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS = (1 << 20),
+    PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE = (1 << 21),
+    PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE = (1 << 22),
+    PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE = (1 << 23),
+    PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL = (1 << 24),
+    PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE = (1 << 25),
+    PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE = (1 << 26),
+    PVR_TIMER_TYPE_IS_REMINDER = (1 << 27),
+    PVR_TIMER_TYPE_SUPPORTS_START_MARGIN = (1 << 28),
+    PVR_TIMER_TYPE_SUPPORTS_END_MARGIN = (1 << 29),
+  } PVR_TIMER_TYPES;
+
+  typedef enum PVR_WEEKDAYS
+  {
+    PVR_WEEKDAY_NONE = 0,
+    PVR_WEEKDAY_MONDAY = (1 << 0),
+    PVR_WEEKDAY_TUESDAY = (1 << 1),
+    PVR_WEEKDAY_WEDNESDAY = (1 << 2),
+    PVR_WEEKDAY_THURSDAY = (1 << 3),
+    PVR_WEEKDAY_FRIDAY = (1 << 4),
+    PVR_WEEKDAY_SATURDAY = (1 << 5),
+    PVR_WEEKDAY_SUNDAY = (1 << 6),
+    PVR_WEEKDAY_ALLDAYS = PVR_WEEKDAY_MONDAY | PVR_WEEKDAY_TUESDAY | PVR_WEEKDAY_WEDNESDAY |
+                          PVR_WEEKDAY_THURSDAY | PVR_WEEKDAY_FRIDAY | PVR_WEEKDAY_SATURDAY |
+                          PVR_WEEKDAY_SUNDAY
+  } PVR_WEEKDAY;
+
+  typedef enum PVR_TIMER_STATE
+  {
+    PVR_TIMER_STATE_NEW = 0,
+    PVR_TIMER_STATE_SCHEDULED = 1,
+    PVR_TIMER_STATE_RECORDING = 2,
+    PVR_TIMER_STATE_COMPLETED = 3,
+    PVR_TIMER_STATE_ABORTED = 4,
+    PVR_TIMER_STATE_CANCELLED = 5,
+    PVR_TIMER_STATE_CONFLICT_OK = 6,
+    PVR_TIMER_STATE_CONFLICT_NOK = 7,
+    PVR_TIMER_STATE_ERROR = 8,
+    PVR_TIMER_STATE_DISABLED = 9,
+  } PVR_TIMER_STATE;
+
+  typedef struct PVR_TIMER
+  {
+    unsigned int iClientIndex;
+    unsigned int iParentClientIndex;
+    int iClientChannelUid;
+    time_t startTime;
+    time_t endTime;
+    bool bStartAnyTime;
+    bool bEndAnyTime;
+    enum PVR_TIMER_STATE state;
+    unsigned int iTimerType;
+    char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
+    char strEpgSearchString[PVR_ADDON_NAME_STRING_LENGTH];
+    bool bFullTextEpgSearch;
+    char strDirectory[PVR_ADDON_URL_STRING_LENGTH];
+    char strSummary[PVR_ADDON_DESC_STRING_LENGTH];
+    int iPriority;
+    int iLifetime;
+    int iMaxRecordings;
+    unsigned int iRecordingGroup;
+    time_t firstDay;
+    unsigned int iWeekdays;
+    unsigned int iPreventDuplicateEpisodes;
+    unsigned int iEpgUid;
+    unsigned int iMarginStart;
+    unsigned int iMarginEnd;
+    int iGenreType;
+    int iGenreSubType;
+    char strSeriesLink[PVR_ADDON_URL_STRING_LENGTH];
+  } ATTRIBUTE_PACKED PVR_TIMER;
+
+  typedef struct PVR_TIMER_TYPE
+  {
+    unsigned int iId;
+    unsigned int iAttributes;
+    char strDescription[PVR_ADDON_TIMERTYPE_STRING_LENGTH];
+
+    unsigned int iPrioritiesSize;
+    PVR_ATTRIBUTE_INT_VALUE priorities[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    int iPrioritiesDefault;
+
+    unsigned int iLifetimesSize;
+    PVR_ATTRIBUTE_INT_VALUE lifetimes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    int iLifetimesDefault;
+
+    unsigned int iPreventDuplicateEpisodesSize;
+    PVR_ATTRIBUTE_INT_VALUE preventDuplicateEpisodes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    unsigned int iPreventDuplicateEpisodesDefault;
+
+    unsigned int iRecordingGroupSize;
+    PVR_ATTRIBUTE_INT_VALUE recordingGroup[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    unsigned int iRecordingGroupDefault;
+
+    unsigned int iMaxRecordingsSize;
+    PVR_ATTRIBUTE_INT_VALUE maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
+    int iMaxRecordingsDefault;
+  } ATTRIBUTE_PACKED PVR_TIMER_TYPE;
+
+  typedef enum PVR_MENUHOOK_CAT
+  {
+    PVR_MENUHOOK_UNKNOWN = -1,
+    PVR_MENUHOOK_ALL = 0,
+    PVR_MENUHOOK_CHANNEL = 1,
+    PVR_MENUHOOK_TIMER = 2,
+    PVR_MENUHOOK_EPG = 3,
+    PVR_MENUHOOK_RECORDING = 4,
+    PVR_MENUHOOK_DELETED_RECORDING = 5,
+    PVR_MENUHOOK_SETTING = 6,
+  } PVR_MENUHOOK_CAT;
+
+  typedef struct PVR_MENUHOOK
+  {
+    unsigned int iHookId;
+    unsigned int iLocalizedStringId;
+    enum PVR_MENUHOOK_CAT category;
+  } ATTRIBUTE_PACKED PVR_MENUHOOK;
+
   typedef enum PVR_EDL_TYPE
   {
     PVR_EDL_TYPE_CUT = 0,
@@ -519,6 +453,56 @@ extern "C" {
     enum PVR_EDL_TYPE type;
   } ATTRIBUTE_PACKED PVR_EDL_ENTRY;
 
+  #define PVR_STREAM_MAX_STREAMS 20
+
+  #define XBMC_INVALID_CODEC_ID 0
+  #define XBMC_INVALID_CODEC \
+    { \
+      XBMC_CODEC_TYPE_UNKNOWN, XBMC_INVALID_CODEC_ID \
+    }
+
+  typedef unsigned int xbmc_codec_id_t;
+
+  typedef enum xbmc_codec_type_t
+  {
+    XBMC_CODEC_TYPE_UNKNOWN = -1,
+    XBMC_CODEC_TYPE_VIDEO,
+    XBMC_CODEC_TYPE_AUDIO,
+    XBMC_CODEC_TYPE_DATA,
+    XBMC_CODEC_TYPE_SUBTITLE,
+    XBMC_CODEC_TYPE_RDS,
+    XBMC_CODEC_TYPE_NB
+  } xbmc_codec_type_t;
+
+  typedef struct xbmc_codec_t
+  {
+    enum xbmc_codec_type_t codec_type;
+    xbmc_codec_id_t codec_id;
+  } xbmc_codec_t;
+
+  typedef struct PVR_STREAM_PROPERTIES
+  {
+    unsigned int iStreamCount;
+    struct PVR_STREAM
+    {
+      unsigned int iPID;
+      xbmc_codec_type_t iCodecType;
+      xbmc_codec_id_t iCodecId;
+      char strLanguage[4];
+      int iSubtitleInfo;
+      int iFPSScale;
+      int iFPSRate;
+      int iHeight;
+      int iWidth;
+      float fAspect;
+      int iChannels;
+      int iSampleRate;
+      int iBlockAlign;
+      int iBitRate;
+      int iBitsPerSample;
+    } stream[PVR_STREAM_MAX_STREAMS];
+  } ATTRIBUTE_PACKED PVR_STREAM_PROPERTIES;
+
   typedef struct PVR_STREAM_TIMES
   {
     time_t startTime;
@@ -527,8 +511,30 @@ extern "C" {
     int64_t ptsEnd;
   } ATTRIBUTE_PACKED PVR_STREAM_TIMES;
 
+  #define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
+  #define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
+  #define PVR_STREAM_PROPERTY_MIMETYPE "mimetype"
+  #define PVR_STREAM_PROPERTY_ISREALTIMESTREAM STREAM_PROPERTY_ISREALTIMESTREAM
+  #define PVR_STREAM_PROPERTY_EPGPLAYBACKASLIVE "epgplaybackaslive"
+  #define PVR_STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG
+
+  #define PVR_CHANNEL_INVALID_UID -1
+
   struct AddonInstance_PVR;
 
+  /*!
+   * @brief Structure to define typical standard values
+   */
+  typedef struct AddonProperties_PVR
+  {
+    const char* strUserPath;
+    const char* strClientPath;
+    int iEpgMaxDays;
+  } AddonProperties_PVR;
+
+  /*!
+   * @brief Structure to transfer the methods from Kodi to addon
+   */
   typedef struct AddonToKodiFuncTable_PVR
   {
     // Pointer inside Kodi where used from him to find his class

From 410646f64bcbf022db98e8f7750e70eeeea4acca Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Tue, 5 May 2020 23:19:32 +0200
Subject: [PATCH 07/27] [addons][pvr] remove use of ATTRIBUTE_PACKED on pvr

Becomed a note that some "C" systems have problems about.
---
 .../include/kodi/xbmc_pvr_types.h             | 32 +++++++++----------
 1 file changed, 16 insertions(+), 16 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index 875a4b2e53c1..64affcb527b6 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -46,13 +46,13 @@ extern "C" {
   {
     int iValue;
     char strDescription[PVR_ADDON_ATTRIBUTE_DESC_LENGTH];
-  } ATTRIBUTE_PACKED PVR_ATTRIBUTE_INT_VALUE;
+  } PVR_ATTRIBUTE_INT_VALUE;
 
   typedef struct PVR_NAMED_VALUE
   {
     char strName[PVR_ADDON_NAME_STRING_LENGTH];
     char strValue[PVR_ADDON_NAME_STRING_LENGTH];
-  } ATTRIBUTE_PACKED PVR_NAMED_VALUE;
+  } PVR_NAMED_VALUE;
 
   typedef enum PVR_ERROR
   {
@@ -105,7 +105,7 @@ extern "C" {
 
     unsigned int iRecordingsLifetimesSize;
     PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE];
-  } ATTRIBUTE_PACKED PVR_ADDON_CAPABILITIES;
+  } PVR_ADDON_CAPABILITIES;
 
   typedef struct PVR_CHANNEL
   {
@@ -120,7 +120,7 @@ extern "C" {
     bool bIsHidden;
     bool bHasArchive;
     int iOrder;
-  } ATTRIBUTE_PACKED PVR_CHANNEL;
+  } PVR_CHANNEL;
 
   typedef struct PVR_SIGNAL_STATUS
   {
@@ -133,7 +133,7 @@ extern "C" {
     int iSignal;
     long iBER;
     long iUNC;
-  } ATTRIBUTE_PACKED PVR_SIGNAL_STATUS;
+  } PVR_SIGNAL_STATUS;
 
   #define PVR_DESCRAMBLE_INFO_NOT_AVAILABLE -1
 
@@ -148,14 +148,14 @@ extern "C" {
     char strReader[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
     char strFrom[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
     char strProtocol[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
-  } ATTRIBUTE_PACKED PVR_DESCRAMBLE_INFO;
+  } PVR_DESCRAMBLE_INFO;
 
   typedef struct PVR_CHANNEL_GROUP
   {
     char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
     bool bIsRadio;
     unsigned int iPosition;
-  } ATTRIBUTE_PACKED PVR_CHANNEL_GROUP;
+  } PVR_CHANNEL_GROUP;
 
   typedef struct PVR_CHANNEL_GROUP_MEMBER
   {
@@ -164,7 +164,7 @@ extern "C" {
     unsigned int iChannelNumber;
     unsigned int iSubChannelNumber;
     int iOrder;
-  } ATTRIBUTE_PACKED PVR_CHANNEL_GROUP_MEMBER;
+  } PVR_CHANNEL_GROUP_MEMBER;
 
   typedef enum EPG_EVENT_CONTENTMASK
   {
@@ -237,7 +237,7 @@ extern "C" {
     const char* strEpisodeName;
     unsigned int iFlags;
     const char* strSeriesLink;
-  } ATTRIBUTE_PACKED EPG_TAG;
+  } EPG_TAG;
 
   typedef enum PVR_RECORDING_FLAG
   {
@@ -289,7 +289,7 @@ extern "C" {
     char strFirstAired[PVR_ADDON_DATE_STRING_LENGTH];
     unsigned int iFlags;
     int64_t sizeInBytes;
-  } ATTRIBUTE_PACKED PVR_RECORDING;
+  } PVR_RECORDING;
 
   #define PVR_TIMER_TYPE_NONE 0
   #define PVR_TIMER_NO_CLIENT_INDEX 0
@@ -390,7 +390,7 @@ extern "C" {
     int iGenreType;
     int iGenreSubType;
     char strSeriesLink[PVR_ADDON_URL_STRING_LENGTH];
-  } ATTRIBUTE_PACKED PVR_TIMER;
+  } PVR_TIMER;
 
   typedef struct PVR_TIMER_TYPE
   {
@@ -417,7 +417,7 @@ extern "C" {
     unsigned int iMaxRecordingsSize;
     PVR_ATTRIBUTE_INT_VALUE maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
     int iMaxRecordingsDefault;
-  } ATTRIBUTE_PACKED PVR_TIMER_TYPE;
+  } PVR_TIMER_TYPE;
 
   typedef enum PVR_MENUHOOK_CAT
   {
@@ -436,7 +436,7 @@ extern "C" {
     unsigned int iHookId;
     unsigned int iLocalizedStringId;
     enum PVR_MENUHOOK_CAT category;
-  } ATTRIBUTE_PACKED PVR_MENUHOOK;
+  } PVR_MENUHOOK;
 
   typedef enum PVR_EDL_TYPE
   {
@@ -451,7 +451,7 @@ extern "C" {
     int64_t start;
     int64_t end;
     enum PVR_EDL_TYPE type;
-  } ATTRIBUTE_PACKED PVR_EDL_ENTRY;
+  } PVR_EDL_ENTRY;
 
   #define PVR_STREAM_MAX_STREAMS 20
 
@@ -501,7 +501,7 @@ extern "C" {
       int iBitRate;
       int iBitsPerSample;
     } stream[PVR_STREAM_MAX_STREAMS];
-  } ATTRIBUTE_PACKED PVR_STREAM_PROPERTIES;
+  } PVR_STREAM_PROPERTIES;
 
   typedef struct PVR_STREAM_TIMES
   {
@@ -509,7 +509,7 @@ extern "C" {
     int64_t ptsStart;
     int64_t ptsBegin;
     int64_t ptsEnd;
-  } ATTRIBUTE_PACKED PVR_STREAM_TIMES;
+  } PVR_STREAM_TIMES;
 
   #define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
   #define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM

From b47879cf7dbba143000bb4c507b54f8123d65732 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Tue, 5 May 2020 23:22:41 +0200
Subject: [PATCH 08/27] [addons][pvr] cleanup PVR related stream and codec
 structures

Before this was e.g. named xbmc, but as this only be related to PVR
and to be shot away in future are related parts renamed to match
them.
---
 .../include/kodi/libXBMC_pvr.h                |  2 +-
 .../include/kodi/xbmc_pvr_types.h             | 54 +++++++++----------
 .../DVDInputStreams/InputStreamPVRBase.cpp    |  8 +--
 xbmc/pvr/addons/PVRClient.cpp                 | 18 +++----
 xbmc/pvr/addons/PVRClient.h                   |  2 +-
 5 files changed, 41 insertions(+), 43 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
index 1aef14084d7c..81263658636d 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
@@ -232,7 +232,7 @@ class CHelper_libXBMC_pvr
    * @param strCodecName The name of the codec
    * @return The codec_id, or a codec_id with 0 values when not supported
    */
-  xbmc_codec_t GetCodecByName(const char* strCodecName)
+  PVR_CODEC GetCodecByName(const char* strCodecName)
   {
     return m_Callbacks->toKodi->GetCodecByName(m_Callbacks->toKodi->kodiInstance, strCodecName);
   }
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index 64affcb527b6..a558fe676cdb 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -104,7 +104,7 @@ extern "C" {
     bool bSupportsRecordingSize;
 
     unsigned int iRecordingsLifetimesSize;
-    PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE];
+    struct PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE];
   } PVR_ADDON_CAPABILITIES;
 
   typedef struct PVR_CHANNEL
@@ -285,7 +285,7 @@ extern "C" {
     bool bIsDeleted;
     unsigned int iEpgEventId;
     int iChannelUid;
-    PVR_RECORDING_CHANNEL_TYPE channelType;
+    enum PVR_RECORDING_CHANNEL_TYPE channelType;
     char strFirstAired[PVR_ADDON_DATE_STRING_LENGTH];
     unsigned int iFlags;
     int64_t sizeInBytes;
@@ -399,23 +399,23 @@ extern "C" {
     char strDescription[PVR_ADDON_TIMERTYPE_STRING_LENGTH];
 
     unsigned int iPrioritiesSize;
-    PVR_ATTRIBUTE_INT_VALUE priorities[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    struct PVR_ATTRIBUTE_INT_VALUE priorities[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
     int iPrioritiesDefault;
 
     unsigned int iLifetimesSize;
-    PVR_ATTRIBUTE_INT_VALUE lifetimes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    struct PVR_ATTRIBUTE_INT_VALUE lifetimes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
     int iLifetimesDefault;
 
     unsigned int iPreventDuplicateEpisodesSize;
-    PVR_ATTRIBUTE_INT_VALUE preventDuplicateEpisodes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    struct PVR_ATTRIBUTE_INT_VALUE preventDuplicateEpisodes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
     unsigned int iPreventDuplicateEpisodesDefault;
 
     unsigned int iRecordingGroupSize;
-    PVR_ATTRIBUTE_INT_VALUE recordingGroup[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    struct PVR_ATTRIBUTE_INT_VALUE recordingGroup[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
     unsigned int iRecordingGroupDefault;
 
     unsigned int iMaxRecordingsSize;
-    PVR_ATTRIBUTE_INT_VALUE maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
+    struct PVR_ATTRIBUTE_INT_VALUE maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
     int iMaxRecordingsDefault;
   } PVR_TIMER_TYPE;
 
@@ -455,30 +455,28 @@ extern "C" {
 
   #define PVR_STREAM_MAX_STREAMS 20
 
-  #define XBMC_INVALID_CODEC_ID 0
-  #define XBMC_INVALID_CODEC \
+  #define PVR_INVALID_CODEC_ID 0
+  #define PVR_INVALID_CODEC \
     { \
-      XBMC_CODEC_TYPE_UNKNOWN, XBMC_INVALID_CODEC_ID \
+      PVR_CODEC_TYPE_UNKNOWN, PVR_INVALID_CODEC_ID \
     }
 
-  typedef unsigned int xbmc_codec_id_t;
-
-  typedef enum xbmc_codec_type_t
+  typedef enum PVR_CODEC_TYPE
   {
-    XBMC_CODEC_TYPE_UNKNOWN = -1,
-    XBMC_CODEC_TYPE_VIDEO,
-    XBMC_CODEC_TYPE_AUDIO,
-    XBMC_CODEC_TYPE_DATA,
-    XBMC_CODEC_TYPE_SUBTITLE,
-    XBMC_CODEC_TYPE_RDS,
-    XBMC_CODEC_TYPE_NB
-  } xbmc_codec_type_t;
+    PVR_CODEC_TYPE_UNKNOWN = -1,
+    PVR_CODEC_TYPE_VIDEO,
+    PVR_CODEC_TYPE_AUDIO,
+    PVR_CODEC_TYPE_DATA,
+    PVR_CODEC_TYPE_SUBTITLE,
+    PVR_CODEC_TYPE_RDS,
+    PVR_CODEC_TYPE_NB
+  } PVR_CODEC_TYPE;
 
-  typedef struct xbmc_codec_t
+  typedef struct PVR_CODEC
   {
-    enum xbmc_codec_type_t codec_type;
-    xbmc_codec_id_t codec_id;
-  } xbmc_codec_t;
+    enum PVR_CODEC_TYPE codec_type;
+    unsigned int codec_id;
+  } PVR_CODEC;
 
   typedef struct PVR_STREAM_PROPERTIES
   {
@@ -486,8 +484,8 @@ extern "C" {
     struct PVR_STREAM
     {
       unsigned int iPID;
-      xbmc_codec_type_t iCodecType;
-      xbmc_codec_id_t iCodecId;
+      enum PVR_CODEC_TYPE iCodecType;
+      unsigned int iCodecId;
       char strLanguage[4];
       int iSubtitleInfo;
       int iFPSScale;
@@ -585,7 +583,7 @@ extern "C" {
     // Stream demux interface functions
     void (*FreeDemuxPacket)(void* kodiInstance, struct DemuxPacket* pPacket);
     struct DemuxPacket* (*AllocateDemuxPacket)(void* kodiInstance, int iDataSize);
-    struct xbmc_codec_t (*GetCodecByName)(const void* kodiInstance, const char* strCodecName);
+    struct PVR_CODEC (*GetCodecByName)(const void* kodiInstance, const char* strCodecName);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // New functions becomes added below and can be on another API change (where
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamPVRBase.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamPVRBase.cpp
index 0d6ea25175bc..b082dcdb3e25 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamPVRBase.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamPVRBase.cpp
@@ -263,7 +263,7 @@ void CInputStreamPVRBase::UpdateStreamMap()
 
     std::shared_ptr<CDemuxStream> dStream = GetStreamInternal(stream.iPID);
 
-    if (stream.iCodecType == XBMC_CODEC_TYPE_AUDIO)
+    if (stream.iCodecType == PVR_CODEC_TYPE_AUDIO)
     {
       std::shared_ptr<CDemuxStreamAudio> streamAudio;
 
@@ -280,7 +280,7 @@ void CInputStreamPVRBase::UpdateStreamMap()
 
       dStream = streamAudio;
     }
-    else if (stream.iCodecType == XBMC_CODEC_TYPE_VIDEO)
+    else if (stream.iCodecType == PVR_CODEC_TYPE_VIDEO)
     {
       std::shared_ptr<CDemuxStreamVideo> streamVideo;
 
@@ -308,7 +308,7 @@ void CInputStreamPVRBase::UpdateStreamMap()
 
       dStream = streamTeletext;
     }
-    else if (stream.iCodecType == XBMC_CODEC_TYPE_SUBTITLE)
+    else if (stream.iCodecType == PVR_CODEC_TYPE_SUBTITLE)
     {
       std::shared_ptr<CDemuxStreamSubtitle> streamSubtitle;
 
@@ -328,7 +328,7 @@ void CInputStreamPVRBase::UpdateStreamMap()
       }
       dStream = streamSubtitle;
     }
-    else if (stream.iCodecType == XBMC_CODEC_TYPE_RDS &&
+    else if (stream.iCodecType == PVR_CODEC_TYPE_RDS &&
              CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool("pvrplayback.enableradiords"))
     {
       std::shared_ptr<CDemuxStreamRadioRDS> streamRadioRDS;
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index f2c2b43900b7..67a72bc4caca 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -1746,16 +1746,16 @@ class CCodecIds
     return _instance;
   }
 
-  xbmc_codec_t GetCodecByName(const char* strCodecName)
+  PVR_CODEC GetCodecByName(const char* strCodecName)
   {
-    xbmc_codec_t retVal = XBMC_INVALID_CODEC;
+    PVR_CODEC retVal = PVR_INVALID_CODEC;
     if (strlen(strCodecName) == 0)
       return retVal;
 
     std::string strUpperCodecName = strCodecName;
     StringUtils::ToUpper(strUpperCodecName);
 
-    std::map<std::string, xbmc_codec_t>::const_iterator it = m_lookup.find(strUpperCodecName);
+    std::map<std::string, PVR_CODEC>::const_iterator it = m_lookup.find(strUpperCodecName);
     if (it != m_lookup.end())
       retVal = it->second;
 
@@ -1768,12 +1768,12 @@ class CCodecIds
     // get ids and names
     const AVCodec* codec = nullptr;
     void* i = nullptr;
-    xbmc_codec_t tmp;
+    PVR_CODEC tmp;
     while ((codec = av_codec_iterate(&i)))
     {
       if (av_codec_is_decoder(codec))
       {
-        tmp.codec_type = (xbmc_codec_type_t)codec->type;
+        tmp.codec_type = static_cast<PVR_CODEC_TYPE>(codec->type);
         tmp.codec_id = codec->id;
 
         std::string strUpperCodecName = codec->name;
@@ -1784,20 +1784,20 @@ class CCodecIds
     }
 
     // teletext is not returned by av_codec_next. we got our own decoder
-    tmp.codec_type = XBMC_CODEC_TYPE_SUBTITLE;
+    tmp.codec_type = PVR_CODEC_TYPE_SUBTITLE;
     tmp.codec_id = AV_CODEC_ID_DVB_TELETEXT;
     m_lookup.insert(std::make_pair("TELETEXT", tmp));
 
     // rds is not returned by av_codec_next. we got our own decoder
-    tmp.codec_type = XBMC_CODEC_TYPE_RDS;
+    tmp.codec_type = PVR_CODEC_TYPE_RDS;
     tmp.codec_id = AV_CODEC_ID_NONE;
     m_lookup.insert(std::make_pair("RDS", tmp));
   }
 
-  std::map<std::string, xbmc_codec_t> m_lookup;
+  std::map<std::string, PVR_CODEC> m_lookup;
 };
 
-xbmc_codec_t CPVRClient::cb_get_codec_by_name(const void* kodiInstance, const char* strCodecName)
+PVR_CODEC CPVRClient::cb_get_codec_by_name(const void* kodiInstance, const char* strCodecName)
 {
   return CCodecIds::GetInstance().GetCodecByName(strCodecName);
 }
diff --git a/xbmc/pvr/addons/PVRClient.h b/xbmc/pvr/addons/PVRClient.h
index 9670a513dbfd..efba5ef3c69b 100644
--- a/xbmc/pvr/addons/PVRClient.h
+++ b/xbmc/pvr/addons/PVRClient.h
@@ -1123,7 +1123,7 @@ namespace PVR
     /*! @todo remove the use complete from them, or add as generl function?!
      * Returns the ffmpeg codec id from given ffmpeg codec string name
      */
-    static xbmc_codec_t cb_get_codec_by_name(const void* kodiInstance, const char* strCodecName);
+    static PVR_CODEC cb_get_codec_by_name(const void* kodiInstance, const char* strCodecName);
     //@}
 
     std::atomic<bool> m_bReadyToUse; /*!< true if this add-on is initialised (ADDON_Create returned true), false otherwise */

From 2648743a1bf89f5d4af1977c17b5458c77dfa1d2 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Sun, 3 May 2020 14:37:16 +0200
Subject: [PATCH 09/27] [addons][pvr] move xbmc_pvr_types.h to
 addon-instance/PVR.h

This done to have them on final place.
---
 .../include/kodi/addon-instance/CMakeLists.txt              | 1 +
 .../include/kodi/{xbmc_pvr_types.h => addon-instance/PVR.h} | 6 +++---
 xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h   | 2 +-
 xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h      | 3 +--
 xbmc/pvr/PVREdl.cpp                                         | 2 +-
 xbmc/pvr/PVRManager.h                                       | 2 +-
 xbmc/pvr/PVRStreamProperties.cpp                            | 2 +-
 xbmc/pvr/addons/PVRClient.h                                 | 2 +-
 xbmc/pvr/addons/PVRClientMenuHooks.cpp                      | 2 +-
 xbmc/pvr/addons/PVRClients.h                                | 2 +-
 xbmc/pvr/channels/PVRChannel.h                              | 2 +-
 xbmc/pvr/channels/PVRChannelGroup.cpp                       | 2 +-
 xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h                | 2 +-
 xbmc/pvr/epg/Epg.h                                          | 2 +-
 xbmc/pvr/epg/EpgContainer.h                                 | 2 +-
 xbmc/pvr/epg/EpgInfoTag.cpp                                 | 2 +-
 xbmc/pvr/epg/EpgSearchData.h                                | 2 +-
 xbmc/pvr/epg/EpgTagsContainer.cpp                           | 2 +-
 xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h                        | 2 +-
 xbmc/pvr/recordings/PVRRecording.cpp                        | 2 +-
 xbmc/pvr/timers/PVRTimerType.h                              | 2 +-
 21 files changed, 23 insertions(+), 23 deletions(-)
 rename xbmc/addons/kodi-addon-dev-kit/include/kodi/{xbmc_pvr_types.h => addon-instance/PVR.h} (99%)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/CMakeLists.txt
index 9e3646be0e7f..8fa6e0542bb5 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/CMakeLists.txt
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/CMakeLists.txt
@@ -5,6 +5,7 @@ set(HEADERS AudioDecoder.h
             Inputstream.h
             Peripheral.h
             PeripheralUtils.h
+            PVR.h
             Screensaver.h
             VFS.h
             VideoCodec.h
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
similarity index 99%
rename from xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
rename to xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index a558fe676cdb..dd9aa8b986a8 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -8,11 +8,11 @@
 
 #pragma once
 
-#include "AddonBase.h"
+#include "../AddonBase.h"
 
 #ifdef BUILD_KODI_ADDON
-#include "DemuxPacket.h"
-#include "InputStreamConstants.h"
+#include "../DemuxPacket.h"
+#include "../InputStreamConstants.h"
 #else
 #include "cores/VideoPlayer/Interface/Addon/DemuxPacket.h"
 #include "cores/VideoPlayer/Interface/Addon/InputStreamConstants.h"
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
index 81263658636d..10ba9d99b95a 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
@@ -13,7 +13,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
-#include "xbmc_pvr_types.h"
+#include "addon-instance/PVR.h"
 #include "libXBMC_addon.h"
 
 #define DVD_TIME_BASE 1000000
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index a2ef674e9363..b7388c0dfdfd 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -113,8 +113,7 @@
 #define ADDON_INSTANCE_VERSION_PVR                    "6.5.2"
 #define ADDON_INSTANCE_VERSION_PVR_MIN                "6.5.1"
 #define ADDON_INSTANCE_VERSION_PVR_XML_ID             "kodi.binary.instance.pvr"
-#define ADDON_INSTANCE_VERSION_PVR_DEPENDS            "xbmc_pvr_types.h" \
-                                                      "libXBMC_pvr.h"
+#define ADDON_INSTANCE_VERSION_PVR_DEPENDS            "addon-instance/PVR.h"
 
 #define ADDON_INSTANCE_VERSION_SCREENSAVER            "2.0.1"
 #define ADDON_INSTANCE_VERSION_SCREENSAVER_MIN        "2.0.1"
diff --git a/xbmc/pvr/PVREdl.cpp b/xbmc/pvr/PVREdl.cpp
index 3213ccc4736e..39aac8199442 100644
--- a/xbmc/pvr/PVREdl.cpp
+++ b/xbmc/pvr/PVREdl.cpp
@@ -9,7 +9,7 @@
 #include "PVREdl.h"
 
 #include "FileItem.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "cores/Cut.h"
 #include "pvr/epg/EpgInfoTag.h"
 #include "pvr/recordings/PVRRecording.h"
diff --git a/xbmc/pvr/PVRManager.h b/xbmc/pvr/PVRManager.h
index c94dd4db543a..a52e09e5573b 100644
--- a/xbmc/pvr/PVRManager.h
+++ b/xbmc/pvr/PVRManager.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "interfaces/IAnnouncer.h"
 #include "pvr/epg/EpgContainer.h"
 #include "pvr/guilib/PVRGUIActionListener.h"
diff --git a/xbmc/pvr/PVRStreamProperties.cpp b/xbmc/pvr/PVRStreamProperties.cpp
index f17494c566f0..cb736fabf4c7 100644
--- a/xbmc/pvr/PVRStreamProperties.cpp
+++ b/xbmc/pvr/PVRStreamProperties.cpp
@@ -8,7 +8,7 @@
 
 #include "PVRStreamProperties.h"
 
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "utils/StringUtils.h"
 
 using namespace PVR;
diff --git a/xbmc/pvr/addons/PVRClient.h b/xbmc/pvr/addons/PVRClient.h
index efba5ef3c69b..2239076f78c1 100644
--- a/xbmc/pvr/addons/PVRClient.h
+++ b/xbmc/pvr/addons/PVRClient.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "addons/binary-addons/AddonDll.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 
 #include <atomic>
 #include <functional>
diff --git a/xbmc/pvr/addons/PVRClientMenuHooks.cpp b/xbmc/pvr/addons/PVRClientMenuHooks.cpp
index 5b8ea83979ff..4a4c7e036d70 100644
--- a/xbmc/pvr/addons/PVRClientMenuHooks.cpp
+++ b/xbmc/pvr/addons/PVRClientMenuHooks.cpp
@@ -8,7 +8,7 @@
 
 #include "PVRClientMenuHooks.h"
 
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "guilib/LocalizeStrings.h"
 #include "pvr/PVRContextMenus.h"
 #include "utils/log.h"
diff --git a/xbmc/pvr/addons/PVRClients.h b/xbmc/pvr/addons/PVRClients.h
index 50288ecd56df..96cd7384152e 100644
--- a/xbmc/pvr/addons/PVRClients.h
+++ b/xbmc/pvr/addons/PVRClients.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "addons/AddonManager.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "threads/CriticalSection.h"
 
 #include <functional>
diff --git a/xbmc/pvr/channels/PVRChannel.h b/xbmc/pvr/channels/PVRChannel.h
index 21464ae757bb..971bcbf70e51 100644
--- a/xbmc/pvr/channels/PVRChannel.h
+++ b/xbmc/pvr/channels/PVRChannel.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "pvr/channels/PVRChannelNumber.h"
 #include "threads/CriticalSection.h"
 #include "utils/ISerializable.h"
diff --git a/xbmc/pvr/channels/PVRChannelGroup.cpp b/xbmc/pvr/channels/PVRChannelGroup.cpp
index 31167975d397..94295ccb31b6 100644
--- a/xbmc/pvr/channels/PVRChannelGroup.cpp
+++ b/xbmc/pvr/channels/PVRChannelGroup.cpp
@@ -11,7 +11,7 @@
 #include "PVRChannelGroup.h"
 
 #include "ServiceBroker.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "pvr/PVRDatabase.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClient.h"
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h b/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
index dcdcf1de4bd6..ae8b65487f57 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
+++ b/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h" // PVR_CHANNEL_INVALID_UID
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h" // PVR_CHANNEL_INVALID_UID
 #include "settings/SettingConditions.h"
 #include "settings/dialogs/GUIDialogSettingsManualBase.h"
 #include "settings/lib/SettingDependency.h"
diff --git a/xbmc/pvr/epg/Epg.h b/xbmc/pvr/epg/Epg.h
index a2225a029396..0ca49d7f387a 100644
--- a/xbmc/pvr/epg/Epg.h
+++ b/xbmc/pvr/epg/Epg.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "XBDateTime.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "pvr/epg/EpgTagsContainer.h"
 #include "threads/CriticalSection.h"
 #include "utils/EventStream.h"
diff --git a/xbmc/pvr/epg/EpgContainer.h b/xbmc/pvr/epg/EpgContainer.h
index 8b1e32beb45f..2edde768fb61 100644
--- a/xbmc/pvr/epg/EpgContainer.h
+++ b/xbmc/pvr/epg/EpgContainer.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "XBDateTime.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "pvr/settings/PVRSettings.h"
 #include "threads/CriticalSection.h"
 #include "threads/Event.h"
diff --git a/xbmc/pvr/epg/EpgInfoTag.cpp b/xbmc/pvr/epg/EpgInfoTag.cpp
index 298c99d4b117..c6b8255e96e3 100644
--- a/xbmc/pvr/epg/EpgInfoTag.cpp
+++ b/xbmc/pvr/epg/EpgInfoTag.cpp
@@ -9,7 +9,7 @@
 #include "EpgInfoTag.h"
 
 #include "ServiceBroker.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "pvr/PVRManager.h"
 #include "pvr/PVRPlaybackState.h"
 #include "pvr/addons/PVRClient.h"
diff --git a/xbmc/pvr/epg/EpgSearchData.h b/xbmc/pvr/epg/EpgSearchData.h
index d663d4fffbdc..df8d965e7480 100644
--- a/xbmc/pvr/epg/EpgSearchData.h
+++ b/xbmc/pvr/epg/EpgSearchData.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "XBDateTime.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 
 #include <string>
 
diff --git a/xbmc/pvr/epg/EpgTagsContainer.cpp b/xbmc/pvr/epg/EpgTagsContainer.cpp
index 8aa9d18bdd26..bb2034e55c9a 100644
--- a/xbmc/pvr/epg/EpgTagsContainer.cpp
+++ b/xbmc/pvr/epg/EpgTagsContainer.cpp
@@ -8,7 +8,7 @@
 
 #include "EpgTagsContainer.h"
 
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "pvr/epg/EpgDatabase.h"
 #include "pvr/epg/EpgInfoTag.h"
 #include "pvr/epg/EpgTagsCache.h"
diff --git a/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h b/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h
index 0a073537ca9e..f06480a9f358 100644
--- a/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h
+++ b/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "guilib/guiinfo/GUIInfoProvider.h"
 #include "pvr/addons/PVRClients.h"
 #include "pvr/guilib/guiinfo/PVRGUITimerInfo.h"
diff --git a/xbmc/pvr/recordings/PVRRecording.cpp b/xbmc/pvr/recordings/PVRRecording.cpp
index a85dbd7a70a9..26f187439b6b 100644
--- a/xbmc/pvr/recordings/PVRRecording.cpp
+++ b/xbmc/pvr/recordings/PVRRecording.cpp
@@ -9,7 +9,7 @@
 #include "PVRRecording.h"
 
 #include "ServiceBroker.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "guilib/LocalizeStrings.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClient.h"
diff --git a/xbmc/pvr/timers/PVRTimerType.h b/xbmc/pvr/timers/PVRTimerType.h
index 4ce960da67fa..a757660a9781 100644
--- a/xbmc/pvr/timers/PVRTimerType.h
+++ b/xbmc/pvr/timers/PVRTimerType.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 
 #include <memory>
 #include <string>

From 8881643ba9638f84aa410d09812ab0a54db4fd90 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Fri, 8 May 2020 15:04:05 +0200
Subject: [PATCH 10/27] [addons][pvr] change to multi instance usage

By them the instance creation way like on addons becomes added.
On next changes becomes his related part added to the PVR
header.
---
 xbmc/addons/AddonBuilder.cpp                  |  3 +-
 xbmc/addons/binary-addons/AddonDll.cpp        | 24 +++++++++++
 xbmc/addons/binary-addons/AddonDll.h          |  5 +++
 .../binary-addons/AddonInstanceHandler.h      |  5 +++
 xbmc/addons/binary-addons/BinaryAddonBase.cpp | 31 +++++++++++++-
 xbmc/addons/binary-addons/BinaryAddonBase.h   | 11 +++--
 xbmc/pvr/addons/PVRClient.cpp                 | 32 ++++-----------
 xbmc/pvr/addons/PVRClient.h                   | 12 ++----
 xbmc/pvr/addons/PVRClients.cpp                | 41 ++++++-------------
 xbmc/pvr/addons/PVRClients.h                  | 10 +----
 10 files changed, 96 insertions(+), 78 deletions(-)

diff --git a/xbmc/addons/AddonBuilder.cpp b/xbmc/addons/AddonBuilder.cpp
index 2754634fb693..39dd3c9eed8e 100644
--- a/xbmc/addons/AddonBuilder.cpp
+++ b/xbmc/addons/AddonBuilder.cpp
@@ -65,12 +65,11 @@ AddonPtr CAddonBuilder::Generate(const AddonInfoPtr& info, TYPE type)
   case ADDON_IMAGEDECODER:
   case ADDON_INPUTSTREAM:
   case ADDON_PERIPHERALDLL:
+  case ADDON_PVRDLL:
   case ADDON_VFS:
   case ADDON_VIZ:
   case ADDON_SCREENSAVER:
     return std::make_shared<CAddonDll>(info, type);
-  case ADDON_PVRDLL:
-    return std::make_shared<PVR::CPVRClient>(info);
   case ADDON_GAMEDLL:
     return std::make_shared<GAME::CGameClient>(info);
   case ADDON_PLUGIN:
diff --git a/xbmc/addons/binary-addons/AddonDll.cpp b/xbmc/addons/binary-addons/AddonDll.cpp
index 97c9130f18a0..e51a0c733896 100644
--- a/xbmc/addons/binary-addons/AddonDll.cpp
+++ b/xbmc/addons/binary-addons/AddonDll.cpp
@@ -337,6 +337,30 @@ AddonPtr CAddonDll::GetRunningInstance() const
   return AddonPtr();
 }
 
+void CAddonDll::OnPreInstall()
+{
+  if (m_binaryAddonBase)
+    m_binaryAddonBase->OnPreInstall();
+}
+
+void CAddonDll::OnPostInstall(bool update, bool modal)
+{
+  if (m_binaryAddonBase)
+    m_binaryAddonBase->OnPostInstall(update, modal);
+}
+
+void CAddonDll::OnPreUnInstall()
+{
+  if (m_binaryAddonBase)
+    m_binaryAddonBase->OnPreUnInstall();
+}
+
+void CAddonDll::OnPostUnInstall()
+{
+  if (m_binaryAddonBase)
+    m_binaryAddonBase->OnPostUnInstall();
+}
+
 bool CAddonDll::DllLoaded(void) const
 {
   return m_pDll != nullptr;
diff --git a/xbmc/addons/binary-addons/AddonDll.h b/xbmc/addons/binary-addons/AddonDll.h
index 602db1ae250f..e1426269d309 100644
--- a/xbmc/addons/binary-addons/AddonDll.h
+++ b/xbmc/addons/binary-addons/AddonDll.h
@@ -102,6 +102,11 @@ class CAddonDll : public CAddon
 
   AddonPtr GetRunningInstance() const override;
 
+  void OnPreInstall() override;
+  void OnPostInstall(bool update, bool modal) override;
+  void OnPreUnInstall() override;
+  void OnPostUnInstall() override;
+
   bool Initialized() const { return m_initialized; }
 
 protected:
diff --git a/xbmc/addons/binary-addons/AddonInstanceHandler.h b/xbmc/addons/binary-addons/AddonInstanceHandler.h
index 8ee9b3062c7c..d293fe400e8a 100644
--- a/xbmc/addons/binary-addons/AddonInstanceHandler.h
+++ b/xbmc/addons/binary-addons/AddonInstanceHandler.h
@@ -39,6 +39,11 @@ namespace ADDON
     const AddonDllPtr& Addon() const { return m_addon; }
     BinaryAddonBasePtr GetAddonBase() const { return m_addonBase; };
 
+    virtual void OnPreInstall() { }
+    virtual void OnPostInstall(bool update, bool modal) { }
+    virtual void OnPreUnInstall() { }
+    virtual void OnPostUnInstall() { }
+
   private:
     ADDON_TYPE m_type;
     std::string m_instanceId;
diff --git a/xbmc/addons/binary-addons/BinaryAddonBase.cpp b/xbmc/addons/binary-addons/BinaryAddonBase.cpp
index a54a2ca711c9..b34ecac5de32 100644
--- a/xbmc/addons/binary-addons/BinaryAddonBase.cpp
+++ b/xbmc/addons/binary-addons/BinaryAddonBase.cpp
@@ -113,7 +113,7 @@ bool CBinaryAddonBase::MeetsVersion(const AddonVersion& versionMin,
   return m_addonInfo->MeetsVersion(versionMin, version);
 }
 
-AddonDllPtr CBinaryAddonBase::GetAddon(const IAddonInstanceHandler* handler)
+AddonDllPtr CBinaryAddonBase::GetAddon(IAddonInstanceHandler* handler)
 {
   if (handler == nullptr)
   {
@@ -133,7 +133,7 @@ AddonDllPtr CBinaryAddonBase::GetAddon(const IAddonInstanceHandler* handler)
   return m_activeAddon;
 }
 
-void CBinaryAddonBase::ReleaseAddon(const IAddonInstanceHandler* handler)
+void CBinaryAddonBase::ReleaseAddon(IAddonInstanceHandler* handler)
 {
   if (handler == nullptr)
   {
@@ -162,3 +162,30 @@ AddonDllPtr CBinaryAddonBase::GetActiveAddon()
   return m_activeAddon;
 }
 
+void CBinaryAddonBase::OnPreInstall()
+{
+  const std::unordered_set<IAddonInstanceHandler*> activeAddonHandlers = m_activeAddonHandlers;
+  for (const auto& instance : activeAddonHandlers)
+    instance->OnPreInstall();
+}
+
+void CBinaryAddonBase::OnPostInstall(bool update, bool modal)
+{
+  const std::unordered_set<IAddonInstanceHandler*> activeAddonHandlers = m_activeAddonHandlers;
+  for (const auto& instance : activeAddonHandlers)
+    instance->OnPostInstall(update, modal);
+}
+
+void CBinaryAddonBase::OnPreUnInstall()
+{
+  const std::unordered_set<IAddonInstanceHandler*> activeAddonHandlers = m_activeAddonHandlers;
+  for (const auto& instance : activeAddonHandlers)
+    instance->OnPreUnInstall();
+}
+
+void CBinaryAddonBase::OnPostUnInstall()
+{
+  const std::unordered_set<IAddonInstanceHandler*> activeAddonHandlers = m_activeAddonHandlers;
+  for (const auto& instance : activeAddonHandlers)
+    instance->OnPostUnInstall();
+}
diff --git a/xbmc/addons/binary-addons/BinaryAddonBase.h b/xbmc/addons/binary-addons/BinaryAddonBase.h
index 1387f12700db..e86d43c2ee13 100644
--- a/xbmc/addons/binary-addons/BinaryAddonBase.h
+++ b/xbmc/addons/binary-addons/BinaryAddonBase.h
@@ -53,17 +53,22 @@ namespace ADDON
 
     bool MeetsVersion(const AddonVersion& versionMin, const AddonVersion& version) const;
 
-    AddonDllPtr GetAddon(const IAddonInstanceHandler* handler);
-    void ReleaseAddon(const IAddonInstanceHandler* handler);
+    AddonDllPtr GetAddon(IAddonInstanceHandler* handler);
+    void ReleaseAddon(IAddonInstanceHandler* handler);
 
     AddonDllPtr GetActiveAddon();
 
+    void OnPreInstall();
+    void OnPostInstall(bool update, bool modal);
+    void OnPreUnInstall();
+    void OnPostUnInstall();
+
   private:
     AddonInfoPtr m_addonInfo;
 
     CCriticalSection m_critSection;
     AddonDllPtr m_activeAddon;
-    std::unordered_set<const IAddonInstanceHandler*> m_activeAddonHandlers;
+    std::unordered_set<IAddonInstanceHandler*> m_activeAddonHandlers;
   };
 
 } /* namespace ADDON */
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index 67a72bc4caca..bd6542ba286a 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -56,8 +56,8 @@ namespace PVR
 
 #define DEFAULT_INFO_STRING_VALUE "unknown"
 
-CPVRClient::CPVRClient(const AddonInfoPtr& addonInfo)
-  : CAddonDll(addonInfo, ADDON_PVRDLL)
+CPVRClient::CPVRClient(ADDON::BinaryAddonBasePtr addonBase)
+  : IAddonInstanceHandler(ADDON_INSTANCE_PVR, addonBase)
 {
   // Create all interface parts independent to make API changes easier if
   // something is added
@@ -79,33 +79,20 @@ CPVRClient::~CPVRClient()
 
 void CPVRClient::StopRunningInstance()
 {
-  const ADDON::AddonPtr addon(GetRunningInstance());
-  if (addon)
-  {
-    // stop the pvr manager and stop and unload the running pvr addon. pvr manager will be restarted on demand.
-    CServiceBroker::GetPVRManager().Stop();
-    CServiceBroker::GetPVRManager().Clients()->StopClient(addon->ID(), false);
-  }
+  // stop the pvr manager and stop and unload the running pvr addon. pvr manager will be restarted on demand.
+  CServiceBroker::GetPVRManager().Stop();
+  CServiceBroker::GetPVRManager().Clients()->StopClient(ID(), false);
 }
 
 void CPVRClient::OnPreInstall()
 {
   // note: this method is also called on update; thus stop and unload possibly running instance
   StopRunningInstance();
-  CAddon::OnPreInstall();
 }
 
 void CPVRClient::OnPreUnInstall()
 {
   StopRunningInstance();
-  CAddon::OnPreUnInstall();
-}
-
-ADDON::AddonPtr CPVRClient::GetRunningInstance() const
-{
-  ADDON::AddonPtr addon;
-  CServiceBroker::GetPVRManager().Clients()->GetClient(ID(), addon);
-  return addon;
 }
 
 void CPVRClient::ResetProperties(int iClientId /* = PVR_INVALID_CLIENT_ID */)
@@ -173,18 +160,13 @@ ADDON_STATUS CPVRClient::Create(int iClientId)
   /* initialise the add-on */
   bool bReadyToUse(false);
   CLog::LogFC(LOGDEBUG, LOGPVR, "Creating PVR add-on instance '%s'", Name().c_str());
-  if ((status = CAddonDll::Create(ADDON_INSTANCE_PVR, &m_struct, m_struct.props)) == ADDON_STATUS_OK)
+  if ((status = CreateInstance(&m_struct)) == ADDON_STATUS_OK)
     bReadyToUse = GetAddonProperties();
 
   m_bReadyToUse = bReadyToUse;
   return status;
 }
 
-bool CPVRClient::DllLoaded() const
-{
-  return CAddonDll::DllLoaded();
-}
-
 void CPVRClient::Destroy()
 {
   if (!m_bReadyToUse)
@@ -196,7 +178,7 @@ void CPVRClient::Destroy()
   CLog::LogFC(LOGDEBUG, LOGPVR, "Destroying PVR add-on instance '%s'", GetFriendlyName().c_str());
 
   /* destroy the add-on */
-  CAddonDll::Destroy();
+  DestroyInstance();
 
   if (m_menuhooks)
     m_menuhooks->Clear();
diff --git a/xbmc/pvr/addons/PVRClient.h b/xbmc/pvr/addons/PVRClient.h
index 2239076f78c1..3f5b24125ab5 100644
--- a/xbmc/pvr/addons/PVRClient.h
+++ b/xbmc/pvr/addons/PVRClient.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/binary-addons/AddonDll.h"
+#include "addons/binary-addons/AddonInstanceHandler.h"
 #include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 
 #include <atomic>
@@ -221,15 +221,14 @@ namespace PVR
    *
    * Also translates Kodi's C++ structures to the add-on's C structures.
    */
-  class CPVRClient : public ADDON::CAddonDll
+  class CPVRClient : public ADDON::IAddonInstanceHandler
   {
   public:
-    explicit CPVRClient(const ADDON::AddonInfoPtr& addonInfo);
+    explicit CPVRClient(ADDON::BinaryAddonBasePtr addonBase);
     ~CPVRClient() override;
 
     void OnPreInstall() override;
     void OnPreUnInstall() override;
-    ADDON::AddonPtr GetRunningInstance() const override;
 
     /** @name PVR add-on methods */
     //@{
@@ -240,11 +239,6 @@ namespace PVR
      */
     ADDON_STATUS Create(int iClientId);
 
-    /*!
-     * @return True when the dll for this add-on was loaded, false otherwise (e.g. unresolved symbols)
-     */
-    bool DllLoaded() const;
-
     /*!
      * @brief Stop this add-on instance. No more client add-on access after this call.
      */
diff --git a/xbmc/pvr/addons/PVRClients.cpp b/xbmc/pvr/addons/PVRClients.cpp
index 971655fea1b4..4fe8222bec65 100644
--- a/xbmc/pvr/addons/PVRClients.cpp
+++ b/xbmc/pvr/addons/PVRClients.cpp
@@ -9,7 +9,7 @@
 #include "PVRClients.h"
 
 #include "ServiceBroker.h"
-#include "addons/BinaryAddonCache.h"
+#include "addons/binary-addons/BinaryAddonBase.h"
 #include "guilib/LocalizeStrings.h"
 #include "messaging/ApplicationMessenger.h"
 #include "pvr/PVREventLogJob.h"
@@ -85,17 +85,17 @@ void CPVRClients::Continue()
 
 void CPVRClients::UpdateAddons(const std::string& changedAddonId /*= ""*/)
 {
-  VECADDONS addons;
-  CServiceBroker::GetAddonMgr().GetInstalledAddons(addons, ADDON_PVRDLL);
+  BinaryAddonBaseList addons;
+  CServiceBroker::GetBinaryAddonManager().GetAddonInfos(addons, false, ADDON_PVRDLL);
 
   if (addons.empty())
     return;
 
   bool bFoundChangedAddon = changedAddonId.empty();
-  std::vector<std::pair<AddonPtr, bool>> addonsWithStatus;
-  for (const auto& addon : addons)
+  std::vector<std::pair<BinaryAddonBasePtr, bool>> addonsWithStatus;
+  for (const auto &addon : addons)
   {
-    bool bEnabled = !CServiceBroker::GetAddonMgr().IsAddonDisabled(addon->ID());
+    bool bEnabled = CServiceBroker::GetBinaryAddonManager().IsAddonEnabled(addon->ID());
     addonsWithStatus.emplace_back(std::make_pair(addon, bEnabled));
 
     if (!bFoundChangedAddon && addon->ID() == changedAddonId)
@@ -108,14 +108,14 @@ void CPVRClients::UpdateAddons(const std::string& changedAddonId /*= ""*/)
   addons.clear();
 
   std::vector<std::pair<std::shared_ptr<CPVRClient>, int>> addonsToCreate;
-  std::vector<AddonPtr> addonsToReCreate;
-  std::vector<AddonPtr> addonsToDestroy;
+  std::vector<BinaryAddonBasePtr> addonsToReCreate;
+  std::vector<BinaryAddonBasePtr> addonsToDestroy;
 
   {
     CSingleLock lock(m_critSection);
     for (const auto& addonWithStatus : addonsWithStatus)
     {
-      AddonPtr addon = addonWithStatus.first;
+      BinaryAddonBasePtr addon = addonWithStatus.first;
       bool bEnabled = addonWithStatus.second;
 
       if (bEnabled && (!IsKnownClient(addon->ID()) || !IsCreatedClient(addon->ID())))
@@ -129,7 +129,7 @@ void CPVRClients::UpdateAddons(const std::string& changedAddonId /*= ""*/)
         }
         else
         {
-          client = std::dynamic_pointer_cast<CPVRClient>(addon);
+          client = std::make_shared<CPVRClient>(addon);
           if (!client)
           {
             CLog::LogF(LOGERROR, "Severe error, incorrect add-on type");
@@ -254,20 +254,6 @@ void CPVRClients::OnAddonEvent(const AddonEvent& event)
 // client access
 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
-bool CPVRClients::GetClient(const std::string& strId, AddonPtr& addon) const
-{
-  CSingleLock lock(m_critSection);
-  for (const auto& client : m_clientMap)
-  {
-    if (client.second->ID() == strId)
-    {
-      addon = client.second;
-      return true;
-    }
-  }
-  return false;
-}
-
 bool CPVRClients::GetClient(int iClientId, std::shared_ptr<CPVRClient>& addon) const
 {
   bool bReturn = false;
@@ -337,7 +323,7 @@ bool CPVRClients::IsCreatedClient(int iClientId) const
   return GetCreatedClient(iClientId, client);
 }
 
-bool CPVRClients::IsCreatedClient(const std::string& id)
+bool CPVRClients::IsCreatedClient(const std::string& id) const
 {
   CSingleLock lock(m_critSection);
   for (const auto& client : m_clientMap)
@@ -377,9 +363,8 @@ PVR_ERROR CPVRClients::GetCreatedClients(CPVRClientMap& clientsReady, std::vecto
 {
   clientsNotReady.clear();
 
-  VECADDONS addons;
-  CBinaryAddonCache& addonCache = CServiceBroker::GetBinaryAddonCache();
-  addonCache.GetAddons(addons, ADDON::ADDON_PVRDLL);
+  BinaryAddonBaseList addons;
+  CServiceBroker::GetBinaryAddonManager().GetAddonInfos(addons, true, ADDON::ADDON_PVRDLL);
 
   for (const auto& addon : addons)
   {
diff --git a/xbmc/pvr/addons/PVRClients.h b/xbmc/pvr/addons/PVRClients.h
index 96cd7384152e..56a1a19d89b9 100644
--- a/xbmc/pvr/addons/PVRClients.h
+++ b/xbmc/pvr/addons/PVRClients.h
@@ -101,14 +101,6 @@ namespace PVR
      */
     void OnAddonEvent(const ADDON::AddonEvent& event);
 
-    /*!
-     * @brief Get a client given its ID.
-     * @param strId The ID of the client.
-     * @param addon On success, filled with the client matching the given ID, null otherwise.
-     * @return True if the client was found, false otherwise.
-     */
-    bool GetClient(const std::string& strId, ADDON::AddonPtr& addon) const;
-
     /*!
      * @brief Get a client's numeric ID given its string ID.
      * @param strId The string ID.
@@ -344,7 +336,7 @@ namespace PVR
      * @param id The addon id.
      * @return True if the the addon represents a created client, false otherwise.
      */
-    bool IsCreatedClient(const std::string& id);
+    bool IsCreatedClient(const std::string& id) const;
 
     /*!
      * @brief Get all created clients and clients not (yet) ready to use.

From 7069486fc7c25f1519fd8165f3e1d24091b4e1ac Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 8 Jun 2020 13:27:42 +0200
Subject: [PATCH 11/27] [addons] remove old interface code (no more needed
 anymore)

This cleanup the whole binary addon interface and kickout
all old no more used parts.

This change does nothing destroy on the current addons, as this
was only used by PVR system.

There comes a separate request after everything is done where
no more needed basic "C" functions becomes removed, but that
is related all addons and need complete update!
---
 cmake/treedata/common/subdirs.txt             |    1 -
 xbmc/addons/AddonBindings.cmake               |    1 -
 xbmc/addons/binary-addons/AddonDll.cpp        |   62 -
 xbmc/addons/binary-addons/AddonDll.h          |   12 +-
 .../interfaces/Addon/AddonCallbacksAddon.cpp  |  704 -------
 .../interfaces/Addon/AddonCallbacksAddon.h    |   94 -
 xbmc/addons/interfaces/Addon/CMakeLists.txt   |    5 -
 xbmc/addons/interfaces/AddonInterfaces.cpp    |  151 --
 xbmc/addons/interfaces/AddonInterfaces.h      |   67 -
 xbmc/addons/interfaces/CMakeLists.txt         |    2 -
 .../interfaces/gui/AddonCallbacksGUI.cpp      | 1863 -----------------
 .../addons/interfaces/gui/AddonCallbacksGUI.h |  170 --
 .../gui/AddonGUIRenderingControl.cpp          |   78 -
 .../interfaces/gui/AddonGUIRenderingControl.h |   44 -
 xbmc/addons/interfaces/gui/AddonGUIWindow.cpp |  343 ---
 xbmc/addons/interfaces/gui/AddonGUIWindow.h   |   95 -
 xbmc/addons/interfaces/gui/CMakeLists.txt     |   10 +-
 .../include/kodi/CMakeLists.txt               |    7 +-
 .../include/kodi/libKODI_guilib.h             | 1172 -----------
 .../include/kodi/libXBMC_addon.h              |  570 -----
 .../include/kodi/libXBMC_pvr.h                |  243 ---
 .../include/kodi/versions.h                   |    4 +-
 .../include/kodi/xbmc_addon_dll.h             |   33 -
 xbmc/guilib/GUIWindowManager.cpp              |    4 +-
 24 files changed, 13 insertions(+), 5722 deletions(-)
 delete mode 100644 xbmc/addons/interfaces/Addon/AddonCallbacksAddon.cpp
 delete mode 100644 xbmc/addons/interfaces/Addon/AddonCallbacksAddon.h
 delete mode 100644 xbmc/addons/interfaces/Addon/CMakeLists.txt
 delete mode 100644 xbmc/addons/interfaces/AddonInterfaces.cpp
 delete mode 100644 xbmc/addons/interfaces/AddonInterfaces.h
 delete mode 100644 xbmc/addons/interfaces/gui/AddonCallbacksGUI.cpp
 delete mode 100644 xbmc/addons/interfaces/gui/AddonCallbacksGUI.h
 delete mode 100644 xbmc/addons/interfaces/gui/AddonGUIRenderingControl.cpp
 delete mode 100644 xbmc/addons/interfaces/gui/AddonGUIRenderingControl.h
 delete mode 100644 xbmc/addons/interfaces/gui/AddonGUIWindow.cpp
 delete mode 100644 xbmc/addons/interfaces/gui/AddonGUIWindow.h
 delete mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_guilib.h
 delete mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h
 delete mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
 delete mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_addon_dll.h

diff --git a/cmake/treedata/common/subdirs.txt b/cmake/treedata/common/subdirs.txt
index f48fdfb7703b..15ed9c5046d6 100644
--- a/cmake/treedata/common/subdirs.txt
+++ b/cmake/treedata/common/subdirs.txt
@@ -3,7 +3,6 @@ xbmc/addons                                     addons
 xbmc/addons/addoninfo                           addons_addoninfo
 xbmc/addons/binary-addons                       addons_binary-addons
 xbmc/addons/interfaces                          addons_interfaces
-xbmc/addons/interfaces/Addon                    addons_interfaces_addon
 xbmc/addons/interfaces/gui                      addons_interfaces_gui
 xbmc/addons/interfaces/gui/controls             addons_interfaces_gui_controls
 xbmc/addons/interfaces/gui/dialogs              addons_interfaces_gui_dialogs
diff --git a/xbmc/addons/AddonBindings.cmake b/xbmc/addons/AddonBindings.cmake
index 53a980173a9d..7fb5aba17fc2 100644
--- a/xbmc/addons/AddonBindings.cmake
+++ b/xbmc/addons/AddonBindings.cmake
@@ -5,7 +5,6 @@
 # Keep this in alphabetical order
 set(CORE_ADDON_BINDINGS_FILES
     ${CORE_SOURCE_DIR}/xbmc/cores/AudioEngine/Utils/AEChannelData.h
-    ${CORE_SOURCE_DIR}/xbmc/filesystem/IFileTypes.h
     ${CORE_SOURCE_DIR}/xbmc/input/actions/ActionIDs.h
     ${CORE_SOURCE_DIR}/xbmc/input/XBMC_vkeys.h
 )
diff --git a/xbmc/addons/binary-addons/AddonDll.cpp b/xbmc/addons/binary-addons/AddonDll.cpp
index e51a0c733896..e1ed9e94108d 100644
--- a/xbmc/addons/binary-addons/AddonDll.cpp
+++ b/xbmc/addons/binary-addons/AddonDll.cpp
@@ -151,66 +151,6 @@ bool CAddonDll::LoadDll()
   return true;
 }
 
-ADDON_STATUS CAddonDll::Create(ADDON_TYPE type, void* funcTable, void* info)
-{
-  /* ensure that a previous instance is destroyed */
-  Destroy();
-
-  if (!funcTable)
-    return ADDON_STATUS_PERMANENT_FAILURE;
-
-  CLog::Log(LOGDEBUG, "ADDON: Dll Initializing - %s", Name().c_str());
-  m_initialized = false;
-
-  if (!LoadDll())
-    return ADDON_STATUS_PERMANENT_FAILURE;
-
-  /* Check requested instance version on add-on */
-  if (!CheckAPIVersion(type))
-    return ADDON_STATUS_PERMANENT_FAILURE;
-
-  /* Check versions about global parts on add-on (parts used on all types) */
-  for (unsigned int id = ADDON_GLOBAL_MAIN; id <= ADDON_GLOBAL_MAX; ++id)
-  {
-    if (!CheckAPIVersion(id))
-      return ADDON_STATUS_PERMANENT_FAILURE;
-  }
-
-  /* Load add-on function table (written by add-on itself) */
-  m_pDll->GetAddon(funcTable);
-
-  /* Allocate the helper function class to allow crosstalk over
-     helper libraries */
-  m_pHelpers = new CAddonInterfaces(this);
-
-  /* Call Create to make connections, initializing data or whatever is
-     needed to become the AddOn running */
-  ADDON_STATUS status = m_pDll->Create(m_pHelpers->GetCallbacks(),
-                                       kodi::addon::GetTypeVersion(ADDON_GLOBAL_MAIN), info);
-
-  if (status == ADDON_STATUS_OK)
-  {
-    m_initialized = true;
-  }
-  else if (status == ADDON_STATUS_NEED_SETTINGS)
-  {
-    status = TransferSettings();
-    if (status == ADDON_STATUS_OK)
-      m_initialized = true;
-    else
-      new CAddonStatusHandler(ID(), status, "", false);
-  }
-  else
-  { // Addon failed initialization
-    CLog::Log(LOGERROR, "ADDON: Dll %s - Client returned bad status (%i) from Create and is not usable", Name().c_str(), status);
-
-    std::string heading = StringUtils::Format("%s: %s", CAddonInfo::TranslateType(Type(), true).c_str(), Name().c_str());
-    HELPERS::ShowOKDialogLines(CVariant{ heading }, CVariant{ 24070 }, CVariant{ 24071 });
-  }
-
-  return status;
-}
-
 ADDON_STATUS CAddonDll::Create(KODI_HANDLE firstKodiInstance)
 {
   CLog::Log(LOGDEBUG, "ADDON: Dll Initializing - %s", Name().c_str());
@@ -272,8 +212,6 @@ void CAddonDll::Destroy()
 
   Interface_Base::DeInitInterface(m_interface);
 
-  delete m_pHelpers;
-  m_pHelpers = nullptr;
   if (m_pDll)
   {
     delete m_pDll;
diff --git a/xbmc/addons/binary-addons/AddonDll.h b/xbmc/addons/binary-addons/AddonDll.h
index e1426269d309..291cf2dcfb58 100644
--- a/xbmc/addons/binary-addons/AddonDll.h
+++ b/xbmc/addons/binary-addons/AddonDll.h
@@ -11,7 +11,6 @@
 #include "BinaryAddonManager.h"
 #include "DllAddon.h"
 #include "addons/Addon.h"
-#include "addons/interfaces/AddonInterfaces.h"
 #include "utils/XMLUtils.h"
 
 // Global addon callback handle classes
@@ -46,9 +45,6 @@ class CAddonDll : public CAddon
   // addon settings
   void SaveSettings() override;
 
-  ADDON_STATUS Create(ADDON_TYPE type, void* funcTable, void* info);
-  void Destroy();
-
   bool DllLoaded(void) const;
 
   /*!
@@ -112,7 +108,6 @@ class CAddonDll : public CAddon
 protected:
   static std::string GetDllPath(const std::string& strFileName);
 
-  CAddonInterfaces* m_pHelpers = nullptr;
   std::string m_parentLib;
 
 private:
@@ -132,6 +127,13 @@ class CAddonDll : public CAddon
    */
   ADDON_STATUS Create(KODI_HANDLE firstKodiInstance);
 
+  /*!
+   * @brief Main addon destroying call function
+   *
+   * This becomes called only one time after the last addon instance becomes destroyed.
+   */
+  void Destroy();
+
   bool CheckAPIVersion(int type);
 
   BinaryAddonBasePtr m_binaryAddonBase = nullptr;
diff --git a/xbmc/addons/interfaces/Addon/AddonCallbacksAddon.cpp b/xbmc/addons/interfaces/Addon/AddonCallbacksAddon.cpp
deleted file mode 100644
index bf4fbcb614ad..000000000000
--- a/xbmc/addons/interfaces/Addon/AddonCallbacksAddon.cpp
+++ /dev/null
@@ -1,704 +0,0 @@
-/*
- *  Copyright (C) 2012-2018 Team Kodi
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-#include "addons/Addon.h"
-
-#include "AddonCallbacksAddon.h"
-#include "Application.h"
-#include "FileItem.h"
-#include "LangInfo.h"
-#include "ServiceBroker.h"
-#include "addons/settings/AddonSettings.h"
-#include "dialogs/GUIDialogKaiToast.h"
-#include "filesystem/Directory.h"
-#include "filesystem/File.h"
-#include "filesystem/SpecialProtocol.h"
-#include "guilib/LocalizeStrings.h"
-#include "network/Network.h"
-#include "utils/CharsetConverter.h"
-#include "utils/StringUtils.h"
-#include "utils/XMLUtils.h"
-#include "utils/log.h"
-
-#include <vector>
-
-using namespace ADDON;
-using namespace XFILE;
-
-namespace KodiAPI
-{
-namespace AddOn
-{
-
-CAddonCallbacksAddon::CAddonCallbacksAddon(CAddon* addon)
-  : m_addon(addon),
-    m_callbacks(new CB_AddOnLib)
-{
-  /* write XBMC addon-on specific add-on function addresses to the callback table */
-  m_callbacks->Log                = AddOnLog;
-  m_callbacks->QueueNotification  = QueueNotification;
-  m_callbacks->WakeOnLan          = WakeOnLan;
-  m_callbacks->GetSetting         = GetAddonSetting;
-  m_callbacks->TranslateSpecialProtocol = TranslateSpecialProtocol;
-  m_callbacks->UnknownToUTF8      = UnknownToUTF8;
-  m_callbacks->GetLocalizedString = GetLocalizedString;
-  m_callbacks->GetDVDMenuLanguage = GetDVDMenuLanguage;
-  m_callbacks->FreeString         = FreeString;
-  m_callbacks->FreeStringArray    = FreeStringArray;
-
-  m_callbacks->OpenFile           = OpenFile;
-  m_callbacks->OpenFileForWrite   = OpenFileForWrite;
-  m_callbacks->ReadFile           = ReadFile;
-  m_callbacks->ReadFileString     = ReadFileString;
-  m_callbacks->WriteFile          = WriteFile;
-  m_callbacks->FlushFile          = FlushFile;
-  m_callbacks->SeekFile           = SeekFile;
-  m_callbacks->TruncateFile       = TruncateFile;
-  m_callbacks->GetFilePosition    = GetFilePosition;
-  m_callbacks->GetFileLength      = GetFileLength;
-  m_callbacks->GetFileDownloadSpeed = GetFileDownloadSpeed;
-  m_callbacks->CloseFile          = CloseFile;
-  m_callbacks->GetFileChunkSize   = GetFileChunkSize;
-  m_callbacks->FileExists         = FileExists;
-  m_callbacks->StatFile           = StatFile;
-  m_callbacks->GetFilePropertyValue = GetFilePropertyValue;
-  m_callbacks->GetFilePropertyValues = GetFilePropertyValues;
-  m_callbacks->DeleteFile         = DeleteFile;
-
-  m_callbacks->CanOpenDirectory   = CanOpenDirectory;
-  m_callbacks->CreateDirectory    = CreateDirectory;
-  m_callbacks->DirectoryExists    = DirectoryExists;
-  m_callbacks->RemoveDirectory    = RemoveDirectory;
-  m_callbacks->GetDirectory       = GetDirectory;
-  m_callbacks->FreeDirectory      = FreeDirectory;
-
-  m_callbacks->CURLCreate         = CURLCreate;
-  m_callbacks->CURLAddOption      = CURLAddOption;
-  m_callbacks->CURLOpen           = CURLOpen;
-}
-
-CAddonCallbacksAddon::~CAddonCallbacksAddon()
-{
-  /* delete the callback table */
-  delete m_callbacks;
-}
-
-void CAddonCallbacksAddon::AddOnLog(void *addonData, const int addonLogLevel, const char *strMessage)
-{
-  CAddonInterfaces* addon = (CAddonInterfaces*) addonData;
-  if (addon == NULL || strMessage == NULL)
-  {
-    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - called with a null pointer", __FUNCTION__);
-    return;
-  }
-
-  CAddonCallbacksAddon* addonHelper = static_cast<CAddonCallbacksAddon*>(addon->AddOnLib_GetHelper());
-
-  try
-  {
-    int xbmcLogLevel;
-    switch (addonLogLevel)
-    {
-      case LOG_DEBUG:
-        xbmcLogLevel = LOGDEBUG;
-        break;
-      case LOG_INFO:
-        xbmcLogLevel = LOGINFO;
-        break;
-      case LOG_WARNING:
-        xbmcLogLevel = LOGWARNING;
-        break;
-      case LOG_ERROR:
-        xbmcLogLevel = LOGERROR;
-        break;
-      case LOG_FATAL:
-        xbmcLogLevel = LOGFATAL;
-        break;
-      default:
-        xbmcLogLevel = LOGDEBUG;
-        break;
-    }
-
-    std::string strXbmcMessage = StringUtils::Format("AddOnLog: %s: %s", addonHelper->m_addon->Name().c_str(), strMessage);
-    CLog::Log(xbmcLogLevel, "%s", strXbmcMessage.c_str());
-  }
-  catch (std::exception &e)
-  {
-    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - exception '%s' caught in call in add-on '%s'. please contact the developer of this addon: %s",
-        __FUNCTION__, e.what(), addonHelper->m_addon->Name().c_str(), addonHelper->m_addon->Author().c_str());
-  }
-}
-
-void CAddonCallbacksAddon::QueueNotification(void *addonData, const int type, const char *strMessage)
-{
-  CAddonInterfaces* addon = (CAddonInterfaces*) addonData;
-  if (addon == NULL || strMessage == NULL)
-  {
-    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - called with a null pointer", __FUNCTION__);
-    return;
-  }
-
-  CAddonCallbacksAddon* addonHelper = static_cast<CAddonCallbacksAddon*>(addon->AddOnLib_GetHelper());
-
-  try
-  {
-    switch (type)
-    {
-      case QUEUE_WARNING:
-        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Warning, addonHelper->m_addon->Name(), strMessage, 3000, true);
-        CLog::Log(LOGDEBUG, "CAddonCallbacksAddon - %s - %s - Warning Message: '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str(), strMessage);
-        break;
-
-      case QUEUE_ERROR:
-        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, addonHelper->m_addon->Name(), strMessage, 3000, true);
-        CLog::Log(LOGDEBUG, "CAddonCallbacksAddon - %s - %s - Error Message : '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str(), strMessage);
-        break;
-
-      case QUEUE_INFO:
-      default:
-        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, addonHelper->m_addon->Name(), strMessage, 3000, false);
-        CLog::Log(LOGDEBUG, "CAddonCallbacksAddon - %s - %s - Info Message : '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str(), strMessage);
-        break;
-    }
-  }
-  catch (std::exception &e)
-  {
-    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - exception '%s' caught in call in add-on '%s'. please contact the developer of this addon: %s",
-        __FUNCTION__, e.what(), addonHelper->m_addon->Name().c_str(), addonHelper->m_addon->Author().c_str());
-  }
-}
-
-bool CAddonCallbacksAddon::WakeOnLan(const char *mac)
-{
-  return CServiceBroker::GetNetwork().WakeOnLan(mac);
-}
-
-bool CAddonCallbacksAddon::GetAddonSetting(void *addonData, const char *strSettingName, void *settingValue)
-{
-  CAddonInterfaces* addon = (CAddonInterfaces*) addonData;
-  if (addon == NULL || strSettingName == NULL || settingValue == NULL)
-  {
-    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - called with a null pointer", __FUNCTION__);
-    return false;
-  }
-
-  CAddonCallbacksAddon* addonHelper = static_cast<CAddonCallbacksAddon*>(addon->AddOnLib_GetHelper());
-
-  try
-  {
-    CLog::Log(LOGDEBUG, "CAddonCallbacksAddon - %s - add-on '%s' requests setting '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str(), strSettingName);
-
-    if (StringUtils::CompareNoCase(strSettingName, "__addonpath__") == 0)
-    {
-      strcpy((char*) settingValue, addonHelper->m_addon->Path().c_str());
-      return true;
-    }
-    else if (StringUtils::CompareNoCase(strSettingName, "__addonname__") == 0)
-    {
-      strcpy((char*)settingValue, addonHelper->m_addon->Name().c_str());
-      return true;
-    }
-
-    if (!addonHelper->m_addon->ReloadSettings() || addonHelper->m_addon->GetSettings() == nullptr)
-    {
-      CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - couldn't get settings for add-on '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str());
-      return false;
-    }
-
-    auto setting = addonHelper->m_addon->GetSettings()->GetSetting(strSettingName);
-    if (setting == nullptr)
-    {
-      CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - can't find setting '%s' in '%s'", __FUNCTION__, strSettingName, addonHelper->m_addon->Name().c_str());
-      return false;
-    }
-
-    switch (setting->GetType())
-    {
-      case SettingType::Boolean:
-        *static_cast<bool*>(settingValue) = std::static_pointer_cast<CSettingBool>(setting)->GetValue();
-        return true;
-
-      case SettingType::Integer:
-        *static_cast<int*>(settingValue) = std::static_pointer_cast<CSettingInt>(setting)->GetValue();
-        return true;
-
-      case SettingType::Number:
-        *static_cast<float*>(settingValue) = static_cast<float>(std::static_pointer_cast<CSettingNumber>(setting)->GetValue());
-        return true;
-
-      case SettingType::String:
-        strcpy((char*)settingValue, std::static_pointer_cast<CSettingString>(setting)->GetValue().c_str());
-        return true;
-
-      default:
-        CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - setting '%s' in '%s' has unsupported type", __FUNCTION__, strSettingName, addonHelper->m_addon->Name().c_str());
-        return false;
-    }
-  }
-  catch (std::exception &e)
-  {
-    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - exception '%s' caught in call in add-on '%s'. please contact the developer of this addon: %s",
-        __FUNCTION__, e.what(), addonHelper->m_addon->Name().c_str(), addonHelper->m_addon->Author().c_str());
-  }
-
-  return false;
-}
-
-char* CAddonCallbacksAddon::TranslateSpecialProtocol(const char *strSource)
-{
-  try
-  {
-    if (strSource)
-      return strdup(CSpecialProtocol::TranslatePath(strSource).c_str());
-    else
-      return NULL;
-  }
-  catch (std::exception &e)
-  {
-    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - exception '%s' caught", __FUNCTION__, e.what());
-    return NULL;
-  }
-}
-
-char* CAddonCallbacksAddon::UnknownToUTF8(const char *strSource)
-{
-  std::string string;
-  if (strSource != NULL)
-    g_charsetConverter.unknownToUTF8(strSource, string);
-  else
-    string = "";
-  char* buffer = strdup(string.c_str());
-  return buffer;
-}
-
-char* CAddonCallbacksAddon::GetLocalizedString(const void* addonData, long dwCode)
-{
-  CAddonInterfaces* addon = (CAddonInterfaces*) addonData;
-  if (!addon || g_application.m_bStop)
-    return NULL;
-
-  CAddonCallbacksAddon* addonHelper = static_cast<CAddonCallbacksAddon*>(addon->AddOnLib_GetHelper());
-
-  std::string string;
-  if ((dwCode >= 30000 && dwCode <= 30999) || (dwCode >= 32000 && dwCode <= 32999))
-    string = g_localizeStrings.GetAddonString(addonHelper->m_addon->ID(), dwCode).c_str();
-  else
-    string = g_localizeStrings.Get(dwCode).c_str();
-
-  char* buffer = strdup(string.c_str());
-  return buffer;
-}
-
-char* CAddonCallbacksAddon::GetDVDMenuLanguage(const void* addonData)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return NULL;
-
-  std::string string = g_langInfo.GetDVDMenuLanguage();
-
-  char* buffer = strdup(string.c_str());
-  return buffer;
-}
-
-void CAddonCallbacksAddon::FreeString(const void* addonData, char* str)
-{
-  free(str);
-}
-
-void CAddonCallbacksAddon::FreeStringArray(const void* addonData, char** arr, int numElements)
-{
-  for (int i = 0; i < numElements; ++i)
-  {
-    free(arr[i]);
-  }
-  free(arr);
-}
-
-void* CAddonCallbacksAddon::OpenFile(const void* addonData, const char* strFileName, unsigned int flags)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return NULL;
-
-  CFile* file = new CFile;
-  if (file->Open(strFileName, flags))
-    return ((void*)file);
-
-  delete file;
-  return NULL;
-}
-
-void* CAddonCallbacksAddon::OpenFileForWrite(const void* addonData, const char* strFileName, bool bOverwrite)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return NULL;
-
-  CFile* file = new CFile;
-  if (file->OpenForWrite(strFileName, bOverwrite))
-    return ((void*)file);
-
-  delete file;
-  return NULL;
-}
-
-ssize_t CAddonCallbacksAddon::ReadFile(const void* addonData, void* file, void* lpBuf, size_t uiBufSize)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return 0;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return 0;
-
-  return cfile->Read(lpBuf, uiBufSize);
-}
-
-bool CAddonCallbacksAddon::ReadFileString(const void* addonData, void* file, char *szLine, int iLineLength)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return false;
-
-  return cfile->ReadString(szLine, iLineLength);
-}
-
-ssize_t CAddonCallbacksAddon::WriteFile(const void* addonData, void* file, const void* lpBuf, size_t uiBufSize)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return -1;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return -1;
-
-  return cfile->Write(lpBuf, uiBufSize);
-}
-
-void CAddonCallbacksAddon::FlushFile(const void* addonData, void* file)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return;
-
-  cfile->Flush();
-}
-
-int64_t CAddonCallbacksAddon::SeekFile(const void* addonData, void* file, int64_t iFilePosition, int iWhence)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return 0;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return 0;
-
-  return cfile->Seek(iFilePosition, iWhence);
-}
-
-int CAddonCallbacksAddon::TruncateFile(const void* addonData, void* file, int64_t iSize)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return 0;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return 0;
-
-  return cfile->Truncate(iSize);
-}
-
-int64_t CAddonCallbacksAddon::GetFilePosition(const void* addonData, void* file)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return 0;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return 0;
-
-  return cfile->GetPosition();
-}
-
-int64_t CAddonCallbacksAddon::GetFileLength(const void* addonData, void* file)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return 0;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return 0;
-
-  return cfile->GetLength();
-}
-
-double CAddonCallbacksAddon::GetFileDownloadSpeed(const void* addonData, void* file)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*)addonData;
-  if (!helper)
-    return 0.0f;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return 0.0f;
-
-  return cfile->GetDownloadSpeed();
-}
-
-void CAddonCallbacksAddon::CloseFile(const void* addonData, void* file)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  CFile* cfile = (CFile*)file;
-  if (cfile)
-  {
-    cfile->Close();
-    delete cfile;
-  }
-}
-
-int CAddonCallbacksAddon::GetFileChunkSize(const void* addonData, void* file)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return 0;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return 0;
-
-  return cfile->GetChunkSize();
-}
-
-bool CAddonCallbacksAddon::FileExists(const void* addonData, const char *strFileName, bool bUseCache)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  return CFile::Exists(strFileName, bUseCache);
-}
-
-int CAddonCallbacksAddon::StatFile(const void* addonData, const char *strFileName, struct ::__stat64* buffer)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return -1;
-
-  return CFile::Stat(strFileName, buffer);
-}
-
-char *CAddonCallbacksAddon::GetFilePropertyValue(const void* addonData, void* file, XFILE::FileProperty type, const char *name)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*)addonData;
-  if (!helper)
-    return nullptr;
-
-  CFile* cfile = (CFile*)file;
-  if (cfile)
-  {
-    std::vector<std::string> values = cfile->GetPropertyValues(type, name);
-    if (values.empty()) {
-      return nullptr;
-    }
-    return strdup(values[0].c_str());
-  }
-  return nullptr;
-}
-
-char **CAddonCallbacksAddon::GetFilePropertyValues(const void* addonData, void* file, XFILE::FileProperty type, const char *name, int *numValues)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*)addonData;
-  if (!helper)
-    return nullptr;
-
-  CFile* cfile = static_cast<CFile*>(file);
-  if (!cfile)
-  {
-    return nullptr;
-  }
-  std::vector<std::string> values = cfile->GetPropertyValues(type, name);
-  *numValues = values.size();
-  char **ret = static_cast<char**>(malloc(sizeof(char*)*values.size()));
-  for (int i = 0; i < *numValues; ++i)
-  {
-    ret[i] = strdup(values[i].c_str());
-  }
-  return ret;
-}
-
-bool CAddonCallbacksAddon::DeleteFile(const void* addonData, const char *strFileName)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  return CFile::Delete(strFileName);
-}
-
-bool CAddonCallbacksAddon::CanOpenDirectory(const void* addonData, const char* strURL)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  CFileItemList items;
-  return CDirectory::GetDirectory(strURL, items, "", DIR_FLAG_DEFAULTS);
-}
-
-bool CAddonCallbacksAddon::CreateDirectory(const void* addonData, const char *strPath)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  return CDirectory::Create(strPath);
-}
-
-bool CAddonCallbacksAddon::DirectoryExists(const void* addonData, const char *strPath)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  return CDirectory::Exists(strPath);
-}
-
-bool CAddonCallbacksAddon::RemoveDirectory(const void* addonData, const char *strPath)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  // Empty directory
-  CFileItemList fileItems;
-  CDirectory::GetDirectory(strPath, fileItems, "", DIR_FLAG_DEFAULTS);
-  for (int i = 0; i < fileItems.Size(); ++i)
-    CFile::Delete(fileItems.Get(i)->GetPath());
-
-  return CDirectory::Remove(strPath);
-}
-
-static void CFileItemListToVFSDirEntries(VFSDirEntry* entries,
-                                         unsigned int num_entries,
-                                         const CFileItemList& items)
-{
-  if (!entries)
-    return;
-
-  int toCopy = std::min(num_entries, (unsigned int)items.Size());
-
-  for (int i=0;i<toCopy;++i)
-  {
-    entries[i].label = strdup(items[i]->GetLabel().c_str());
-    entries[i].path = strdup(items[i]->GetPath().c_str());
-    entries[i].size = items[i]->m_dwSize;
-    entries[i].folder = items[i]->m_bIsFolder;
-    items[i]->m_dateTime.GetAsTime(entries[i].date_time);
-  }
-}
-
-bool CAddonCallbacksAddon::GetDirectory(const void* addonData, const char *strPath, const char* mask, VFSDirEntry** items, unsigned int* num_items)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  CFileItemList fileItems;
-  if (!CDirectory::GetDirectory(strPath, fileItems, mask, DIR_FLAG_NO_FILE_DIRS))
-    return false;
-
-  if (fileItems.Size() > 0)
-  {
-    *num_items = static_cast<unsigned int>(fileItems.Size());
-    *items = new VFSDirEntry[fileItems.Size()];
-  }
-  else
-  {
-    *num_items = 0;
-    *items = nullptr;
-  }
-
-  CFileItemListToVFSDirEntries(*items, *num_items, fileItems);
-  return true;
-}
-
-void CAddonCallbacksAddon::FreeDirectory(const void* addonData, VFSDirEntry* items, unsigned int num_items)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  for (unsigned int i = 0; i < num_items; ++i)
-  {
-    free(items[i].label);
-    free(items[i].path);
-  }
-  delete[] items;
-}
-
-void* CAddonCallbacksAddon::CURLCreate(const void* addonData, const char* strURL)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*)addonData;
-  if (!helper)
-    return nullptr;
-
-  CFile* file = new CFile;
-  if (file->CURLCreate(strURL))
-    return ((void*)file);
-
-  delete file;
-
-  return nullptr;
-}
-
-bool CAddonCallbacksAddon::CURLAddOption(const void* addonData, void* file, XFILE::CURLOPTIONTYPE type, const char* name, const char * value)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*)addonData;
-  if (!helper)
-    return false;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return false;
-
-  return cfile->CURLAddOption(type, name, value);
-}
-
-bool CAddonCallbacksAddon::CURLOpen(const void* addonData, void* file, unsigned int flags)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*)addonData;
-  if (!helper)
-    return false;
-
-  CFile* cfile = (CFile*)file;
-  if (!cfile)
-    return false;
-
-  return cfile->CURLOpen(flags);
-}
-
-} /* namespace AddOn */
-} /* namespace KodiAPI */
diff --git a/xbmc/addons/interfaces/Addon/AddonCallbacksAddon.h b/xbmc/addons/interfaces/Addon/AddonCallbacksAddon.h
deleted file mode 100644
index 8e56a251b592..000000000000
--- a/xbmc/addons/interfaces/Addon/AddonCallbacksAddon.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *  Copyright (C) 2012-2018 Team Kodi
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include "addons/interfaces/AddonInterfaces.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h"
-
-struct VFSDirEntry;
-
-#ifdef TARGET_WINDOWS
-#ifndef _SSIZE_T_DEFINED
-typedef intptr_t ssize_t;
-#define _SSIZE_T_DEFINED
-#endif // !_SSIZE_T_DEFINED
-#endif // TARGET_WINDOWS
-
-namespace ADDON
-{
-  class CAddon;
-};
-
-namespace KodiAPI
-{
-namespace AddOn
-{
-
-class CAddonCallbacksAddon
-{
-public:
-  explicit CAddonCallbacksAddon(ADDON::CAddon* addon);
-  virtual ~CAddonCallbacksAddon();
-
-  /*!
-   * @return The callback table.
-   */
-  CB_AddOnLib *GetCallbacks() { return m_callbacks; }
-
-  static void AddOnLog(void *addonData, const int addonLogLevel, const char *strMessage);
-  static bool GetAddonSetting(void *addonData, const char *strSettingName, void *settingValue);
-  static char *TranslateSpecialProtocol(const char *strSource);
-  static void QueueNotification(void *addonData, const int type, const char *strMessage);
-  static bool WakeOnLan(const char *mac);
-  static char* UnknownToUTF8(const char *strSource);
-  static char* GetLocalizedString(const void* addonData, long dwCode);
-  static char* GetDVDMenuLanguage(const void* addonData);
-  static void FreeString(const void* addonData, char* str);
-  static void FreeStringArray(const void* addonData, char** arr, int numElements);
-
-  // file operations
-  static void* OpenFile(const void* addonData, const char* strFileName, unsigned int flags);
-  static void* OpenFileForWrite(const void* addonData, const char* strFileName, bool bOverwrite);
-  static ssize_t ReadFile(const void* addonData, void* file, void* lpBuf, size_t uiBufSize);
-  static bool ReadFileString(const void* addonData, void* file, char *szLine, int iLineLength);
-  static ssize_t WriteFile(const void* addonData, void* file, const void* lpBuf, size_t uiBufSize);
-  static void FlushFile(const void* addonData, void* file);
-  static int64_t SeekFile(const void* addonData, void* file, int64_t iFilePosition, int iWhence);
-  static int TruncateFile(const void* addonData, void* file, int64_t iSize);
-  static int64_t GetFilePosition(const void* addonData, void* file);
-  static int64_t GetFileLength(const void* addonData, void* file);
-  static double GetFileDownloadSpeed(const void* addonData, void* file);
-  static void CloseFile(const void* addonData, void* file);
-  static int GetFileChunkSize(const void* addonData, void* file);
-  static bool FileExists(const void* addonData, const char *strFileName, bool bUseCache);
-  static int StatFile(const void* addonData, const char *strFileName, struct __stat64* buffer);
-  static char *GetFilePropertyValue(const void* addonData, void* file, XFILE::FileProperty type, const char *name);
-  static char **GetFilePropertyValues(const void* addonData, void* file, XFILE::FileProperty type, const char *name, int *numValues);
-  static bool DeleteFile(const void* addonData, const char *strFileName);
-  static bool CanOpenDirectory(const void* addonData, const char* strURL);
-  static bool CreateDirectory(const void* addonData, const char *strPath);
-  static bool DirectoryExists(const void* addonData, const char *strPath);
-  static bool RemoveDirectory(const void* addonData, const char *strPath);
-  static bool GetDirectory(const void* addondata, const char* strPath, const char* mask, VFSDirEntry** items, unsigned int* num_items);
-  static void FreeDirectory(const void* addondata, VFSDirEntry* items, unsigned int num_items);
-  static void* CURLCreate(const void* addonData, const char* strURL);
-  static bool CURLAddOption(const void* addonData, void* curl, XFILE::CURLOPTIONTYPE type, const char* name, const char * value);
-  static bool CURLOpen(const void* addonData, void* curl, unsigned int flags);
-
-private:
-  CAddonCallbacksAddon(const CAddonCallbacksAddon&) = delete;
-  CAddonCallbacksAddon& operator=(const CAddonCallbacksAddon&) = delete;
-
-  ADDON::CAddon* m_addon; /*!< the addon */
-  CB_AddOnLib  *m_callbacks; /*!< callback addresses */
-};
-
-} /* namespace AddOn */
-} /* namespace KodiAPI */
diff --git a/xbmc/addons/interfaces/Addon/CMakeLists.txt b/xbmc/addons/interfaces/Addon/CMakeLists.txt
deleted file mode 100644
index de94db4b15fb..000000000000
--- a/xbmc/addons/interfaces/Addon/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-set(SOURCES AddonCallbacksAddon.cpp)
-
-set(HEADERS AddonCallbacksAddon.h)
-
-core_add_library(addons_interfaces_addon)
diff --git a/xbmc/addons/interfaces/AddonInterfaces.cpp b/xbmc/addons/interfaces/AddonInterfaces.cpp
deleted file mode 100644
index 90ace617bfb9..000000000000
--- a/xbmc/addons/interfaces/AddonInterfaces.cpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- *  Copyright (C) 2012-2018 Team Kodi
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#include "AddonInterfaces.h"
-
-#include "addons/Addon.h"
-#include "addons/interfaces/Addon/AddonCallbacksAddon.h"
-#include "addons/interfaces/gui/AddonCallbacksGUI.h"
-#include "addons/interfaces/gui/AddonGUIWindow.h"
-#include "addons/interfaces/gui/Window.h"
-#include "filesystem/SpecialProtocol.h"
-#include "messaging/ApplicationMessenger.h"
-#include "pvr/addons/PVRClient.h"
-#include "utils/log.h"
-
-using namespace KODI;
-using namespace MESSAGING;
-
-namespace ADDON
-{
-
-CAddonInterfaces::CAddonInterfaces(CAddon* addon)
-  : m_callbacks(new AddonCB),
-    m_addon(addon),
-    m_helperAddOn(nullptr),
-    m_helperGUI(nullptr)
-{
-  m_callbacks->libBasePath                  = strdup(CSpecialProtocol::TranslatePath("special://xbmcbinaddons").c_str());
-  m_callbacks->addonData                    = this;
-
-  m_callbacks->AddOnLib_RegisterMe          = CAddonInterfaces::AddOnLib_RegisterMe;
-  m_callbacks->AddOnLib_UnRegisterMe        = CAddonInterfaces::AddOnLib_UnRegisterMe;
-  m_callbacks->GUILib_RegisterMe            = CAddonInterfaces::GUILib_RegisterMe;
-  m_callbacks->GUILib_UnRegisterMe          = CAddonInterfaces::GUILib_UnRegisterMe;
-  m_callbacks->PVRLib_RegisterMe            = CAddonInterfaces::PVRLib_RegisterMe;
-  m_callbacks->PVRLib_UnRegisterMe          = CAddonInterfaces::PVRLib_UnRegisterMe;
-}
-
-CAddonInterfaces::~CAddonInterfaces()
-{
-  delete static_cast<KodiAPI::AddOn::CAddonCallbacksAddon*>(m_helperAddOn);
-  delete static_cast<KodiAPI::GUI::CAddonCallbacksGUI*>(m_helperGUI);
-
-  free(const_cast<char*>(m_callbacks->libBasePath));
-  delete m_callbacks;
-}
-
-/*\_____________________________________________________________________________
-\*/
-
-void* CAddonInterfaces::AddOnLib_RegisterMe(void *addonData)
-{
-  CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
-  if (addon == nullptr)
-  {
-    CLog::Log(LOGERROR, "CAddonInterfaces - %s - called with a null pointer", __FUNCTION__);
-    return nullptr;
-  }
-
-  addon->m_helperAddOn = new KodiAPI::AddOn::CAddonCallbacksAddon(addon->m_addon);
-  return static_cast<KodiAPI::AddOn::CAddonCallbacksAddon*>(addon->m_helperAddOn)->GetCallbacks();
-}
-
-void CAddonInterfaces::AddOnLib_UnRegisterMe(void *addonData, void *cbTable)
-{
-  CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
-  if (addon == nullptr)
-  {
-    CLog::Log(LOGERROR, "CAddonInterfaces - %s - called with a null pointer", __FUNCTION__);
-    return;
-  }
-
-  delete static_cast<KodiAPI::AddOn::CAddonCallbacksAddon*>(addon->m_helperAddOn);
-  addon->m_helperAddOn = nullptr;
-}
-/*\_____________________________________________________________________________
-\*/
-void* CAddonInterfaces::GUILib_RegisterMe(void *addonData)
-{
-  CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
-  if (addon == nullptr)
-  {
-    CLog::Log(LOGERROR, "CAddonInterfaces - %s - called with a null pointer", __FUNCTION__);
-    return nullptr;
-  }
-
-  addon->m_helperGUI = new KodiAPI::GUI::CAddonCallbacksGUI(addon->m_addon);
-  return static_cast<KodiAPI::GUI::CAddonCallbacksGUI*>(addon->m_helperGUI)->GetCallbacks();
-}
-
-void CAddonInterfaces::GUILib_UnRegisterMe(void *addonData, void *cbTable)
-{
-  CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
-  if (addon == nullptr)
-  {
-    CLog::Log(LOGERROR, "CAddonInterfaces - %s - called with a null pointer", __FUNCTION__);
-    return;
-  }
-
-  delete static_cast<KodiAPI::GUI::CAddonCallbacksGUI*>(addon->m_helperGUI);
-  addon->m_helperGUI = nullptr;
-}
-/*\_____________________________________________________________________________
-\*/
-void* CAddonInterfaces::PVRLib_RegisterMe(void *addonData)
-{
-  CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
-  if (addon == nullptr)
-  {
-    CLog::Log(LOGERROR, "CAddonInterfaces - %s - called with a null pointer", __FUNCTION__);
-    return nullptr;
-  }
-
-  return dynamic_cast<PVR::CPVRClient*>(addon->m_addon)->GetInstanceInterface();
-}
-
-void CAddonInterfaces::PVRLib_UnRegisterMe(void *addonData, void *cbTable)
-{
-}
-/*\_____________________________________________________________________________
-\*/
-void CAddonInterfaces::OnApplicationMessage(ThreadMessage* pMsg)
-{
-  switch (pMsg->dwMessage)
-  {
-  case TMSG_GUI_ADDON_DIALOG:
-  {
-    if (pMsg->lpVoid)
-    { //! @todo This is ugly - really these binary add-on dialogs should just be normal Kodi dialogs
-      switch (pMsg->param1)
-      {
-      case 0:
-        static_cast<ADDON::CGUIAddonWindowDialog*>(pMsg->lpVoid)->Show_Internal(pMsg->param2 > 0);
-        break;
-      case 1:
-        static_cast<KodiAPI::GUI::CGUIAddonWindowDialog*>(pMsg->lpVoid)->Show_Internal(pMsg->param2 > 0);
-        break;
-      };
-    }
-  }
-  break;
-  }
-}
-
-} /* namespace ADDON */
diff --git a/xbmc/addons/interfaces/AddonInterfaces.h b/xbmc/addons/interfaces/AddonInterfaces.h
deleted file mode 100644
index 4ad1cac25345..000000000000
--- a/xbmc/addons/interfaces/AddonInterfaces.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *  Copyright (C) 2012-2018 Team Kodi
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include <stdint.h>
-
-struct AddonCB;
-
-namespace KODI
-{
-namespace MESSAGING
-{
-  class ThreadMessage;
-}
-}
-
-namespace ADDON
-{
-
-  class CAddon;
-
-  class CAddonInterfaces
-  {
-  public:
-    explicit CAddonInterfaces(CAddon* addon);
-    ~CAddonInterfaces();
-
-    AddonCB* GetCallbacks()        { return m_callbacks; }
-    CAddon *GetAddon()             { return m_addon; }
-    const CAddon *GetAddon() const { return m_addon; }
-    /*\_________________________________________________________________________
-    \*/
-    static void*        AddOnLib_RegisterMe            (void* addonData);
-    static void         AddOnLib_UnRegisterMe          (void* addonData, void* cbTable);
-    void*               AddOnLib_GetHelper()          { return m_helperAddOn; }
-    /*\_________________________________________________________________________
-    \*/
-    static void*        GUILib_RegisterMe              (void* addonData);
-    static void         GUILib_UnRegisterMe            (void* addonData, void* cbTable);
-    void*               GUILib_GetHelper()            { return m_helperGUI; }
-    /*\_________________________________________________________________________
-    \*/
-    static void*        PVRLib_RegisterMe              (void* addonData);
-    static void         PVRLib_UnRegisterMe            (void* addonData, void* cbTable);
-    /*
-     * API level independent functions for Kodi
-     */
-    static void OnApplicationMessage(KODI::MESSAGING::ThreadMessage* pMsg);
-
-  private:
-    CAddonInterfaces(const CAddonInterfaces&) = delete;
-    CAddonInterfaces& operator=(const CAddonInterfaces&) = delete;
-    AddonCB*  m_callbacks;
-    CAddon*   m_addon;
-
-    void*     m_helperAddOn;
-    void*     m_helperGUI;
-  };
-
-} /* namespace ADDON */
diff --git a/xbmc/addons/interfaces/CMakeLists.txt b/xbmc/addons/interfaces/CMakeLists.txt
index ac1689935c3d..8e58bb6cf969 100644
--- a/xbmc/addons/interfaces/CMakeLists.txt
+++ b/xbmc/addons/interfaces/CMakeLists.txt
@@ -1,12 +1,10 @@
 set(SOURCES AddonBase.cpp
-            AddonInterfaces.cpp
             AudioEngine.cpp
             General.cpp
             Filesystem.cpp
             Network.cpp)
 
 set(HEADERS AddonBase.h
-            AddonInterfaces.h
             AudioEngine.h
             General.h
             Filesystem.h
diff --git a/xbmc/addons/interfaces/gui/AddonCallbacksGUI.cpp b/xbmc/addons/interfaces/gui/AddonCallbacksGUI.cpp
deleted file mode 100644
index 3a7f3274a7e9..000000000000
--- a/xbmc/addons/interfaces/gui/AddonCallbacksGUI.cpp
+++ /dev/null
@@ -1,1863 +0,0 @@
-/*
- *  Copyright (C) 2012-2018 Team Kodi
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#include "AddonCallbacksGUI.h"
-
-#include "AddonGUIRenderingControl.h"
-#include "AddonGUIWindow.h"
-#include "Application.h"
-#include "FileItem.h"
-#include "ServiceBroker.h"
-#include "addons/Addon.h"
-#include "addons/Skin.h"
-#include "dialogs/GUIDialogFileBrowser.h"
-#include "dialogs/GUIDialogNumeric.h"
-#include "dialogs/GUIDialogSelect.h"
-#include "dialogs/GUIDialogTextViewer.h"
-#include "filesystem/File.h"
-#include "guilib/GUIComponent.h"
-#include "guilib/GUIKeyboardFactory.h"
-#include "guilib/GUIProgressControl.h"
-#include "guilib/GUIRadioButtonControl.h"
-#include "guilib/GUIRenderingControl.h"
-#include "guilib/GUISettingsSliderControl.h"
-#include "guilib/GUISpinControlEx.h"
-#include "guilib/GUIWindowManager.h"
-#include "messaging/ApplicationMessenger.h"
-#include "messaging/helpers/DialogHelper.h"
-#include "messaging/helpers/DialogOKHelper.h"
-#include "utils/StringUtils.h"
-#include "utils/URIUtils.h"
-#include "utils/Variant.h"
-#include "utils/log.h"
-
-using namespace KODI::MESSAGING;
-using KODI::MESSAGING::HELPERS::DialogResponse;
-
-using namespace ADDON;
-
-namespace KodiAPI
-{
-namespace GUI
-{
-
-static int iXBMCGUILockRef = 0;
-
-CAddonCallbacksGUI::CAddonCallbacksGUI(CAddon* addon)
-  : m_addon(addon),
-    m_callbacks(new CB_GUILib)
-{
-  /* GUI Helper functions */
-  m_callbacks->Lock                           = CAddonCallbacksGUI::Lock;
-  m_callbacks->Unlock                         = CAddonCallbacksGUI::Unlock;
-  m_callbacks->GetScreenHeight                = CAddonCallbacksGUI::GetScreenHeight;
-  m_callbacks->GetScreenWidth                 = CAddonCallbacksGUI::GetScreenWidth;
-  m_callbacks->GetVideoResolution             = CAddonCallbacksGUI::GetVideoResolution;
-  m_callbacks->Window_New                     = CAddonCallbacksGUI::Window_New;
-  m_callbacks->Window_Delete                  = CAddonCallbacksGUI::Window_Delete;
-  m_callbacks->Window_SetCallbacks            = CAddonCallbacksGUI::Window_SetCallbacks;
-  m_callbacks->Window_Show                    = CAddonCallbacksGUI::Window_Show;
-  m_callbacks->Window_Close                   = CAddonCallbacksGUI::Window_Close;
-  m_callbacks->Window_DoModal                 = CAddonCallbacksGUI::Window_DoModal;
-  m_callbacks->Window_SetFocusId              = CAddonCallbacksGUI::Window_SetFocusId;
-  m_callbacks->Window_GetFocusId              = CAddonCallbacksGUI::Window_GetFocusId;
-  m_callbacks->Window_SetCoordinateResolution = CAddonCallbacksGUI::Window_SetCoordinateResolution;
-  m_callbacks->Window_SetProperty             = CAddonCallbacksGUI::Window_SetProperty;
-  m_callbacks->Window_SetPropertyInt          = CAddonCallbacksGUI::Window_SetPropertyInt;
-  m_callbacks->Window_SetPropertyBool         = CAddonCallbacksGUI::Window_SetPropertyBool;
-  m_callbacks->Window_SetPropertyDouble       = CAddonCallbacksGUI::Window_SetPropertyDouble;
-  m_callbacks->Window_GetProperty             = CAddonCallbacksGUI::Window_GetProperty;
-  m_callbacks->Window_GetPropertyInt          = CAddonCallbacksGUI::Window_GetPropertyInt;
-  m_callbacks->Window_GetPropertyBool         = CAddonCallbacksGUI::Window_GetPropertyBool;
-  m_callbacks->Window_GetPropertyDouble       = CAddonCallbacksGUI::Window_GetPropertyDouble;
-  m_callbacks->Window_ClearProperties         = CAddonCallbacksGUI::Window_ClearProperties;
-
-  m_callbacks->Window_GetListSize             = CAddonCallbacksGUI::Window_GetListSize;
-  m_callbacks->Window_ClearList               = CAddonCallbacksGUI::Window_ClearList;
-  m_callbacks->Window_AddItem                 = CAddonCallbacksGUI::Window_AddItem;
-  m_callbacks->Window_AddStringItem           = CAddonCallbacksGUI::Window_AddStringItem;
-  m_callbacks->Window_RemoveItem              = CAddonCallbacksGUI::Window_RemoveItem;
-  m_callbacks->Window_GetListItem             = CAddonCallbacksGUI::Window_GetListItem;
-  m_callbacks->Window_SetCurrentListPosition  = CAddonCallbacksGUI::Window_SetCurrentListPosition;
-  m_callbacks->Window_GetCurrentListPosition  = CAddonCallbacksGUI::Window_GetCurrentListPosition;
-
-  m_callbacks->Window_GetControl_Spin         = CAddonCallbacksGUI::Window_GetControl_Spin;
-  m_callbacks->Window_GetControl_Button       = CAddonCallbacksGUI::Window_GetControl_Button;
-  m_callbacks->Window_GetControl_RadioButton  = CAddonCallbacksGUI::Window_GetControl_RadioButton;
-  m_callbacks->Window_GetControl_Edit         = CAddonCallbacksGUI::Window_GetControl_Edit;
-  m_callbacks->Window_GetControl_Progress     = CAddonCallbacksGUI::Window_GetControl_Progress;
-  m_callbacks->Window_GetControl_RenderAddon  = CAddonCallbacksGUI::Window_GetControl_RenderAddon;
-  m_callbacks->Window_GetControl_Slider       = CAddonCallbacksGUI::Window_GetControl_Slider;
-  m_callbacks->Window_GetControl_SettingsSlider= CAddonCallbacksGUI::Window_GetControl_SettingsSlider;
-
-  m_callbacks->Window_SetControlLabel         = CAddonCallbacksGUI::Window_SetControlLabel;
-  m_callbacks->Window_MarkDirtyRegion         = CAddonCallbacksGUI::Window_MarkDirtyRegion;
-
-  m_callbacks->Control_Spin_SetVisible        = CAddonCallbacksGUI::Control_Spin_SetVisible;
-  m_callbacks->Control_Spin_SetText           = CAddonCallbacksGUI::Control_Spin_SetText;
-  m_callbacks->Control_Spin_Clear             = CAddonCallbacksGUI::Control_Spin_Clear;
-  m_callbacks->Control_Spin_AddLabel          = CAddonCallbacksGUI::Control_Spin_AddLabel;
-  m_callbacks->Control_Spin_GetValue          = CAddonCallbacksGUI::Control_Spin_GetValue;
-  m_callbacks->Control_Spin_SetValue          = CAddonCallbacksGUI::Control_Spin_SetValue;
-
-  m_callbacks->Control_RadioButton_SetVisible = CAddonCallbacksGUI::Control_RadioButton_SetVisible;
-  m_callbacks->Control_RadioButton_SetText    = CAddonCallbacksGUI::Control_RadioButton_SetText;
-  m_callbacks->Control_RadioButton_SetSelected= CAddonCallbacksGUI::Control_RadioButton_SetSelected;
-  m_callbacks->Control_RadioButton_IsSelected = CAddonCallbacksGUI::Control_RadioButton_IsSelected;
-
-  m_callbacks->Control_Progress_SetPercentage = CAddonCallbacksGUI::Control_Progress_SetPercentage;
-  m_callbacks->Control_Progress_GetPercentage = CAddonCallbacksGUI::Control_Progress_GetPercentage;
-  m_callbacks->Control_Progress_SetInfo       = CAddonCallbacksGUI::Control_Progress_SetInfo;
-  m_callbacks->Control_Progress_GetInfo       = CAddonCallbacksGUI::Control_Progress_GetInfo;
-  m_callbacks->Control_Progress_GetDescription= CAddonCallbacksGUI::Control_Progress_GetDescription;
-
-  m_callbacks->ListItem_Create                = CAddonCallbacksGUI::ListItem_Create;
-  m_callbacks->ListItem_GetLabel              = CAddonCallbacksGUI::ListItem_GetLabel;
-  m_callbacks->ListItem_SetLabel              = CAddonCallbacksGUI::ListItem_SetLabel;
-  m_callbacks->ListItem_GetLabel2             = CAddonCallbacksGUI::ListItem_GetLabel2;
-  m_callbacks->ListItem_SetLabel2             = CAddonCallbacksGUI::ListItem_SetLabel2;
-  m_callbacks->ListItem_SetInfo               = CAddonCallbacksGUI::ListItem_SetInfo;
-  m_callbacks->ListItem_SetProperty           = CAddonCallbacksGUI::ListItem_SetProperty;
-  m_callbacks->ListItem_GetProperty           = CAddonCallbacksGUI::ListItem_GetProperty;
-  m_callbacks->ListItem_SetPath               = CAddonCallbacksGUI::ListItem_SetPath;
-
-  m_callbacks->RenderAddon_SetCallbacks       = CAddonCallbacksGUI::RenderAddon_SetCallbacks;
-  m_callbacks->RenderAddon_Delete             = CAddonCallbacksGUI::RenderAddon_Delete;
-
-  m_callbacks->Control_Slider_SetVisible                    = CAddonCallbacksGUI::Control_Slider_SetVisible;
-  m_callbacks->Control_Slider_GetDescription                = CAddonCallbacksGUI::Control_Slider_GetDescription;
-  m_callbacks->Control_Slider_SetIntRange                   = CAddonCallbacksGUI::Control_Slider_SetIntRange;
-  m_callbacks->Control_Slider_SetIntValue                   = CAddonCallbacksGUI::Control_Slider_SetIntValue;
-  m_callbacks->Control_Slider_GetIntValue                   = CAddonCallbacksGUI::Control_Slider_GetIntValue;
-  m_callbacks->Control_Slider_SetIntInterval                = CAddonCallbacksGUI::Control_Slider_SetIntInterval;
-  m_callbacks->Control_Slider_SetPercentage                 = CAddonCallbacksGUI::Control_Slider_SetPercentage;
-  m_callbacks->Control_Slider_GetPercentage                 = CAddonCallbacksGUI::Control_Slider_GetPercentage;
-  m_callbacks->Control_Slider_SetFloatRange                 = CAddonCallbacksGUI::Control_Slider_SetFloatRange;
-  m_callbacks->Control_Slider_SetFloatValue                 = CAddonCallbacksGUI::Control_Slider_SetFloatValue;
-  m_callbacks->Control_Slider_GetFloatValue                 = CAddonCallbacksGUI::Control_Slider_GetFloatValue;
-  m_callbacks->Control_Slider_SetFloatInterval              = CAddonCallbacksGUI::Control_Slider_SetFloatInterval;
-
-  m_callbacks->Control_SettingsSlider_SetVisible            = CAddonCallbacksGUI::Control_SettingsSlider_SetVisible;
-  m_callbacks->Control_SettingsSlider_SetText               = CAddonCallbacksGUI::Control_SettingsSlider_SetText;
-  m_callbacks->Control_SettingsSlider_GetDescription        = CAddonCallbacksGUI::Control_SettingsSlider_GetDescription;
-  m_callbacks->Control_SettingsSlider_SetIntRange           = CAddonCallbacksGUI::Control_SettingsSlider_SetIntRange;
-  m_callbacks->Control_SettingsSlider_SetIntValue           = CAddonCallbacksGUI::Control_SettingsSlider_SetIntValue;
-  m_callbacks->Control_SettingsSlider_GetIntValue           = CAddonCallbacksGUI::Control_SettingsSlider_GetIntValue;
-  m_callbacks->Control_SettingsSlider_SetIntInterval        = CAddonCallbacksGUI::Control_SettingsSlider_SetIntInterval;
-  m_callbacks->Control_SettingsSlider_SetPercentage         = CAddonCallbacksGUI::Control_SettingsSlider_SetPercentage;
-  m_callbacks->Control_SettingsSlider_GetPercentage         = CAddonCallbacksGUI::Control_SettingsSlider_GetPercentage;
-  m_callbacks->Control_SettingsSlider_SetFloatRange         = CAddonCallbacksGUI::Control_SettingsSlider_SetFloatRange;
-  m_callbacks->Control_SettingsSlider_SetFloatValue         = CAddonCallbacksGUI::Control_SettingsSlider_SetFloatValue;
-  m_callbacks->Control_SettingsSlider_GetFloatValue         = CAddonCallbacksGUI::Control_SettingsSlider_GetFloatValue;
-  m_callbacks->Control_SettingsSlider_SetFloatInterval      = CAddonCallbacksGUI::Control_SettingsSlider_SetFloatInterval;
-
-  m_callbacks->Dialog_Keyboard_ShowAndGetInputWithHead      = CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetInputWithHead;
-  m_callbacks->Dialog_Keyboard_ShowAndGetInput              = CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetInput;
-  m_callbacks->Dialog_Keyboard_ShowAndGetNewPasswordWithHead = CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetNewPasswordWithHead;
-  m_callbacks->Dialog_Keyboard_ShowAndGetNewPassword        = CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetNewPassword;
-  m_callbacks->Dialog_Keyboard_ShowAndVerifyNewPasswordWithHead = CAddonCallbacksGUI::Dialog_Keyboard_ShowAndVerifyNewPasswordWithHead;
-  m_callbacks->Dialog_Keyboard_ShowAndVerifyNewPassword     = CAddonCallbacksGUI::Dialog_Keyboard_ShowAndVerifyNewPassword;
-  m_callbacks->Dialog_Keyboard_ShowAndVerifyPassword        = CAddonCallbacksGUI::Dialog_Keyboard_ShowAndVerifyPassword;
-  m_callbacks->Dialog_Keyboard_ShowAndGetFilter             = CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetFilter;
-  m_callbacks->Dialog_Keyboard_SendTextToActiveKeyboard     = CAddonCallbacksGUI::Dialog_Keyboard_SendTextToActiveKeyboard;
-  m_callbacks->Dialog_Keyboard_isKeyboardActivated          = CAddonCallbacksGUI::Dialog_Keyboard_isKeyboardActivated;
-
-  m_callbacks->Dialog_Numeric_ShowAndVerifyNewPassword      = CAddonCallbacksGUI::Dialog_Numeric_ShowAndVerifyNewPassword;
-  m_callbacks->Dialog_Numeric_ShowAndVerifyPassword         = CAddonCallbacksGUI::Dialog_Numeric_ShowAndVerifyPassword;
-  m_callbacks->Dialog_Numeric_ShowAndVerifyInput            = CAddonCallbacksGUI::Dialog_Numeric_ShowAndVerifyInput;
-  m_callbacks->Dialog_Numeric_ShowAndGetTime                = CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetTime;
-  m_callbacks->Dialog_Numeric_ShowAndGetDate                = CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetDate;
-  m_callbacks->Dialog_Numeric_ShowAndGetIPAddress           = CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetIPAddress;
-  m_callbacks->Dialog_Numeric_ShowAndGetNumber              = CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetNumber;
-  m_callbacks->Dialog_Numeric_ShowAndGetSeconds             = CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetSeconds;
-
-  m_callbacks->Dialog_FileBrowser_ShowAndGetFile            = CAddonCallbacksGUI::Dialog_FileBrowser_ShowAndGetFile;
-
-  m_callbacks->Dialog_OK_ShowAndGetInputSingleText          = CAddonCallbacksGUI::Dialog_OK_ShowAndGetInputSingleText;
-  m_callbacks->Dialog_OK_ShowAndGetInputLineText            = CAddonCallbacksGUI::Dialog_OK_ShowAndGetInputLineText;
-
-  m_callbacks->Dialog_YesNo_ShowAndGetInputSingleText       = CAddonCallbacksGUI::Dialog_YesNo_ShowAndGetInputSingleText;
-  m_callbacks->Dialog_YesNo_ShowAndGetInputLineText         = CAddonCallbacksGUI::Dialog_YesNo_ShowAndGetInputLineText;
-  m_callbacks->Dialog_YesNo_ShowAndGetInputLineButtonText   = CAddonCallbacksGUI::Dialog_YesNo_ShowAndGetInputLineButtonText;
-
-  m_callbacks->Dialog_TextViewer                            = CAddonCallbacksGUI::Dialog_TextViewer;
-
-  m_callbacks->Dialog_Select                                = CAddonCallbacksGUI::Dialog_Select;
-}
-
-CAddonCallbacksGUI::~CAddonCallbacksGUI()
-{
-  delete m_callbacks;
-}
-
-void CAddonCallbacksGUI::Lock()
-{
-  if (iXBMCGUILockRef == 0)
-    CServiceBroker::GetWinSystem()->GetGfxContext().lock();
-  iXBMCGUILockRef++;
-}
-
-void CAddonCallbacksGUI::Unlock()
-{
-  if (iXBMCGUILockRef > 0)
-  {
-    iXBMCGUILockRef--;
-    if (iXBMCGUILockRef == 0)
-      CServiceBroker::GetWinSystem()->GetGfxContext().unlock();
-  }
-}
-
-int CAddonCallbacksGUI::GetScreenHeight()
-{
-  return CServiceBroker::GetWinSystem()->GetGfxContext().GetHeight();
-}
-
-int CAddonCallbacksGUI::GetScreenWidth()
-{
-  return CServiceBroker::GetWinSystem()->GetGfxContext().GetWidth();
-}
-
-int CAddonCallbacksGUI::GetVideoResolution()
-{
-  return (int)CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution();
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_New(void *addonData, const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return NULL;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  RESOLUTION_INFO res;
-  std::string strSkinPath;
-  if (!forceFallback)
-  {
-    /* Check to see if the XML file exists in current skin. If not use
-       fallback path to find a skin for the addon */
-    strSkinPath = g_SkinInfo->GetSkinPath(xmlFilename, &res);
-    if (!XFILE::CFile::Exists(strSkinPath))
-    {
-      /* Check for the matching folder for the skin in the fallback skins folder */
-      std::string basePath = URIUtils::AddFileToFolder(
-        guiHelper->m_addon->Path(),
-        "resources",
-        "skins",
-        URIUtils::GetFileName(g_SkinInfo->Path()));
-      strSkinPath = g_SkinInfo->GetSkinPath(xmlFilename, &res, basePath);
-      if (!XFILE::CFile::Exists(strSkinPath))
-      {
-        /* Finally fallback to the DefaultSkin as it didn't exist in either the
-           XBMC Skin folder or the fallback skin folder */
-        forceFallback = true;
-      }
-    }
-  }
-
-  if (forceFallback)
-  {
-    //FIXME make this static method of current skin?
-    std::string str("none");
-    AddonInfoPtr addonInfo = std::make_shared<CAddonInfo>(str, ADDON_SKIN);
-    addonInfo->SetPath(URIUtils::AddFileToFolder(
-      guiHelper->m_addon->Path(),
-      "resources",
-      "skins",
-      defaultSkin));
-
-    std::shared_ptr<CSkinInfo> skinInfo = std::make_shared<ADDON::CSkinInfo>(addonInfo);
-    skinInfo->Start();
-    strSkinPath = skinInfo->GetSkinPath(xmlFilename, &res, addonInfo->Path());
-
-    if (!XFILE::CFile::Exists(strSkinPath))
-    {
-      CLog::Log(LOGERROR, "Window_New: %s/%s - XML File '%s' for Window is missing, contact Developer '%s' of this AddOn", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str(), strSkinPath.c_str(), guiHelper->m_addon->Author().c_str());
-      return NULL;
-    }
-  }
-
-  // window id's 14000 - 14100 are reserved for addons
-  // get first window id that is not in use
-  int id = WINDOW_ADDON_START;
-  // if window 14099 is in use it means addon can't create more windows
-  Lock();
-  if (CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_ADDON_END))
-  {
-    Unlock();
-    CLog::Log(LOGERROR, "Window_New: %s/%s - maximum number of windows reached", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return NULL;
-  }
-  while(id < WINDOW_ADDON_END && CServiceBroker::GetGUI()->GetWindowManager().GetWindow(id) != NULL) id++;
-  Unlock();
-
-  CGUIWindow *window;
-  if (!asDialog)
-    window = new CGUIAddonWindow(id, strSkinPath, guiHelper->m_addon);
-  else
-    window = new CGUIAddonWindowDialog(id, strSkinPath, guiHelper->m_addon);
-
-  Lock();
-  CServiceBroker::GetGUI()->GetWindowManager().Add(window);
-  Unlock();
-
-  window->SetCoordsRes(res);
-
-  return window;
-}
-
-void CAddonCallbacksGUI::Window_Delete(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle)
-  {
-    CLog::Log(LOGERROR, "Window_Show: %s/%s - No Window", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return;
-
-  Lock();
-  // first change to an existing window
-  if (CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow() == pAddonWindow->m_iWindowId && !g_application.m_bStop)
-  {
-    if(CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iOldWindowId))
-      CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(pAddonWindow->m_iOldWindowId);
-    else // old window does not exist anymore, switch to home
-      CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(WINDOW_HOME);
-  }
-  // Free any window properties
-  pAddonWindow->ClearProperties();
-  // free the window's resources and unload it (free all guicontrols)
-  pAddonWindow->FreeResources(true);
-
-  CServiceBroker::GetGUI()->GetWindowManager().Remove(pAddonWindow->GetID());
-  delete pAddonWindow;
-  Unlock();
-}
-
-void CAddonCallbacksGUI::Window_SetCallbacks(void *addonData, GUIHANDLE handle, GUIHANDLE clienthandle, bool (*initCB)(GUIHANDLE), bool (*clickCB)(GUIHANDLE, int), bool (*focusCB)(GUIHANDLE, int), bool (*onActionCB)(GUIHANDLE handle, int))
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  Lock();
-  pAddonWindow->m_clientHandle  = clienthandle;
-  pAddonWindow->CBOnInit        = initCB;
-  pAddonWindow->CBOnClick       = clickCB;
-  pAddonWindow->CBOnFocus       = focusCB;
-  pAddonWindow->CBOnAction      = onActionCB;
-  Unlock();
-}
-
-bool CAddonCallbacksGUI::Window_Show(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle)
-  {
-    CLog::Log(LOGERROR, "Window_Show: %s/%s - No Window", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return false;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return false;
-
-  if (pAddonWindow->m_iOldWindowId != pAddonWindow->m_iWindowId && pAddonWindow->m_iWindowId != CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow())
-    pAddonWindow->m_iOldWindowId = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow();
-
-  Lock();
-  if (pAddonWindow->IsDialog())
-    static_cast<CGUIAddonWindowDialog*>(pAddonWindow)->Show();
-  else
-    CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(pAddonWindow->m_iWindowId);
-  Unlock();
-
-  return true;
-}
-
-bool CAddonCallbacksGUI::Window_Close(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle)
-  {
-    CLog::Log(LOGERROR, "Window_Close: %s/%s - No Window", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return false;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return false;
-
-  pAddonWindow->m_bModal = false;
-  if (pAddonWindow->IsDialog())
-    static_cast<CGUIAddonWindowDialog*>(pAddonWindow)->PulseActionEvent();
-  else
-    pAddonWindow->PulseActionEvent();
-
-  Lock();
-  // if it's a dialog, we have to close it a bit different
-  if (pAddonWindow->IsDialog())
-    static_cast<CGUIAddonWindowDialog*>(pAddonWindow)->Show(false);
-  else
-    CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(pAddonWindow->m_iOldWindowId);
-  pAddonWindow->m_iOldWindowId = 0;
-
-  Unlock();
-
-  return true;
-}
-
-bool CAddonCallbacksGUI::Window_DoModal(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle)
-  {
-    CLog::Log(LOGERROR, "Window_DoModal: %s/%s - No Window", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return false;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return false;
-
-  pAddonWindow->m_bModal = true;
-
-  if (pAddonWindow->m_iWindowId != CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow())
-    Window_Show(addonData, handle);
-
-  return true;
-}
-
-bool CAddonCallbacksGUI::Window_SetFocusId(void *addonData, GUIHANDLE handle, int iControlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle)
-  {
-    CLog::Log(LOGERROR, "Window_SetFocusId: %s/%s - No Window", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return false;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return false;
-
-  if(!pWindow->GetControl(iControlId))
-  {
-    CLog::Log(LOGERROR, "Window_SetFocusId: %s/%s - Control does not exist in window", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return false;
-  }
-
-  Lock();
-  CGUIMessage msg = CGUIMessage(GUI_MSG_SETFOCUS, pAddonWindow->m_iWindowId, iControlId);
-  pWindow->OnMessage(msg);
-  Unlock();
-
-  return true;
-}
-
-int CAddonCallbacksGUI::Window_GetFocusId(void *addonData, GUIHANDLE handle)
-{
-  int iControlId = -1;
-
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return iControlId;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle)
-  {
-    CLog::Log(LOGERROR, "Window_GetFocusId: %s/%s - No Window", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return iControlId;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return iControlId;
-
-  Lock();
-  iControlId = pWindow->GetFocusedControlID();
-  Unlock();
-
-  if (iControlId == -1)
-  {
-    CLog::Log(LOGERROR, "Window_GetFocusId: %s/%s - No control in this window has focus", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return iControlId;
-  }
-
-  return iControlId;
-}
-
-bool CAddonCallbacksGUI::Window_SetCoordinateResolution(void *addonData, GUIHANDLE handle, int res)
-{
-  CLog::Log(LOGERROR, "SetCoordinateResolution: not implemented");
-  return false;
-}
-
-void CAddonCallbacksGUI::Window_SetProperty(void *addonData, GUIHANDLE handle, const char *key, const char *value)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle || !key || !value)
-  {
-    CLog::Log(LOGERROR, "Window_SetProperty: %s/%s - No Window or NULL key or value", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return;
-
-  std::string lowerKey = key;
-  StringUtils::ToLower(lowerKey);
-
-  Lock();
-  pWindow->SetProperty(lowerKey, value);
-  Unlock();
-}
-
-void CAddonCallbacksGUI::Window_SetPropertyInt(void *addonData, GUIHANDLE handle, const char *key, int value)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle || !key)
-  {
-    CLog::Log(LOGERROR, "Window_SetPropertyInt: %s/%s - No Window or NULL key", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return;
-
-  std::string lowerKey = key;
-  StringUtils::ToLower(lowerKey);
-
-  Lock();
-  pWindow->SetProperty(lowerKey, value);
-  Unlock();
-}
-
-void CAddonCallbacksGUI::Window_SetPropertyBool(void *addonData, GUIHANDLE handle, const char *key, bool value)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle || !key)
-  {
-    CLog::Log(LOGERROR, "Window_SetPropertyBool: %s/%s - No Window or NULL key", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return;
-
-  std::string lowerKey = key;
-  StringUtils::ToLower(lowerKey);
-
-  Lock();
-  pWindow->SetProperty(lowerKey, value);
-  Unlock();
-}
-
-void CAddonCallbacksGUI::Window_SetPropertyDouble(void *addonData, GUIHANDLE handle, const char *key, double value)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle || !key)
-  {
-    CLog::Log(LOGERROR, "Window_SetPropertyDouble: %s/%s - No Window or NULL key", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return;
-
-  std::string lowerKey = key;
-  StringUtils::ToLower(lowerKey);
-
-  Lock();
-  pWindow->SetProperty(lowerKey, value);
-  Unlock();
-}
-
-const char* CAddonCallbacksGUI::Window_GetProperty(void *addonData, GUIHANDLE handle, const char *key)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return NULL;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle || !key)
-  {
-    CLog::Log(LOGERROR, "Window_GetProperty: %s/%s - No Window or NULL key", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return NULL;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return NULL;
-
-  std::string lowerKey = key;
-  StringUtils::ToLower(lowerKey);
-
-  Lock();
-  std::string value = pWindow->GetProperty(lowerKey).asString();
-  Unlock();
-
-  return strdup(value.c_str());
-}
-
-int CAddonCallbacksGUI::Window_GetPropertyInt(void *addonData, GUIHANDLE handle, const char *key)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return -1;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle || !key)
-  {
-    CLog::Log(LOGERROR, "Window_GetPropertyInt: %s/%s - No Window or NULL key", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return -1;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return -1;
-
-  std::string lowerKey = key;
-  StringUtils::ToLower(lowerKey);
-
-  Lock();
-  int value = (int)pWindow->GetProperty(lowerKey).asInteger();
-  Unlock();
-
-  return value;
-}
-
-bool CAddonCallbacksGUI::Window_GetPropertyBool(void *addonData, GUIHANDLE handle, const char *key)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return false;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle || !key)
-  {
-    CLog::Log(LOGERROR, "Window_GetPropertyBool: %s/%s - No Window or NULL key", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return false;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return false;
-
-  std::string lowerKey = key;
-  StringUtils::ToLower(lowerKey);
-
-  Lock();
-  bool value = pWindow->GetProperty(lowerKey).asBoolean();
-  Unlock();
-
-  return value;
-}
-
-double CAddonCallbacksGUI::Window_GetPropertyDouble(void *addonData, GUIHANDLE handle, const char *key)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return 0.0;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle || !key)
-  {
-    CLog::Log(LOGERROR, "Window_GetPropertyDouble: %s/%s - No Window or NULL key", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return 0.0;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return 0.0;
-
-  std::string lowerKey = key;
-  StringUtils::ToLower(lowerKey);
-
-  Lock();
-  double value = pWindow->GetProperty(lowerKey).asDouble();
-  Unlock();
-
-  return value;
-}
-
-void CAddonCallbacksGUI::Window_ClearProperties(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-
-  if (!handle)
-  {
-    CLog::Log(LOGERROR, "Window_ClearProperties: %s/%s - No Window", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return;
-  }
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIWindow      *pWindow      = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(pAddonWindow->m_iWindowId);
-  if (!pWindow)
-    return;
-
-  Lock();
-  pWindow->ClearProperties();
-  Unlock();
-}
-
-int CAddonCallbacksGUI::Window_GetListSize(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return -1;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  Lock();
-  int listSize = pAddonWindow->GetListSize();
-  Unlock();
-
-  return listSize;
-}
-
-void CAddonCallbacksGUI::Window_ClearList(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  Lock();
-  pAddonWindow->ClearList();
-  Unlock();
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_AddItem(void *addonData, GUIHANDLE handle, GUIHANDLE item, int itemPosition)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle || !item)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CFileItemPtr pItem(static_cast<CFileItem*>(item));
-  Lock();
-  pAddonWindow->AddItem(pItem, itemPosition);
-  Unlock();
-
-  return item;
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_AddStringItem(void *addonData, GUIHANDLE handle, const char *itemName, int itemPosition)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle || !itemName)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CFileItemPtr item(new CFileItem(itemName));
-  Lock();
-  pAddonWindow->AddItem(item, itemPosition);
-  Unlock();
-
-  return item.get();
-}
-
-void CAddonCallbacksGUI::Window_RemoveItem(void *addonData, GUIHANDLE handle, int itemPosition)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  Lock();
-  pAddonWindow->RemoveItem(itemPosition);
-  Unlock();
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_GetListItem(void *addonData, GUIHANDLE handle, int listPos)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CAddonCallbacksGUI* guiHelper = static_cast<CAddonCallbacksGUI*>(helper->GUILib_GetHelper());
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  Lock();
-  CFileItemPtr fi = pAddonWindow->GetListItem(listPos);
-  if (fi == NULL)
-  {
-    Unlock();
-    CLog::Log(LOGERROR, "Window_GetListItem: %s/%s - Index out of range", CAddonInfo::TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
-    return NULL;
-  }
-  Unlock();
-
-  return fi.get();
-}
-
-void CAddonCallbacksGUI::Window_SetCurrentListPosition(void *addonData, GUIHANDLE handle, int listPos)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  Lock();
-  pAddonWindow->SetCurrentListPosition(listPos);
-  Unlock();
-}
-
-int CAddonCallbacksGUI::Window_GetCurrentListPosition(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return -1;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  Lock();
-  int listPos = pAddonWindow->GetCurrentListPosition();
-  Unlock();
-
-  return listPos;
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Spin(void *addonData, GUIHANDLE handle, int controlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIControl* pGUIControl = pAddonWindow->GetControl(controlId);
-  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_SPINEX)
-    return NULL;
-
-  return pGUIControl;
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Button(void *addonData, GUIHANDLE handle, int controlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIControl* pGUIControl = pAddonWindow->GetControl(controlId);
-  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_BUTTON)
-    return NULL;
-
-  return pGUIControl;
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_GetControl_RadioButton(void *addonData, GUIHANDLE handle, int controlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIControl* pGUIControl = pAddonWindow->GetControl(controlId);
-  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_RADIO)
-    return NULL;
-
-  return pGUIControl;
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Edit(void *addonData, GUIHANDLE handle, int controlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIControl* pGUIControl = pAddonWindow->GetControl(controlId);
-  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_EDIT)
-    return NULL;
-
-  return pGUIControl;
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Progress(void *addonData, GUIHANDLE handle, int controlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIControl* pGUIControl = pAddonWindow->GetControl(controlId);
-  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_PROGRESS)
-    return NULL;
-
-  return pGUIControl;
-}
-
-GUIHANDLE CAddonCallbacksGUI::Window_GetControl_RenderAddon(void *addonData, GUIHANDLE handle, int controlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIControl* pGUIControl = pAddonWindow->GetControl(controlId);
-  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_RENDERADDON)
-    return NULL;
-
-  CGUIAddonRenderingControl *pProxyControl;
-  pProxyControl = new CGUIAddonRenderingControl(static_cast<CGUIRenderingControl*>(pGUIControl));
-  return pProxyControl;
-}
-
-void CAddonCallbacksGUI::Window_SetControlLabel(void *addonData, GUIHANDLE handle, int controlId, const char *label)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  CGUIMessage msg(GUI_MSG_LABEL_SET, pAddonWindow->m_iWindowId, controlId);
-  msg.SetLabel(label);
-  pAddonWindow->OnMessage(msg);
-}
-
-void CAddonCallbacksGUI::Window_MarkDirtyRegion(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-
-  pAddonWindow->MarkDirtyRegion();
-}
-
-void CAddonCallbacksGUI::Control_Spin_SetVisible(void *addonData, GUIHANDLE spinhandle, bool yesNo)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !spinhandle)
-    return;
-
-  CGUISpinControlEx *pSpin = static_cast<CGUISpinControlEx*>(spinhandle);
-  pSpin->SetVisible(yesNo);
-}
-
-void CAddonCallbacksGUI::Control_Spin_SetText(void *addonData, GUIHANDLE spinhandle, const char *label)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !spinhandle)
-    return;
-
-  CGUISpinControlEx *pSpin = static_cast<CGUISpinControlEx*>(spinhandle);
-  pSpin->SetText(label);
-}
-
-void CAddonCallbacksGUI::Control_Spin_Clear(void *addonData, GUIHANDLE spinhandle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !spinhandle)
-    return;
-
-  CGUISpinControlEx *pSpin = static_cast<CGUISpinControlEx*>(spinhandle);
-  pSpin->Clear();
-}
-
-void CAddonCallbacksGUI::Control_Spin_AddLabel(void *addonData, GUIHANDLE spinhandle, const char *label, int iValue)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !spinhandle)
-    return;
-
-  CGUISpinControlEx *pSpin = static_cast<CGUISpinControlEx*>(spinhandle);
-  pSpin->AddLabel(label, iValue);
-}
-
-int CAddonCallbacksGUI::Control_Spin_GetValue(void *addonData, GUIHANDLE spinhandle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !spinhandle)
-    return -1;
-
-  CGUISpinControlEx *pSpin = static_cast<CGUISpinControlEx*>(spinhandle);
-  return pSpin->GetValue();
-}
-
-void CAddonCallbacksGUI::Control_Spin_SetValue(void *addonData, GUIHANDLE spinhandle, int iValue)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !spinhandle)
-    return;
-
-  CGUISpinControlEx *pSpin = static_cast<CGUISpinControlEx*>(spinhandle);
-  pSpin->SetValue(iValue);
-}
-
-void CAddonCallbacksGUI::Control_RadioButton_SetVisible(void *addonData, GUIHANDLE handle, bool yesNo)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIRadioButtonControl *pRadioButton = static_cast<CGUIRadioButtonControl*>(handle);
-  pRadioButton->SetVisible(yesNo);
-}
-
-void CAddonCallbacksGUI::Control_RadioButton_SetText(void *addonData, GUIHANDLE handle, const char *label)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIRadioButtonControl *pRadioButton = static_cast<CGUIRadioButtonControl*>(handle);
-  pRadioButton->SetLabel(label);
-}
-
-void CAddonCallbacksGUI::Control_RadioButton_SetSelected(void *addonData, GUIHANDLE handle, bool yesNo)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIRadioButtonControl *pRadioButton = static_cast<CGUIRadioButtonControl*>(handle);
-  pRadioButton->SetSelected(yesNo);
-}
-
-bool CAddonCallbacksGUI::Control_RadioButton_IsSelected(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return false;
-
-  CGUIRadioButtonControl *pRadioButton = static_cast<CGUIRadioButtonControl*>(handle);
-  return pRadioButton->IsSelected();
-}
-
-void CAddonCallbacksGUI::Control_Progress_SetPercentage(void *addonData, GUIHANDLE handle, float fPercent)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIProgressControl *pControl = static_cast<CGUIProgressControl*>(handle);
-  pControl->SetPercentage(fPercent);
-}
-
-float CAddonCallbacksGUI::Control_Progress_GetPercentage(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return 0.0;
-
-  CGUIProgressControl *pControl = static_cast<CGUIProgressControl*>(handle);
-  return pControl->GetPercentage();
-}
-
-void CAddonCallbacksGUI::Control_Progress_SetInfo(void *addonData, GUIHANDLE handle, int iInfo)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIProgressControl *pControl = static_cast<CGUIProgressControl*>(handle);
-  pControl->SetInfo(iInfo);
-}
-
-int CAddonCallbacksGUI::Control_Progress_GetInfo(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return -1;
-
-  CGUIProgressControl *pControl = static_cast<CGUIProgressControl*>(handle);
-  return pControl->GetInfo();
-}
-
-const char* CAddonCallbacksGUI::Control_Progress_GetDescription(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIProgressControl *pControl = static_cast<CGUIProgressControl*>(handle);
-  std::string string = pControl->GetDescription();
-
-  char *buffer = (char*) malloc (string.length()+1);
-  strcpy(buffer, string.c_str());
-  return buffer;
-}
-
-/*
- * GUI slider control callback functions
- */
-GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Slider(void *addonData, GUIHANDLE handle, int controlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIControl* pGUIControl = pAddonWindow->GetControl(controlId);
-  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_SLIDER)
-    return NULL;
-
-  return pGUIControl;
-}
-
-void CAddonCallbacksGUI::Control_Slider_SetVisible(void *addonData, GUIHANDLE handle, bool yesNo)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIControl *pControl = static_cast<CGUIControl*>(handle);
-  pControl->SetVisible(yesNo);
-}
-
-const char* CAddonCallbacksGUI::Control_Slider_GetDescription(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  std::string string = pControl->GetDescription();
-
-  char *buffer = (char*) malloc (string.length()+1);
-  strcpy(buffer, string.c_str());
-  return buffer;
-}
-
-void CAddonCallbacksGUI::Control_Slider_SetIntRange(void *addonData, GUIHANDLE handle, int iStart, int iEnd)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  pControl->SetRange(iStart, iEnd);
-}
-
-void CAddonCallbacksGUI::Control_Slider_SetIntValue(void *addonData, GUIHANDLE handle, int iValue)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  pControl->SetType(SPIN_CONTROL_TYPE_INT);
-  pControl->SetIntValue(iValue);
-}
-
-int CAddonCallbacksGUI::Control_Slider_GetIntValue(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return 0;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  return pControl->GetIntValue();
-}
-
-void CAddonCallbacksGUI::Control_Slider_SetIntInterval(void *addonData, GUIHANDLE handle, int iInterval)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  pControl->SetIntInterval(iInterval);
-}
-
-void CAddonCallbacksGUI::Control_Slider_SetPercentage(void *addonData, GUIHANDLE handle, float fPercent)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  pControl->SetType(SPIN_CONTROL_TYPE_FLOAT);
-  pControl->SetPercentage(fPercent);
-}
-
-float CAddonCallbacksGUI::Control_Slider_GetPercentage(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return 0.0f;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  return pControl->GetPercentage();
-}
-
-void CAddonCallbacksGUI::Control_Slider_SetFloatRange(void *addonData, GUIHANDLE handle, float fStart, float fEnd)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  pControl->SetFloatRange(fStart, fEnd);
-}
-
-void CAddonCallbacksGUI::Control_Slider_SetFloatValue(void *addonData, GUIHANDLE handle, float iValue)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  pControl->SetType(SPIN_CONTROL_TYPE_FLOAT);
-  pControl->SetFloatValue(iValue);
-}
-
-float CAddonCallbacksGUI::Control_Slider_GetFloatValue(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return 0.0f;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  return pControl->GetFloatValue();
-}
-
-void CAddonCallbacksGUI::Control_Slider_SetFloatInterval(void *addonData, GUIHANDLE handle, float fInterval)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISliderControl *pControl = static_cast<CGUISliderControl*>(handle);
-  pControl->SetFloatInterval(fInterval);
-}
-
-/*
- * GUI settings slider control callback functions
- */
-GUIHANDLE CAddonCallbacksGUI::Window_GetControl_SettingsSlider(void *addonData, GUIHANDLE handle, int controlId)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUIAddonWindow *pAddonWindow = static_cast<CGUIAddonWindow*>(handle);
-  CGUIControl* pGUIControl = pAddonWindow->GetControl(controlId);
-  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_SETTINGS_SLIDER)
-    return NULL;
-
-  return pGUIControl;
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetVisible(void *addonData, GUIHANDLE handle, bool yesNo)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIControl *pControl = static_cast<CGUIControl*>(handle);
-  pControl->SetVisible(yesNo);
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetText(void *addonData, GUIHANDLE handle, const char *label)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  pControl->SetText(label);
-}
-
-const char* CAddonCallbacksGUI::Control_SettingsSlider_GetDescription(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  std::string string = pControl->GetDescription();
-
-  char *buffer = (char*) malloc (string.length()+1);
-  strcpy(buffer, string.c_str());
-  return buffer;
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetIntRange(void *addonData, GUIHANDLE handle, int iStart, int iEnd)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  pControl->SetRange(iStart, iEnd);
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetIntValue(void *addonData, GUIHANDLE handle, int iValue)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  pControl->SetType(SPIN_CONTROL_TYPE_INT);
-  pControl->SetIntValue(iValue);
-}
-
-int CAddonCallbacksGUI::Control_SettingsSlider_GetIntValue(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return 0;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  return pControl->GetIntValue();
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetIntInterval(void *addonData, GUIHANDLE handle, int iInterval)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  pControl->SetIntInterval(iInterval);
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetPercentage(void *addonData, GUIHANDLE handle, float fPercent)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  pControl->SetType(SPIN_CONTROL_TYPE_FLOAT);
-  pControl->SetPercentage(fPercent);
-}
-
-float CAddonCallbacksGUI::Control_SettingsSlider_GetPercentage(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return 0.0f;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  return pControl->GetPercentage();
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetFloatRange(void *addonData, GUIHANDLE handle, float fStart, float fEnd)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  pControl->SetFloatRange(fStart, fEnd);
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetFloatValue(void *addonData, GUIHANDLE handle, float fValue)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  pControl->SetType(SPIN_CONTROL_TYPE_FLOAT);
-  pControl->SetFloatValue(fValue);
-}
-
-float CAddonCallbacksGUI::Control_SettingsSlider_GetFloatValue(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return 0.0f;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  return pControl->GetFloatValue();
-}
-
-void CAddonCallbacksGUI::Control_SettingsSlider_SetFloatInterval(void *addonData, GUIHANDLE handle, float fInterval)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUISettingsSliderControl *pControl = static_cast<CGUISettingsSliderControl*>(handle);
-  pControl->SetFloatInterval(fInterval);
-}
-
-/*
- * GUI list item control callback functions
- */
-GUIHANDLE CAddonCallbacksGUI::ListItem_Create(void *addonData, const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper)
-    return NULL;
-
-  // create CFileItem
-  CFileItem *pItem = new CFileItem();
-  if (!pItem)
-    return NULL;
-
-  if (label)
-    pItem->SetLabel(label);
-  if (label2)
-    pItem->SetLabel2(label2);
-  if (iconImage)
-    pItem->SetArt("icon", iconImage);
-  if (thumbnailImage)
-    pItem->SetArt("thumb", thumbnailImage);
-  if (path)
-    pItem->SetPath(path);
-
-  return pItem;
-}
-
-const char* CAddonCallbacksGUI::ListItem_GetLabel(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  std::string string = static_cast<CFileItem*>(handle)->GetLabel();
-  char *buffer = (char*) malloc (string.length()+1);
-  strcpy(buffer, string.c_str());
-  return buffer;
-}
-
-void CAddonCallbacksGUI::ListItem_SetLabel(void *addonData, GUIHANDLE handle, const char *label)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  static_cast<CFileItem*>(handle)->SetLabel(label);
-}
-
-const char* CAddonCallbacksGUI::ListItem_GetLabel2(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  std::string string = static_cast<CFileItem*>(handle)->GetLabel2();
-
-  char *buffer = (char*) malloc (string.length()+1);
-  strcpy(buffer, string.c_str());
-  return buffer;
-}
-
-void CAddonCallbacksGUI::ListItem_SetLabel2(void *addonData, GUIHANDLE handle, const char *label)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  static_cast<CFileItem*>(handle)->SetLabel2(label);
-}
-
-void CAddonCallbacksGUI::ListItem_SetInfo(void *addonData, GUIHANDLE handle, const char *info)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-}
-
-void CAddonCallbacksGUI::ListItem_SetProperty(void *addonData, GUIHANDLE handle, const char *key, const char *value)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  static_cast<CFileItem*>(handle)->SetProperty(key, value);
-}
-
-const char* CAddonCallbacksGUI::ListItem_GetProperty(void *addonData, GUIHANDLE handle, const char *key)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return NULL;
-
-  std::string string = static_cast<CFileItem*>(handle)->GetProperty(key).asString();
-  char *buffer = (char*) malloc (string.length()+1);
-  strcpy(buffer, string.c_str());
-  return buffer;
-}
-
-void CAddonCallbacksGUI::ListItem_SetPath(void *addonData, GUIHANDLE handle, const char *path)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  static_cast<CFileItem*>(handle)->SetPath(path);
-}
-
-void CAddonCallbacksGUI::RenderAddon_SetCallbacks(void *addonData, GUIHANDLE handle, GUIHANDLE clienthandle, bool (*createCB)(GUIHANDLE,int,int,int,int,void*), void (*renderCB)(GUIHANDLE), void (*stopCB)(GUIHANDLE), bool (*dirtyCB)(GUIHANDLE))
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIAddonRenderingControl *pAddonControl = static_cast<CGUIAddonRenderingControl*>(handle);
-
-  Lock();
-  pAddonControl->m_clientHandle  = clienthandle;
-  pAddonControl->CBCreate        = createCB;
-  pAddonControl->CBRender        = renderCB;
-  pAddonControl->CBStop          = stopCB;
-  pAddonControl->CBDirty         = dirtyCB;
-  Unlock();
-
-  pAddonControl->m_pControl->InitCallback(pAddonControl);
-}
-
-void CAddonCallbacksGUI::RenderAddon_Delete(void *addonData, GUIHANDLE handle)
-{
-  CAddonInterfaces* helper = (CAddonInterfaces*) addonData;
-  if (!helper || !handle)
-    return;
-
-  CGUIAddonRenderingControl *pAddonControl = static_cast<CGUIAddonRenderingControl*>(handle);
-
-  Lock();
-  pAddonControl->Delete();
-  Unlock();
-}
-
-/*! @name GUI Keyboard functions */
-//@{
-bool CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetInputWithHead(char &aTextString, unsigned int iMaxStringSize, const char *strHeading, bool allowEmptyResult, bool hiddenInput, unsigned int autoCloseMs)
-{
-  std::string str = &aTextString;
-  bool bRet = CGUIKeyboardFactory::ShowAndGetInput(str, CVariant{strHeading}, allowEmptyResult, hiddenInput, autoCloseMs);
-  if (bRet)
-    strncpy(&aTextString, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetInput(char &aTextString, unsigned int iMaxStringSize, bool allowEmptyResult, unsigned int autoCloseMs)
-{
-  std::string str = &aTextString;
-  bool bRet = CGUIKeyboardFactory::ShowAndGetInput(str, allowEmptyResult, autoCloseMs);
-  if (bRet)
-    strncpy(&aTextString, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetNewPasswordWithHead(char &strNewPassword, unsigned int iMaxStringSize, const char *strHeading, bool allowEmptyResult, unsigned int autoCloseMs)
-{
-  std::string str = &strNewPassword;
-  bool bRet = CGUIKeyboardFactory::ShowAndGetNewPassword(str, strHeading, allowEmptyResult, autoCloseMs);
-  if (bRet)
-    strncpy(&strNewPassword, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetNewPassword(char &strNewPassword, unsigned int iMaxStringSize, unsigned int autoCloseMs)
-{
-  std::string str = &strNewPassword;
-  bool bRet = CGUIKeyboardFactory::ShowAndGetNewPassword(str, autoCloseMs);
-  if (bRet)
-    strncpy(&strNewPassword, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Keyboard_ShowAndVerifyNewPasswordWithHead(char &strNewPassword, unsigned int iMaxStringSize, const char *strHeading, bool allowEmptyResult, unsigned int autoCloseMs)
-{
-  std::string str = &strNewPassword;
-  bool bRet = CGUIKeyboardFactory::ShowAndVerifyNewPassword(str, strHeading, allowEmptyResult, autoCloseMs);
-  if (bRet)
-    strncpy(&strNewPassword, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Keyboard_ShowAndVerifyNewPassword(char &strNewPassword, unsigned int iMaxStringSize, unsigned int autoCloseMs)
-{
-  std::string str = &strNewPassword;
-  bool bRet = CGUIKeyboardFactory::ShowAndVerifyNewPassword(str, autoCloseMs);
-  if (bRet)
-    strncpy(&strNewPassword, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-int CAddonCallbacksGUI::Dialog_Keyboard_ShowAndVerifyPassword(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, int iRetries, unsigned int autoCloseMs)
-{
-  std::string str = &strPassword;
-  int iRet = CGUIKeyboardFactory::ShowAndVerifyPassword(str, strHeading, iRetries, autoCloseMs);
-  if (iRet)
-    strncpy(&strPassword, str.c_str(), iMaxStringSize);
-  return iRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Keyboard_ShowAndGetFilter(char &aTextString, unsigned int iMaxStringSize, bool searching, unsigned int autoCloseMs)
-{
-  std::string strText = &aTextString;
-  bool bRet = CGUIKeyboardFactory::ShowAndGetFilter(strText, searching, autoCloseMs);
-  if (bRet)
-    strncpy(&aTextString, strText.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Keyboard_SendTextToActiveKeyboard(const char *aTextString, bool closeKeyboard)
-{
-  return CGUIKeyboardFactory::SendTextToActiveKeyboard(aTextString, closeKeyboard);
-}
-
-bool CAddonCallbacksGUI::Dialog_Keyboard_isKeyboardActivated()
-{
-  return CGUIKeyboardFactory::isKeyboardActivated();
-}
-//@}
-
-/*! @name GUI Numeric functions */
-//@{
-bool CAddonCallbacksGUI::Dialog_Numeric_ShowAndVerifyNewPassword(char &strNewPassword, unsigned int iMaxStringSize)
-{
-  std::string str = &strNewPassword;
-  bool bRet = CGUIDialogNumeric::ShowAndVerifyNewPassword(str);
-  if (bRet)
-    strncpy(&strNewPassword, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-int CAddonCallbacksGUI::Dialog_Numeric_ShowAndVerifyPassword(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, int iRetries)
-{
-  std::string str = &strPassword;
-  int bRet = CGUIDialogNumeric::ShowAndVerifyPassword(str, strHeading, iRetries);
-  if (bRet)
-    strncpy(&strPassword, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Numeric_ShowAndVerifyInput(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, bool bGetUserInput)
-{
-  std::string str = &strPassword;
-  if (CGUIDialogNumeric::ShowAndVerifyInput(str, strHeading, bGetUserInput) == InputVerificationResult::SUCCESS)
-  {
-    strncpy(&strPassword, str.c_str(), iMaxStringSize);
-    return true;
-  }
-  return false;
-}
-
-bool CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetTime(tm &time, const char *strHeading)
-{
-  KODI::TIME::SystemTime systemTime;
-  CDateTime dateTime(time);
-  dateTime.GetAsSystemTime(systemTime);
-  if (CGUIDialogNumeric::ShowAndGetTime(systemTime, strHeading))
-  {
-    dateTime = systemTime;
-    dateTime.GetAsTm(time);
-    return true;
-  }
-  return false;
-}
-
-bool CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetDate(tm &date, const char *strHeading)
-{
-  KODI::TIME::SystemTime systemTime;
-  CDateTime dateTime(date);
-  dateTime.GetAsSystemTime(systemTime);
-  if (CGUIDialogNumeric::ShowAndGetDate(systemTime, strHeading))
-  {
-    dateTime = systemTime;
-    dateTime.GetAsTm(date);
-    return true;
-  }
-  return false;
-}
-
-bool CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetIPAddress(char &strIPAddress, unsigned int iMaxStringSize, const char *strHeading)
-{
-  std::string strIP = &strIPAddress;
-  bool bRet = CGUIDialogNumeric::ShowAndGetIPAddress(strIP, strHeading);
-  if (bRet)
-    strncpy(&strIPAddress, strIP.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetNumber(char &strInput, unsigned int iMaxStringSize, const char *strHeading, unsigned int iAutoCloseTimeoutMs)
-{
-  std::string str = &strInput;
-  bool bRet = CGUIDialogNumeric::ShowAndGetNumber(str, strHeading, iAutoCloseTimeoutMs);
-  if (bRet)
-    strncpy(&strInput, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-
-bool CAddonCallbacksGUI::Dialog_Numeric_ShowAndGetSeconds(char &timeString, unsigned int iMaxStringSize, const char *strHeading)
-{
-  std::string str = &timeString;
-  bool bRet = CGUIDialogNumeric::ShowAndGetSeconds(str, strHeading);
-  if (bRet)
-    strncpy(&timeString, str.c_str(), iMaxStringSize);
-  return bRet;
-}
-//@}
-
-/*! @name GUI File browser functions */
-//@{
-bool CAddonCallbacksGUI::Dialog_FileBrowser_ShowAndGetFile(const char *directory, const char *mask, const char *heading, char &path, unsigned int iMaxStringSize, bool useThumbs, bool useFileDirectories, bool singleList)
-{
-  std::string strPath = &path;
-  bool bRet = CGUIDialogFileBrowser::ShowAndGetFile(directory, mask, heading, strPath, useThumbs, useFileDirectories, singleList);
-  if (bRet)
-    strncpy(&path, strPath.c_str(), iMaxStringSize);
-  return bRet;
-}
-//@}
-
-/*! @name GUI OK Dialog */
-//@{
-void CAddonCallbacksGUI::Dialog_OK_ShowAndGetInputSingleText(const char *heading, const char *text)
-{
-  HELPERS::ShowOKDialogText(CVariant{heading}, CVariant{text});
-}
-
-void CAddonCallbacksGUI::Dialog_OK_ShowAndGetInputLineText(const char *heading, const char *line0, const char *line1, const char *line2)
-{
-  HELPERS::ShowOKDialogLines(CVariant{heading}, CVariant{line0}, CVariant{line1}, CVariant{line2});
-}
-//@}
-
-/*! @name GUI Yes No Dialog */
-//@{
-bool CAddonCallbacksGUI::Dialog_YesNo_ShowAndGetInputSingleText(const char *heading, const char *text, bool& bCanceled, const char *noLabel, const char *yesLabel)
-{
-  DialogResponse result = HELPERS::ShowYesNoDialogText(heading, text, noLabel, yesLabel);
-  bCanceled = result == DialogResponse::CANCELLED;
-  return result == DialogResponse::YES;
-}
-
-bool CAddonCallbacksGUI::Dialog_YesNo_ShowAndGetInputLineText(const char *heading, const char *line0, const char *line1, const char *line2, const char *noLabel, const char *yesLabel)
-{
-  return HELPERS::ShowYesNoDialogLines(heading, line0, line1, line2, noLabel, yesLabel) ==
-    DialogResponse::YES;
-}
-
-bool CAddonCallbacksGUI::Dialog_YesNo_ShowAndGetInputLineButtonText(const char *heading, const char *line0, const char *line1, const char *line2, bool &bCanceled, const char *noLabel, const char *yesLabel)
-{
-  DialogResponse result = HELPERS::ShowYesNoDialogLines(heading, line0, line1, line2, noLabel, yesLabel);
-  bCanceled = result == DialogResponse::CANCELLED;
-  return result == DialogResponse::YES;
-}
-//@}
-
-/*! @name GUI Text viewer Dialog */
-//@{
-void CAddonCallbacksGUI::Dialog_TextViewer(const char *heading, const char *text)
-{
-  CGUIDialogTextViewer* pDialog = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogTextViewer>(WINDOW_DIALOG_TEXT_VIEWER);
-  pDialog->SetHeading(heading);
-  pDialog->SetText(text);
-  pDialog->Open();
-}
-//@}
-
-/*! @name GUI select Dialog */
-//@{
-int CAddonCallbacksGUI::Dialog_Select(const char *heading, const char *entries[], unsigned int size, int selected)
-{
-  CGUIDialogSelect* pDialog = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogSelect>(WINDOW_DIALOG_SELECT);
-  pDialog->Reset();
-  pDialog->SetHeading(CVariant{heading});
-
-  for (unsigned int i = 0; i < size; i++)
-    pDialog->Add(entries[i]);
-
-  if (selected > 0)
-    pDialog->SetSelected(selected);
-
-  pDialog->Open();
-  return pDialog->GetSelectedItem();
-}
-//@}
-
-} /* namespace GUI */
-} /* namespace KodiAPI */
diff --git a/xbmc/addons/interfaces/gui/AddonCallbacksGUI.h b/xbmc/addons/interfaces/gui/AddonCallbacksGUI.h
deleted file mode 100644
index c6b98e465e6d..000000000000
--- a/xbmc/addons/interfaces/gui/AddonCallbacksGUI.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- *  Copyright (C) 2012-2018 Team Kodi
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include "addons/interfaces/AddonInterfaces.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/libKODI_guilib.h"
-
-namespace ADDON
-{
-  class CAddon;
-}
-
-namespace KodiAPI
-{
-namespace GUI
-{
-
-class CAddonCallbacksGUI
-{
-public:
-  explicit CAddonCallbacksGUI(ADDON::CAddon* addon);
-  virtual ~CAddonCallbacksGUI();
-
-  /**! \name General Functions */
-  CB_GUILib *GetCallbacks() { return m_callbacks; }
-
-  static void         Lock();
-  static void         Unlock();
-  static int          GetScreenHeight();
-  static int          GetScreenWidth();
-  static int          GetVideoResolution();
-
-  static GUIHANDLE    Window_New(void *addonData, const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog);
-  static void         Window_Delete(void *addonData, GUIHANDLE handle);
-  static void         Window_SetCallbacks(void *addonData, GUIHANDLE handle, GUIHANDLE clienthandle, bool (*initCB)(GUIHANDLE), bool (*clickCB)(GUIHANDLE, int), bool (*focusCB)(GUIHANDLE, int), bool (*onActionCB)(GUIHANDLE handle, int));
-  static bool         Window_Show(void *addonData, GUIHANDLE handle);
-  static bool         Window_Close(void *addonData, GUIHANDLE handle);
-  static bool         Window_DoModal(void *addonData, GUIHANDLE handle);
-  static bool         Window_SetFocusId(void *addonData, GUIHANDLE handle, int iControlId);
-  static int          Window_GetFocusId(void *addonData, GUIHANDLE handle);
-  static bool         Window_SetCoordinateResolution(void *addonData, GUIHANDLE handle, int res);
-  static void         Window_SetProperty(void *addonData, GUIHANDLE handle, const char *key, const char *value);
-  static void         Window_SetPropertyInt(void *addonData, GUIHANDLE handle, const char *key, int value);
-  static void         Window_SetPropertyBool(void *addonData, GUIHANDLE handle, const char *key, bool value);
-  static void         Window_SetPropertyDouble(void *addonData, GUIHANDLE handle, const char *key, double value);
-  static const char * Window_GetProperty(void *addonData, GUIHANDLE handle, const char *key);
-  static int          Window_GetPropertyInt(void *addonData, GUIHANDLE handle, const char *key);
-  static bool         Window_GetPropertyBool(void *addonData, GUIHANDLE handle, const char *key);
-  static double       Window_GetPropertyDouble(void *addonData, GUIHANDLE handle, const char *key);
-  static void         Window_ClearProperties(void *addonData, GUIHANDLE handle);
-  static int          Window_GetListSize(void *addonData, GUIHANDLE handle);
-  static void         Window_ClearList(void *addonData, GUIHANDLE handle);
-  static GUIHANDLE    Window_AddItem(void *addonData, GUIHANDLE handle, GUIHANDLE item, int itemPosition);
-  static GUIHANDLE    Window_AddStringItem(void *addonData, GUIHANDLE handle, const char *itemName, int itemPosition);
-  static void         Window_RemoveItem(void *addonData, GUIHANDLE handle, int itemPosition);
-  static GUIHANDLE    Window_GetListItem(void *addonData, GUIHANDLE handle, int listPos);
-  static void         Window_SetCurrentListPosition(void *addonData, GUIHANDLE handle, int listPos);
-  static int          Window_GetCurrentListPosition(void *addonData, GUIHANDLE handle);
-  static GUIHANDLE    Window_GetControl_Spin(void *addonData, GUIHANDLE handle, int controlId);
-  static GUIHANDLE    Window_GetControl_Button(void *addonData, GUIHANDLE handle, int controlId);
-  static GUIHANDLE    Window_GetControl_RadioButton(void *addonData, GUIHANDLE handle, int controlId);
-  static GUIHANDLE    Window_GetControl_Edit(void *addonData, GUIHANDLE handle, int controlId);
-  static GUIHANDLE    Window_GetControl_Progress(void *addonData, GUIHANDLE handle, int controlId);
-  static GUIHANDLE    Window_GetControl_RenderAddon(void *addonData, GUIHANDLE handle, int controlId);
-  static void         Window_SetControlLabel(void *addonData, GUIHANDLE handle, int controlId, const char *label);
-  static void         Window_MarkDirtyRegion(void *addonData, GUIHANDLE handle);
-  static void         Control_Spin_SetVisible(void *addonData, GUIHANDLE spinhandle, bool yesNo);
-  static void         Control_Spin_SetText(void *addonData, GUIHANDLE spinhandle, const char *label);
-  static void         Control_Spin_Clear(void *addonData, GUIHANDLE spinhandle);
-  static void         Control_Spin_AddLabel(void *addonData, GUIHANDLE spinhandle, const char *label, int iValue);
-  static int          Control_Spin_GetValue(void *addonData, GUIHANDLE spinhandle);
-  static void         Control_Spin_SetValue(void *addonData, GUIHANDLE spinhandle, int iValue);
-  static void         Control_RadioButton_SetVisible(void *addonData, GUIHANDLE handle, bool yesNo);
-  static void         Control_RadioButton_SetText(void *addonData, GUIHANDLE handle, const char *label);
-  static void         Control_RadioButton_SetSelected(void *addonData, GUIHANDLE handle, bool yesNo);
-  static bool         Control_RadioButton_IsSelected(void *addonData, GUIHANDLE handle);
-  static void         Control_Progress_SetPercentage(void *addonData, GUIHANDLE handle, float fPercent);
-  static float        Control_Progress_GetPercentage(void *addonData, GUIHANDLE handle);
-  static void         Control_Progress_SetInfo(void *addonData, GUIHANDLE handle, int iInfo);
-  static int          Control_Progress_GetInfo(void *addonData, GUIHANDLE handle);
-  static const char * Control_Progress_GetDescription(void *addonData, GUIHANDLE handle);
-
-  static GUIHANDLE    Window_GetControl_Slider(void *addonData, GUIHANDLE handle, int controlId);
-  static void         Control_Slider_SetVisible(void *addonData, GUIHANDLE handle, bool yesNo);
-  static const char * Control_Slider_GetDescription(void *addonData, GUIHANDLE handle);
-  static void         Control_Slider_SetIntRange(void *addonData, GUIHANDLE handle, int iStart, int iEnd);
-  static void         Control_Slider_SetIntValue(void *addonData, GUIHANDLE handle, int iValue);
-  static int          Control_Slider_GetIntValue(void *addonData, GUIHANDLE handle);
-  static void         Control_Slider_SetIntInterval(void *addonData, GUIHANDLE handle, int iInterval);
-  static void         Control_Slider_SetPercentage(void *addonData, GUIHANDLE handle, float fPercent);
-  static float        Control_Slider_GetPercentage(void *addonData, GUIHANDLE handle);
-  static void         Control_Slider_SetFloatRange(void *addonData, GUIHANDLE handle, float fStart, float fEnd);
-  static void         Control_Slider_SetFloatValue(void *addonData, GUIHANDLE handle, float fValue);
-  static float        Control_Slider_GetFloatValue(void *addonData, GUIHANDLE handle);
-  static void         Control_Slider_SetFloatInterval(void *addonData, GUIHANDLE handle, float fInterval);
-
-  static GUIHANDLE    Window_GetControl_SettingsSlider(void *addonData, GUIHANDLE handle, int controlId);
-  static void         Control_SettingsSlider_SetVisible(void *addonData, GUIHANDLE handle, bool yesNo);
-  static void         Control_SettingsSlider_SetText(void *addonData, GUIHANDLE handle, const char *label);
-  static const char * Control_SettingsSlider_GetDescription(void *addonData, GUIHANDLE handle);
-  static void         Control_SettingsSlider_SetIntRange(void *addonData, GUIHANDLE handle, int iStart, int iEnd);
-  static void         Control_SettingsSlider_SetIntValue(void *addonData, GUIHANDLE handle, int iValue);
-  static int          Control_SettingsSlider_GetIntValue(void *addonData, GUIHANDLE handle);
-  static void         Control_SettingsSlider_SetIntInterval(void *addonData, GUIHANDLE handle, int iInterval);
-  static void         Control_SettingsSlider_SetPercentage(void *addonData, GUIHANDLE handle, float fPercent);
-  static float        Control_SettingsSlider_GetPercentage(void *addonData, GUIHANDLE handle);
-  static void         Control_SettingsSlider_SetFloatRange(void *addonData, GUIHANDLE handle, float fStart, float fEnd);
-  static void         Control_SettingsSlider_SetFloatValue(void *addonData, GUIHANDLE handle, float fValue);
-  static float        Control_SettingsSlider_GetFloatValue(void *addonData, GUIHANDLE handle);
-  static void         Control_SettingsSlider_SetFloatInterval(void *addonData, GUIHANDLE handle, float fInterval);
-
-  static GUIHANDLE    ListItem_Create(void *addonData, const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path);
-  static const char * ListItem_GetLabel(void *addonData, GUIHANDLE handle);
-  static void         ListItem_SetLabel(void *addonData, GUIHANDLE handle, const char *label);
-  static const char * ListItem_GetLabel2(void *addonData, GUIHANDLE handle);
-  static void         ListItem_SetLabel2(void *addonData, GUIHANDLE handle, const char *label);
-  static void         ListItem_SetInfo(void *addonData, GUIHANDLE handle, const char *info);
-  static void         ListItem_SetProperty(void *addonData, GUIHANDLE handle, const char *key, const char *value);
-  static const char * ListItem_GetProperty(void *addonData, GUIHANDLE handle, const char *key);
-  static void         ListItem_SetPath(void *addonData, GUIHANDLE handle, const char *path);
-  static void         RenderAddon_SetCallbacks(void *addonData, GUIHANDLE handle, GUIHANDLE clienthandle, bool (*createCB)(GUIHANDLE,int,int,int,int,void*), void (*renderCB)(GUIHANDLE), void (*stopCB)(GUIHANDLE), bool (*dirtyCB)(GUIHANDLE));
-  static void         RenderAddon_Delete(void *addonData, GUIHANDLE handle);
-  static void         RenderAddon_MarkDirty(void *addonData, GUIHANDLE handle);
-
-  static bool         Dialog_Keyboard_ShowAndGetInput(char &aTextString, unsigned int iMaxStringSize, bool allowEmptyResult, unsigned int autoCloseMs);
-  static bool         Dialog_Keyboard_ShowAndGetInputWithHead(char &aTextString, unsigned int iMaxStringSize, const char *heading, bool allowEmptyResult, bool hiddenInput, unsigned int autoCloseMs);
-  static bool         Dialog_Keyboard_ShowAndGetNewPassword(char &strNewPassword, unsigned int iMaxStringSize, unsigned int autoCloseMs);
-  static bool         Dialog_Keyboard_ShowAndGetNewPasswordWithHead(char &newPassword, unsigned int iMaxStringSize, const char *strHeading, bool allowEmptyResult, unsigned int autoCloseMs);
-  static bool         Dialog_Keyboard_ShowAndVerifyNewPassword(char &strNewPassword, unsigned int iMaxStringSize, unsigned int autoCloseMs);
-  static bool         Dialog_Keyboard_ShowAndVerifyNewPasswordWithHead(char &strNewPassword, unsigned int iMaxStringSize, const char *strHeading, bool allowEmpty, unsigned int autoCloseMs);
-  static int          Dialog_Keyboard_ShowAndVerifyPassword(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, int iRetries, unsigned int autoCloseMs);
-  static bool         Dialog_Keyboard_ShowAndGetFilter(char &aTextString, unsigned int iMaxStringSize, bool searching, unsigned int autoCloseMs);
-  static bool         Dialog_Keyboard_SendTextToActiveKeyboard(const char *aTextString, bool closeKeyboard);
-  static bool         Dialog_Keyboard_isKeyboardActivated();
-
-  static bool         Dialog_Numeric_ShowAndVerifyNewPassword(char &strNewPasswor, unsigned int iMaxStringSized);
-  static int          Dialog_Numeric_ShowAndVerifyPassword(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, int iRetries);
-  static bool         Dialog_Numeric_ShowAndVerifyInput(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, bool bGetUserInput);
-  static bool         Dialog_Numeric_ShowAndGetTime(tm &time, const char *strHeading);
-  static bool         Dialog_Numeric_ShowAndGetDate(tm &date, const char *strHeading);
-  static bool         Dialog_Numeric_ShowAndGetIPAddress(char &strIPAddress, unsigned int iMaxStringSize, const char *strHeading);
-  static bool         Dialog_Numeric_ShowAndGetNumber(char &strInput, unsigned int iMaxStringSize, const char *strHeading, unsigned int iAutoCloseTimeoutMs);
-  static bool         Dialog_Numeric_ShowAndGetSeconds(char &timeString, unsigned int iMaxStringSize, const char *strHeading);
-
-  static bool         Dialog_FileBrowser_ShowAndGetFile(const char *directory, const char *mask, const char *heading, char &path, unsigned int iMaxStringSize, bool useThumbs, bool useFileDirectories, bool singleList);
-
-  static void         Dialog_OK_ShowAndGetInputSingleText(const char *heading, const char *text);
-  static void         Dialog_OK_ShowAndGetInputLineText(const char *heading, const char *line0, const char *line1, const char *line2);
-
-  static bool         Dialog_YesNo_ShowAndGetInputSingleText(const char *heading, const char *text, bool& bCanceled, const char *noLabel, const char *yesLabel);
-  static bool         Dialog_YesNo_ShowAndGetInputLineText(const char *heading, const char *line0, const char *line1, const char *line2, const char *noLabel, const char *yesLabel);
-  static bool         Dialog_YesNo_ShowAndGetInputLineButtonText(const char *heading, const char *line0, const char *line1, const char *line2, bool &bCanceled, const char *noLabel, const char *yesLabel);
-
-  static void         Dialog_TextViewer(const char *heading, const char *text);
-  static int          Dialog_Select(const char *heading, const char *entries[], unsigned int size, int selected);
-
-private:
-  ADDON::CAddon* m_addon; /*!< the addon */
-  CB_GUILib    *m_callbacks;
-};
-
-} /* namespace GUI */
-} /* namespace KodiAPI */
diff --git a/xbmc/addons/interfaces/gui/AddonGUIRenderingControl.cpp b/xbmc/addons/interfaces/gui/AddonGUIRenderingControl.cpp
deleted file mode 100644
index f1f250e98ed8..000000000000
--- a/xbmc/addons/interfaces/gui/AddonGUIRenderingControl.cpp
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#include "AddonGUIRenderingControl.h"
-
-#include "guilib/GUIRenderingControl.h"
-
-namespace KodiAPI
-{
-namespace GUI
-{
-
-CGUIAddonRenderingControl::CGUIAddonRenderingControl(CGUIRenderingControl *pControl)
-  : CBCreate{nullptr},
-  CBRender{nullptr},
-  CBStop{nullptr},
-  CBDirty{nullptr},
-  m_clientHandle{nullptr},
-  m_pControl{pControl},
-  m_refCount{1}
-{ }
-
-bool CGUIAddonRenderingControl::Create(int x, int y, int w, int h, void *device)
-{
-  if (CBCreate)
-  {
-    if (CBCreate(m_clientHandle, x, y, w, h, device))
-    {
-      m_refCount++;
-      return true;
-    }
-  }
-  return false;
-}
-
-void CGUIAddonRenderingControl::Render()
-{
-  if (CBRender)
-  {
-    CBRender(m_clientHandle);
-  }
-}
-
-void CGUIAddonRenderingControl::Stop()
-{
-  if (CBStop)
-  {
-    CBStop(m_clientHandle);
-  }
-  m_refCount--;
-  if (m_refCount <= 0)
-    delete this;
-}
-
-void CGUIAddonRenderingControl::Delete()
-{
-  m_refCount--;
-  if (m_refCount <= 0)
-    delete this;
-}
-
-bool CGUIAddonRenderingControl::IsDirty()
-{
-  bool ret = true;
-  if (CBDirty)
-  {
-    ret = CBDirty(m_clientHandle);
-  }
-  return ret;
-}
-
-} /* namespace GUI */
-} /* namespace KodiAPI */
diff --git a/xbmc/addons/interfaces/gui/AddonGUIRenderingControl.h b/xbmc/addons/interfaces/gui/AddonGUIRenderingControl.h
deleted file mode 100644
index 2ad04d266423..000000000000
--- a/xbmc/addons/interfaces/gui/AddonGUIRenderingControl.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include "addons/kodi-addon-dev-kit/include/kodi/libKODI_guilib.h"
-#include "guilib/IRenderingCallback.h"
-
-class CGUIRenderingControl;
-
-namespace KodiAPI
-{
-namespace GUI
-{
-
-class CGUIAddonRenderingControl : public IRenderingCallback
-{
-friend class CAddonCallbacksGUI;
-public:
-  explicit CGUIAddonRenderingControl(CGUIRenderingControl *pControl);
-  ~CGUIAddonRenderingControl() override = default;
-  bool Create(int x, int y, int w, int h, void *device) override;
-  void Render() override;
-  void Stop() override;
-  bool IsDirty() override;
-  virtual void Delete();
-protected:
-  bool (*CBCreate) (GUIHANDLE cbhdl, int x, int y, int w, int h, void *device);
-  void (*CBRender)(GUIHANDLE cbhdl);
-  void (*CBStop)(GUIHANDLE cbhdl);
-  bool (*CBDirty)(GUIHANDLE cbhdl);
-
-  GUIHANDLE m_clientHandle;
-  CGUIRenderingControl *m_pControl;
-  int m_refCount;
-};
-
-} /* namespace GUI */
-} /* namespace KodiAPI */
diff --git a/xbmc/addons/interfaces/gui/AddonGUIWindow.cpp b/xbmc/addons/interfaces/gui/AddonGUIWindow.cpp
deleted file mode 100644
index 30fe80cbc50b..000000000000
--- a/xbmc/addons/interfaces/gui/AddonGUIWindow.cpp
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#include "AddonGUIWindow.h"
-
-#include "Application.h"
-#include "FileItem.h"
-#include "ServiceBroker.h"
-#include "addons/Addon.h"
-#include "guilib/GUIComponent.h"
-#include "guilib/GUIWindowManager.h"
-#include "guilib/TextureManager.h"
-#include "input/Key.h"
-#include "messaging/ApplicationMessenger.h"
-#include "utils/URIUtils.h"
-#include "utils/log.h"
-
-#define CONTROL_BTNVIEWASICONS  2
-#define CONTROL_BTNSORTBY       3
-#define CONTROL_BTNSORTASC      4
-#define CONTROL_LABELFILES      12
-
-using namespace KODI::MESSAGING;
-using namespace ADDON;
-
-namespace KodiAPI
-{
-namespace GUI
-{
-
-CGUIAddonWindow::CGUIAddonWindow(int id, const std::string& strXML, CAddon* addon)
- : CGUIMediaWindow(id, strXML.c_str())
- , CBOnInit{nullptr}
- , CBOnFocus{nullptr}
- , CBOnClick{nullptr}
- , CBOnAction{nullptr}
- , m_clientHandle{nullptr}
- , m_iWindowId(id)
- , m_iOldWindowId(0)
- , m_bModal(false)
- , m_bIsDialog(false)
- , m_actionEvent(true)
- , m_addon(addon)
-
-{
-  m_loadType = LOAD_ON_GUI_INIT;
-}
-
-CGUIAddonWindow::~CGUIAddonWindow(void) = default;
-
-bool CGUIAddonWindow::OnAction(const CAction &action)
-{
-  // Let addon decide whether it wants to handle action first
-  if (CBOnAction && CBOnAction(m_clientHandle, action.GetID()))
-    return true;
-
-  return CGUIWindow::OnAction(action);
-}
-
-bool CGUIAddonWindow::OnMessage(CGUIMessage& message)
-{
-  //! @todo We shouldn't be dropping down to CGUIWindow in any of this ideally.
-  //! We have to make up our minds about what python should be doing and
-  //! what this side of things should be doing
-  switch (message.GetMessage())
-  {
-    case GUI_MSG_WINDOW_DEINIT:
-    {
-      return CGUIMediaWindow::OnMessage(message);
-    }
-    break;
-
-    case GUI_MSG_WINDOW_INIT:
-    {
-      CGUIMediaWindow::OnMessage(message);
-      if (CBOnInit)
-        CBOnInit(m_clientHandle);
-
-      return true;
-    }
-    break;
-
-    case GUI_MSG_SETFOCUS:
-    {
-      if (m_viewControl.HasControl(message.GetControlId()) && m_viewControl.GetCurrentControl() != message.GetControlId())
-      {
-        m_viewControl.SetFocused();
-        return true;
-      }
-      // check if our focused control is one of our category buttons
-      int iControl = message.GetControlId();
-      if (CBOnFocus)
-      {
-        CBOnFocus(m_clientHandle, iControl);
-      }
-    }
-    break;
-
-    case GUI_MSG_FOCUSED:
-    {
-      if (HasID(message.GetSenderId()) && CBOnFocus)
-      {
-        CBOnFocus(m_clientHandle, message.GetControlId());
-      }
-    }
-    break;
-
-    case GUI_MSG_CLICKED:
-    {
-      int iControl=message.GetSenderId();
-      // Handle Sort/View internally. Scripters shouldn't use ID 2, 3 or 4.
-      if (iControl == CONTROL_BTNSORTASC) // sort asc
-      {
-        CLog::Log(LOGINFO, "WindowXML: Internal asc/dsc button not implemented");
-        /*if (m_guiState.get())
-          m_guiState->SetNextSortOrder();
-        UpdateFileList();*/
-        return true;
-      }
-      else if (iControl == CONTROL_BTNSORTBY) // sort by
-      {
-        CLog::Log(LOGINFO, "WindowXML: Internal sort button not implemented");
-        /*if (m_guiState.get())
-          m_guiState->SetNextSortMethod();
-        UpdateFileList();*/
-        return true;
-      }
-
-      if (CBOnClick && iControl && iControl != this->GetID())
-      {
-        CGUIControl* controlClicked = this->GetControl(iControl);
-
-        // The old python way used to check list AND SELECITEM method or if its a button, radiobutton.
-        // Its done this way for now to allow other controls without a python version like togglebutton to still raise a onAction event
-        if (controlClicked) // Will get problems if we the id is not on the window and we try to do GetControlType on it. So check to make sure it exists
-        {
-          if ((controlClicked->IsContainer() && (message.GetParam1() == ACTION_SELECT_ITEM ||
-                                                 message.GetParam1() == ACTION_MOUSE_LEFT_CLICK)) ||
-                                                 !controlClicked->IsContainer())
-          {
-            if (CBOnClick(m_clientHandle, iControl))
-              return true;
-          }
-          else if (controlClicked->IsContainer() && message.GetParam1() == ACTION_MOUSE_RIGHT_CLICK)
-          {
-//            PyXBMCAction* inf = new PyXBMCAction;
-//            inf->pObject = Action_FromAction(CAction(ACTION_CONTEXT_MENU));
-//            inf->pCallbackWindow = pCallbackWindow;
-//
-//            // acquire lock?
-//            PyXBMC_AddPendingCall(Py_XBMC_Event_OnAction, inf);
-//            PulseActionEvent();
-          }
-        }
-      }
-    }
-    break;
-  }
-
-  return CGUIMediaWindow::OnMessage(message);
-}
-
-void CGUIAddonWindow::AllocResources(bool forceLoad /*= false */)
-{
-  std::string tmpDir = URIUtils::GetDirectory(GetProperty("xmlfile").asString());
-  std::string fallbackMediaPath;
-  URIUtils::GetParentPath(tmpDir, fallbackMediaPath);
-  URIUtils::RemoveSlashAtEnd(fallbackMediaPath);
-  m_mediaDir = fallbackMediaPath;
-
-  //CLog::Log(LOGDEBUG, "CGUIPythonWindowXML::AllocResources called: %s", fallbackMediaPath.c_str());
-  CServiceBroker::GetGUI()->GetTextureManager().AddTexturePath(m_mediaDir);
-  CGUIMediaWindow::AllocResources(forceLoad);
-  CServiceBroker::GetGUI()->GetTextureManager().RemoveTexturePath(m_mediaDir);
-}
-
-void CGUIAddonWindow::FreeResources(bool forceUnLoad /*= false */)
-{
-  CGUIMediaWindow::FreeResources(forceUnLoad);
-}
-
-void CGUIAddonWindow::Render()
-{
-  CServiceBroker::GetGUI()->GetTextureManager().AddTexturePath(m_mediaDir);
-  CGUIMediaWindow::Render();
-  CServiceBroker::GetGUI()->GetTextureManager().RemoveTexturePath(m_mediaDir);
-}
-
-void CGUIAddonWindow::Update()
-{
-}
-
-void CGUIAddonWindow::AddItem(CFileItemPtr fileItem, int itemPosition)
-{
-  if (itemPosition == -1 || itemPosition > m_vecItems->Size())
-  {
-    m_vecItems->Add(fileItem);
-  }
-  else if (itemPosition <  -1 &&  !(itemPosition-1 < m_vecItems->Size()))
-  {
-    m_vecItems->AddFront(fileItem,0);
-  }
-  else
-  {
-    m_vecItems->AddFront(fileItem,itemPosition);
-  }
-  m_viewControl.SetItems(*m_vecItems);
-  UpdateButtons();
-}
-
-void CGUIAddonWindow::RemoveItem(int itemPosition)
-{
-  m_vecItems->Remove(itemPosition);
-  m_viewControl.SetItems(*m_vecItems);
-  UpdateButtons();
-}
-
-int CGUIAddonWindow::GetCurrentListPosition()
-{
-  return m_viewControl.GetSelectedItem();
-}
-
-void CGUIAddonWindow::SetCurrentListPosition(int item)
-{
-  m_viewControl.SetSelectedItem(item);
-}
-
-int CGUIAddonWindow::GetListSize()
-{
-  return m_vecItems->Size();
-}
-
-CFileItemPtr CGUIAddonWindow::GetListItem(int position)
-{
-  if (position < 0 || position >= m_vecItems->Size()) return CFileItemPtr();
-  return m_vecItems->Get(position);
-}
-
-void CGUIAddonWindow::ClearList()
-{
-  ClearFileItems();
-
-  m_viewControl.SetItems(*m_vecItems);
-  UpdateButtons();
-}
-
-void CGUIAddonWindow::GetContextButtons(int itemNumber, CContextButtons &buttons)
-{
-  // maybe on day we can make an easy way to do this context menu
-  // with out this method overriding the MediaWindow version, it will display 'Add to Favourites'
-}
-
-void CGUIAddonWindow::WaitForActionEvent(unsigned int timeout)
-{
-  m_actionEvent.WaitMSec(timeout);
-  m_actionEvent.Reset();
-}
-
-void CGUIAddonWindow::PulseActionEvent()
-{
-  m_actionEvent.Set();
-}
-
-bool CGUIAddonWindow::OnClick(int iItem, const std::string &player)
-{
-  // Hook Over calling  CGUIMediaWindow::OnClick(iItem) results in it trying to PLAY the file item
-  // which if its not media is BAD and 99 out of 100 times undesirable.
-  return false;
-}
-
-// SetupShares();
-/*
- CGUIMediaWindow::OnWindowLoaded() calls SetupShares() so override it
-and just call UpdateButtons();
-*/
-void CGUIAddonWindow::SetupShares()
-{
-  UpdateButtons();
-}
-
-CGUIAddonWindowDialog::CGUIAddonWindowDialog(int id, const std::string& strXML, CAddon* addon)
-: CGUIAddonWindow(id,strXML,addon)
-{
-  m_bRunning = false;
-  m_bIsDialog = true;
-}
-
-CGUIAddonWindowDialog::~CGUIAddonWindowDialog(void) = default;
-
-bool CGUIAddonWindowDialog::OnMessage(CGUIMessage &message)
-{
-  if (message.GetMessage() == GUI_MSG_WINDOW_DEINIT)
-    return CGUIWindow::OnMessage(message);
-
-  return CGUIAddonWindow::OnMessage(message);
-}
-
-void CGUIAddonWindowDialog::Show(bool show /* = true */)
-{
-  unsigned int iCount = CServiceBroker::GetWinSystem()->GetGfxContext().exit();
-  CApplicationMessenger::GetInstance().SendMsg(TMSG_GUI_ADDON_DIALOG, 1, show ? 1 : 0, static_cast<void*>(this));
-  CServiceBroker::GetWinSystem()->GetGfxContext().restore(iCount);
-}
-
-void CGUIAddonWindowDialog::Show_Internal(bool show /* = true */)
-{
-  if (show)
-  {
-    m_bModal = true;
-    m_bRunning = true;
-    CServiceBroker::GetGUI()->GetWindowManager().RegisterDialog(this);
-
-    // active this window...
-    CGUIMessage msg(GUI_MSG_WINDOW_INIT, 0, 0, WINDOW_INVALID, m_iWindowId);
-    OnMessage(msg);
-
-    // this dialog is derived from GUiMediaWindow
-    // make sure it is rendered last
-    m_renderOrder = RENDER_ORDER_DIALOG;
-    while (m_bRunning)
-    {
-      if (!ProcessRenderLoop(false))
-        break;
-    }
-  }
-  else // hide
-  {
-    m_bRunning = false;
-
-    CGUIMessage msg(GUI_MSG_WINDOW_DEINIT,0,0);
-    OnMessage(msg);
-
-    CServiceBroker::GetGUI()->GetWindowManager().RemoveDialog(GetID());
-  }
-}
-
-} /* namespace GUI */
-} /* namespace KodiAPI */
diff --git a/xbmc/addons/interfaces/gui/AddonGUIWindow.h b/xbmc/addons/interfaces/gui/AddonGUIWindow.h
deleted file mode 100644
index 0831446cec5d..000000000000
--- a/xbmc/addons/interfaces/gui/AddonGUIWindow.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- *  Copyright (C) 2015-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include "addons/kodi-addon-dev-kit/include/kodi/libKODI_guilib.h"
-#include "threads/Event.h"
-#include "windows/GUIMediaWindow.h"
-
-namespace ADDON
-{
-  class CAddon;
-}
-
-namespace KodiAPI
-{
-namespace GUI
-{
-
-class CGUIAddonWindow : public CGUIMediaWindow
-{
-friend class CAddonCallbacksGUI;
-
-public:
-  CGUIAddonWindow(int id, const std::string& strXML, ADDON::CAddon* addon);
-  ~CGUIAddonWindow(void) override;
-
-  bool OnMessage(CGUIMessage& message) override;
-  bool OnAction(const CAction &action) override;
-  void AllocResources(bool forceLoad = false) override;
-  void FreeResources(bool forceUnLoad = false) override;
-  void Render() override;
-  void WaitForActionEvent(unsigned int timeout);
-  void PulseActionEvent();
-  void AddItem(CFileItemPtr fileItem, int itemPosition);
-  void RemoveItem(int itemPosition);
-  void ClearList();
-  CFileItemPtr GetListItem(int position);
-  int GetListSize();
-  int GetCurrentListPosition();
-  void SetCurrentListPosition(int item);
-  bool OnClick(int iItem, const std::string &player = "") override;
-
-protected:
-  using CGUIMediaWindow::Update;
-  void Update();
-  void GetContextButtons(int itemNumber, CContextButtons &buttons) override;
-  void SetupShares() override;
-
-  bool (*CBOnInit)(GUIHANDLE cbhdl);
-  bool (*CBOnFocus)(GUIHANDLE cbhdl, int controlId);
-  bool (*CBOnClick)(GUIHANDLE cbhdl, int controlId);
-  bool (*CBOnAction)(GUIHANDLE cbhdl, int);
-
-  GUIHANDLE        m_clientHandle;
-  const int m_iWindowId;
-  int m_iOldWindowId;
-  bool m_bModal;
-  bool m_bIsDialog;
-
-private:
-  CEvent           m_actionEvent;
-  ADDON::CAddon*   m_addon;
-  std::string      m_mediaDir;
-};
-
-/*\_____________________________________________________________________________
-\*/
-
-class CGUIAddonWindowDialog : public CGUIAddonWindow
-{
-public:
-  CGUIAddonWindowDialog(int id, const std::string& strXML, ADDON::CAddon* addon);
-  ~CGUIAddonWindowDialog(void) override;
-
-  void            Show(bool show = true);
-  bool    OnMessage(CGUIMessage &message) override;
-  bool    IsDialogRunning() const override { return m_bRunning; }
-  bool    IsDialog() const override { return true;};
-  bool    IsModalDialog() const override { return true; };
-  bool    IsMediaWindow() const override { return false; };
-
-  void Show_Internal(bool show = true);
-
-private:
-  bool             m_bRunning;
-};
-
-} /* namespace GUI */
-} /* namespace KodiAPI */
diff --git a/xbmc/addons/interfaces/gui/CMakeLists.txt b/xbmc/addons/interfaces/gui/CMakeLists.txt
index ce1cdcde1569..0170dafd8a38 100644
--- a/xbmc/addons/interfaces/gui/CMakeLists.txt
+++ b/xbmc/addons/interfaces/gui/CMakeLists.txt
@@ -1,15 +1,9 @@
 set(SOURCES General.cpp
             ListItem.cpp
-            Window.cpp
-            AddonCallbacksGUI.cpp
-            AddonGUIRenderingControl.cpp
-            AddonGUIWindow.cpp)
+            Window.cpp)
 
 set(HEADERS General.h
             ListItem.h
-            Window.h
-            AddonCallbacksGUI.h
-            AddonGUIRenderingControl.h
-            AddonGUIWindow.h)
+            Window.h)
 
 core_add_library(addons_interfaces_gui)
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
index c6c8fbf7f459..de7cb3eceb8a 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
@@ -5,12 +5,7 @@ set(HEADERS AddonBase.h
             Network.h
             StreamCodec.h
             StreamCrypto.h
-            libKODI_guilib.h
-            libXBMC_addon.h
-            libXBMC_pvr.h
-            versions.h
-            xbmc_addon_dll.h
-            xbmc_pvr_types.h)
+            versions.h)
 
 if(CORE_SYSTEM_NAME STREQUAL android)
   list(APPEND SOURCES platform/android/System.h)
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_guilib.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_guilib.h
deleted file mode 100644
index 672974e453d3..000000000000
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_guilib.h
+++ /dev/null
@@ -1,1172 +0,0 @@
-/*
- *  Copyright (C) 2005-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include <string>
-#include <vector>
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include "libXBMC_addon.h"
-
-typedef void* GUIHANDLE;
-
-namespace KodiAPI
-{
-namespace GUI
-{
-
-typedef struct CB_GUILib
-{
-  void (*Lock)();
-  void (*Unlock)();
-  int (*GetScreenHeight)();
-  int (*GetScreenWidth)();
-  int (*GetVideoResolution)();
-  GUIHANDLE (*Window_New)(void *addonData, const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog);
-  void (*Window_Delete)(void *addonData, GUIHANDLE handle);
-  void (*Window_SetCallbacks)(void *addonData, GUIHANDLE handle, GUIHANDLE clienthandle, bool (*)(GUIHANDLE handle), bool (*)(GUIHANDLE handle, int), bool (*)(GUIHANDLE handle, int), bool (*)(GUIHANDLE handle, int));
-  bool (*Window_Show)(void *addonData, GUIHANDLE handle);
-  bool (*Window_Close)(void *addonData, GUIHANDLE handle);
-  bool (*Window_DoModal)(void *addonData, GUIHANDLE handle);
-  bool (*Window_SetFocusId)(void *addonData, GUIHANDLE handle, int iControlId);
-  int (*Window_GetFocusId)(void *addonData, GUIHANDLE handle);
-  bool (*Window_SetCoordinateResolution)(void *addonData, GUIHANDLE handle, int res);
-  void (*Window_SetProperty)(void *addonData, GUIHANDLE handle, const char *key, const char *value);
-  void (*Window_SetPropertyInt)(void *addonData, GUIHANDLE handle, const char *key, int value);
-  void (*Window_SetPropertyBool)(void *addonData, GUIHANDLE handle, const char *key, bool value);
-  void (*Window_SetPropertyDouble)(void *addonData, GUIHANDLE handle, const char *key, double value);
-  const char* (*Window_GetProperty)(void *addonData, GUIHANDLE handle, const char *key);
-  int (*Window_GetPropertyInt)(void *addonData, GUIHANDLE handle, const char *key);
-  bool (*Window_GetPropertyBool)(void *addonData, GUIHANDLE handle, const char *key);
-  double (*Window_GetPropertyDouble)(void *addonData, GUIHANDLE handle, const char *key);
-  void (*Window_ClearProperties)(void *addonData, GUIHANDLE handle);
-  int (*Window_GetListSize)(void *addonData, GUIHANDLE handle);
-  void (*Window_ClearList)(void *addonData, GUIHANDLE handle);
-  GUIHANDLE (*Window_AddItem)(void *addonData, GUIHANDLE handle, GUIHANDLE item, int itemPosition);
-  GUIHANDLE (*Window_AddStringItem)(void *addonData, GUIHANDLE handle, const char *itemName, int itemPosition);
-  void (*Window_RemoveItem)(void *addonData, GUIHANDLE handle, int itemPosition);
-  GUIHANDLE (*Window_GetListItem)(void *addonData, GUIHANDLE handle, int listPos);
-  void (*Window_SetCurrentListPosition)(void *addonData, GUIHANDLE handle, int listPos);
-  int (*Window_GetCurrentListPosition)(void *addonData, GUIHANDLE handle);
-  GUIHANDLE (*Window_GetControl_Spin)(void *addonData, GUIHANDLE handle, int controlId);
-  GUIHANDLE (*Window_GetControl_Button)(void *addonData, GUIHANDLE handle, int controlId);
-  GUIHANDLE (*Window_GetControl_RadioButton)(void *addonData, GUIHANDLE handle, int controlId);
-  GUIHANDLE (*Window_GetControl_Edit)(void *addonData, GUIHANDLE handle, int controlId);
-  GUIHANDLE (*Window_GetControl_Progress)(void *addonData, GUIHANDLE handle, int controlId);
-  GUIHANDLE (*Window_GetControl_RenderAddon)(void *addonData, GUIHANDLE handle, int controlId);
-  void (*Window_SetControlLabel)(void *addonData, GUIHANDLE handle, int controlId, const char *label);
-  void (*Window_MarkDirtyRegion)(void *addonData, GUIHANDLE handle);
-  void (*Control_Spin_SetVisible)(void *addonData, GUIHANDLE spinhandle, bool yesNo);
-  void (*Control_Spin_SetText)(void *addonData, GUIHANDLE spinhandle, const char *label);
-  void (*Control_Spin_Clear)(void *addonData, GUIHANDLE spinhandle);
-  void (*Control_Spin_AddLabel)(void *addonData, GUIHANDLE spinhandle, const char *label, int iValue);
-  int (*Control_Spin_GetValue)(void *addonData, GUIHANDLE spinhandle);
-  void (*Control_Spin_SetValue)(void *addonData, GUIHANDLE spinhandle, int iValue);
-  void (*Control_RadioButton_SetVisible)(void *addonData, GUIHANDLE handle, bool yesNo);
-  void (*Control_RadioButton_SetText)(void *addonData, GUIHANDLE handle, const char *label);
-  void (*Control_RadioButton_SetSelected)(void *addonData, GUIHANDLE handle, bool yesNo);
-  bool (*Control_RadioButton_IsSelected)(void *addonData, GUIHANDLE handle);
-  void (*Control_Progress_SetPercentage)(void *addonData, GUIHANDLE handle, float fPercent);
-  float (*Control_Progress_GetPercentage)(void *addonData, GUIHANDLE handle);
-  void (*Control_Progress_SetInfo)(void *addonData, GUIHANDLE handle, int iInfo);
-  int (*Control_Progress_GetInfo)(void *addonData, GUIHANDLE handle);
-  const char* (*Control_Progress_GetDescription)(void *addonData, GUIHANDLE handle);
-  GUIHANDLE (*Window_GetControl_Slider)(void *addonData, GUIHANDLE handle, int controlId);
-  void (*Control_Slider_SetVisible)(void *addonData, GUIHANDLE handle, bool yesNo);
-  const char *(*Control_Slider_GetDescription)(void *addonData, GUIHANDLE handle);
-  void (*Control_Slider_SetIntRange)(void *addonData, GUIHANDLE handle, int iStart, int iEnd);
-  void (*Control_Slider_SetIntValue)(void *addonData, GUIHANDLE handle, int iValue);
-  int (*Control_Slider_GetIntValue)(void *addonData, GUIHANDLE handle);
-  void (*Control_Slider_SetIntInterval)(void *addonData, GUIHANDLE handle, int iInterval);
-  void (*Control_Slider_SetPercentage)(void *addonData, GUIHANDLE handle, float fPercent);
-  float (*Control_Slider_GetPercentage)(void *addonData, GUIHANDLE handle);
-  void (*Control_Slider_SetFloatRange)(void *addonData, GUIHANDLE handle, float fStart, float fEnd);
-  void (*Control_Slider_SetFloatValue)(void *addonData, GUIHANDLE handle, float fValue);
-  float (*Control_Slider_GetFloatValue)(void *addonData, GUIHANDLE handle);
-  void (*Control_Slider_SetFloatInterval)(void *addonData, GUIHANDLE handle, float fInterval);
-  GUIHANDLE (*Window_GetControl_SettingsSlider)(void *addonData, GUIHANDLE handle, int controlId);
-  void (*Control_SettingsSlider_SetVisible)(void *addonData, GUIHANDLE handle, bool yesNo);
-  void (*Control_SettingsSlider_SetText)(void *addonData, GUIHANDLE handle, const char *label);
-  const char *(*Control_SettingsSlider_GetDescription)(void *addonData, GUIHANDLE handle);
-  void (*Control_SettingsSlider_SetIntRange)(void *addonData, GUIHANDLE handle, int iStart, int iEnd);
-  void (*Control_SettingsSlider_SetIntValue)(void *addonData, GUIHANDLE handle, int iValue);
-  int (*Control_SettingsSlider_GetIntValue)(void *addonData, GUIHANDLE handle);
-  void (*Control_SettingsSlider_SetIntInterval)(void *addonData, GUIHANDLE handle, int iInterval);
-  void (*Control_SettingsSlider_SetPercentage)(void *addonData, GUIHANDLE handle, float fPercent);
-  float (*Control_SettingsSlider_GetPercentage)(void *addonData, GUIHANDLE handle);
-  void (*Control_SettingsSlider_SetFloatRange)(void *addonData, GUIHANDLE handle, float fStart, float fEnd);
-  void (*Control_SettingsSlider_SetFloatValue)(void *addonData, GUIHANDLE handle, float fValue);
-  float (*Control_SettingsSlider_GetFloatValue)(void *addonData, GUIHANDLE handle);
-  void (*Control_SettingsSlider_SetFloatInterval)(void *addonData, GUIHANDLE handle, float fInterval);
-  GUIHANDLE (*ListItem_Create)(void *addonData, const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path);
-  const char* (*ListItem_GetLabel)(void *addonData, GUIHANDLE handle);
-  void (*ListItem_SetLabel)(void *addonData, GUIHANDLE handle, const char *label);
-  const char* (*ListItem_GetLabel2)(void *addonData, GUIHANDLE handle);
-  void (*ListItem_SetLabel2)(void *addonData, GUIHANDLE handle, const char *label);
-  void (*ListItem_SetInfo)(void *addonData, GUIHANDLE handle, const char *info);
-  void (*ListItem_SetProperty)(void *addonData, GUIHANDLE handle, const char *key, const char *value);
-  const char* (*ListItem_GetProperty)(void *addonData, GUIHANDLE handle, const char *key);
-  void (*ListItem_SetPath)(void *addonData, GUIHANDLE handle, const char *path);
-  void (*RenderAddon_SetCallbacks)(void *addonData, GUIHANDLE handle, GUIHANDLE clienthandle, bool (*createCB)(GUIHANDLE,int,int,int,int,void*), void (*renderCB)(GUIHANDLE), void (*stopCB)(GUIHANDLE), bool (*dirtyCB)(GUIHANDLE));
-  void (*RenderAddon_Delete)(void *addonData, GUIHANDLE handle);
-  void (*RenderAddon_MarkDirty)(void *addonData, GUIHANDLE handle);
-
-  bool (*Dialog_Keyboard_ShowAndGetInputWithHead)(char &strTextString, unsigned int iMaxStringSize, const char *heading, bool allowEmptyResult, bool hiddenInput, unsigned int autoCloseMs);
-  bool (*Dialog_Keyboard_ShowAndGetInput)(char &strTextString, unsigned int iMaxStringSize, bool allowEmptyResult, unsigned int autoCloseMs);
-  bool (*Dialog_Keyboard_ShowAndGetNewPasswordWithHead)(char &newPassword, unsigned int iMaxStringSize, const char *strHeading, bool allowEmptyResult, unsigned int autoCloseMs);
-  bool (*Dialog_Keyboard_ShowAndGetNewPassword)(char &strNewPassword, unsigned int iMaxStringSize, unsigned int autoCloseMs);
-  bool (*Dialog_Keyboard_ShowAndVerifyNewPasswordWithHead)(char &strNewPassword, unsigned int iMaxStringSize, const char *strHeading, bool allowEmpty, unsigned int autoCloseMs);
-  bool (*Dialog_Keyboard_ShowAndVerifyNewPassword)(char &strNewPassword, unsigned int iMaxStringSize, unsigned int autoCloseMs);
-  int (*Dialog_Keyboard_ShowAndVerifyPassword)(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, int iRetries, unsigned int autoCloseMs);
-  bool (*Dialog_Keyboard_ShowAndGetFilter)(char &aTextString, unsigned int iMaxStringSize, bool searching, unsigned int autoCloseMs);
-  bool (*Dialog_Keyboard_SendTextToActiveKeyboard)(const char *aTextString, bool closeKeyboard);
-  bool (*Dialog_Keyboard_isKeyboardActivated)();
-
-  bool (*Dialog_Numeric_ShowAndVerifyNewPassword)(char &strNewPassword, unsigned int iMaxStringSize);
-  int (*Dialog_Numeric_ShowAndVerifyPassword)(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, int iRetries);
-  bool (*Dialog_Numeric_ShowAndVerifyInput)(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, bool bGetUserInput);
-  bool (*Dialog_Numeric_ShowAndGetTime)(tm &time, const char *strHeading);
-  bool (*Dialog_Numeric_ShowAndGetDate)(tm &date, const char *strHeading);
-  bool (*Dialog_Numeric_ShowAndGetIPAddress)(char &strIPAddress, unsigned int iMaxStringSize, const char *strHeading);
-  bool (*Dialog_Numeric_ShowAndGetNumber)(char &strInput, unsigned int iMaxStringSize, const char *strHeading, unsigned int iAutoCloseTimeoutMs);
-  bool (*Dialog_Numeric_ShowAndGetSeconds)(char &timeString, unsigned int iMaxStringSize, const char *strHeading);
-
-  bool (*Dialog_FileBrowser_ShowAndGetFile)(const char *directory, const char *mask, const char *heading, char &path, unsigned int iMaxStringSize, bool useThumbs, bool useFileDirectories, bool singleList);
-
-  void (*Dialog_OK_ShowAndGetInputSingleText)(const char *heading, const char *text);
-  void (*Dialog_OK_ShowAndGetInputLineText)(const char *heading, const char *line0, const char *line1, const char *line2);
-
-  bool (*Dialog_YesNo_ShowAndGetInputSingleText)(const char *heading, const char *text, bool& bCanceled, const char *noLabel, const char *yesLabel);
-  bool (*Dialog_YesNo_ShowAndGetInputLineText)(const char *heading, const char *line0, const char *line1, const char *line2, const char *noLabel, const char *yesLabel);
-  bool (*Dialog_YesNo_ShowAndGetInputLineButtonText)(const char *heading, const char *line0, const char *line1, const char *line2, bool &bCanceled, const char *noLabel, const char *yesLabel);
-
-  void (*Dialog_TextViewer)(const char *heading, const char *text);
-
-  int (*Dialog_Select)(const char *heading, const char *entries[], unsigned int size, int selected);
-} CB_GUILib;
-
-} /* namespace GUI */
-} /* namespace KodiAPI */
-
-
-#define ADDON_ACTION_PREVIOUS_MENU          10
-#define ADDON_ACTION_CLOSE_DIALOG           51
-#define ADDON_ACTION_NAV_BACK               92
-
-class CAddonGUIControlBase
-{
-public:
-  GUIHANDLE GetControlHandle() const { return m_controlHandle; }
-
-protected:
-  CAddonGUIControlBase(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, CAddonGUIControlBase* window)
-  : m_controlHandle(nullptr), m_Handle(hdl), m_cb(cb), m_Window(window) {}
-  virtual ~CAddonGUIControlBase() = default;
-
-  GUIHANDLE m_controlHandle;
-  AddonCB* m_Handle;
-  KodiAPI::GUI::CB_GUILib* m_cb;
-  CAddonGUIControlBase* m_Window;
-
-private:
-  CAddonGUIControlBase() = delete;
-  CAddonGUIControlBase(const CAddonGUIControlBase&) = delete;
-  CAddonGUIControlBase &operator=(const CAddonGUIControlBase&) = delete;
-};
-
-class CAddonListItem : public CAddonGUIControlBase
-{
-public:
-  CAddonListItem(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path)
-    : CAddonGUIControlBase(hdl, cb, nullptr)
-  {
-    m_controlHandle = m_cb->ListItem_Create(m_Handle->addonData, label, label2, iconImage, thumbnailImage, path);
-  }
-
-  ~CAddonListItem() override = default;
-
-  const char *GetLabel()
-  {
-    if (!m_controlHandle)
-      return "";
-
-    return m_cb->ListItem_GetLabel(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetLabel(const char *label)
-  {
-    if (m_controlHandle)
-      m_cb->ListItem_SetLabel(m_Handle->addonData, m_controlHandle, label);
-  }
-
-  const char *GetLabel2()
-  {
-    if (!m_controlHandle)
-      return "";
-
-    return m_cb->ListItem_GetLabel2(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetLabel2(const char *label)
-  {
-    if (m_controlHandle)
-      m_cb->ListItem_SetLabel2(m_Handle->addonData, m_controlHandle, label);
-  }
-
-  void SetInfo(const char *Info)
-  {
-    if (m_controlHandle)
-      m_cb->ListItem_SetInfo(m_Handle->addonData, m_controlHandle, Info);
-  }
-
-  void SetProperty(const char *key, const char *value)
-  {
-    if (m_controlHandle)
-      m_cb->ListItem_SetProperty(m_Handle->addonData, m_controlHandle, key, value);
-  }
-
-  const char *GetProperty(const char *key) const
-  {
-    if (!m_controlHandle)
-      return "";
-
-    return m_cb->ListItem_GetProperty(m_Handle->addonData, m_controlHandle, key);
-  }
-
-  void SetPath(const char *Path)
-  {
-    if (m_controlHandle)
-      m_cb->ListItem_SetPath(m_Handle->addonData, m_controlHandle, Path);
-  }
-};
-
-class CAddonGUIWindow : public CAddonGUIControlBase
-{
-public:
-  CAddonGUIWindow(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog)
-    : CAddonGUIControlBase(hdl, cb, nullptr)
-    , m_cbhdl(nullptr)
-    , CBOnInit(nullptr)
-    , CBOnFocus(nullptr)
-    , CBOnClick(nullptr)
-    , CBOnAction(nullptr)
-  {
-    if (hdl && cb)
-    {
-      m_controlHandle = m_cb->Window_New(m_Handle->addonData, xmlFilename, defaultSkin, forceFallback, asDialog);
-      if (!m_controlHandle)
-        fprintf(stderr, "libKODI_guilib: ERROR: Can't create window class !!!\n");
-
-      m_cb->Window_SetCallbacks(m_Handle->addonData, m_controlHandle, this, OnInitCB, OnClickCB, OnFocusCB, OnActionCB);
-    }
-  }
-
-  ~CAddonGUIWindow() override
-  {
-    if (m_Handle && m_cb && m_controlHandle)
-    {
-      m_cb->Window_Delete(m_Handle->addonData, m_controlHandle);
-      m_controlHandle = nullptr;
-    }
-  }
-
-  bool Show()
-  {
-    return m_cb->Window_Show(m_Handle->addonData, m_controlHandle);
-  }
-
-  void Close()
-  {
-    m_cb->Window_Close(m_Handle->addonData, m_controlHandle);
-  }
-
-  void DoModal()
-  {
-    m_cb->Window_DoModal(m_Handle->addonData, m_controlHandle);
-  }
-
-  bool SetFocusId(int iControlId)
-  {
-    return m_cb->Window_SetFocusId(m_Handle->addonData, m_controlHandle, iControlId);
-  }
-
-  int GetFocusId()
-  {
-    return m_cb->Window_GetFocusId(m_Handle->addonData, m_controlHandle);
-  }
-
-  bool SetCoordinateResolution(int res)
-  {
-    return m_cb->Window_SetCoordinateResolution(m_Handle->addonData, m_controlHandle, res);
-  }
-
-  void SetProperty(const char *key, const char *value)
-  {
-    m_cb->Window_SetProperty(m_Handle->addonData, m_controlHandle, key, value);
-  }
-
-  void SetPropertyInt(const char *key, int value)
-  {
-    m_cb->Window_SetPropertyInt(m_Handle->addonData, m_controlHandle, key, value);
-  }
-
-  void SetPropertyBool(const char *key, bool value)
-  {
-    m_cb->Window_SetPropertyBool(m_Handle->addonData, m_controlHandle, key, value);
-  }
-
-  void SetPropertyDouble(const char *key, double value)
-  {
-    m_cb->Window_SetPropertyDouble(m_Handle->addonData, m_controlHandle, key, value);
-  }
-
-  const char *GetProperty(const char *key) const
-  {
-    return m_cb->Window_GetProperty(m_Handle->addonData, m_controlHandle, key);
-  }
-
-  int GetPropertyInt(const char *key) const
-  {
-    return m_cb->Window_GetPropertyInt(m_Handle->addonData, m_controlHandle, key);
-  }
-
-  bool GetPropertyBool(const char *key) const
-  {
-    return m_cb->Window_GetPropertyBool(m_Handle->addonData, m_controlHandle, key);
-  }
-
-  double GetPropertyDouble(const char *key) const
-  {
-    return m_cb->Window_GetPropertyDouble(m_Handle->addonData, m_controlHandle, key);
-  }
-
-  void ClearProperties()
-  {
-    m_cb->Window_ClearProperties(m_Handle->addonData, m_controlHandle);
-  }
-
-  int GetListSize()
-  {
-    return m_cb->Window_GetListSize(m_Handle->addonData, m_controlHandle);
-  }
-
-  void ClearList()
-  {
-    m_cb->Window_ClearList(m_Handle->addonData, m_controlHandle);
-  }
-
-  GUIHANDLE AddStringItem(const char *name, int itemPosition = -1)
-  {
-    return m_cb->Window_AddStringItem(m_Handle->addonData, m_controlHandle, name, itemPosition);
-  }
-
-  void AddItem(GUIHANDLE item, int itemPosition = -1)
-  {
-    m_cb->Window_AddItem(m_Handle->addonData, m_controlHandle, item, itemPosition);
-  }
-
-  void AddItem(CAddonListItem *item, int itemPosition = -1)
-  {
-    m_cb->Window_AddItem(m_Handle->addonData, m_controlHandle, item->GetControlHandle(), itemPosition);
-  }
-
-  void RemoveItem(int itemPosition)
-  {
-    m_cb->Window_RemoveItem(m_Handle->addonData, m_controlHandle, itemPosition);
-  }
-
-  GUIHANDLE GetListItem(int listPos)
-  {
-    return m_cb->Window_GetListItem(m_Handle->addonData, m_controlHandle, listPos);
-  }
-
-  void SetCurrentListPosition(int listPos)
-  {
-    m_cb->Window_SetCurrentListPosition(m_Handle->addonData, m_controlHandle, listPos);
-  }
-
-  int GetCurrentListPosition()
-  {
-    return m_cb->Window_GetCurrentListPosition(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetControlLabel(int controlId, const char *label)
-  {
-    m_cb->Window_SetControlLabel(m_Handle->addonData, m_controlHandle, controlId, label);
-  }
-
-  void MarkDirtyRegion()
-  {
-    m_cb->Window_MarkDirtyRegion(m_Handle->addonData, m_controlHandle);
-  }
-
-  bool OnClick(int controlId)
-  {
-    if (!CBOnClick)
-      return false;
-
-    return CBOnClick(m_cbhdl, controlId);
-  }
-
-  bool OnFocus(int controlId)
-  {
-    if (!CBOnFocus)
-      return false;
-
-    return CBOnFocus(m_cbhdl, controlId);
-  }
-
-  bool OnInit()
-  {
-    if (!CBOnInit)
-      return false;
-
-    return CBOnInit(m_cbhdl);
-  }
-
-  bool OnAction(int actionId)
-  {
-    if (!CBOnAction)
-      return false;
-
-    return CBOnAction(m_cbhdl, actionId);
-  }
-
-  GUIHANDLE m_cbhdl;
-  bool (*CBOnInit)(GUIHANDLE cbhdl);
-  bool (*CBOnFocus)(GUIHANDLE cbhdl, int controlId);
-  bool (*CBOnClick)(GUIHANDLE cbhdl, int controlId);
-  bool (*CBOnAction)(GUIHANDLE cbhdl, int actionId);
-
-protected:
-  static bool OnInitCB(GUIHANDLE cbhdl);
-  static bool OnFocusCB(GUIHANDLE cbhdl, int controlId);
-  static bool OnClickCB(GUIHANDLE cbhdl, int controlId);
-  static bool OnActionCB(GUIHANDLE cbhdl, int actionId);
-};
-
-
-inline bool CAddonGUIWindow::OnInitCB(GUIHANDLE cbhdl)
-{
-  return static_cast<CAddonGUIWindow*>(cbhdl)->OnInit();
-}
-
-inline bool CAddonGUIWindow::OnClickCB(GUIHANDLE cbhdl, int controlId)
-{
-  return static_cast<CAddonGUIWindow*>(cbhdl)->OnClick(controlId);
-}
-
-inline bool CAddonGUIWindow::OnFocusCB(GUIHANDLE cbhdl, int controlId)
-{
-  return static_cast<CAddonGUIWindow*>(cbhdl)->OnFocus(controlId);
-}
-
-inline bool CAddonGUIWindow::OnActionCB(GUIHANDLE cbhdl, int actionId)
-{
-  return static_cast<CAddonGUIWindow*>(cbhdl)->OnAction(actionId);
-}
-
-class CAddonGUISpinControl: public CAddonGUIControlBase
-{
-public:
-  CAddonGUISpinControl(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, CAddonGUIWindow *window, int controlId)
-    : CAddonGUIControlBase(hdl, cb, window)
-  {
-    m_controlHandle = m_cb->Window_GetControl_Spin(m_Handle->addonData, m_Window->GetControlHandle(), controlId);
-  }
-  ~CAddonGUISpinControl(void) override = default;
-
-  void SetVisible(bool yesNo)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Spin_SetVisible(m_Handle->addonData, m_controlHandle, yesNo);
-  }
-
-  void SetText(const char *label)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Spin_SetText(m_Handle->addonData, m_controlHandle, label);
-  }
-
-  void Clear()
-  {
-    if (m_controlHandle)
-      m_cb->Control_Spin_Clear(m_Handle->addonData, m_controlHandle);
-  }
-
-  void AddLabel(const char *label, int iValue)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Spin_AddLabel(m_Handle->addonData, m_controlHandle, label, iValue);
-  }
-
-  int GetValue()
-  {
-    if (!m_controlHandle)
-      return -1;
-
-    return m_cb->Control_Spin_GetValue(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetValue(int iValue)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Spin_SetValue(m_Handle->addonData, m_controlHandle, iValue);
-  }
-};
-
-class CAddonGUIRadioButton : public CAddonGUIControlBase
-{
-public:
-  CAddonGUIRadioButton(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, CAddonGUIWindow *window, int controlId)
-    : CAddonGUIControlBase(hdl, cb, window)
-  {
-    m_controlHandle = m_cb->Window_GetControl_RadioButton(m_Handle->addonData, m_Window->GetControlHandle(), controlId);
-  }
-  ~CAddonGUIRadioButton() override = default;
-
-  void SetVisible(bool yesNo)
-  {
-    if (m_controlHandle)
-      m_cb->Control_RadioButton_SetVisible(m_Handle->addonData, m_controlHandle, yesNo);
-  }
-
-  void SetText(const char *label)
-  {
-    if (m_controlHandle)
-      m_cb->Control_RadioButton_SetText(m_Handle->addonData, m_controlHandle, label);
-  }
-
-  void SetSelected(bool yesNo)
-  {
-    if (m_controlHandle)
-      m_cb->Control_RadioButton_SetSelected(m_Handle->addonData, m_controlHandle, yesNo);
-  }
-
-  bool IsSelected()
-  {
-    if (!m_controlHandle)
-      return false;
-
-    return m_cb->Control_RadioButton_IsSelected(m_Handle->addonData, m_controlHandle);
-  }
-};
-
-class CAddonGUIProgressControl : public CAddonGUIControlBase
-{
-public:
-  CAddonGUIProgressControl(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, CAddonGUIWindow *window, int controlId)
-    : CAddonGUIControlBase(hdl, cb, window)
-  {
-    m_controlHandle = m_cb->Window_GetControl_Progress(m_Handle->addonData, m_Window->GetControlHandle(), controlId);
-  }
-
-  ~CAddonGUIProgressControl(void) override = default;
-
-  void SetPercentage(float fPercent)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Progress_SetPercentage(m_Handle->addonData, m_controlHandle, fPercent);
-  }
-
-  float GetPercentage() const
-  {
-    if (!m_controlHandle)
-      return 0.0f;
-
-    return m_cb->Control_Progress_GetPercentage(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetInfo(int iInfo)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Progress_SetInfo(m_Handle->addonData, m_controlHandle, iInfo);
-  }
-
-  int GetInfo() const
-  {
-    if (!m_controlHandle)
-      return -1;
-
-    return m_cb->Control_Progress_GetInfo(m_Handle->addonData, m_controlHandle);
-  }
-
-  std::string GetDescription() const
-  {
-    if (!m_controlHandle)
-      return "";
-
-    return m_cb->Control_Progress_GetDescription(m_Handle->addonData, m_controlHandle);
-  }
-};
-
-class CAddonGUISliderControl : public CAddonGUIControlBase
-{
-public:
-  CAddonGUISliderControl(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, CAddonGUIWindow *window, int controlId)
-    : CAddonGUIControlBase(hdl, cb, window)
-  {
-    m_controlHandle = m_cb->Window_GetControl_Slider(m_Handle->addonData, m_Window->GetControlHandle(), controlId);
-  }
-
-  ~CAddonGUISliderControl(void) override = default;
-
-  void SetVisible(bool yesNo)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Slider_SetVisible(m_Handle->addonData, m_controlHandle, yesNo);
-  }
-
-  std::string GetDescription() const
-  {
-    if (!m_controlHandle)
-      return "";
-
-    return m_cb->Control_Slider_GetDescription(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetIntRange(int iStart, int iEnd)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Slider_SetIntRange(m_Handle->addonData, m_controlHandle, iStart, iEnd);
-  }
-
-  void SetIntValue(int iValue)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Slider_SetIntValue(m_Handle->addonData, m_controlHandle, iValue);
-  }
-
-  int GetIntValue() const
-  {
-    if (!m_controlHandle)
-      return 0;
-    return m_cb->Control_Slider_GetIntValue(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetIntInterval(int iInterval)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Slider_SetIntInterval(m_Handle->addonData, m_controlHandle, iInterval);
-  }
-
-  void SetPercentage(float fPercent)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Slider_SetPercentage(m_Handle->addonData, m_controlHandle, fPercent);
-  }
-
-  float GetPercentage() const
-  {
-    if (!m_controlHandle)
-      return 0.0f;
-
-    return m_cb->Control_Slider_GetPercentage(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetFloatRange(float fStart, float fEnd)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Slider_SetFloatRange(m_Handle->addonData, m_controlHandle, fStart, fEnd);
-  }
-
-  void SetFloatValue(float fValue)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Slider_SetFloatValue(m_Handle->addonData, m_controlHandle, fValue);
-  }
-
-  float GetFloatValue() const
-  {
-    if (!m_controlHandle)
-      return 0.0f;
-    return m_cb->Control_Slider_GetFloatValue(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetFloatInterval(float fInterval)
-  {
-    if (m_controlHandle)
-      m_cb->Control_Slider_SetFloatInterval(m_Handle->addonData, m_controlHandle, fInterval);
-  }
-};
-
-class CAddonGUISettingsSliderControl : public CAddonGUIControlBase
-{
-public:
-  CAddonGUISettingsSliderControl(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, CAddonGUIWindow *window, int controlId)
-    : CAddonGUIControlBase(hdl, cb, window)
-  {
-    m_controlHandle = m_cb->Window_GetControl_SettingsSlider(m_Handle->addonData, m_Window->GetControlHandle(), controlId);
-  }
-
-  ~CAddonGUISettingsSliderControl(void) override = default;
-
-  void SetVisible(bool yesNo)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetVisible(m_Handle->addonData, m_controlHandle, yesNo);
-  }
-
-  void SetText(const char *label)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetText(m_Handle->addonData, m_controlHandle, label);
-  }
-
-  std::string GetDescription() const
-  {
-    if (!m_controlHandle)
-      return "";
-
-    return m_cb->Control_SettingsSlider_GetDescription(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetIntRange(int iStart, int iEnd)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetIntRange(m_Handle->addonData, m_controlHandle, iStart, iEnd);
-  }
-
-  void SetIntValue(int iValue)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetIntValue(m_Handle->addonData, m_controlHandle, iValue);
-  }
-
-  int GetIntValue() const
-  {
-    if (!m_controlHandle)
-      return 0;
-    return m_cb->Control_SettingsSlider_GetIntValue(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetIntInterval(int iInterval)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetIntInterval(m_Handle->addonData, m_controlHandle, iInterval);
-  }
-
-  void SetPercentage(float fPercent)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetPercentage(m_Handle->addonData, m_controlHandle, fPercent);
-  }
-
-  float GetPercentage() const
-  {
-    if (!m_controlHandle)
-      return 0.0f;
-
-    return m_cb->Control_SettingsSlider_GetPercentage(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetFloatRange(float fStart, float fEnd)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetFloatRange(m_Handle->addonData, m_controlHandle, fStart, fEnd);
-  }
-
-  void SetFloatValue(float fValue)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetFloatValue(m_Handle->addonData, m_controlHandle, fValue);
-  }
-
-  float GetFloatValue() const
-  {
-    if (!m_controlHandle)
-      return 0.0f;
-    return m_cb->Control_SettingsSlider_GetFloatValue(m_Handle->addonData, m_controlHandle);
-  }
-
-  void SetFloatInterval(float fInterval)
-  {
-    if (m_controlHandle)
-      m_cb->Control_SettingsSlider_SetFloatInterval(m_Handle->addonData, m_controlHandle, fInterval);
-  }
-};
-
-class CAddonGUIRenderingControl : public CAddonGUIControlBase
-{
-public:
-  CAddonGUIRenderingControl(AddonCB* hdl, KodiAPI::GUI::CB_GUILib* cb, CAddonGUIWindow *window, int controlId)
-    : CAddonGUIControlBase(hdl, cb, window)
-    , m_cbhdl(nullptr)
-    , CBCreate(nullptr)
-    , CBRender(nullptr)
-    , CBStop(nullptr)
-    , CBDirty(nullptr)
-  {
-    m_controlHandle = m_cb->Window_GetControl_RenderAddon(m_Handle->addonData, m_Window->GetControlHandle(), controlId);
-  }
-
-  ~CAddonGUIRenderingControl() override
-  {
-    m_cb->RenderAddon_Delete(m_Handle->addonData, m_controlHandle);
-  }
-
-  void Init()
-  {
-    m_cb->RenderAddon_SetCallbacks(m_Handle->addonData, m_controlHandle, this, OnCreateCB, OnRenderCB, OnStopCB, OnDirtyCB);
-  }
-
-  bool Create(int x, int y, int w, int h, void *device)
-  {
-    if (!CBCreate)
-      return false;
-
-    return CBCreate(m_cbhdl, x, y, w, h, device);
-  }
-
-  void Render()
-  {
-    if (!CBRender)
-      return;
-
-    CBRender(m_cbhdl);
-  }
-
-  void Stop()
-  {
-    if (!CBStop)
-      return;
-
-    CBStop(m_cbhdl);
-  }
-
-  bool Dirty()
-  {
-    if (!CBDirty)
-      return true;
-
-    return CBDirty(m_cbhdl);
-  }
-
-  GUIHANDLE m_cbhdl;
-  bool (*CBCreate)(GUIHANDLE cbhdl, int x, int y, int w, int h, void *device);
-  void (*CBRender)(GUIHANDLE cbhdl);
-  void (*CBStop)(GUIHANDLE cbhdl);
-  bool (*CBDirty)(GUIHANDLE cbhdl);
-
-private:
-  static bool OnCreateCB(GUIHANDLE cbhdl, int x, int y, int w, int h, void* device);
-  static void OnRenderCB(GUIHANDLE cbhdl);
-  static void OnStopCB(GUIHANDLE cbhdl);
-  static bool OnDirtyCB(GUIHANDLE cbhdl);
-};
-
-inline bool CAddonGUIRenderingControl::OnCreateCB(GUIHANDLE cbhdl, int x, int y, int w, int h, void* device)
-{
-  return static_cast<CAddonGUIRenderingControl*>(cbhdl)->Create(x, y, w, h, device);
-}
-
-inline void CAddonGUIRenderingControl::OnRenderCB(GUIHANDLE cbhdl)
-{
-  static_cast<CAddonGUIRenderingControl*>(cbhdl)->Render();
-}
-
-inline void CAddonGUIRenderingControl::OnStopCB(GUIHANDLE cbhdl)
-{
-  static_cast<CAddonGUIRenderingControl*>(cbhdl)->Stop();
-}
-
-inline bool CAddonGUIRenderingControl::OnDirtyCB(GUIHANDLE cbhdl)
-{
-  return static_cast<CAddonGUIRenderingControl*>(cbhdl)->Dirty();
-}
-
-class CHelper_libKODI_guilib
-{
-public:
-  CHelper_libKODI_guilib()
-  {
-    m_Handle = nullptr;
-    m_Callbacks = nullptr;
-  }
-
-  ~CHelper_libKODI_guilib()
-  {
-    if (m_Handle && m_Callbacks)
-    {
-      m_Handle->GUILib_UnRegisterMe(m_Handle->addonData, m_Callbacks);
-    }
-  }
-
-  bool RegisterMe(void *handle)
-  {
-    m_Handle = static_cast<AddonCB*>(handle);
-    if (m_Handle)
-      m_Callbacks = (KodiAPI::GUI::CB_GUILib*)m_Handle->GUILib_RegisterMe(m_Handle->addonData);
-    if (!m_Callbacks)
-      fprintf(stderr, "libKODI_guilib-ERROR: GUILib_RegisterMe can't get callback table from Kodi !!!\n");
-
-    return m_Callbacks != nullptr;
-  }
-
-  void Lock()
-  {
-    m_Callbacks->Lock();
-  }
-
-  void Unlock()
-  {
-    m_Callbacks->Unlock();
-  }
-
-  int GetScreenHeight()
-  {
-    return m_Callbacks->GetScreenHeight();
-  }
-
-  int GetScreenWidth()
-  {
-    return m_Callbacks->GetScreenWidth();
-  }
-
-  int GetVideoResolution()
-  {
-    return m_Callbacks->GetVideoResolution();
-  }
-
-  CAddonGUIWindow* Window_create(const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog)
-  {
-    return new CAddonGUIWindow(m_Handle, m_Callbacks, xmlFilename, defaultSkin, forceFallback, asDialog);
-  }
-
-  void Window_destroy(CAddonGUIWindow* p)
-  {
-    delete p;
-  }
-
-  CAddonGUISpinControl* Control_getSpin(CAddonGUIWindow *window, int controlId)
-  {
-    return new CAddonGUISpinControl(m_Handle, m_Callbacks, window, controlId);
-  }
-
-  void Control_releaseSpin(CAddonGUISpinControl* p)
-  {
-    delete p;
-  }
-
-  CAddonGUIRadioButton* Control_getRadioButton(CAddonGUIWindow *window, int controlId)
-  {
-    return new CAddonGUIRadioButton(m_Handle, m_Callbacks, window, controlId);
-  }
-
-  void Control_releaseRadioButton(CAddonGUIRadioButton* p)
-  {
-    delete p;
-  }
-
-  CAddonGUIProgressControl* Control_getProgress(CAddonGUIWindow *window, int controlId)
-  {
-    return new CAddonGUIProgressControl(m_Handle, m_Callbacks, window, controlId);
-  }
-
-  void Control_releaseProgress(CAddonGUIProgressControl* p)
-  {
-    delete p;
-  }
-
-  CAddonListItem* ListItem_create(const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path)
-  {
-    return new CAddonListItem(m_Handle, m_Callbacks, label, label2, iconImage, thumbnailImage, path);
-  }
-
-  void ListItem_destroy(CAddonListItem* p)
-  {
-    delete p;
-  }
-
-  CAddonGUIRenderingControl* Control_getRendering(CAddonGUIWindow *window, int controlId)
-  {
-    return new CAddonGUIRenderingControl(m_Handle, m_Callbacks, window, controlId);
-  }
-
-  void Control_releaseRendering(CAddonGUIRenderingControl* p)
-  {
-    delete p;
-  }
-
-  CAddonGUISliderControl* Control_getSlider(CAddonGUIWindow *window, int controlId)
-  {
-    return new CAddonGUISliderControl(m_Handle, m_Callbacks, window, controlId);
-  }
-
-  void Control_releaseSlider(CAddonGUISliderControl* p)
-  {
-    delete p;
-  }
-
-  CAddonGUISettingsSliderControl* Control_getSettingsSlider(CAddonGUIWindow *window, int controlId)
-  {
-    return new CAddonGUISettingsSliderControl(m_Handle, m_Callbacks, window, controlId);
-  }
-
-  void Control_releaseSettingsSlider(CAddonGUISettingsSliderControl* p)
-  {
-    delete p;
-  }
-
-  /*! @name GUI Keyboard functions */
-  //@{
-  bool Dialog_Keyboard_ShowAndGetInput(char &strText, unsigned int iMaxStringSize, const char *strHeading, bool allowEmptyResult, bool hiddenInput, unsigned int autoCloseMs = 0)
-  {
-    return m_Callbacks->Dialog_Keyboard_ShowAndGetInputWithHead(strText, iMaxStringSize, strHeading, allowEmptyResult, hiddenInput, autoCloseMs);
-  }
-
-  bool Dialog_Keyboard_ShowAndGetInput(char &strText, unsigned int iMaxStringSize, bool allowEmptyResult, unsigned int autoCloseMs = 0)
-  {
-    return m_Callbacks->Dialog_Keyboard_ShowAndGetInput(strText, iMaxStringSize, allowEmptyResult, autoCloseMs);
-  }
-
-  bool Dialog_Keyboard_ShowAndGetNewPassword(char &strNewPassword, unsigned int iMaxStringSize, const char *strHeading, bool allowEmptyResult, unsigned int autoCloseMs = 0)
-  {
-    return m_Callbacks->Dialog_Keyboard_ShowAndGetNewPasswordWithHead(strNewPassword, iMaxStringSize, strHeading, allowEmptyResult, autoCloseMs);
-  }
-
-  bool Dialog_Keyboard_ShowAndGetNewPassword(char &strNewPassword, unsigned int iMaxStringSize, unsigned int autoCloseMs = 0)
-  {
-    return m_Callbacks->Dialog_Keyboard_ShowAndGetNewPassword(strNewPassword, iMaxStringSize, autoCloseMs);
-  }
-
-  bool Dialog_Keyboard_ShowAndVerifyNewPassword(char &strNewPassword, unsigned int iMaxStringSize, const char *strHeading, bool allowEmptyResult, unsigned int autoCloseMs = 0)
-  {
-    return m_Callbacks->Dialog_Keyboard_ShowAndVerifyNewPasswordWithHead(strNewPassword, iMaxStringSize, strHeading, allowEmptyResult, autoCloseMs);
-  }
-
-  bool Dialog_Keyboard_ShowAndVerifyNewPassword(char &strNewPassword, unsigned int iMaxStringSize, unsigned int autoCloseMs = 0)
-  {
-    return m_Callbacks->Dialog_Keyboard_ShowAndVerifyNewPassword(strNewPassword, iMaxStringSize, autoCloseMs);
-  }
-
-  int Dialog_Keyboard_ShowAndVerifyPassword(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, int iRetries, unsigned int autoCloseMs = 0)
-  {
-    return m_Callbacks->Dialog_Keyboard_ShowAndVerifyPassword(strPassword, iMaxStringSize, strHeading, iRetries, autoCloseMs);
-  }
-
-  bool Dialog_Keyboard_ShowAndGetFilter(char &strText, unsigned int iMaxStringSize, bool searching, unsigned int autoCloseMs = 0)
-  {
-    return m_Callbacks->Dialog_Keyboard_ShowAndGetFilter(strText, iMaxStringSize, searching, autoCloseMs);
-  }
-
-  bool Dialog_Keyboard_SendTextToActiveKeyboard(const char *aTextString, bool closeKeyboard = false)
-  {
-    return m_Callbacks->Dialog_Keyboard_SendTextToActiveKeyboard(aTextString, closeKeyboard);
-  }
-
-  bool Dialog_Keyboard_isKeyboardActivated()
-  {
-    return m_Callbacks->Dialog_Keyboard_isKeyboardActivated();
-  }
-  //@}
-
-  /*! @name GUI Numeric functions */
-  //@{
-  bool Dialog_Numeric_ShowAndVerifyNewPassword(char &strNewPassword, unsigned int iMaxStringSize)
-  {
-    return m_Callbacks->Dialog_Numeric_ShowAndVerifyNewPassword(strNewPassword, iMaxStringSize);
-  }
-
-  int Dialog_Numeric_ShowAndVerifyPassword(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, int iRetries)
-  {
-    return m_Callbacks->Dialog_Numeric_ShowAndVerifyPassword(strPassword, iMaxStringSize, strHeading, iRetries);
-  }
-
-  bool Dialog_Numeric_ShowAndVerifyInput(char &strPassword, unsigned int iMaxStringSize, const char *strHeading, bool bGetUserInput)
-  {
-    return m_Callbacks->Dialog_Numeric_ShowAndVerifyInput(strPassword, iMaxStringSize, strHeading, bGetUserInput);
-  }
-
-  bool Dialog_Numeric_ShowAndGetTime(tm &time, const char *strHeading)
-  {
-    return m_Callbacks->Dialog_Numeric_ShowAndGetTime(time, strHeading);
-  }
-
-  bool Dialog_Numeric_ShowAndGetDate(tm &date, const char *strHeading)
-  {
-    return m_Callbacks->Dialog_Numeric_ShowAndGetDate(date, strHeading);
-  }
-
-  bool Dialog_Numeric_ShowAndGetIPAddress(char &strIPAddress, unsigned int iMaxStringSize, const char *strHeading)
-  {
-    return m_Callbacks->Dialog_Numeric_ShowAndGetIPAddress(strIPAddress, iMaxStringSize, strHeading);
-  }
-
-  bool Dialog_Numeric_ShowAndGetNumber(char &strInput, unsigned int iMaxStringSize, const char *strHeading, unsigned int iAutoCloseTimeoutMs = 0)
-  {
-    return m_Callbacks->Dialog_Numeric_ShowAndGetNumber(strInput, iMaxStringSize, strHeading, iAutoCloseTimeoutMs);
-  }
-
-  bool Dialog_Numeric_ShowAndGetSeconds(char &strTime, unsigned int iMaxStringSize, const char *strHeading)
-  {
-    return m_Callbacks->Dialog_Numeric_ShowAndGetSeconds(strTime, iMaxStringSize, strHeading);
-  }
-  //@}
-
-  /*! @name GUI File browser functions */
-  //@{
-  bool Dialog_FileBrowser_ShowAndGetFile(const char *directory, const char *mask, const char *heading, char &strPath, unsigned int iMaxStringSize, bool useThumbs = false, bool useFileDirectories = false, bool singleList = false)
-  {
-    return m_Callbacks->Dialog_FileBrowser_ShowAndGetFile(directory, mask, heading, strPath, iMaxStringSize, useThumbs, useFileDirectories, singleList);
-  }
-  //@}
-
-  /*! @name GUI OK Dialog functions */
-  //@{
-  void Dialog_OK_ShowAndGetInput(const char *heading, const char *text)
-  {
-    return m_Callbacks->Dialog_OK_ShowAndGetInputSingleText(heading, text);
-  }
-
-  void Dialog_OK_ShowAndGetInput(const char *heading, const char *line0, const char *line1, const char *line2)
-  {
-    return m_Callbacks->Dialog_OK_ShowAndGetInputLineText(heading, line0, line1, line2);
-  }
-  //@}
-
-  /*! @name GUI Yes No Dialog functions */
-  //@{
-  bool Dialog_YesNo_ShowAndGetInput(const char *heading, const char *text, bool& bCanceled, const char *noLabel = "", const char *yesLabel = "")
-  {
-    return m_Callbacks->Dialog_YesNo_ShowAndGetInputSingleText(heading, text, bCanceled, noLabel, yesLabel);
-  }
-
-  bool Dialog_YesNo_ShowAndGetInput(const char *heading, const char *line0, const char *line1, const char *line2, const char *noLabel = "", const char *yesLabel = "")
-  {
-    return m_Callbacks->Dialog_YesNo_ShowAndGetInputLineText(heading, line0, line1, line2, noLabel, yesLabel);
-  }
-
-  bool Dialog_YesNo_ShowAndGetInput(const char *heading, const char *line0, const char *line1, const char *line2, bool &bCanceled, const char *noLabel = "", const char *yesLabel = "")
-  {
-    return m_Callbacks->Dialog_YesNo_ShowAndGetInputLineButtonText(heading, line0, line1, line2, bCanceled, noLabel, yesLabel);
-  }
-  //@}
-
-  /*! @name GUI Text viewer Dialog */
-  //@{
-  void Dialog_TextViewer(const char *heading, const char *text)
-  {
-    return m_Callbacks->Dialog_TextViewer(heading, text);
-  }
-  //@}
-
-  /*! @name GUI select Dialog */
-  //@{
-  int Dialog_Select(const char *heading, const char *entries[], unsigned int size, int selected = -1)
-  {
-    return m_Callbacks->Dialog_Select(heading, entries, size, selected);
-  }
-  //@}
-
-private:
-  AddonCB* m_Handle;
-  KodiAPI::GUI::CB_GUILib* m_Callbacks;
-};
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h
deleted file mode 100644
index 8aad6736bc27..000000000000
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h
+++ /dev/null
@@ -1,570 +0,0 @@
-/*
- *  Copyright (C) 2005-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include <string>
-#include <vector>
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <stdint.h>
-#include <stdarg.h>
-#include <time.h>
-
-#include "Filesystem.h"
-#include "General.h"
-#include "versions.h"
-#if defined(BUILD_KODI_ADDON)
-#include "IFileTypes.h"
-#else
-#include "filesystem/IFileTypes.h"
-#endif
-
-struct __stat64;
-
-#ifdef _WIN32                   // windows
-#ifndef _SSIZE_T_DEFINED
-typedef intptr_t      ssize_t;
-#define _SSIZE_T_DEFINED
-#endif // !_SSIZE_T_DEFINED
-
-#endif
-
-#ifdef LOG_DEBUG
-#undef LOG_DEBUG
-#endif
-#ifdef LOG_INFO
-#undef LOG_INFO
-#endif
-#ifdef LOG_NOTICE
-#undef LOG_NOTICE
-#endif
-#ifdef LOG_ERROR
-#undef LOG_ERROR
-#endif
-
-typedef void* (*KODIAddOnLib_RegisterMe)(void *addonData);
-typedef void (*KODIAddOnLib_UnRegisterMe)(void *addonData, void *cbTable);
-typedef void* (*KODIGUILib_RegisterMe)(void *addonData);
-typedef void (*KODIGUILib_UnRegisterMe)(void *addonData, void *cbTable);
-typedef void* (*KODIPVRLib_RegisterMe)(void *addonData);
-typedef void (*KODIPVRLib_UnRegisterMe)(void *addonData, void *cbTable);
-
-typedef struct AddonCB
-{
-  const char* libBasePath;  ///< Never, never change this!!!
-  void*       addonData;
-  KODIAddOnLib_RegisterMe           AddOnLib_RegisterMe;
-  KODIAddOnLib_UnRegisterMe         AddOnLib_UnRegisterMe;
-  KODIGUILib_RegisterMe             GUILib_RegisterMe;
-  KODIGUILib_UnRegisterMe           GUILib_UnRegisterMe;
-  KODIPVRLib_RegisterMe             PVRLib_RegisterMe;
-  KODIPVRLib_UnRegisterMe           PVRLib_UnRegisterMe;
-} AddonCB;
-
-typedef enum addon_log
-{
-  LOG_DEBUG,
-  LOG_INFO,
-  LOG_WARNING,
-  LOG_ERROR,
-  LOG_FATAL
-} addon_log_t;
-
-namespace KodiAPI
-{
-namespace AddOn
-{
-typedef struct CB_AddOn
-{
-  void (*Log)(void *addonData, const int loglevel, const char *msg);
-  void (*QueueNotification)(void *addonData, const int type, const char *msg);
-  bool (*WakeOnLan)(const char* mac);
-  bool (*GetSetting)(void *addonData, const char *settingName, void *settingValue);
-  char* (*TranslateSpecialProtocol)(const char *strSource);
-  char* (*UnknownToUTF8)(const char *sourceDest);
-  char* (*GetLocalizedString)(const void* addonData, long dwCode);
-  char* (*GetDVDMenuLanguage)(const void* addonData);
-  void (*FreeString)(const void* addonData, char* str);
-  void (*FreeStringArray)(const void* addonData, char** arr, int numElements);
-
-  void* (*OpenFile)(const void* addonData, const char* strFileName, unsigned int flags);
-  void* (*OpenFileForWrite)(const void* addonData, const char* strFileName, bool bOverWrite);
-  ssize_t (*ReadFile)(const void* addonData, void* file, void* lpBuf, size_t uiBufSize);
-  bool (*ReadFileString)(const void* addonData, void* file, char *szLine, int iLineLength);
-  ssize_t (*WriteFile)(const void* addonData, void* file, const void* lpBuf, size_t uiBufSize);
-  void (*FlushFile)(const void* addonData, void* file);
-  int64_t (*SeekFile)(const void* addonData, void* file, int64_t iFilePosition, int iWhence);
-  int (*TruncateFile)(const void* addonData, void* file, int64_t iSize);
-  int64_t (*GetFilePosition)(const void* addonData, void* file);
-  int64_t (*GetFileLength)(const void* addonData, void* file);
-  double (*GetFileDownloadSpeed)(const void* addonData, void* file);
-  void (*CloseFile)(const void* addonData, void* file);
-  int (*GetFileChunkSize)(const void* addonData, void* file);
-  bool (*FileExists)(const void* addonData, const char *strFileName, bool bUseCache);
-  int (*StatFile)(const void* addonData, const char *strFileName, struct __stat64* buffer);
-  char *(*GetFilePropertyValue)(const void* addonData, void* file, XFILE::FileProperty type, const char *name);
-  char **(*GetFilePropertyValues)(const void* addonData, void* file, XFILE::FileProperty type, const char *name, int *numPorperties);
-  bool (*DeleteFile)(const void* addonData, const char *strFileName);
-  bool (*CanOpenDirectory)(const void* addonData, const char* strURL);
-  bool (*CreateDirectory)(const void* addonData, const char *strPath);
-  bool (*DirectoryExists)(const void* addonData, const char *strPath);
-  bool (*RemoveDirectory)(const void* addonData, const char *strPath);
-  bool (*GetDirectory)(const void* addonData, const char *strPath, const char* mask, VFSDirEntry** items, unsigned int* num_items);
-  void (*FreeDirectory)(const void* addonData, VFSDirEntry* items, unsigned int num_items);
-  void* (*CURLCreate)(const void* addonData, const char* strURL);
-  bool (*CURLAddOption)(const void* addonData, void* file, XFILE::CURLOPTIONTYPE type, const char* name, const char * value);
-  bool (*CURLOpen)(const void* addonData, void* file, unsigned int flags);
-} CB_AddOnLib;
-
-} /* namespace AddOn */
-} /* namespace KodiAPI */
-
-namespace ADDON
-{
-  class CHelper_libXBMC_addon
-  {
-  public:
-    CHelper_libXBMC_addon()
-    {
-      m_Handle = nullptr;
-      m_Callbacks = nullptr;
-    }
-
-    ~CHelper_libXBMC_addon()
-    {
-      if (m_Handle && m_Callbacks)
-      {
-        m_Handle->AddOnLib_UnRegisterMe(m_Handle->addonData, m_Callbacks);
-      }
-    }
-
-    bool RegisterMe(void *handle)
-    {
-      m_Handle = static_cast<AddonCB*>(handle);
-      if (m_Handle)
-        m_Callbacks = (KodiAPI::AddOn::CB_AddOnLib*)m_Handle->AddOnLib_RegisterMe(m_Handle->addonData);
-      if (!m_Callbacks)
-        fprintf(stderr, "libXBMC_addon-ERROR: AddOnLib_RegisterMe can't get callback table from Kodi !!!\n");
-
-      return m_Callbacks != nullptr;
-    }
-
-    /*!
-     * @brief Add a message to XBMC's log.
-     * @param loglevel The log level of the message.
-     * @param format The format of the message to pass to XBMC.
-     * @note This method uses limited buffer (16k) for the formatted output.
-     * So data, which will not fit into it, will be silently discarded.
-     */
-    void Log(const addon_log_t loglevel, const char *format, ... )
-    {
-      char buffer[16384];
-      static constexpr size_t len = sizeof (buffer) - 1;
-      va_list args;
-      va_start (args, format);
-      vsnprintf (buffer, len, format, args);
-      va_end (args);
-      buffer[len] = '\0'; // to be sure it's null-terminated
-      m_Callbacks->Log(m_Handle->addonData, loglevel, buffer);
-    }
-
-    /*!
-     * @brief Get a settings value for this add-on.
-     * @param settingName The name of the setting to get.
-     * @param settingValue The value.
-     * @return True if the settings was fetched successfully, false otherwise.
-     */
-    bool GetSetting(const char* settingName, void *settingValue)
-    {
-      return m_Callbacks->GetSetting(m_Handle->addonData, settingName, settingValue);
-    }
-
-    /*!
-    * @brief Translates a special protocol folder.
-    * @param source The file / folder to translate.
-    * @return The string translated to resolved path. Must be freed by calling FreeString() when done.
-    */
-    char *TranslateSpecialProtocol(const char *source)
-    {
-      return m_Callbacks->TranslateSpecialProtocol(source);
-    }
-
-    /*!
-     * @brief Queue a notification in the GUI.
-     * @param type The message type.
-     * @param format The format of the message to pass to display in XBMC.
-     */
-    void QueueNotification(const QueueMsg& type, const char* format, ... )
-    {
-      char buffer[16384];
-      va_list args;
-      va_start (args, format);
-      vsprintf (buffer, format, args);
-      va_end (args);
-      m_Callbacks->QueueNotification(m_Handle->addonData, type, buffer);
-    }
-
-    /*!
-     * @brief Send WakeOnLan magic packet.
-     * @param mac Network address of the host to wake.
-     * @return True if the magic packet was successfully sent, false otherwise.
-     */
-    bool WakeOnLan(const char* mac)
-    {
-      return m_Callbacks->WakeOnLan(mac);
-    }
-
-    /*!
-     * @brief Translate a string with an unknown encoding to UTF8.
-     * @param str The string to translate.
-     * @return The string translated to UTF8. Must be freed by calling FreeString() when done.
-     */
-    char* UnknownToUTF8(const char* str)
-    {
-      return m_Callbacks->UnknownToUTF8(str);
-    }
-
-    /*!
-     * @brief Get a localised message.
-     * @param dwCode The code of the message to get.
-     * @return The message. Must be freed by calling FreeString() when done.
-     */
-    char* GetLocalizedString(int dwCode)
-    {
-      return m_Callbacks->GetLocalizedString(m_Handle->addonData, dwCode);
-    }
-
-    /*!
-     * @brief Get the DVD menu language.
-     * @return The language. Must be freed by calling FreeString() when done.
-     */
-    char* GetDVDMenuLanguage()
-    {
-      return m_Callbacks->GetDVDMenuLanguage(m_Handle->addonData);
-    }
-
-    /*!
-     * @brief Free the memory used by str
-     * @param str The string to free
-     */
-    void FreeString(char* str)
-    {
-      m_Callbacks->FreeString(m_Handle->addonData, str);
-    }
-
-    /*!
-     * @brief Free the memory used by arr including its elements
-     * @param arr The string array to free
-     * @param numElements The length of the array
-     */
-    void FreeStringArray(char** arr, int numElements)
-    {
-      m_Callbacks->FreeStringArray(m_Handle->addonData, arr, numElements);
-    }
-
-    /*!
-     * @brief Open the file with filename via XBMC's CFile. Needs to be closed by calling CloseFile() when done.
-     * @param strFileName The filename to open.
-     * @param flags The flags to pass. Documented in XBMC's File.h
-     * @return A handle for the file, or NULL if it couldn't be opened.
-     */
-    void* OpenFile(const char* strFileName, unsigned int flags)
-    {
-      return m_Callbacks->OpenFile(m_Handle->addonData, strFileName, flags);
-    }
-
-    /*!
-     * @brief Open the file with filename via XBMC's CFile in write mode. Needs to be closed by calling CloseFile() when done.
-     * @param strFileName The filename to open.
-     * @param bOverWrite True to overwrite, false otherwise.
-     * @return A handle for the file, or NULL if it couldn't be opened.
-     */
-    void* OpenFileForWrite(const char* strFileName, bool bOverWrite)
-    {
-      return m_Callbacks->OpenFileForWrite(m_Handle->addonData, strFileName, bOverWrite);
-    }
-
-    /*!
-     * @brief Read from an open file.
-     * @param file The file handle to read from.
-     * @param lpBuf The buffer to store the data in.
-     * @param uiBufSize The size of the buffer.
-     * @return number of successfully read bytes if any bytes were read and stored in
-     *         buffer, zero if no bytes are available to read (end of file was reached)
-     *         or undetectable error occur, -1 in case of any explicit error
-     */
-    ssize_t ReadFile(void* file, void* lpBuf, size_t uiBufSize)
-    {
-      return m_Callbacks->ReadFile(m_Handle->addonData, file, lpBuf, uiBufSize);
-    }
-
-    /*!
-     * @brief Read a string from an open file.
-     * @param file The file handle to read from.
-     * @param szLine The buffer to store the data in.
-     * @param iLineLength The size of the buffer.
-     * @return True when a line was read, false otherwise.
-     */
-    bool ReadFileString(void* file, char *szLine, int iLineLength)
-    {
-      return m_Callbacks->ReadFileString(m_Handle->addonData, file, szLine, iLineLength);
-    }
-
-    /*!
-     * @brief Write to a file opened in write mode.
-     * @param file The file handle to write to.
-     * @param lpBuf The data to write.
-     * @param uiBufSize Size of the data to write.
-     * @return number of successfully written bytes if any bytes were written,
-     *         zero if no bytes were written and no detectable error occur,
-     *         -1 in case of any explicit error
-     */
-    ssize_t WriteFile(void* file, const void* lpBuf, size_t uiBufSize)
-    {
-      return m_Callbacks->WriteFile(m_Handle->addonData, file, lpBuf, uiBufSize);
-    }
-
-    /*!
-     * @brief Flush buffered data.
-     * @param file The file handle to flush the data for.
-     */
-    void FlushFile(void* file)
-    {
-       m_Callbacks->FlushFile(m_Handle->addonData, file);
-    }
-
-    /*!
-     * @brief Seek in an open file.
-     * @param file The file handle to see in.
-     * @param iFilePosition The new position.
-     * @param iWhence Seek argument. See stdio.h for possible values.
-     * @return The new position.
-     */
-    int64_t SeekFile(void* file, int64_t iFilePosition, int iWhence)
-    {
-      return m_Callbacks->SeekFile(m_Handle->addonData, file, iFilePosition, iWhence);
-    }
-
-    /*!
-     * @brief Truncate a file to the requested size.
-     * @param file The file handle to truncate.
-     * @param iSize The new max size.
-     * @return New size?
-     */
-    int TruncateFile(void* file, int64_t iSize)
-    {
-      return m_Callbacks->TruncateFile(m_Handle->addonData, file, iSize);
-    }
-
-    /*!
-     * @brief The current position in an open file.
-     * @param file The file handle to get the position for.
-     * @return The requested position.
-     */
-    int64_t GetFilePosition(void* file)
-    {
-      return m_Callbacks->GetFilePosition(m_Handle->addonData, file);
-    }
-
-    /*!
-     * @brief Get the file size of an open file.
-     * @param file The file to get the size for.
-     * @return The requested size.
-     */
-    int64_t GetFileLength(void* file)
-    {
-      return m_Callbacks->GetFileLength(m_Handle->addonData, file);
-    }
-
-    /*!
-    * @brief Get the download speed of an open file if available.
-    * @param file The file to get the size for.
-    * @return The download speed in seconds.
-    */
-    double GetFileDownloadSpeed(void* file)
-    {
-      return m_Callbacks->GetFileDownloadSpeed(m_Handle->addonData, file);
-    }
-
-    /*!
-     * @brief Close an open file.
-     * @param file The file handle to close.
-     */
-    void CloseFile(void* file)
-    {
-      m_Callbacks->CloseFile(m_Handle->addonData, file);
-    }
-
-    /*!
-     * @brief Get the chunk size for an open file.
-     * @param file the file handle to get the size for.
-     * @return The requested size.
-     */
-    int GetFileChunkSize(void* file)
-    {
-      return m_Callbacks->GetFileChunkSize(m_Handle->addonData, file);
-    }
-
-    /*!
-     * @brief Check if a file exists.
-     * @param strFileName The filename to check.
-     * @param bUseCache Check in file cache.
-     * @return true if the file exists false otherwise.
-     */
-    bool FileExists(const char *strFileName, bool bUseCache)
-    {
-      return m_Callbacks->FileExists(m_Handle->addonData, strFileName, bUseCache);
-    }
-
-    /*!
-     * @brief Reads file status.
-     * @param strFileName The filename to read the status from.
-     * @param buffer The file status is written into this buffer.
-     * @return The file status was successfully read.
-     */
-    int StatFile(const char *strFileName, struct __stat64* buffer)
-    {
-      return m_Callbacks->StatFile(m_Handle->addonData, strFileName, buffer);
-    }
-
-    /*!
-    * @brief Get a property from an open file.
-    * @param file The file to get an property for
-    * @param type Type of the requested property.
-    * @param name Name of the requested property / can be null.
-    * @return The value of the requested property, must be FreeString'ed.
-    */
-    char *GetFilePropertyValue(void* file, XFILE::FileProperty type, const char *name)
-    {
-      return m_Callbacks->GetFilePropertyValue(m_Handle->addonData, file, type, name);
-    }
-
-    /*!
-    * @brief Get multiple property values from an open file.
-    * @param file The file to get the property values for
-    * @param type Type of the requested property.
-    * @param name Name of the requested property / can be null.
-    * @param numValues Number of property values returned.
-    * @return List of values of the requested property, must be FreeStringArray'ed.
-    */
-    char **GetFilePropertyValues(void* file, XFILE::FileProperty type, const char *name, int *numValues)
-    {
-      return m_Callbacks->GetFilePropertyValues(m_Handle->addonData, file, type, name, numValues);
-    }
-
-    /*!
-     * @brief Deletes a file.
-     * @param strFileName The filename to delete.
-     * @return The file was successfully deleted.
-     */
-    bool DeleteFile(const char *strFileName)
-    {
-      return m_Callbacks->DeleteFile(m_Handle->addonData, strFileName);
-    }
-
-    /*!
-     * @brief Checks whether a directory can be opened.
-     * @param strUrl The URL of the directory to check.
-     * @return True when it can be opened, false otherwise.
-     */
-    bool CanOpenDirectory(const char* strUrl)
-    {
-      return m_Callbacks->CanOpenDirectory(m_Handle->addonData, strUrl);
-    }
-
-    /*!
-     * @brief Creates a directory.
-     * @param strPath Path to the directory.
-     * @return True when it was created, false otherwise.
-     */
-    bool CreateDirectory(const char *strPath)
-    {
-      return m_Callbacks->CreateDirectory(m_Handle->addonData, strPath);
-    }
-
-    /*!
-     * @brief Checks if a directory exists.
-     * @param strPath Path to the directory.
-     * @return True when it exists, false otherwise.
-     */
-    bool DirectoryExists(const char *strPath)
-    {
-      return m_Callbacks->DirectoryExists(m_Handle->addonData, strPath);
-    }
-
-    /*!
-     * @brief Removes a directory.
-     * @param strPath Path to the directory.
-     * @return True when it was removed, false otherwise.
-     */
-    bool RemoveDirectory(const char *strPath)
-    {
-      return m_Callbacks->RemoveDirectory(m_Handle->addonData, strPath);
-    }
-
-    /*!
-     * @brief Lists a directory.
-     * @param strPath Path to the directory.
-     * @param mask File mask
-     * @param items The directory entries
-     * @param num_items Number of entries in directory
-     * @return True if listing was successful, false otherwise.
-     */
-    bool GetDirectory(const char *strPath, const char* mask, VFSDirEntry** items, unsigned int* num_items)
-    {
-      return m_Callbacks->GetDirectory(m_Handle->addonData, strPath, mask, items, num_items);
-    }
-
-    /*!
-     * @brief Free a directory list
-     * @param items The directory entries
-     * @param num_items Number of entries in directory
-     */
-    void FreeDirectory(VFSDirEntry* items, unsigned int num_items)
-    {
-      m_Callbacks->FreeDirectory(m_Handle->addonData, items, num_items);
-    }
-
-    /*!
-    * @brief Create a Curl representation
-    * @param strURL the URL of the Type.
-    */
-    void* CURLCreate(const char* strURL)
-    {
-      return m_Callbacks->CURLCreate(m_Handle->addonData, strURL);
-    }
-
-    /*!
-    * @brief Adds options to the curl file created with CURLCeate
-    * @param file file pointer to the file returned by CURLCeate
-    * @param type option type to set
-    * @param name name of the option
-    * @param value value of the option
-    */
-    bool CURLAddOption(void* file, XFILE::CURLOPTIONTYPE type, const char* name, const char * value)
-    {
-      return m_Callbacks->CURLAddOption(m_Handle->addonData, file, type, name, value);
-    }
-
-    /*!
-    * @brief Opens the curl file created with CURLCeate
-    * @param file file pointer to the file returned by CURLCeate
-    * @param flags one or more bitwise or combinded flags form XFILE
-    */
-    bool CURLOpen(void* file, unsigned int flags)
-    {
-      return m_Callbacks->CURLOpen(m_Handle->addonData, file, flags);
-    }
-
-  private:
-    AddonCB* m_Handle;
-    KodiAPI::AddOn::CB_AddOnLib *m_Callbacks;
-  };
-};
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
deleted file mode 100644
index 10ba9d99b95a..000000000000
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- *  Copyright (C) 2005-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include <string>
-#include <vector>
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include "addon-instance/PVR.h"
-#include "libXBMC_addon.h"
-
-#define DVD_TIME_BASE 1000000
-
-//! @todo original definition is in DVDClock.h
-#define DVD_NOPTS_VALUE 0xFFF0000000000000
-
-class CHelper_libXBMC_pvr
-{
-public:
-  CHelper_libXBMC_pvr(void)
-  {
-    m_Handle = nullptr;
-    m_Callbacks = nullptr;
-  }
-
-  ~CHelper_libXBMC_pvr(void)
-  {
-    if (m_Handle && m_Callbacks)
-    {
-      m_Handle->PVRLib_UnRegisterMe(m_Handle->addonData, m_Callbacks);
-    }
-  }
-
-  /*!
-   * @brief Resolve all callback methods
-   * @param handle Pointer to the add-on
-   * @return True when all methods were resolved, false otherwise.
-   */
-  bool RegisterMe(void* handle)
-  {
-    m_Handle = static_cast<AddonCB*>(handle);
-    if (m_Handle)
-      m_Callbacks = (AddonInstance_PVR*)m_Handle->PVRLib_RegisterMe(m_Handle->addonData);
-    if (!m_Callbacks)
-      fprintf(stderr, "libXBMC_pvr-ERROR: PVRLib_register_me can't get callback table from Kodi !!!\n");
-
-    return m_Callbacks != NULL;
-  }
-
-  /*!
-   * @brief Transfer an EPG tag from the add-on to XBMC
-   * @param handle The handle parameter that XBMC used when requesting the EPG data
-   * @param entry The entry to transfer to XBMC
-   */
-  void TransferEpgEntry(const ADDON_HANDLE handle, const EPG_TAG* entry)
-  {
-    return m_Callbacks->toKodi->TransferEpgEntry(m_Callbacks->toKodi->kodiInstance, handle, entry);
-  }
-
-  /*!
-   * @brief Transfer a channel entry from the add-on to XBMC
-   * @param handle The handle parameter that XBMC used when requesting the channel list
-   * @param entry The entry to transfer to XBMC
-   */
-  void TransferChannelEntry(const ADDON_HANDLE handle, const PVR_CHANNEL* entry)
-  {
-    return m_Callbacks->toKodi->TransferChannelEntry(m_Callbacks->toKodi->kodiInstance, handle,
-                                                     entry);
-  }
-
-  /*!
-   * @brief Transfer a timer entry from the add-on to XBMC
-   * @param handle The handle parameter that XBMC used when requesting the timers list
-   * @param entry The entry to transfer to XBMC
-   */
-  void TransferTimerEntry(const ADDON_HANDLE handle, const PVR_TIMER* entry)
-  {
-    return m_Callbacks->toKodi->TransferTimerEntry(m_Callbacks->toKodi->kodiInstance, handle,
-                                                   entry);
-  }
-
-  /*!
-   * @brief Transfer a recording entry from the add-on to XBMC
-   * @param handle The handle parameter that XBMC used when requesting the recordings list
-   * @param entry The entry to transfer to XBMC
-   */
-  void TransferRecordingEntry(const ADDON_HANDLE handle, const PVR_RECORDING* entry)
-  {
-    return m_Callbacks->toKodi->TransferRecordingEntry(m_Callbacks->toKodi->kodiInstance, handle,
-                                                       entry);
-  }
-
-  /*!
-   * @brief Transfer a channel group from the add-on to XBMC. The group will be created if it doesn't exist.
-   * @param handle The handle parameter that XBMC used when requesting the channel groups list
-   * @param entry The entry to transfer to XBMC
-   */
-  void TransferChannelGroup(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP* entry)
-  {
-    return m_Callbacks->toKodi->TransferChannelGroup(m_Callbacks->toKodi->kodiInstance, handle,
-                                                     entry);
-  }
-
-  /*!
-   * @brief Transfer a channel group member entry from the add-on to XBMC. The channel will be added to the group if the group can be found.
-   * @param handle The handle parameter that XBMC used when requesting the channel group members list
-   * @param entry The entry to transfer to XBMC
-   */
-  void TransferChannelGroupMember(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP_MEMBER* entry)
-  {
-    return m_Callbacks->toKodi->TransferChannelGroupMember(m_Callbacks->toKodi->kodiInstance,
-                                                           handle, entry);
-  }
-
-  /*!
-   * @brief Add or replace a menu hook for the context menu for this add-on
-   * @param hook The hook to add
-   */
-  void AddMenuHook(PVR_MENUHOOK* hook)
-  {
-    return m_Callbacks->toKodi->AddMenuHook(m_Callbacks->toKodi->kodiInstance, hook);
-  }
-
-  /*!
-   * @brief Display a notification in XBMC that a recording started or stopped on the server
-   * @param strRecordingName The name of the recording to display
-   * @param strFileName The filename of the recording
-   * @param bOn True when recording started, false when it stopped
-   */
-  void Recording(const char* strRecordingName, const char* strFileName, bool bOn)
-  {
-    return m_Callbacks->toKodi->Recording(m_Callbacks->toKodi->kodiInstance, strRecordingName,
-                                          strFileName, bOn);
-  }
-
-  /*!
-   * @brief Request XBMC to update it's list of timers
-   */
-  void TriggerTimerUpdate(void)
-  {
-    return m_Callbacks->toKodi->TriggerTimerUpdate(m_Callbacks->toKodi->kodiInstance);
-  }
-
-  /*!
-   * @brief Request XBMC to update it's list of recordings
-   */
-  void TriggerRecordingUpdate(void)
-  {
-    return m_Callbacks->toKodi->TriggerRecordingUpdate(m_Callbacks->toKodi->kodiInstance);
-  }
-
-  /*!
-   * @brief Request XBMC to update it's list of channels
-   */
-  void TriggerChannelUpdate(void)
-  {
-    return m_Callbacks->toKodi->TriggerChannelUpdate(m_Callbacks->toKodi->kodiInstance);
-  }
-
-  /*!
-   * @brief Schedule an EPG update for the given channel channel
-   * @param iChannelUid The unique id of the channel for this add-on
-   */
-  void TriggerEpgUpdate(unsigned int iChannelUid)
-  {
-    return m_Callbacks->toKodi->TriggerEpgUpdate(m_Callbacks->toKodi->kodiInstance, iChannelUid);
-  }
-
-  /*!
-   * @brief Request XBMC to update it's list of channel groups
-   */
-  void TriggerChannelGroupsUpdate(void)
-  {
-    return m_Callbacks->toKodi->TriggerChannelGroupsUpdate(m_Callbacks->toKodi->kodiInstance);
-  }
-
-#ifdef USE_DEMUX
-  /*!
-   * @brief Free a packet that was allocated with AllocateDemuxPacket
-   * @param pPacket The packet to free
-   */
-  void FreeDemuxPacket(DemuxPacket* pPacket)
-  {
-    return m_Callbacks->toKodi->FreeDemuxPacket(m_Callbacks->toKodi->kodiInstance, pPacket);
-  }
-
-  /*!
-   * @brief Allocate a demux packet. Free with FreeDemuxPacket
-   * @param iDataSize The size of the data that will go into the packet
-   * @return The allocated packet
-   */
-  DemuxPacket* AllocateDemuxPacket(int iDataSize)
-  {
-    return m_Callbacks->toKodi->AllocateDemuxPacket(m_Callbacks->toKodi->kodiInstance, iDataSize);
-  }
-#endif
-
-  /*!
-   * @brief Notify a state change for a PVR backend connection
-   * @param strConnectionString The connection string reported by the backend that can be displayed in the UI.
-   * @param newState The new state.
-   * @param strMessage A localized addon-defined string representing the new state, that can be displayed
-   *        in the UI or NULL if the Kodi-defined default string for the new state shall be displayed.
-   */
-  void ConnectionStateChange(const char *strConnectionString, PVR_CONNECTION_STATE newState, const char *strMessage)
-  {
-    return m_Callbacks->toKodi->ConnectionStateChange(m_Callbacks->toKodi->kodiInstance,
-                                                      strConnectionString, newState, strMessage);
-  }
-
-  /*!
-   * @brief Notify a state change for an EPG event
-   * @param tag The EPG event.
-   * @param newState The new state. For EPG_EVENT_CREATED and EPG_EVENT_UPDATED, tag must be filled with all available
-   *        event data, not just a delta. For EPG_EVENT_DELETED, it is sufficient to fill EPG_TAG.iUniqueBroadcastId
-   */
-  void EpgEventStateChange(EPG_TAG *tag, EPG_EVENT_STATE newState)
-  {
-    return m_Callbacks->toKodi->EpgEventStateChange(m_Callbacks->toKodi->kodiInstance, tag,
-                                                    newState);
-  }
-
-  /*!
-   * @brief Get the codec id used by XBMC
-   * @param strCodecName The name of the codec
-   * @return The codec_id, or a codec_id with 0 values when not supported
-   */
-  PVR_CODEC GetCodecByName(const char* strCodecName)
-  {
-    return m_Callbacks->toKodi->GetCodecByName(m_Callbacks->toKodi->kodiInstance, strCodecName);
-  }
-
-private:
-  AddonCB* m_Handle;
-  AddonInstance_PVR *m_Callbacks;
-};
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index b7388c0dfdfd..2a2e697310be 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -38,8 +38,6 @@
 #define ADDON_GLOBAL_VERSION_MAIN_MIN                 "1.2.0"
 #define ADDON_GLOBAL_VERSION_MAIN_XML_ID              "kodi.binary.global.main"
 #define ADDON_GLOBAL_VERSION_MAIN_DEPENDS             "AddonBase.h" \
-                                                      "xbmc_addon_dll.h" \
-                                                      "libXBMC_addon.h" \
                                                       "addon-instance/" \
                                                       "c-api/addon_base.h"
 
@@ -51,7 +49,7 @@
 #define ADDON_GLOBAL_VERSION_GUI                      "5.14.0"
 #define ADDON_GLOBAL_VERSION_GUI_MIN                  "5.14.0"
 #define ADDON_GLOBAL_VERSION_GUI_XML_ID               "kodi.binary.global.gui"
-#define ADDON_GLOBAL_VERSION_GUI_DEPENDS              "libKODI_guilib.h" \
+#define ADDON_GLOBAL_VERSION_GUI_DEPENDS              "ActionIDs.h" \
                                                       "gui/"
 
 #define ADDON_GLOBAL_VERSION_AUDIOENGINE              "1.1.0"
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_addon_dll.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_addon_dll.h
deleted file mode 100644
index 97361a555a9e..000000000000
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_addon_dll.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- *  Copyright (C) 2005-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include "AddonBase.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  ADDON_STATUS __declspec(dllexport)
-      ADDON_Create(void* callbacks, const char* globalApiVersion, void* props);
-  void         __declspec(dllexport) ADDON_Destroy();
-  ADDON_STATUS __declspec(dllexport) ADDON_GetStatus();
-  ADDON_STATUS __declspec(dllexport) ADDON_SetSetting(const char *settingName, const void *settingValue);
-  __declspec(dllexport) const char* ADDON_GetTypeVersion(int type)
-  {
-    return kodi::addon::GetTypeVersion(type);
-  }
-  __declspec(dllexport) const char* ADDON_GetTypeMinVersion(int type)
-  {
-    return kodi::addon::GetTypeMinVersion(type);
-  }
-
-#ifdef __cplusplus
-};
-#endif
diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index 34eaf0563ddc..69df284e9774 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -10,6 +10,7 @@
 #include "GUIAudioManager.h"
 #include "GUIDialog.h"
 #include "Application.h"
+#include "addons/interfaces/gui/Window.h"
 #include "messaging/ApplicationMessenger.h"
 #include "messaging/helpers/DialogHelper.h"
 #include "GUIPassword.h"
@@ -130,7 +131,6 @@
 
 #include "peripherals/dialogs/GUIDialogPeripherals.h"
 #include "peripherals/dialogs/GUIDialogPeripheralSettings.h"
-#include "addons/interfaces/AddonInterfaces.h"
 
 /* Game related include files */
 #include "cores/RetroPlayer/guiwindows/GameWindowFullScreen.h"
@@ -920,7 +920,7 @@ void CGUIWindowManager::OnApplicationMessage(ThreadMessage* pMsg)
   {
     if (pMsg->lpVoid)
     {
-      ADDON::CAddonInterfaces::OnApplicationMessage(pMsg);
+      static_cast<ADDON::CGUIAddonWindowDialog*>(pMsg->lpVoid)->Show_Internal(pMsg->param2 > 0);
     }
   }
   break;

From ac7f66f2912be44566755d0e96c6eac8ac6d82a5 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Thu, 7 May 2020 23:26:42 +0200
Subject: [PATCH 12/27] [addons][inputstream] add property
 STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID

This is used to give a possible identification to the associated addon already at CreateInstance.

Normally, these would otherwise only be available after everything has been created, but this one is also available earlier.
---
 .../include/kodi/addon-instance/PVR.h             |  1 +
 .../kodi-addon-dev-kit/include/kodi/versions.h    |  2 +-
 .../DVDInputStreams/DVDFactoryInputStream.cpp     |  8 +++++++-
 .../DVDInputStreams/InputStreamAddon.cpp          |  7 +++++--
 .../DVDInputStreams/InputStreamAddon.h            |  5 ++++-
 .../Interface/Addon/InputStreamConstants.h        | 15 +++++++++++++++
 6 files changed, 33 insertions(+), 5 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index dd9aa8b986a8..353e53e4e6cc 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -511,6 +511,7 @@ extern "C" {
 
   #define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
   #define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
+  #define PVR_STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID
   #define PVR_STREAM_PROPERTY_MIMETYPE "mimetype"
   #define PVR_STREAM_PROPERTY_ISREALTIMESTREAM STREAM_PROPERTY_ISREALTIMESTREAM
   #define PVR_STREAM_PROPERTY_EPGPLAYBACKASLIVE "epgplaybackaslive"
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index 2a2e697310be..85737b70ce0b 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -97,7 +97,7 @@
 #define ADDON_INSTANCE_VERSION_IMAGEDECODER_XML_ID    "kodi.binary.instance.imagedecoder"
 #define ADDON_INSTANCE_VERSION_IMAGEDECODER_DEPENDS   "addon-instance/ImageDecoder.h"
 
-#define ADDON_INSTANCE_VERSION_INPUTSTREAM            "2.3.1"
+#define ADDON_INSTANCE_VERSION_INPUTSTREAM            "2.3.2"
 #define ADDON_INSTANCE_VERSION_INPUTSTREAM_MIN        "2.3.1"
 #define ADDON_INSTANCE_VERSION_INPUTSTREAM_XML_ID     "kodi.binary.instance.inputstream"
 #define ADDON_INSTANCE_VERSION_INPUTSTREAM_DEPENDS    "addon-instance/Inputstream.h"
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.cpp
index 4bfc5230cb33..2c3fdb89425f 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.cpp
@@ -56,7 +56,13 @@ std::shared_ptr<CDVDInputStream> CDVDFactoryInputStream::CreateInputStream(IVide
   for (auto addonInfo : addonInfos)
   {
     if (CInputStreamAddon::Supports(addonInfo, fileitem))
-      return std::shared_ptr<CInputStreamAddon>(new CInputStreamAddon(addonInfo, pPlayer, fileitem));
+    {
+      // Used to inform input stream about special identifier;
+      const std::string instanceId =
+          fileitem.GetProperty(STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID).asString();
+
+      return std::make_shared<CInputStreamAddon>(addonInfo, pPlayer, fileitem, instanceId);
+    }
   }
 
   if (fileitem.GetProperty(STREAM_PROPERTY_INPUTSTREAM).asString() ==
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
index 00b3345b876c..0f3d3d267e63 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
@@ -43,8 +43,11 @@ void CInputStreamProvider::getAddonInstance(INSTANCE_TYPE instance_type,
 using namespace ADDON;
 using namespace kodi::addon;
 
-CInputStreamAddon::CInputStreamAddon(BinaryAddonBasePtr& addonBase, IVideoPlayer* player, const CFileItem& fileitem)
-  : IAddonInstanceHandler(ADDON_INSTANCE_INPUTSTREAM, addonBase),
+CInputStreamAddon::CInputStreamAddon(BinaryAddonBasePtr& addonBase,
+                                     IVideoPlayer* player,
+                                     const CFileItem& fileitem,
+                                     const std::string& instanceId)
+  : IAddonInstanceHandler(ADDON_INSTANCE_INPUTSTREAM, addonBase, nullptr, instanceId),
     CDVDInputStream(DVDSTREAM_TYPE_ADDON, fileitem),
     m_player(player)
 {
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
index 2c8a7fc8ff47..4bf9d53fd5ce 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
@@ -43,7 +43,10 @@ class CInputStreamAddon
   , public CDVDInputStream::IChapter
 {
 public:
-  CInputStreamAddon(ADDON::BinaryAddonBasePtr& addonBase, IVideoPlayer* player, const CFileItem& fileitem);
+  CInputStreamAddon(ADDON::BinaryAddonBasePtr& addonBase,
+                    IVideoPlayer* player,
+                    const CFileItem& fileitem,
+                    const std::string& instanceId);
   ~CInputStreamAddon() override;
 
   static bool Supports(ADDON::BinaryAddonBasePtr& addonBase, const CFileItem& fileitem);
diff --git a/xbmc/cores/VideoPlayer/Interface/Addon/InputStreamConstants.h b/xbmc/cores/VideoPlayer/Interface/Addon/InputStreamConstants.h
index 1c5ce7fc2354..ff4dbead1097 100644
--- a/xbmc/cores/VideoPlayer/Interface/Addon/InputStreamConstants.h
+++ b/xbmc/cores/VideoPlayer/Interface/Addon/InputStreamConstants.h
@@ -16,6 +16,21 @@
  */
 #define STREAM_PROPERTY_INPUTSTREAM "inputstream"
 
+/*!
+ * @brief Identification string for an input stream.
+ *
+ * This value can be used in addition to @ref STREAM_PROPERTY_INPUTSTREAM. It is
+ * used to provide the respective inpustream addon with additional
+ * identification.
+ *
+ * The difference between this and other stream properties is that it is also
+ * passed in the associated @ref kodi::addon::CAddonBase::CreateInstance call.
+ *
+ * This makes it possible to select different processing classes within the
+ * associated add-on.
+ */
+#define STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID "inputstream-instance-id"
+
 /*!
  * @brief "true" to denote that the stream that should be played is a
  * realtime stream. Any other value indicates that this is not a realtime

From 8d3834d4bbf02f260f7e80322dc88c3d2f5fc6f4 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Sun, 3 May 2020 14:42:50 +0200
Subject: [PATCH 13/27] [addons][pvr] replace long long use with
 int64_t/uint64_t

With them more clean.
---
 .../include/kodi/addon-instance/PVR.h                  | 10 +++++-----
 xbmc/pvr/addons/PVRClient.cpp                          |  6 +++---
 xbmc/pvr/addons/PVRClient.h                            |  2 +-
 xbmc/pvr/addons/PVRClients.h                           |  4 ++--
 4 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index 353e53e4e6cc..3c2512d74154 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -607,7 +607,7 @@ extern "C" {
     const char*(__cdecl* GetBackendVersion)(const struct AddonInstance_PVR*);
     const char*(__cdecl* GetBackendHostname)(const struct AddonInstance_PVR*);
     const char*(__cdecl* GetConnectionString)(const struct AddonInstance_PVR*);
-    enum PVR_ERROR(__cdecl* GetDriveSpace)(const struct AddonInstance_PVR*, long long*, long long*);
+    enum PVR_ERROR(__cdecl* GetDriveSpace)(const struct AddonInstance_PVR*, uint64_t*, uint64_t*);
     enum PVR_ERROR(__cdecl* CallSettingsMenuHook)(const struct AddonInstance_PVR*,
                                                   const struct PVR_MENUHOOK*);
 
@@ -740,16 +740,16 @@ extern "C" {
     bool(__cdecl* OpenLiveStream)(const struct AddonInstance_PVR*, const struct PVR_CHANNEL*);
     void(__cdecl* CloseLiveStream)(const struct AddonInstance_PVR*);
     int(__cdecl* ReadLiveStream)(const struct AddonInstance_PVR*, unsigned char*, unsigned int);
-    long long(__cdecl* SeekLiveStream)(const struct AddonInstance_PVR*, long long, int);
-    long long(__cdecl* LengthLiveStream)(const struct AddonInstance_PVR*);
+    int64_t(__cdecl* SeekLiveStream)(const struct AddonInstance_PVR*, int64_t, int);
+    int64_t(__cdecl* LengthLiveStream)(const struct AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Recording stream read interface functions
     bool(__cdecl* OpenRecordedStream)(const struct AddonInstance_PVR*, const struct PVR_RECORDING*);
     void(__cdecl* CloseRecordedStream)(const struct AddonInstance_PVR*);
     int(__cdecl* ReadRecordedStream)(const struct AddonInstance_PVR*, unsigned char*, unsigned int);
-    long long(__cdecl* SeekRecordedStream)(const struct AddonInstance_PVR*, long long, int);
-    long long(__cdecl* LengthRecordedStream)(const struct AddonInstance_PVR*);
+    int64_t(__cdecl* SeekRecordedStream)(const struct AddonInstance_PVR*, int64_t, int);
+    int64_t(__cdecl* LengthRecordedStream)(const struct AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Stream demux interface functions
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index bd6542ba286a..7280a8c19ae8 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -533,15 +533,15 @@ const std::string& CPVRClient::GetFriendlyName() const
   return m_strFriendlyName;
 }
 
-PVR_ERROR CPVRClient::GetDriveSpace(long long& iTotal, long long& iUsed)
+PVR_ERROR CPVRClient::GetDriveSpace(uint64_t& iTotal, uint64_t& iUsed)
 {
   /* default to 0 in case of error */
   iTotal = 0;
   iUsed = 0;
 
   return DoAddonCall(__FUNCTION__, [&iTotal, &iUsed](const AddonInstance* addon) {
-    long long iTotalSpace = 0;
-    long long iUsedSpace = 0;
+    uint64_t iTotalSpace = 0;
+    uint64_t iUsedSpace = 0;
     PVR_ERROR error = addon->toAddon->GetDriveSpace(addon, &iTotalSpace, &iUsedSpace);
     if (error == PVR_ERROR_NO_ERROR)
     {
diff --git a/xbmc/pvr/addons/PVRClient.h b/xbmc/pvr/addons/PVRClient.h
index 3f5b24125ab5..71aae30d1a4b 100644
--- a/xbmc/pvr/addons/PVRClient.h
+++ b/xbmc/pvr/addons/PVRClient.h
@@ -341,7 +341,7 @@ namespace PVR
      * @param iUsed The used disk space.
      * @return PVR_ERROR_NO_ERROR if the drive space has been fetched successfully.
      */
-    PVR_ERROR GetDriveSpace(long long& iTotal, long long& iUsed);
+    PVR_ERROR GetDriveSpace(uint64_t& iTotal, uint64_t& iUsed);
 
     /*!
      * @brief Start a channel scan on the server.
diff --git a/xbmc/pvr/addons/PVRClients.h b/xbmc/pvr/addons/PVRClients.h
index 56a1a19d89b9..775c5ca78334 100644
--- a/xbmc/pvr/addons/PVRClients.h
+++ b/xbmc/pvr/addons/PVRClients.h
@@ -48,8 +48,8 @@ namespace PVR
     int numRecordings = 0;
     int numDeletedRecordings = 0;
     int numChannels = 0;
-    long long diskUsed = 0;
-    long long diskTotal = 0;
+    uint64_t diskUsed = 0;
+    uint64_t diskTotal = 0;
   };
 
   class CPVRClients : public ADDON::IAddonMgrCallback

From 712def55c93d43cdf0924bc4f90dd13bc459af54 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Tue, 5 May 2020 22:23:03 +0200
Subject: [PATCH 14/27] [addons][pvr] rename interface value inputFormat to
 mimetype

With before it has referenced to a ffmpeg file where no more contains
related data, further was this on addons only be used give Kodi his
wanted mimetype.

This change his value name to them and make link to a mimetype list,
instead to ffmpeg.
---
 xbmc/FileItem.cpp                                |  2 +-
 .../include/kodi/addon-instance/PVR.h            |  2 +-
 xbmc/pvr/addons/PVRClient.cpp                    |  2 +-
 xbmc/pvr/channels/PVRChannel.cpp                 | 16 ++++++++--------
 xbmc/pvr/channels/PVRChannel.h                   |  8 ++++----
 5 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index 6ef8b42cb91c..d0a86211a85f 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -1483,7 +1483,7 @@ void CFileItem::FillInMimeType(bool lookup /*= true*/)
     if( m_bIsFolder )
       m_mimetype = "x-directory/normal";
     else if( m_pvrChannelInfoTag )
-      m_mimetype = m_pvrChannelInfoTag->InputFormat();
+      m_mimetype = m_pvrChannelInfoTag->MimeType();
     else if( StringUtils::StartsWithNoCase(GetDynPath(), "shout://")
           || StringUtils::StartsWithNoCase(GetDynPath(), "http://")
           || StringUtils::StartsWithNoCase(GetDynPath(), "https://"))
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index 3c2512d74154..7c96fc826904 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -114,7 +114,7 @@ extern "C" {
     unsigned int iChannelNumber;
     unsigned int iSubChannelNumber;
     char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strInputFormat[PVR_ADDON_INPUT_FORMAT_STRING_LENGTH];
+    char strMimeType[PVR_ADDON_INPUT_FORMAT_STRING_LENGTH];
     unsigned int iEncryptionSystem;
     char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
     bool bIsHidden;
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index 7280a8c19ae8..c732826189c1 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -363,7 +363,7 @@ void CPVRClient::WriteClientChannelInfo(const std::shared_ptr<CPVRChannel>& xbmc
   addonChannel.iEncryptionSystem = xbmcChannel->EncryptionSystem();
   addonChannel.bIsRadio = xbmcChannel->IsRadio();
   addonChannel.bIsHidden = xbmcChannel->IsHidden();
-  strncpy(addonChannel.strInputFormat, xbmcChannel->InputFormat().c_str(), sizeof(addonChannel.strInputFormat) - 1);
+  strncpy(addonChannel.strMimeType, xbmcChannel->MimeType().c_str(), sizeof(addonChannel.strMimeType) - 1);
 }
 
 bool CPVRClient::GetAddonProperties()
diff --git a/xbmc/pvr/channels/PVRChannel.cpp b/xbmc/pvr/channels/PVRChannel.cpp
index 945fb1e94d30..c14a1505b59c 100644
--- a/xbmc/pvr/channels/PVRChannel.cpp
+++ b/xbmc/pvr/channels/PVRChannel.cpp
@@ -58,7 +58,7 @@ CPVRChannel::CPVRChannel(const PVR_CHANNEL& channel, unsigned int iClientId)
   m_iClientId(iClientId),
   m_clientChannelNumber(channel.iChannelNumber, channel.iSubChannelNumber),
   m_strClientChannelName(channel.strChannelName),
-  m_strInputFormat(channel.strInputFormat),
+  m_strMimeType(channel.strMimeType),
   m_iClientEncryptionSystem(channel.iEncryptionSystem)
 {
   if (m_strChannelName.empty())
@@ -158,14 +158,14 @@ bool CPVRChannel::UpdateFromClient(const std::shared_ptr<CPVRChannel>& channel)
 
   CSingleLock lock(m_critSection);
 
-  if (m_clientChannelNumber     != channel->m_clientChannelNumber ||
-      m_strInputFormat          != channel->InputFormat() ||
+  if (m_clientChannelNumber != channel->m_clientChannelNumber ||
+      m_strMimeType != channel->MimeType() ||
       m_iClientEncryptionSystem != channel->EncryptionSystem() ||
-      m_strClientChannelName    != channel->ClientChannelName() ||
-      m_bHasArchive             != channel->HasArchive())
+      m_strClientChannelName != channel->ClientChannelName() ||
+      m_bHasArchive != channel->HasArchive())
   {
     m_clientChannelNumber = channel->m_clientChannelNumber;
-    m_strInputFormat = channel->InputFormat();
+    m_strMimeType = channel->MimeType();
     m_iClientEncryptionSystem = channel->EncryptionSystem();
     m_strClientChannelName = channel->ClientChannelName();
     m_bHasArchive = channel->HasArchive();
@@ -743,10 +743,10 @@ std::string CPVRChannel::ClientChannelName() const
   return m_strClientChannelName;
 }
 
-std::string CPVRChannel::InputFormat() const
+std::string CPVRChannel::MimeType() const
 {
   CSingleLock lock(m_critSection);
-  return m_strInputFormat;
+  return m_strMimeType;
 }
 
 std::string CPVRChannel::Path() const
diff --git a/xbmc/pvr/channels/PVRChannel.h b/xbmc/pvr/channels/PVRChannel.h
index 971bcbf70e51..5b9acd47fa0e 100644
--- a/xbmc/pvr/channels/PVRChannel.h
+++ b/xbmc/pvr/channels/PVRChannel.h
@@ -252,16 +252,16 @@ namespace PVR
     std::string ClientChannelName() const;
 
     /*!
-     * @brief The stream input type
+     * @brief The stream input mime type
      *
      * The stream input type
      * If it is empty, ffmpeg will try to scan the stream to find the right input format.
-     * See "xbmc/cores/VideoPlayer/Codecs/ffmpeg/libavformat/allformats.c" for a
+     * See https://www.iana.org/assignments/media-types/media-types.xhtml for a
      * list of the input formats.
      *
      * @return The stream input type
      */
-    std::string InputFormat() const;
+    std::string MimeType() const;
 
     /*!
      * @brief The path in the XBMC VFS to be used by PVRManager to open and read the stream.
@@ -488,7 +488,7 @@ namespace PVR
     int m_iClientId = -1; /*!< the identifier of the client that serves this channel */
     CPVRChannelNumber m_clientChannelNumber; /*!< the channel number on the client for the currently selected channel group */
     std::string m_strClientChannelName; /*!< the name of this channel on the client */
-    std::string m_strInputFormat; /*!< the stream input type based on ffmpeg/libavformat/allformats.c */
+    std::string m_strMimeType; /*!< the stream input type based mime type, see @ref https://www.iana.org/assignments/media-types/media-types.xhtml#video */
     std::string m_strFileNameAndPath; /*!< the filename to be used by PVRManager to open and read the stream */
     int m_iClientEncryptionSystem = -1; /*!< the encryption system used by this channel. 0 for FreeToAir, -1 for unknown */
     std::string m_strClientEncryptionName; /*!< the name of the encryption system used by this channel */

From 1fdd64ecb9216970bd88986d9e00b5e94cd62709 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 11 May 2020 22:16:15 +0200
Subject: [PATCH 15/27] [addons][pvr] add EPG_EVENT_CONTENTSUBMASK... types

Before was only the main type defined on addon header, but as Kodi
already define the sup types it make sense to have also the values
of them available for addon.
---
 .../include/kodi/addon-instance/PVR.h         | 136 ++++++++++++++++++
 1 file changed, 136 insertions(+)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index 7c96fc826904..70d1e00005a7 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -184,6 +184,142 @@ extern "C" {
     EPG_GENRE_USE_STRING = 0x100
   } EPG_EVENT_CONTENTMASK;
 
+  typedef enum EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA
+  {
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_DETECTIVE_THRILLER = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ADVENTURE_WESTERN_WAR = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SCIENCEFICTION_FANTASY_HORROR = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_COMEDY = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SOAP_MELODRAMA_FOLKLORIC = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ROMANCE = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SERIOUS_CLASSICAL_RELIGIOUS_HISTORICAL = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ADULT = 0x8,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS
+  {
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_WEATHER = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_MAGAZINE = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_DOCUMENTARY = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_DISCUSSION_INTERVIEW_DEBATE = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_SHOW
+  {
+    EPG_EVENT_CONTENTSUBMASK_SHOW_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_SHOW_GAMESHOW_QUIZ_CONTEST = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_SHOW_VARIETY_SHOW = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_SHOW_TALK_SHOW = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_SHOW_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_SHOW;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_SPORTS
+  {
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_OLYMPICGAMES_WORLDCUP = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_SPORTS_MAGAZINES = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_FOOTBALL_SOCCER = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_TENNIS_SQUASH = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_TEAMSPORTS = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_ATHLETICS = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_MOTORSPORT = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_WATERSPORT = 0x8,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_WINTERSPORTS = 0x9,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_EQUESTRIAN = 0xA,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_MARTIALSPORTS = 0xB,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_SPORTS;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH
+  {
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_PRESCHOOL_CHILDREN = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_ENTERTAIN_6TO14 = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_ENTERTAIN_10TO16 = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_INFORMATIONAL_EDUCATIONAL_SCHOOL = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_CARTOONS_PUPPETS = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE
+  {
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_ROCKPOP = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_SERIOUSMUSIC_CLASSICALMUSIC = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_FOLK_TRADITIONAL_MUSIC = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_JAZZ = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_MUSICAL_OPERA = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_BALLET = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE
+  {
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_PERFORMINGARTS = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FINEARTS = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_RELIGION = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_POPULARCULTURE_TRADITIONALARTS = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_LITERATURE = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FILM_CINEMA = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_EXPERIMENTALFILM_VIDEO = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_BROADCASTING_PRESS = 0x8,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_NEWMEDIA = 0x9,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_ARTS_CULTUREMAGAZINES = 0xA,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FASHION = 0xB,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS
+  {
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_MAGAZINES_REPORTS_DOCUMENTARY = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_ECONOMICS_SOCIALADVISORY = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_REMARKABLEPEOPLE = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE
+  {
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_NATURE_ANIMALS_ENVIRONMENT = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_TECHNOLOGY_NATURALSCIENCES = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_MEDICINE_PHYSIOLOGY_PSYCHOLOGY = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_FOREIGNCOUNTRIES_EXPEDITIONS = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_SOCIAL_SPIRITUALSCIENCES = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_FURTHEREDUCATION = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_LANGUAGES = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES
+  {
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_TOURISM_TRAVEL = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_HANDICRAFT = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_MOTORING = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_FITNESSANDHEALTH = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_COOKING = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_ADVERTISEMENT_SHOPPING = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_GARDENING = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_SPECIAL
+  {
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_BLACKANDWHITE = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_UNPUBLISHED = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_LIVEBROADCAST = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_PLANOSTEREOSCOPIC = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_LOCALORREGIONAL = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_SPECIAL;
+
   #define EPG_STRING_TOKEN_SEPARATOR ","
 
   typedef enum EPG_TAG_FLAG

From 88baa691c94a4fa328f33ce8e5c1cbd9e5c22ee4 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Fri, 8 May 2020 15:32:50 +0200
Subject: [PATCH 16/27] [addons][pvr] move all "C" parts to independent header
 place

This thought to have it cleaner and to take for other languages.
---
 cmake/treedata/common/subdirs.txt             |   3 +-
 .../include/kodi/addon-instance/PVR.h         | 917 +-----------------
 .../kodi/c-api/addon-instance/CMakeLists.txt  |   3 +-
 .../include/kodi/c-api/addon-instance/pvr.h   | 291 ++++++
 .../c-api/addon-instance/pvr/CMakeLists.txt   |  15 +
 .../addon-instance/pvr/pvr_channel_groups.h   |  38 +
 .../c-api/addon-instance/pvr/pvr_channels.h   |  67 ++
 .../c-api/addon-instance/pvr/pvr_defines.h    |  44 +
 .../kodi/c-api/addon-instance/pvr/pvr_edl.h   |  37 +
 .../kodi/c-api/addon-instance/pvr/pvr_epg.h   | 229 +++++
 .../c-api/addon-instance/pvr/pvr_general.h    |  87 ++
 .../c-api/addon-instance/pvr/pvr_menu_hook.h  |  39 +
 .../c-api/addon-instance/pvr/pvr_recordings.h |  76 ++
 .../c-api/addon-instance/pvr/pvr_stream.h     |  85 ++
 .../c-api/addon-instance/pvr/pvr_timers.h     | 151 +++
 15 files changed, 1164 insertions(+), 918 deletions(-)
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/CMakeLists.txt
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_defines.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_stream.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h

diff --git a/cmake/treedata/common/subdirs.txt b/cmake/treedata/common/subdirs.txt
index 15ed9c5046d6..c1fe784d0e86 100644
--- a/cmake/treedata/common/subdirs.txt
+++ b/cmake/treedata/common/subdirs.txt
@@ -7,9 +7,10 @@ xbmc/addons/interfaces/gui                      addons_interfaces_gui
 xbmc/addons/interfaces/gui/controls             addons_interfaces_gui_controls
 xbmc/addons/interfaces/gui/dialogs              addons_interfaces_gui_dialogs
 xbmc/addons/kodi-addon-dev-kit/include/kodi     addons_kodi-addon-dev-kit_include_kodi
+xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance addons_kodi-addon-dev-kit_include_kodi_addon-instance
 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api addons_kodi-addon-dev-kit_include_kodi_c-api
 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance addons_kodi-addon-dev-kit_include_kodi_c-api_addon-instance
-xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance addons_kodi-addon-dev-kit_include_kodi_addon-instance
+xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr addons_kodi-addon-dev-kit_include_kodi_c-api_addon-instance_pvr
 xbmc/addons/kodi-addon-dev-kit/include/kodi/gui addons_kodi-addon-dev-kit_include_kodi_gui
 xbmc/addons/kodi-addon-dev-kit/include/kodi/gui/controls addons_kodi-addon-dev-kit_include_kodi_gui_controls
 xbmc/addons/kodi-addon-dev-kit/include/kodi/gui/dialogs addons_kodi-addon-dev-kit_include_kodi_gui_dialogs
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index 70d1e00005a7..5cb608ed1110 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -8,919 +8,4 @@
 
 #pragma once
 
-#include "../AddonBase.h"
-
-#ifdef BUILD_KODI_ADDON
-#include "../DemuxPacket.h"
-#include "../InputStreamConstants.h"
-#else
-#include "cores/VideoPlayer/Interface/Addon/DemuxPacket.h"
-#include "cores/VideoPlayer/Interface/Addon/InputStreamConstants.h"
-#endif
-
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <string.h>
-#include <time.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-  #define PVR_ADDON_NAME_STRING_LENGTH 1024
-  #define PVR_ADDON_URL_STRING_LENGTH 1024
-  #define PVR_ADDON_DESC_STRING_LENGTH 1024
-  #define PVR_ADDON_INPUT_FORMAT_STRING_LENGTH 32
-  #define PVR_ADDON_EDL_LENGTH 32
-  #define PVR_ADDON_TIMERTYPE_ARRAY_SIZE 32
-  #define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE 512
-  #define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL 128
-  #define PVR_ADDON_TIMERTYPE_STRING_LENGTH 128
-  #define PVR_ADDON_ATTRIBUTE_DESC_LENGTH 128
-  #define PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE 512
-  #define PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH 64
-  #define PVR_ADDON_DATE_STRING_LENGTH 32
-
-  typedef struct PVR_ATTRIBUTE_INT_VALUE
-  {
-    int iValue;
-    char strDescription[PVR_ADDON_ATTRIBUTE_DESC_LENGTH];
-  } PVR_ATTRIBUTE_INT_VALUE;
-
-  typedef struct PVR_NAMED_VALUE
-  {
-    char strName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strValue[PVR_ADDON_NAME_STRING_LENGTH];
-  } PVR_NAMED_VALUE;
-
-  typedef enum PVR_ERROR
-  {
-    PVR_ERROR_NO_ERROR = 0,
-    PVR_ERROR_UNKNOWN = -1,
-    PVR_ERROR_NOT_IMPLEMENTED = -2,
-    PVR_ERROR_SERVER_ERROR = -3,
-    PVR_ERROR_SERVER_TIMEOUT = -4,
-    PVR_ERROR_REJECTED = -5,
-    PVR_ERROR_ALREADY_PRESENT = -6,
-    PVR_ERROR_INVALID_PARAMETERS = -7,
-    PVR_ERROR_RECORDING_RUNNING = -8,
-    PVR_ERROR_FAILED = -9,
-  } PVR_ERROR;
-
-  typedef enum PVR_CONNECTION_STATE
-  {
-    PVR_CONNECTION_STATE_UNKNOWN = 0,
-    PVR_CONNECTION_STATE_SERVER_UNREACHABLE = 1,
-    PVR_CONNECTION_STATE_SERVER_MISMATCH = 2,
-    PVR_CONNECTION_STATE_VERSION_MISMATCH = 3,
-    PVR_CONNECTION_STATE_ACCESS_DENIED = 4,
-    PVR_CONNECTION_STATE_CONNECTED = 5,
-    PVR_CONNECTION_STATE_DISCONNECTED = 6,
-    PVR_CONNECTION_STATE_CONNECTING = 7,
-  } PVR_CONNECTION_STATE;
-
-  typedef struct PVR_ADDON_CAPABILITIES
-  {
-    bool bSupportsEPG;
-    bool bSupportsEPGEdl;
-    bool bSupportsTV;
-    bool bSupportsRadio;
-    bool bSupportsRecordings;
-    bool bSupportsRecordingsUndelete;
-    bool bSupportsTimers;
-    bool bSupportsChannelGroups;
-    bool bSupportsChannelScan;
-    bool bSupportsChannelSettings;
-    bool bHandlesInputStream;
-    bool bHandlesDemuxing;
-    bool bSupportsRecordingPlayCount;
-    bool bSupportsLastPlayedPosition;
-    bool bSupportsRecordingEdl;
-    bool bSupportsRecordingsRename;
-    bool bSupportsRecordingsLifetimeChange;
-    bool bSupportsDescrambleInfo;
-    bool bSupportsAsyncEPGTransfer;
-    bool bSupportsRecordingSize;
-
-    unsigned int iRecordingsLifetimesSize;
-    struct PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE];
-  } PVR_ADDON_CAPABILITIES;
-
-  typedef struct PVR_CHANNEL
-  {
-    unsigned int iUniqueId;
-    bool bIsRadio;
-    unsigned int iChannelNumber;
-    unsigned int iSubChannelNumber;
-    char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strMimeType[PVR_ADDON_INPUT_FORMAT_STRING_LENGTH];
-    unsigned int iEncryptionSystem;
-    char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
-    bool bIsHidden;
-    bool bHasArchive;
-    int iOrder;
-  } PVR_CHANNEL;
-
-  typedef struct PVR_SIGNAL_STATUS
-  {
-    char strAdapterName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strAdapterStatus[PVR_ADDON_NAME_STRING_LENGTH];
-    char strServiceName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strProviderName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strMuxName[PVR_ADDON_NAME_STRING_LENGTH];
-    int iSNR;
-    int iSignal;
-    long iBER;
-    long iUNC;
-  } PVR_SIGNAL_STATUS;
-
-  #define PVR_DESCRAMBLE_INFO_NOT_AVAILABLE -1
-
-  typedef struct PVR_DESCRAMBLE_INFO
-  {
-    int iPid;
-    int iCaid;
-    int iProvid;
-    int iEcmTime;
-    int iHops;
-    char strCardSystem[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
-    char strReader[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
-    char strFrom[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
-    char strProtocol[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
-  } PVR_DESCRAMBLE_INFO;
-
-  typedef struct PVR_CHANNEL_GROUP
-  {
-    char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
-    bool bIsRadio;
-    unsigned int iPosition;
-  } PVR_CHANNEL_GROUP;
-
-  typedef struct PVR_CHANNEL_GROUP_MEMBER
-  {
-    char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
-    unsigned int iChannelUniqueId;
-    unsigned int iChannelNumber;
-    unsigned int iSubChannelNumber;
-    int iOrder;
-  } PVR_CHANNEL_GROUP_MEMBER;
-
-  typedef enum EPG_EVENT_CONTENTMASK
-  {
-    EPG_EVENT_CONTENTMASK_UNDEFINED = 0x00,
-    EPG_EVENT_CONTENTMASK_MOVIEDRAMA = 0x10,
-    EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS = 0x20,
-    EPG_EVENT_CONTENTMASK_SHOW = 0x30,
-    EPG_EVENT_CONTENTMASK_SPORTS = 0x40,
-    EPG_EVENT_CONTENTMASK_CHILDRENYOUTH = 0x50,
-    EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE = 0x60,
-    EPG_EVENT_CONTENTMASK_ARTSCULTURE = 0x70,
-    EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS = 0x80,
-    EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE = 0x90,
-    EPG_EVENT_CONTENTMASK_LEISUREHOBBIES = 0xA0,
-    EPG_EVENT_CONTENTMASK_SPECIAL = 0xB0,
-    EPG_EVENT_CONTENTMASK_USERDEFINED = 0xF0,
-    EPG_GENRE_USE_STRING = 0x100
-  } EPG_EVENT_CONTENTMASK;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA
-  {
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_DETECTIVE_THRILLER = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ADVENTURE_WESTERN_WAR = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SCIENCEFICTION_FANTASY_HORROR = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_COMEDY = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SOAP_MELODRAMA_FOLKLORIC = 0x5,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ROMANCE = 0x6,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SERIOUS_CLASSICAL_RELIGIOUS_HISTORICAL = 0x7,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ADULT = 0x8,
-    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS
-  {
-    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_WEATHER = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_MAGAZINE = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_DOCUMENTARY = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_DISCUSSION_INTERVIEW_DEBATE = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_SHOW
-  {
-    EPG_EVENT_CONTENTSUBMASK_SHOW_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_SHOW_GAMESHOW_QUIZ_CONTEST = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_SHOW_VARIETY_SHOW = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_SHOW_TALK_SHOW = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_SHOW_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_SHOW;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_SPORTS
-  {
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_OLYMPICGAMES_WORLDCUP = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_SPORTS_MAGAZINES = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_FOOTBALL_SOCCER = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_TENNIS_SQUASH = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_TEAMSPORTS = 0x5,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_ATHLETICS = 0x6,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_MOTORSPORT = 0x7,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_WATERSPORT = 0x8,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_WINTERSPORTS = 0x9,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_EQUESTRIAN = 0xA,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_MARTIALSPORTS = 0xB,
-    EPG_EVENT_CONTENTSUBMASK_SPORTS_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_SPORTS;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH
-  {
-    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_PRESCHOOL_CHILDREN = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_ENTERTAIN_6TO14 = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_ENTERTAIN_10TO16 = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_INFORMATIONAL_EDUCATIONAL_SCHOOL = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_CARTOONS_PUPPETS = 0x5,
-    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE
-  {
-    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_ROCKPOP = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_SERIOUSMUSIC_CLASSICALMUSIC = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_FOLK_TRADITIONAL_MUSIC = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_JAZZ = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_MUSICAL_OPERA = 0x5,
-    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_BALLET = 0x6,
-    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE
-  {
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_PERFORMINGARTS = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FINEARTS = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_RELIGION = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_POPULARCULTURE_TRADITIONALARTS = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_LITERATURE = 0x5,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FILM_CINEMA = 0x6,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_EXPERIMENTALFILM_VIDEO = 0x7,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_BROADCASTING_PRESS = 0x8,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_NEWMEDIA = 0x9,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_ARTS_CULTUREMAGAZINES = 0xA,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FASHION = 0xB,
-    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS
-  {
-    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_MAGAZINES_REPORTS_DOCUMENTARY = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_ECONOMICS_SOCIALADVISORY = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_REMARKABLEPEOPLE = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE
-  {
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_NATURE_ANIMALS_ENVIRONMENT = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_TECHNOLOGY_NATURALSCIENCES = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_MEDICINE_PHYSIOLOGY_PSYCHOLOGY = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_FOREIGNCOUNTRIES_EXPEDITIONS = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_SOCIAL_SPIRITUALSCIENCES = 0x5,
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_FURTHEREDUCATION = 0x6,
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_LANGUAGES = 0x7,
-    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES
-  {
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_TOURISM_TRAVEL = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_HANDICRAFT = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_MOTORING = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_FITNESSANDHEALTH = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_COOKING = 0x5,
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_ADVERTISEMENT_SHOPPING = 0x6,
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_GARDENING = 0x7,
-    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES;
-
-  typedef enum EPG_EVENT_CONTENTSUBMASK_SPECIAL
-  {
-    EPG_EVENT_CONTENTSUBMASK_SPECIAL_GENERAL = 0x0,
-    EPG_EVENT_CONTENTSUBMASK_SPECIAL_BLACKANDWHITE = 0x1,
-    EPG_EVENT_CONTENTSUBMASK_SPECIAL_UNPUBLISHED = 0x2,
-    EPG_EVENT_CONTENTSUBMASK_SPECIAL_LIVEBROADCAST = 0x3,
-    EPG_EVENT_CONTENTSUBMASK_SPECIAL_PLANOSTEREOSCOPIC = 0x4,
-    EPG_EVENT_CONTENTSUBMASK_SPECIAL_LOCALORREGIONAL = 0x5,
-    EPG_EVENT_CONTENTSUBMASK_SPECIAL_USERDEFINED = 0xF
-  } EPG_EVENT_CONTENTSUBMASK_SPECIAL;
-
-  #define EPG_STRING_TOKEN_SEPARATOR ","
-
-  typedef enum EPG_TAG_FLAG
-  {
-    EPG_TAG_FLAG_UNDEFINED = 0,
-    EPG_TAG_FLAG_IS_SERIES = (1 << 0),
-    EPG_TAG_FLAG_IS_NEW = (1 << 1),
-    EPG_TAG_FLAG_IS_PREMIERE = (1 << 2),
-    EPG_TAG_FLAG_IS_FINALE = (1 << 3),
-    EPG_TAG_FLAG_IS_LIVE = (1 << 4),
-  } EPG_TAG_FLAG;
-
-  #define EPG_TAG_INVALID_UID 0
-
-  #define EPG_TAG_INVALID_SERIES_EPISODE -1
-
-  #define EPG_TIMEFRAME_UNLIMITED -1
-
-  typedef enum EPG_EVENT_STATE
-  {
-    EPG_EVENT_CREATED = 0,
-    EPG_EVENT_UPDATED = 1,
-    EPG_EVENT_DELETED = 2,
-  } EPG_EVENT_STATE;
-
-  typedef struct EPG_TAG
-  {
-    unsigned int iUniqueBroadcastId;
-    unsigned int iUniqueChannelId;
-    const char* strTitle;
-    time_t startTime;
-    time_t endTime;
-    const char* strPlotOutline;
-    const char* strPlot;
-    const char* strOriginalTitle;
-    const char* strCast;
-    const char* strDirector;
-    const char* strWriter;
-    int iYear;
-    const char* strIMDBNumber;
-    const char* strIconPath;
-    int iGenreType;
-    int iGenreSubType;
-    const char* strGenreDescription;
-    const char* strFirstAired;
-    int iParentalRating;
-    int iStarRating;
-    int iSeriesNumber;
-    int iEpisodeNumber;
-    int iEpisodePartNumber;
-    const char* strEpisodeName;
-    unsigned int iFlags;
-    const char* strSeriesLink;
-  } EPG_TAG;
-
-  typedef enum PVR_RECORDING_FLAG
-  {
-    PVR_RECORDING_FLAG_UNDEFINED = 0,
-    PVR_RECORDING_FLAG_IS_SERIES = (1 << 0),
-    PVR_RECORDING_FLAG_IS_NEW = (1 << 1),
-    PVR_RECORDING_FLAG_IS_PREMIERE = (1 << 2),
-    PVR_RECORDING_FLAG_IS_FINALE = (1 << 3),
-    PVR_RECORDING_FLAG_IS_LIVE = (1 << 4),
-  } PVR_RECORDING_FLAG;
-
-  #define PVR_RECORDING_INVALID_SERIES_EPISODE EPG_TAG_INVALID_SERIES_EPISODE
-
-  typedef enum PVR_RECORDING_CHANNEL_TYPE
-  {
-    PVR_RECORDING_CHANNEL_TYPE_UNKNOWN = 0,
-    PVR_RECORDING_CHANNEL_TYPE_TV = 1,
-    PVR_RECORDING_CHANNEL_TYPE_RADIO = 2,
-  } PVR_RECORDING_CHANNEL_TYPE;
-
-  typedef struct PVR_RECORDING
-  {
-    char strRecordingId[PVR_ADDON_NAME_STRING_LENGTH];
-    char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
-    char strEpisodeName[PVR_ADDON_NAME_STRING_LENGTH];
-    int iSeriesNumber;
-    int iEpisodeNumber;
-    int iYear;
-    char strDirectory[PVR_ADDON_URL_STRING_LENGTH];
-    char strPlotOutline[PVR_ADDON_DESC_STRING_LENGTH];
-    char strPlot[PVR_ADDON_DESC_STRING_LENGTH];
-    char strGenreDescription[PVR_ADDON_DESC_STRING_LENGTH];
-    char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
-    char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
-    char strThumbnailPath[PVR_ADDON_URL_STRING_LENGTH];
-    char strFanartPath[PVR_ADDON_URL_STRING_LENGTH];
-    time_t recordingTime;
-    int iDuration;
-    int iPriority;
-    int iLifetime;
-    int iGenreType;
-    int iGenreSubType;
-    int iPlayCount;
-    int iLastPlayedPosition;
-    bool bIsDeleted;
-    unsigned int iEpgEventId;
-    int iChannelUid;
-    enum PVR_RECORDING_CHANNEL_TYPE channelType;
-    char strFirstAired[PVR_ADDON_DATE_STRING_LENGTH];
-    unsigned int iFlags;
-    int64_t sizeInBytes;
-  } PVR_RECORDING;
-
-  #define PVR_TIMER_TYPE_NONE 0
-  #define PVR_TIMER_NO_CLIENT_INDEX 0
-  #define PVR_TIMER_NO_PARENT PVR_TIMER_NO_CLIENT_INDEX
-  #define PVR_TIMER_NO_EPG_UID EPG_TAG_INVALID_UID
-  #define PVR_TIMER_ANY_CHANNEL -1
-
-  typedef enum PVR_TIMER_TYPES
-  {
-    PVR_TIMER_TYPE_ATTRIBUTE_NONE = 0,
-    PVR_TIMER_TYPE_IS_MANUAL = (1 << 0),
-    PVR_TIMER_TYPE_IS_REPEATING = (1 << 1),
-    PVR_TIMER_TYPE_IS_READONLY = (1 << 2),
-    PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES = (1 << 3),
-    PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE = (1 << 4),
-    PVR_TIMER_TYPE_SUPPORTS_CHANNELS = (1 << 5),
-    PVR_TIMER_TYPE_SUPPORTS_START_TIME = (1 << 6),
-    PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH = (1 << 7),
-    PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH = (1 << 8),
-    PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY = (1 << 9),
-    PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS = (1 << 10),
-    PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES = (1 << 11),
-    PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN = (1 << 12),
-    PVR_TIMER_TYPE_SUPPORTS_PRIORITY = (1 << 13),
-    PVR_TIMER_TYPE_SUPPORTS_LIFETIME = (1 << 14),
-    PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS = (1 << 15),
-    PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP = (1 << 16),
-    PVR_TIMER_TYPE_SUPPORTS_END_TIME = (1 << 17),
-    PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME = (1 << 18),
-    PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME = (1 << 19),
-    PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS = (1 << 20),
-    PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE = (1 << 21),
-    PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE = (1 << 22),
-    PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE = (1 << 23),
-    PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL = (1 << 24),
-    PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE = (1 << 25),
-    PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE = (1 << 26),
-    PVR_TIMER_TYPE_IS_REMINDER = (1 << 27),
-    PVR_TIMER_TYPE_SUPPORTS_START_MARGIN = (1 << 28),
-    PVR_TIMER_TYPE_SUPPORTS_END_MARGIN = (1 << 29),
-  } PVR_TIMER_TYPES;
-
-  typedef enum PVR_WEEKDAYS
-  {
-    PVR_WEEKDAY_NONE = 0,
-    PVR_WEEKDAY_MONDAY = (1 << 0),
-    PVR_WEEKDAY_TUESDAY = (1 << 1),
-    PVR_WEEKDAY_WEDNESDAY = (1 << 2),
-    PVR_WEEKDAY_THURSDAY = (1 << 3),
-    PVR_WEEKDAY_FRIDAY = (1 << 4),
-    PVR_WEEKDAY_SATURDAY = (1 << 5),
-    PVR_WEEKDAY_SUNDAY = (1 << 6),
-    PVR_WEEKDAY_ALLDAYS = PVR_WEEKDAY_MONDAY | PVR_WEEKDAY_TUESDAY | PVR_WEEKDAY_WEDNESDAY |
-                          PVR_WEEKDAY_THURSDAY | PVR_WEEKDAY_FRIDAY | PVR_WEEKDAY_SATURDAY |
-                          PVR_WEEKDAY_SUNDAY
-  } PVR_WEEKDAY;
-
-  typedef enum PVR_TIMER_STATE
-  {
-    PVR_TIMER_STATE_NEW = 0,
-    PVR_TIMER_STATE_SCHEDULED = 1,
-    PVR_TIMER_STATE_RECORDING = 2,
-    PVR_TIMER_STATE_COMPLETED = 3,
-    PVR_TIMER_STATE_ABORTED = 4,
-    PVR_TIMER_STATE_CANCELLED = 5,
-    PVR_TIMER_STATE_CONFLICT_OK = 6,
-    PVR_TIMER_STATE_CONFLICT_NOK = 7,
-    PVR_TIMER_STATE_ERROR = 8,
-    PVR_TIMER_STATE_DISABLED = 9,
-  } PVR_TIMER_STATE;
-
-  typedef struct PVR_TIMER
-  {
-    unsigned int iClientIndex;
-    unsigned int iParentClientIndex;
-    int iClientChannelUid;
-    time_t startTime;
-    time_t endTime;
-    bool bStartAnyTime;
-    bool bEndAnyTime;
-    enum PVR_TIMER_STATE state;
-    unsigned int iTimerType;
-    char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
-    char strEpgSearchString[PVR_ADDON_NAME_STRING_LENGTH];
-    bool bFullTextEpgSearch;
-    char strDirectory[PVR_ADDON_URL_STRING_LENGTH];
-    char strSummary[PVR_ADDON_DESC_STRING_LENGTH];
-    int iPriority;
-    int iLifetime;
-    int iMaxRecordings;
-    unsigned int iRecordingGroup;
-    time_t firstDay;
-    unsigned int iWeekdays;
-    unsigned int iPreventDuplicateEpisodes;
-    unsigned int iEpgUid;
-    unsigned int iMarginStart;
-    unsigned int iMarginEnd;
-    int iGenreType;
-    int iGenreSubType;
-    char strSeriesLink[PVR_ADDON_URL_STRING_LENGTH];
-  } PVR_TIMER;
-
-  typedef struct PVR_TIMER_TYPE
-  {
-    unsigned int iId;
-    unsigned int iAttributes;
-    char strDescription[PVR_ADDON_TIMERTYPE_STRING_LENGTH];
-
-    unsigned int iPrioritiesSize;
-    struct PVR_ATTRIBUTE_INT_VALUE priorities[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-    int iPrioritiesDefault;
-
-    unsigned int iLifetimesSize;
-    struct PVR_ATTRIBUTE_INT_VALUE lifetimes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-    int iLifetimesDefault;
-
-    unsigned int iPreventDuplicateEpisodesSize;
-    struct PVR_ATTRIBUTE_INT_VALUE preventDuplicateEpisodes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-    unsigned int iPreventDuplicateEpisodesDefault;
-
-    unsigned int iRecordingGroupSize;
-    struct PVR_ATTRIBUTE_INT_VALUE recordingGroup[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
-    unsigned int iRecordingGroupDefault;
-
-    unsigned int iMaxRecordingsSize;
-    struct PVR_ATTRIBUTE_INT_VALUE maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
-    int iMaxRecordingsDefault;
-  } PVR_TIMER_TYPE;
-
-  typedef enum PVR_MENUHOOK_CAT
-  {
-    PVR_MENUHOOK_UNKNOWN = -1,
-    PVR_MENUHOOK_ALL = 0,
-    PVR_MENUHOOK_CHANNEL = 1,
-    PVR_MENUHOOK_TIMER = 2,
-    PVR_MENUHOOK_EPG = 3,
-    PVR_MENUHOOK_RECORDING = 4,
-    PVR_MENUHOOK_DELETED_RECORDING = 5,
-    PVR_MENUHOOK_SETTING = 6,
-  } PVR_MENUHOOK_CAT;
-
-  typedef struct PVR_MENUHOOK
-  {
-    unsigned int iHookId;
-    unsigned int iLocalizedStringId;
-    enum PVR_MENUHOOK_CAT category;
-  } PVR_MENUHOOK;
-
-  typedef enum PVR_EDL_TYPE
-  {
-    PVR_EDL_TYPE_CUT = 0,
-    PVR_EDL_TYPE_MUTE = 1,
-    PVR_EDL_TYPE_SCENE = 2,
-    PVR_EDL_TYPE_COMBREAK = 3
-  } PVR_EDL_TYPE;
-
-  typedef struct PVR_EDL_ENTRY
-  {
-    int64_t start;
-    int64_t end;
-    enum PVR_EDL_TYPE type;
-  } PVR_EDL_ENTRY;
-
-  #define PVR_STREAM_MAX_STREAMS 20
-
-  #define PVR_INVALID_CODEC_ID 0
-  #define PVR_INVALID_CODEC \
-    { \
-      PVR_CODEC_TYPE_UNKNOWN, PVR_INVALID_CODEC_ID \
-    }
-
-  typedef enum PVR_CODEC_TYPE
-  {
-    PVR_CODEC_TYPE_UNKNOWN = -1,
-    PVR_CODEC_TYPE_VIDEO,
-    PVR_CODEC_TYPE_AUDIO,
-    PVR_CODEC_TYPE_DATA,
-    PVR_CODEC_TYPE_SUBTITLE,
-    PVR_CODEC_TYPE_RDS,
-    PVR_CODEC_TYPE_NB
-  } PVR_CODEC_TYPE;
-
-  typedef struct PVR_CODEC
-  {
-    enum PVR_CODEC_TYPE codec_type;
-    unsigned int codec_id;
-  } PVR_CODEC;
-
-  typedef struct PVR_STREAM_PROPERTIES
-  {
-    unsigned int iStreamCount;
-    struct PVR_STREAM
-    {
-      unsigned int iPID;
-      enum PVR_CODEC_TYPE iCodecType;
-      unsigned int iCodecId;
-      char strLanguage[4];
-      int iSubtitleInfo;
-      int iFPSScale;
-      int iFPSRate;
-      int iHeight;
-      int iWidth;
-      float fAspect;
-      int iChannels;
-      int iSampleRate;
-      int iBlockAlign;
-      int iBitRate;
-      int iBitsPerSample;
-    } stream[PVR_STREAM_MAX_STREAMS];
-  } PVR_STREAM_PROPERTIES;
-
-  typedef struct PVR_STREAM_TIMES
-  {
-    time_t startTime;
-    int64_t ptsStart;
-    int64_t ptsBegin;
-    int64_t ptsEnd;
-  } PVR_STREAM_TIMES;
-
-  #define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
-  #define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
-  #define PVR_STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID
-  #define PVR_STREAM_PROPERTY_MIMETYPE "mimetype"
-  #define PVR_STREAM_PROPERTY_ISREALTIMESTREAM STREAM_PROPERTY_ISREALTIMESTREAM
-  #define PVR_STREAM_PROPERTY_EPGPLAYBACKASLIVE "epgplaybackaslive"
-  #define PVR_STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG
-
-  #define PVR_CHANNEL_INVALID_UID -1
-
-  struct AddonInstance_PVR;
-
-  /*!
-   * @brief Structure to define typical standard values
-   */
-  typedef struct AddonProperties_PVR
-  {
-    const char* strUserPath;
-    const char* strClientPath;
-    int iEpgMaxDays;
-  } AddonProperties_PVR;
-
-  /*!
-   * @brief Structure to transfer the methods from Kodi to addon
-   */
-  typedef struct AddonToKodiFuncTable_PVR
-  {
-    // Pointer inside Kodi where used from him to find his class
-    KODI_HANDLE kodiInstance;
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // General callback functions
-    void (*AddMenuHook)(void* kodiInstance, struct PVR_MENUHOOK* hook);
-    void (*Recording)(void* kodiInstance, const char* Name, const char* FileName, bool On);
-    void (*ConnectionStateChange)(void* kodiInstance,
-                                  const char* strConnectionString,
-                                  enum PVR_CONNECTION_STATE newState,
-                                  const char* strMessage);
-    void (*EpgEventStateChange)(void* kodiInstance,
-                                struct EPG_TAG* tag,
-                                enum EPG_EVENT_STATE newState);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Transfer functions where give data back to Kodi, e.g. GetChannels calls TransferChannelEntry
-    void (*TransferChannelEntry)(void* kodiInstance,
-                                 const ADDON_HANDLE handle,
-                                 const struct PVR_CHANNEL* chan);
-    void (*TransferChannelGroup)(void* kodiInstance,
-                                 const ADDON_HANDLE handle,
-                                 const struct PVR_CHANNEL_GROUP* group);
-    void (*TransferChannelGroupMember)(void* kodiInstance,
-                                       const ADDON_HANDLE handle,
-                                       const struct PVR_CHANNEL_GROUP_MEMBER* member);
-    void (*TransferEpgEntry)(void* kodiInstance,
-                             const ADDON_HANDLE handle,
-                             const struct EPG_TAG* epgentry);
-    void (*TransferRecordingEntry)(void* kodiInstance,
-                                   const ADDON_HANDLE handle,
-                                   const struct PVR_RECORDING* recording);
-    void (*TransferTimerEntry)(void* kodiInstance,
-                               const ADDON_HANDLE handle,
-                               const struct PVR_TIMER* timer);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Kodi inform interface functions
-    void (*TriggerChannelUpdate)(void* kodiInstance);
-    void (*TriggerChannelGroupsUpdate)(void* kodiInstance);
-    void (*TriggerEpgUpdate)(void* kodiInstance, unsigned int iChannelUid);
-    void (*TriggerRecordingUpdate)(void* kodiInstance);
-    void (*TriggerTimerUpdate)(void* kodiInstance);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Stream demux interface functions
-    void (*FreeDemuxPacket)(void* kodiInstance, struct DemuxPacket* pPacket);
-    struct DemuxPacket* (*AllocateDemuxPacket)(void* kodiInstance, int iDataSize);
-    struct PVR_CODEC (*GetCodecByName)(const void* kodiInstance, const char* strCodecName);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // New functions becomes added below and can be on another API change (where
-    // breaks min API version) moved up.
-  } AddonToKodiFuncTable_PVR;
-
-  /*!
-   * @brief Structure to transfer the methods from addon to Kodi
-   */
-  typedef struct KodiToAddonFuncTable_PVR
-  {
-    // Pointer inside addon where used on them to find his instance class (currently unused!)
-    KODI_HANDLE addonInstance;
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // General interface functions
-    enum PVR_ERROR(__cdecl* GetCapabilities)(const struct AddonInstance_PVR*,
-                                             struct PVR_ADDON_CAPABILITIES*);
-    const char*(__cdecl* GetBackendName)(const struct AddonInstance_PVR*);
-    const char*(__cdecl* GetBackendVersion)(const struct AddonInstance_PVR*);
-    const char*(__cdecl* GetBackendHostname)(const struct AddonInstance_PVR*);
-    const char*(__cdecl* GetConnectionString)(const struct AddonInstance_PVR*);
-    enum PVR_ERROR(__cdecl* GetDriveSpace)(const struct AddonInstance_PVR*, uint64_t*, uint64_t*);
-    enum PVR_ERROR(__cdecl* CallSettingsMenuHook)(const struct AddonInstance_PVR*,
-                                                  const struct PVR_MENUHOOK*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Channel interface functions
-
-    int(__cdecl* GetChannelsAmount)(const struct AddonInstance_PVR*);
-    enum PVR_ERROR(__cdecl* GetChannels)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
-    enum PVR_ERROR(__cdecl* GetChannelStreamProperties)(const struct AddonInstance_PVR*,
-                                                        const struct PVR_CHANNEL*,
-                                                        struct PVR_NAMED_VALUE*,
-                                                        unsigned int*);
-    enum PVR_ERROR(__cdecl* GetSignalStatus)(const struct AddonInstance_PVR*,
-                                             int,
-                                             struct PVR_SIGNAL_STATUS*);
-    enum PVR_ERROR(__cdecl* GetDescrambleInfo)(const struct AddonInstance_PVR*,
-                                               int,
-                                               struct PVR_DESCRAMBLE_INFO*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Channel group interface functions
-    int(__cdecl* GetChannelGroupsAmount)(const struct AddonInstance_PVR*);
-    enum PVR_ERROR(__cdecl* GetChannelGroups)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
-    enum PVR_ERROR(__cdecl* GetChannelGroupMembers)(const struct AddonInstance_PVR*,
-                                                    ADDON_HANDLE,
-                                                    const struct PVR_CHANNEL_GROUP*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Channel edit interface functions
-    enum PVR_ERROR(__cdecl* DeleteChannel)(const struct AddonInstance_PVR*,
-                                           const struct PVR_CHANNEL*);
-    enum PVR_ERROR(__cdecl* RenameChannel)(const struct AddonInstance_PVR*,
-                                           const struct PVR_CHANNEL*);
-    enum PVR_ERROR(__cdecl* OpenDialogChannelSettings)(const struct AddonInstance_PVR*,
-                                                       const struct PVR_CHANNEL*);
-    enum PVR_ERROR(__cdecl* OpenDialogChannelAdd)(const struct AddonInstance_PVR*,
-                                                  const struct PVR_CHANNEL*);
-    enum PVR_ERROR(__cdecl* OpenDialogChannelScan)(const struct AddonInstance_PVR*);
-    enum PVR_ERROR(__cdecl* CallChannelMenuHook)(const struct AddonInstance_PVR*,
-                                                 const PVR_MENUHOOK*,
-                                                 const PVR_CHANNEL*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // EPG interface functions
-    enum PVR_ERROR(__cdecl* GetEPGForChannel)(const struct AddonInstance_PVR*,
-                                              ADDON_HANDLE,
-                                              int,
-                                              time_t,
-                                              time_t);
-    enum PVR_ERROR(__cdecl* IsEPGTagRecordable)(const struct AddonInstance_PVR*,
-                                                const struct EPG_TAG*,
-                                                bool*);
-    enum PVR_ERROR(__cdecl* IsEPGTagPlayable)(const struct AddonInstance_PVR*,
-                                              const struct EPG_TAG*,
-                                              bool*);
-    enum PVR_ERROR(__cdecl* GetEPGTagEdl)(const struct AddonInstance_PVR*,
-                                          const struct EPG_TAG*,
-                                          struct PVR_EDL_ENTRY[],
-                                          int*);
-    enum PVR_ERROR(__cdecl* GetEPGTagStreamProperties)(const struct AddonInstance_PVR*,
-                                                       const struct EPG_TAG*,
-                                                       struct PVR_NAMED_VALUE*,
-                                                       unsigned int*);
-    enum PVR_ERROR(__cdecl* SetEPGTimeFrame)(const struct AddonInstance_PVR*, int);
-    enum PVR_ERROR(__cdecl* CallEPGMenuHook)(const struct AddonInstance_PVR*,
-                                             const struct PVR_MENUHOOK*,
-                                             const struct EPG_TAG*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Recording interface functions
-    int(__cdecl* GetRecordingsAmount)(const struct AddonInstance_PVR*, bool);
-    enum PVR_ERROR(__cdecl* GetRecordings)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
-    enum PVR_ERROR(__cdecl* DeleteRecording)(const struct AddonInstance_PVR*,
-                                             const struct PVR_RECORDING*);
-    enum PVR_ERROR(__cdecl* UndeleteRecording)(const struct AddonInstance_PVR*,
-                                               const struct PVR_RECORDING*);
-    enum PVR_ERROR(__cdecl* DeleteAllRecordingsFromTrash)(const struct AddonInstance_PVR*);
-    enum PVR_ERROR(__cdecl* RenameRecording)(const struct AddonInstance_PVR*,
-                                             const struct PVR_RECORDING*);
-    enum PVR_ERROR(__cdecl* SetRecordingLifetime)(const struct AddonInstance_PVR*,
-                                                  const struct PVR_RECORDING*);
-    enum PVR_ERROR(__cdecl* SetRecordingPlayCount)(const struct AddonInstance_PVR*,
-                                                   const struct PVR_RECORDING*,
-                                                   int);
-    enum PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
-                                                            const struct PVR_RECORDING*,
-                                                            int);
-    int(__cdecl* GetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
-                                                 const struct PVR_RECORDING*);
-    enum PVR_ERROR(__cdecl* GetRecordingEdl)(const struct AddonInstance_PVR*,
-                                             const struct PVR_RECORDING*,
-                                             struct PVR_EDL_ENTRY[],
-                                             int*);
-    enum PVR_ERROR(__cdecl* GetRecordingSize)(const struct AddonInstance_PVR*,
-                                              const PVR_RECORDING*,
-                                              int64_t*);
-    enum PVR_ERROR(__cdecl* GetRecordingStreamProperties)(const struct AddonInstance_PVR*,
-                                                          const struct PVR_RECORDING*,
-                                                          struct PVR_NAMED_VALUE*,
-                                                          unsigned int*);
-    enum PVR_ERROR(__cdecl* CallRecordingMenuHook)(const struct AddonInstance_PVR*,
-                                                   const struct PVR_MENUHOOK*,
-                                                   const struct PVR_RECORDING*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Timer interface functions
-    enum PVR_ERROR(__cdecl* GetTimerTypes)(const struct AddonInstance_PVR*,
-                                           struct PVR_TIMER_TYPE[],
-                                           int*);
-    int(__cdecl* GetTimersAmount)(const struct AddonInstance_PVR*);
-    enum PVR_ERROR(__cdecl* GetTimers)(const struct AddonInstance_PVR*, ADDON_HANDLE);
-    enum PVR_ERROR(__cdecl* AddTimer)(const struct AddonInstance_PVR*, const struct PVR_TIMER*);
-    enum PVR_ERROR(__cdecl* DeleteTimer)(const struct AddonInstance_PVR*,
-                                         const struct PVR_TIMER*,
-                                         bool);
-    enum PVR_ERROR(__cdecl* UpdateTimer)(const struct AddonInstance_PVR*, const struct PVR_TIMER*);
-    enum PVR_ERROR(__cdecl* CallTimerMenuHook)(const struct AddonInstance_PVR*,
-                                               const struct PVR_MENUHOOK*,
-                                               const struct PVR_TIMER*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Powersaving interface functions
-    void(__cdecl* OnSystemSleep)(const struct AddonInstance_PVR*);
-    void(__cdecl* OnSystemWake)(const struct AddonInstance_PVR*);
-    void(__cdecl* OnPowerSavingActivated)(const struct AddonInstance_PVR*);
-    void(__cdecl* OnPowerSavingDeactivated)(const struct AddonInstance_PVR*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Live stream read interface functions
-    bool(__cdecl* OpenLiveStream)(const struct AddonInstance_PVR*, const struct PVR_CHANNEL*);
-    void(__cdecl* CloseLiveStream)(const struct AddonInstance_PVR*);
-    int(__cdecl* ReadLiveStream)(const struct AddonInstance_PVR*, unsigned char*, unsigned int);
-    int64_t(__cdecl* SeekLiveStream)(const struct AddonInstance_PVR*, int64_t, int);
-    int64_t(__cdecl* LengthLiveStream)(const struct AddonInstance_PVR*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Recording stream read interface functions
-    bool(__cdecl* OpenRecordedStream)(const struct AddonInstance_PVR*, const struct PVR_RECORDING*);
-    void(__cdecl* CloseRecordedStream)(const struct AddonInstance_PVR*);
-    int(__cdecl* ReadRecordedStream)(const struct AddonInstance_PVR*, unsigned char*, unsigned int);
-    int64_t(__cdecl* SeekRecordedStream)(const struct AddonInstance_PVR*, int64_t, int);
-    int64_t(__cdecl* LengthRecordedStream)(const struct AddonInstance_PVR*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // Stream demux interface functions
-    enum PVR_ERROR(__cdecl* GetStreamProperties)(const struct AddonInstance_PVR*,
-                                                 struct PVR_STREAM_PROPERTIES*);
-    struct DemuxPacket*(__cdecl* DemuxRead)(const struct AddonInstance_PVR*);
-    void(__cdecl* DemuxReset)(const struct AddonInstance_PVR*);
-    void(__cdecl* DemuxAbort)(const struct AddonInstance_PVR*);
-    void(__cdecl* DemuxFlush)(const struct AddonInstance_PVR*);
-    void(__cdecl* SetSpeed)(const struct AddonInstance_PVR*, int);
-    void(__cdecl* FillBuffer)(const struct AddonInstance_PVR*, bool);
-    bool(__cdecl* SeekTime)(const struct AddonInstance_PVR*, double, bool, double*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // General stream interface functions
-    bool(__cdecl* CanPauseStream)(const struct AddonInstance_PVR*);
-    void(__cdecl* PauseStream)(const struct AddonInstance_PVR*, bool);
-    bool(__cdecl* CanSeekStream)(const struct AddonInstance_PVR*);
-    bool(__cdecl* IsRealTimeStream)(const struct AddonInstance_PVR*);
-    enum PVR_ERROR(__cdecl* GetStreamTimes)(const struct AddonInstance_PVR*,
-                                            struct PVR_STREAM_TIMES*);
-    enum PVR_ERROR(__cdecl* GetStreamReadChunkSize)(const struct AddonInstance_PVR*, int*);
-
-    //--==----==----==----==----==----==----==----==----==----==----==----==----==
-    // New functions becomes added below and can be on another API change (where
-    // breaks min API version) moved up.
-  } KodiToAddonFuncTable_PVR;
-
-  typedef struct AddonInstance_PVR
-  {
-    struct AddonProperties_PVR* props;
-    struct AddonToKodiFuncTable_PVR* toKodi;
-    struct KodiToAddonFuncTable_PVR* toAddon;
-  } AddonInstance_PVR;
-
-#ifdef __cplusplus
-}
-#endif
+#include "../c-api/addon-instance/pvr.h"
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/CMakeLists.txt
index fe229254528f..dfcfe665dc41 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/CMakeLists.txt
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/CMakeLists.txt
@@ -1,4 +1,5 @@
-set(HEADERS image_decoder.h)
+set(HEADERS image_decoder.h
+            pvr.h)
 
 if(NOT ENABLE_STATIC_LIBS)
   core_add_library(addons_kodi-addon-dev-kit_include_kodi_c-api_addon-instance)
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
new file mode 100644
index 000000000000..c89697894fb5
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
@@ -0,0 +1,291 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "pvr/pvr_channel_groups.h"
+#include "pvr/pvr_channels.h"
+#include "pvr/pvr_defines.h"
+#include "pvr/pvr_edl.h"
+#include "pvr/pvr_epg.h"
+#include "pvr/pvr_general.h"
+#include "pvr/pvr_menu_hook.h"
+#include "pvr/pvr_recordings.h"
+#include "pvr/pvr_stream.h"
+#include "pvr/pvr_timers.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  /*!
+   * @brief Structure to define typical standard values
+   */
+  typedef struct AddonProperties_PVR
+  {
+    const char* strUserPath;
+    const char* strClientPath;
+    int iEpgMaxDays;
+  } AddonProperties_PVR;
+
+  /*!
+   * @brief Structure to transfer the methods from Kodi to addon
+   */
+  typedef struct AddonToKodiFuncTable_PVR
+  {
+    // Pointer inside Kodi where used from him to find his class
+    KODI_HANDLE kodiInstance;
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // General callback functions
+    void (*AddMenuHook)(void* kodiInstance, struct PVR_MENUHOOK* hook);
+    void (*Recording)(void* kodiInstance, const char* Name, const char* FileName, bool On);
+    void (*ConnectionStateChange)(void* kodiInstance,
+                                  const char* strConnectionString,
+                                  enum PVR_CONNECTION_STATE newState,
+                                  const char* strMessage);
+    void (*EpgEventStateChange)(void* kodiInstance,
+                                struct EPG_TAG* tag,
+                                enum EPG_EVENT_STATE newState);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Transfer functions where give data back to Kodi, e.g. GetChannels calls TransferChannelEntry
+    void (*TransferChannelEntry)(void* kodiInstance,
+                                 const ADDON_HANDLE handle,
+                                 const struct PVR_CHANNEL* chan);
+    void (*TransferChannelGroup)(void* kodiInstance,
+                                 const ADDON_HANDLE handle,
+                                 const struct PVR_CHANNEL_GROUP* group);
+    void (*TransferChannelGroupMember)(void* kodiInstance,
+                                       const ADDON_HANDLE handle,
+                                       const struct PVR_CHANNEL_GROUP_MEMBER* member);
+    void (*TransferEpgEntry)(void* kodiInstance,
+                             const ADDON_HANDLE handle,
+                             const struct EPG_TAG* epgentry);
+    void (*TransferRecordingEntry)(void* kodiInstance,
+                                   const ADDON_HANDLE handle,
+                                   const struct PVR_RECORDING* recording);
+    void (*TransferTimerEntry)(void* kodiInstance,
+                               const ADDON_HANDLE handle,
+                               const struct PVR_TIMER* timer);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Kodi inform interface functions
+    void (*TriggerChannelUpdate)(void* kodiInstance);
+    void (*TriggerChannelGroupsUpdate)(void* kodiInstance);
+    void (*TriggerEpgUpdate)(void* kodiInstance, unsigned int iChannelUid);
+    void (*TriggerRecordingUpdate)(void* kodiInstance);
+    void (*TriggerTimerUpdate)(void* kodiInstance);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Stream demux interface functions
+    void (*FreeDemuxPacket)(void* kodiInstance, struct DemuxPacket* pPacket);
+    struct DemuxPacket* (*AllocateDemuxPacket)(void* kodiInstance, int iDataSize);
+    struct PVR_CODEC (*GetCodecByName)(const void* kodiInstance, const char* strCodecName);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // New functions becomes added below and can be on another API change (where
+    // breaks min API version) moved up.
+  } AddonToKodiFuncTable_PVR;
+
+  /*!
+   * @brief Structure to transfer the methods from addon to Kodi
+   */
+  typedef struct KodiToAddonFuncTable_PVR
+  {
+    // Pointer inside addon where used on them to find his instance class (currently unused!)
+    KODI_HANDLE addonInstance;
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // General interface functions
+    enum PVR_ERROR(__cdecl* GetCapabilities)(const struct AddonInstance_PVR*,
+                                             struct PVR_ADDON_CAPABILITIES*);
+    const char*(__cdecl* GetBackendName)(const struct AddonInstance_PVR*);
+    const char*(__cdecl* GetBackendVersion)(const struct AddonInstance_PVR*);
+    const char*(__cdecl* GetBackendHostname)(const struct AddonInstance_PVR*);
+    const char*(__cdecl* GetConnectionString)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetDriveSpace)(const struct AddonInstance_PVR*, uint64_t*, uint64_t*);
+    enum PVR_ERROR(__cdecl* CallSettingsMenuHook)(const struct AddonInstance_PVR*,
+                                                  const struct PVR_MENUHOOK*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Channel interface functions
+
+    int(__cdecl* GetChannelsAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetChannels)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
+    enum PVR_ERROR(__cdecl* GetChannelStreamProperties)(const struct AddonInstance_PVR*,
+                                                        const struct PVR_CHANNEL*,
+                                                        struct PVR_NAMED_VALUE*,
+                                                        unsigned int*);
+    enum PVR_ERROR(__cdecl* GetSignalStatus)(const struct AddonInstance_PVR*,
+                                             int,
+                                             struct PVR_SIGNAL_STATUS*);
+    enum PVR_ERROR(__cdecl* GetDescrambleInfo)(const struct AddonInstance_PVR*,
+                                               int,
+                                               struct PVR_DESCRAMBLE_INFO*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Channel group interface functions
+    int(__cdecl* GetChannelGroupsAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetChannelGroups)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
+    enum PVR_ERROR(__cdecl* GetChannelGroupMembers)(const struct AddonInstance_PVR*,
+                                                    ADDON_HANDLE,
+                                                    const struct PVR_CHANNEL_GROUP*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Channel edit interface functions
+    enum PVR_ERROR(__cdecl* DeleteChannel)(const struct AddonInstance_PVR*,
+                                           const struct PVR_CHANNEL*);
+    enum PVR_ERROR(__cdecl* RenameChannel)(const struct AddonInstance_PVR*,
+                                           const struct PVR_CHANNEL*);
+    enum PVR_ERROR(__cdecl* OpenDialogChannelSettings)(const struct AddonInstance_PVR*,
+                                                       const struct PVR_CHANNEL*);
+    enum PVR_ERROR(__cdecl* OpenDialogChannelAdd)(const struct AddonInstance_PVR*,
+                                                  const struct PVR_CHANNEL*);
+    enum PVR_ERROR(__cdecl* OpenDialogChannelScan)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* CallChannelMenuHook)(const struct AddonInstance_PVR*,
+                                                 const PVR_MENUHOOK*,
+                                                 const PVR_CHANNEL*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // EPG interface functions
+    enum PVR_ERROR(__cdecl* GetEPGForChannel)(
+        const struct AddonInstance_PVR*, ADDON_HANDLE, int, time_t, time_t);
+    enum PVR_ERROR(__cdecl* IsEPGTagRecordable)(const struct AddonInstance_PVR*,
+                                                const struct EPG_TAG*,
+                                                bool*);
+    enum PVR_ERROR(__cdecl* IsEPGTagPlayable)(const struct AddonInstance_PVR*,
+                                              const struct EPG_TAG*,
+                                              bool*);
+    enum PVR_ERROR(__cdecl* GetEPGTagEdl)(const struct AddonInstance_PVR*,
+                                          const struct EPG_TAG*,
+                                          struct PVR_EDL_ENTRY[],
+                                          int*);
+    enum PVR_ERROR(__cdecl* GetEPGTagStreamProperties)(const struct AddonInstance_PVR*,
+                                                       const struct EPG_TAG*,
+                                                       struct PVR_NAMED_VALUE*,
+                                                       unsigned int*);
+    enum PVR_ERROR(__cdecl* SetEPGTimeFrame)(const struct AddonInstance_PVR*, int);
+    enum PVR_ERROR(__cdecl* CallEPGMenuHook)(const struct AddonInstance_PVR*,
+                                             const struct PVR_MENUHOOK*,
+                                             const struct EPG_TAG*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Recording interface functions
+    int(__cdecl* GetRecordingsAmount)(const struct AddonInstance_PVR*, bool);
+    enum PVR_ERROR(__cdecl* GetRecordings)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
+    enum PVR_ERROR(__cdecl* DeleteRecording)(const struct AddonInstance_PVR*,
+                                             const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* UndeleteRecording)(const struct AddonInstance_PVR*,
+                                               const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* DeleteAllRecordingsFromTrash)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* RenameRecording)(const struct AddonInstance_PVR*,
+                                             const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* SetRecordingLifetime)(const struct AddonInstance_PVR*,
+                                                  const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* SetRecordingPlayCount)(const struct AddonInstance_PVR*,
+                                                   const struct PVR_RECORDING*,
+                                                   int);
+    enum PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
+                                                            const struct PVR_RECORDING*,
+                                                            int);
+    int(__cdecl* GetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
+                                                 const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* GetRecordingEdl)(const struct AddonInstance_PVR*,
+                                             const struct PVR_RECORDING*,
+                                             struct PVR_EDL_ENTRY[],
+                                             int*);
+    enum PVR_ERROR(__cdecl* GetRecordingSize)(const struct AddonInstance_PVR*,
+                                              const PVR_RECORDING*,
+                                              int64_t*);
+    enum PVR_ERROR(__cdecl* GetRecordingStreamProperties)(const struct AddonInstance_PVR*,
+                                                          const struct PVR_RECORDING*,
+                                                          struct PVR_NAMED_VALUE*,
+                                                          unsigned int*);
+    enum PVR_ERROR(__cdecl* CallRecordingMenuHook)(const struct AddonInstance_PVR*,
+                                                   const struct PVR_MENUHOOK*,
+                                                   const struct PVR_RECORDING*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Timer interface functions
+    enum PVR_ERROR(__cdecl* GetTimerTypes)(const struct AddonInstance_PVR*,
+                                           struct PVR_TIMER_TYPE[],
+                                           int*);
+    int(__cdecl* GetTimersAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetTimers)(const struct AddonInstance_PVR*, ADDON_HANDLE);
+    enum PVR_ERROR(__cdecl* AddTimer)(const struct AddonInstance_PVR*, const struct PVR_TIMER*);
+    enum PVR_ERROR(__cdecl* DeleteTimer)(const struct AddonInstance_PVR*,
+                                         const struct PVR_TIMER*,
+                                         bool);
+    enum PVR_ERROR(__cdecl* UpdateTimer)(const struct AddonInstance_PVR*, const struct PVR_TIMER*);
+    enum PVR_ERROR(__cdecl* CallTimerMenuHook)(const struct AddonInstance_PVR*,
+                                               const struct PVR_MENUHOOK*,
+                                               const struct PVR_TIMER*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Powersaving interface functions
+    void(__cdecl* OnSystemSleep)(const struct AddonInstance_PVR*);
+    void(__cdecl* OnSystemWake)(const struct AddonInstance_PVR*);
+    void(__cdecl* OnPowerSavingActivated)(const struct AddonInstance_PVR*);
+    void(__cdecl* OnPowerSavingDeactivated)(const struct AddonInstance_PVR*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Live stream read interface functions
+    bool(__cdecl* OpenLiveStream)(const struct AddonInstance_PVR*, const struct PVR_CHANNEL*);
+    void(__cdecl* CloseLiveStream)(const struct AddonInstance_PVR*);
+    int(__cdecl* ReadLiveStream)(const struct AddonInstance_PVR*, unsigned char*, unsigned int);
+    int64_t(__cdecl* SeekLiveStream)(const struct AddonInstance_PVR*, int64_t, int);
+    int64_t(__cdecl* LengthLiveStream)(const struct AddonInstance_PVR*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Recording stream read interface functions
+    bool(__cdecl* OpenRecordedStream)(const struct AddonInstance_PVR*, const struct PVR_RECORDING*);
+    void(__cdecl* CloseRecordedStream)(const struct AddonInstance_PVR*);
+    int(__cdecl* ReadRecordedStream)(const struct AddonInstance_PVR*, unsigned char*, unsigned int);
+    int64_t(__cdecl* SeekRecordedStream)(const struct AddonInstance_PVR*, int64_t, int);
+    int64_t(__cdecl* LengthRecordedStream)(const struct AddonInstance_PVR*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // Stream demux interface functions
+    enum PVR_ERROR(__cdecl* GetStreamProperties)(const struct AddonInstance_PVR*,
+                                                 struct PVR_STREAM_PROPERTIES*);
+    struct DemuxPacket*(__cdecl* DemuxRead)(const struct AddonInstance_PVR*);
+    void(__cdecl* DemuxReset)(const struct AddonInstance_PVR*);
+    void(__cdecl* DemuxAbort)(const struct AddonInstance_PVR*);
+    void(__cdecl* DemuxFlush)(const struct AddonInstance_PVR*);
+    void(__cdecl* SetSpeed)(const struct AddonInstance_PVR*, int);
+    void(__cdecl* FillBuffer)(const struct AddonInstance_PVR*, bool);
+    bool(__cdecl* SeekTime)(const struct AddonInstance_PVR*, double, bool, double*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // General stream interface functions
+    bool(__cdecl* CanPauseStream)(const struct AddonInstance_PVR*);
+    void(__cdecl* PauseStream)(const struct AddonInstance_PVR*, bool);
+    bool(__cdecl* CanSeekStream)(const struct AddonInstance_PVR*);
+    bool(__cdecl* IsRealTimeStream)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetStreamTimes)(const struct AddonInstance_PVR*,
+                                            struct PVR_STREAM_TIMES*);
+    enum PVR_ERROR(__cdecl* GetStreamReadChunkSize)(const struct AddonInstance_PVR*, int*);
+
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    // New functions becomes added below and can be on another API change (where
+    // breaks min API version) moved up.
+  } KodiToAddonFuncTable_PVR;
+
+  typedef struct AddonInstance_PVR
+  {
+    struct AddonProperties_PVR* props;
+    struct AddonToKodiFuncTable_PVR* toKodi;
+    struct KodiToAddonFuncTable_PVR* toAddon;
+  } AddonInstance_PVR;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/CMakeLists.txt
new file mode 100644
index 000000000000..b561784806cb
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/CMakeLists.txt
@@ -0,0 +1,15 @@
+set(HEADERS pvr.h
+            pvr_channel_groups.h
+            pvr_channels.h
+            pvr_defines.h
+            pvr_edl.h
+            pvr_epg.h
+            pvr_general.h
+            pvr_menu_hook.h
+            pvr_recordings.h
+            pvr_stream.h
+            pvr_timers.h)
+
+if(NOT ENABLE_STATIC_LIBS)
+  core_add_library(addons_kodi-addon-dev-kit_include_kodi_c-api_addon-instance_pvr)
+endif()
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h
new file mode 100644
index 000000000000..87c453c1d56e
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h
@@ -0,0 +1,38 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  typedef struct PVR_CHANNEL_GROUP
+  {
+    char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
+    bool bIsRadio;
+    unsigned int iPosition;
+  } PVR_CHANNEL_GROUP;
+
+  typedef struct PVR_CHANNEL_GROUP_MEMBER
+  {
+    char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
+    unsigned int iChannelUniqueId;
+    unsigned int iChannelNumber;
+    unsigned int iSubChannelNumber;
+    int iOrder;
+  } PVR_CHANNEL_GROUP_MEMBER;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h
new file mode 100644
index 000000000000..470e5d315230
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h
@@ -0,0 +1,67 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  #define PVR_CHANNEL_INVALID_UID -1
+
+  typedef struct PVR_CHANNEL
+  {
+    unsigned int iUniqueId;
+    bool bIsRadio;
+    unsigned int iChannelNumber;
+    unsigned int iSubChannelNumber;
+    char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strMimeType[PVR_ADDON_INPUT_FORMAT_STRING_LENGTH];
+    unsigned int iEncryptionSystem;
+    char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
+    bool bIsHidden;
+    bool bHasArchive;
+    int iOrder;
+  } PVR_CHANNEL;
+
+  typedef struct PVR_SIGNAL_STATUS
+  {
+    char strAdapterName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strAdapterStatus[PVR_ADDON_NAME_STRING_LENGTH];
+    char strServiceName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strProviderName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strMuxName[PVR_ADDON_NAME_STRING_LENGTH];
+    int iSNR;
+    int iSignal;
+    long iBER;
+    long iUNC;
+  } PVR_SIGNAL_STATUS;
+
+  #define PVR_DESCRAMBLE_INFO_NOT_AVAILABLE -1
+
+  typedef struct PVR_DESCRAMBLE_INFO
+  {
+    int iPid;
+    int iCaid;
+    int iProvid;
+    int iEcmTime;
+    int iHops;
+    char strCardSystem[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
+    char strReader[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
+    char strFrom[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
+    char strProtocol[PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH];
+  } PVR_DESCRAMBLE_INFO;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_defines.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_defines.h
new file mode 100644
index 000000000000..7045ed36fa2f
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_defines.h
@@ -0,0 +1,44 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  #define PVR_ADDON_NAME_STRING_LENGTH 1024
+  #define PVR_ADDON_URL_STRING_LENGTH 1024
+  #define PVR_ADDON_DESC_STRING_LENGTH 1024
+  #define PVR_ADDON_INPUT_FORMAT_STRING_LENGTH 32
+  #define PVR_ADDON_EDL_LENGTH 32
+  #define PVR_ADDON_TIMERTYPE_ARRAY_SIZE 32
+  #define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE 512
+  #define PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL 128
+  #define PVR_ADDON_TIMERTYPE_STRING_LENGTH 128
+  #define PVR_ADDON_ATTRIBUTE_DESC_LENGTH 128
+  #define PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE 512
+  #define PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH 64
+  #define PVR_ADDON_DATE_STRING_LENGTH 32
+
+  typedef struct PVR_ATTRIBUTE_INT_VALUE
+  {
+    int iValue;
+    char strDescription[PVR_ADDON_ATTRIBUTE_DESC_LENGTH];
+  } PVR_ATTRIBUTE_INT_VALUE;
+
+  typedef struct PVR_NAMED_VALUE
+  {
+    char strName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strValue[PVR_ADDON_NAME_STRING_LENGTH];
+  } PVR_NAMED_VALUE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h
new file mode 100644
index 000000000000..e32c906e1b25
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h
@@ -0,0 +1,37 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  typedef enum PVR_EDL_TYPE
+  {
+    PVR_EDL_TYPE_CUT = 0,
+    PVR_EDL_TYPE_MUTE = 1,
+    PVR_EDL_TYPE_SCENE = 2,
+    PVR_EDL_TYPE_COMBREAK = 3
+  } PVR_EDL_TYPE;
+
+  typedef struct PVR_EDL_ENTRY
+  {
+    int64_t start;
+    int64_t end;
+    enum PVR_EDL_TYPE type;
+  } PVR_EDL_ENTRY;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h
new file mode 100644
index 000000000000..33259229b0f2
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h
@@ -0,0 +1,229 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  typedef enum EPG_EVENT_CONTENTMASK
+  {
+    EPG_EVENT_CONTENTMASK_UNDEFINED = 0x00,
+    EPG_EVENT_CONTENTMASK_MOVIEDRAMA = 0x10,
+    EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS = 0x20,
+    EPG_EVENT_CONTENTMASK_SHOW = 0x30,
+    EPG_EVENT_CONTENTMASK_SPORTS = 0x40,
+    EPG_EVENT_CONTENTMASK_CHILDRENYOUTH = 0x50,
+    EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE = 0x60,
+    EPG_EVENT_CONTENTMASK_ARTSCULTURE = 0x70,
+    EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS = 0x80,
+    EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE = 0x90,
+    EPG_EVENT_CONTENTMASK_LEISUREHOBBIES = 0xA0,
+    EPG_EVENT_CONTENTMASK_SPECIAL = 0xB0,
+    EPG_EVENT_CONTENTMASK_USERDEFINED = 0xF0,
+    EPG_GENRE_USE_STRING = 0x100
+  } EPG_EVENT_CONTENTMASK;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA
+  {
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_DETECTIVE_THRILLER = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ADVENTURE_WESTERN_WAR = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SCIENCEFICTION_FANTASY_HORROR = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_COMEDY = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SOAP_MELODRAMA_FOLKLORIC = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ROMANCE = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SERIOUS_CLASSICAL_RELIGIOUS_HISTORICAL = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ADULT = 0x8,
+    EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS
+  {
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_WEATHER = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_MAGAZINE = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_DOCUMENTARY = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_DISCUSSION_INTERVIEW_DEBATE = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_SHOW
+  {
+    EPG_EVENT_CONTENTSUBMASK_SHOW_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_SHOW_GAMESHOW_QUIZ_CONTEST = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_SHOW_VARIETY_SHOW = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_SHOW_TALK_SHOW = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_SHOW_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_SHOW;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_SPORTS
+  {
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_OLYMPICGAMES_WORLDCUP = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_SPORTS_MAGAZINES = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_FOOTBALL_SOCCER = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_TENNIS_SQUASH = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_TEAMSPORTS = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_ATHLETICS = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_MOTORSPORT = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_WATERSPORT = 0x8,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_WINTERSPORTS = 0x9,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_EQUESTRIAN = 0xA,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_MARTIALSPORTS = 0xB,
+    EPG_EVENT_CONTENTSUBMASK_SPORTS_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_SPORTS;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH
+  {
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_PRESCHOOL_CHILDREN = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_ENTERTAIN_6TO14 = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_ENTERTAIN_10TO16 = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_INFORMATIONAL_EDUCATIONAL_SCHOOL = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_CARTOONS_PUPPETS = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE
+  {
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_ROCKPOP = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_SERIOUSMUSIC_CLASSICALMUSIC = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_FOLK_TRADITIONAL_MUSIC = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_JAZZ = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_MUSICAL_OPERA = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_BALLET = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE
+  {
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_PERFORMINGARTS = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FINEARTS = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_RELIGION = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_POPULARCULTURE_TRADITIONALARTS = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_LITERATURE = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FILM_CINEMA = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_EXPERIMENTALFILM_VIDEO = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_BROADCASTING_PRESS = 0x8,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_NEWMEDIA = 0x9,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_ARTS_CULTUREMAGAZINES = 0xA,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FASHION = 0xB,
+    EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS
+  {
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_MAGAZINES_REPORTS_DOCUMENTARY = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_ECONOMICS_SOCIALADVISORY = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_REMARKABLEPEOPLE = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE
+  {
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_NATURE_ANIMALS_ENVIRONMENT = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_TECHNOLOGY_NATURALSCIENCES = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_MEDICINE_PHYSIOLOGY_PSYCHOLOGY = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_FOREIGNCOUNTRIES_EXPEDITIONS = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_SOCIAL_SPIRITUALSCIENCES = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_FURTHEREDUCATION = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_LANGUAGES = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES
+  {
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_TOURISM_TRAVEL = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_HANDICRAFT = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_MOTORING = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_FITNESSANDHEALTH = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_COOKING = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_ADVERTISEMENT_SHOPPING = 0x6,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_GARDENING = 0x7,
+    EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES;
+
+  typedef enum EPG_EVENT_CONTENTSUBMASK_SPECIAL
+  {
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_GENERAL = 0x0,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_BLACKANDWHITE = 0x1,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_UNPUBLISHED = 0x2,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_LIVEBROADCAST = 0x3,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_PLANOSTEREOSCOPIC = 0x4,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_LOCALORREGIONAL = 0x5,
+    EPG_EVENT_CONTENTSUBMASK_SPECIAL_USERDEFINED = 0xF
+  } EPG_EVENT_CONTENTSUBMASK_SPECIAL;
+
+  #define EPG_STRING_TOKEN_SEPARATOR ","
+
+  typedef enum EPG_TAG_FLAG
+  {
+    EPG_TAG_FLAG_UNDEFINED = 0,
+    EPG_TAG_FLAG_IS_SERIES = (1 << 0),
+    EPG_TAG_FLAG_IS_NEW = (1 << 1),
+    EPG_TAG_FLAG_IS_PREMIERE = (1 << 2),
+    EPG_TAG_FLAG_IS_FINALE = (1 << 3),
+    EPG_TAG_FLAG_IS_LIVE = (1 << 4),
+  } EPG_TAG_FLAG;
+
+  #define EPG_TAG_INVALID_UID 0
+  #define EPG_TAG_INVALID_SERIES_EPISODE -1
+  #define EPG_TIMEFRAME_UNLIMITED -1
+
+  typedef enum EPG_EVENT_STATE
+  {
+    EPG_EVENT_CREATED = 0,
+    EPG_EVENT_UPDATED = 1,
+    EPG_EVENT_DELETED = 2,
+  } EPG_EVENT_STATE;
+
+  typedef struct EPG_TAG
+  {
+    unsigned int iUniqueBroadcastId;
+    unsigned int iUniqueChannelId;
+    const char* strTitle;
+    time_t startTime;
+    time_t endTime;
+    const char* strPlotOutline;
+    const char* strPlot;
+    const char* strOriginalTitle;
+    const char* strCast;
+    const char* strDirector;
+    const char* strWriter;
+    int iYear;
+    const char* strIMDBNumber;
+    const char* strIconPath;
+    int iGenreType;
+    int iGenreSubType;
+    const char* strGenreDescription;
+    const char* strFirstAired;
+    int iParentalRating;
+    int iStarRating;
+    int iSeriesNumber;
+    int iEpisodeNumber;
+    int iEpisodePartNumber;
+    const char* strEpisodeName;
+    unsigned int iFlags;
+    const char* strSeriesLink;
+  } EPG_TAG;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h
new file mode 100644
index 000000000000..15f7660bd6b4
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h
@@ -0,0 +1,87 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#ifdef BUILD_KODI_ADDON
+#include "../../../InputStreamConstants.h"
+#else
+#include "cores/VideoPlayer/Interface/Addon/InputStreamConstants.h"
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  typedef enum PVR_ERROR
+  {
+    PVR_ERROR_NO_ERROR = 0,
+    PVR_ERROR_UNKNOWN = -1,
+    PVR_ERROR_NOT_IMPLEMENTED = -2,
+    PVR_ERROR_SERVER_ERROR = -3,
+    PVR_ERROR_SERVER_TIMEOUT = -4,
+    PVR_ERROR_REJECTED = -5,
+    PVR_ERROR_ALREADY_PRESENT = -6,
+    PVR_ERROR_INVALID_PARAMETERS = -7,
+    PVR_ERROR_RECORDING_RUNNING = -8,
+    PVR_ERROR_FAILED = -9,
+  } PVR_ERROR;
+
+  typedef enum PVR_CONNECTION_STATE
+  {
+    PVR_CONNECTION_STATE_UNKNOWN = 0,
+    PVR_CONNECTION_STATE_SERVER_UNREACHABLE = 1,
+    PVR_CONNECTION_STATE_SERVER_MISMATCH = 2,
+    PVR_CONNECTION_STATE_VERSION_MISMATCH = 3,
+    PVR_CONNECTION_STATE_ACCESS_DENIED = 4,
+    PVR_CONNECTION_STATE_CONNECTED = 5,
+    PVR_CONNECTION_STATE_DISCONNECTED = 6,
+    PVR_CONNECTION_STATE_CONNECTING = 7,
+  } PVR_CONNECTION_STATE;
+
+  #define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
+  #define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
+  #define PVR_STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID
+  #define PVR_STREAM_PROPERTY_MIMETYPE "mimetype"
+  #define PVR_STREAM_PROPERTY_ISREALTIMESTREAM STREAM_PROPERTY_ISREALTIMESTREAM
+  #define PVR_STREAM_PROPERTY_EPGPLAYBACKASLIVE "epgplaybackaslive"
+  #define PVR_STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG
+
+  typedef struct PVR_ADDON_CAPABILITIES
+  {
+    bool bSupportsEPG;
+    bool bSupportsEPGEdl;
+    bool bSupportsTV;
+    bool bSupportsRadio;
+    bool bSupportsRecordings;
+    bool bSupportsRecordingsUndelete;
+    bool bSupportsTimers;
+    bool bSupportsChannelGroups;
+    bool bSupportsChannelScan;
+    bool bSupportsChannelSettings;
+    bool bHandlesInputStream;
+    bool bHandlesDemuxing;
+    bool bSupportsRecordingPlayCount;
+    bool bSupportsLastPlayedPosition;
+    bool bSupportsRecordingEdl;
+    bool bSupportsRecordingsRename;
+    bool bSupportsRecordingsLifetimeChange;
+    bool bSupportsDescrambleInfo;
+    bool bSupportsAsyncEPGTransfer;
+    bool bSupportsRecordingSize;
+
+    unsigned int iRecordingsLifetimesSize;
+    struct PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE];
+  } PVR_ADDON_CAPABILITIES;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h
new file mode 100644
index 000000000000..d372aed68fde
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h
@@ -0,0 +1,39 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  typedef enum PVR_MENUHOOK_CAT
+  {
+    PVR_MENUHOOK_UNKNOWN = -1,
+    PVR_MENUHOOK_ALL = 0,
+    PVR_MENUHOOK_CHANNEL = 1,
+    PVR_MENUHOOK_TIMER = 2,
+    PVR_MENUHOOK_EPG = 3,
+    PVR_MENUHOOK_RECORDING = 4,
+    PVR_MENUHOOK_DELETED_RECORDING = 5,
+    PVR_MENUHOOK_SETTING = 6,
+  } PVR_MENUHOOK_CAT;
+
+  typedef struct PVR_MENUHOOK
+  {
+    unsigned int iHookId;
+    unsigned int iLocalizedStringId;
+    enum PVR_MENUHOOK_CAT category;
+  } PVR_MENUHOOK;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
new file mode 100644
index 000000000000..7130b7e3e3bf
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
@@ -0,0 +1,76 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  typedef enum PVR_RECORDING_FLAG
+  {
+    PVR_RECORDING_FLAG_UNDEFINED = 0,
+    PVR_RECORDING_FLAG_IS_SERIES = (1 << 0),
+    PVR_RECORDING_FLAG_IS_NEW = (1 << 1),
+    PVR_RECORDING_FLAG_IS_PREMIERE = (1 << 2),
+    PVR_RECORDING_FLAG_IS_FINALE = (1 << 3),
+    PVR_RECORDING_FLAG_IS_LIVE = (1 << 4),
+  } PVR_RECORDING_FLAG;
+
+  #define PVR_RECORDING_INVALID_SERIES_EPISODE EPG_TAG_INVALID_SERIES_EPISODE
+
+  typedef enum PVR_RECORDING_CHANNEL_TYPE
+  {
+    PVR_RECORDING_CHANNEL_TYPE_UNKNOWN = 0,
+    PVR_RECORDING_CHANNEL_TYPE_TV = 1,
+    PVR_RECORDING_CHANNEL_TYPE_RADIO = 2,
+  } PVR_RECORDING_CHANNEL_TYPE;
+
+  typedef struct PVR_RECORDING
+  {
+    char strRecordingId[PVR_ADDON_NAME_STRING_LENGTH];
+    char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
+    char strEpisodeName[PVR_ADDON_NAME_STRING_LENGTH];
+    int iSeriesNumber;
+    int iEpisodeNumber;
+    int iYear;
+    char strDirectory[PVR_ADDON_URL_STRING_LENGTH];
+    char strPlotOutline[PVR_ADDON_DESC_STRING_LENGTH];
+    char strPlot[PVR_ADDON_DESC_STRING_LENGTH];
+    char strGenreDescription[PVR_ADDON_DESC_STRING_LENGTH];
+    char strChannelName[PVR_ADDON_NAME_STRING_LENGTH];
+    char strIconPath[PVR_ADDON_URL_STRING_LENGTH];
+    char strThumbnailPath[PVR_ADDON_URL_STRING_LENGTH];
+    char strFanartPath[PVR_ADDON_URL_STRING_LENGTH];
+    time_t recordingTime;
+    int iDuration;
+    int iPriority;
+    int iLifetime;
+    int iGenreType;
+    int iGenreSubType;
+    int iPlayCount;
+    int iLastPlayedPosition;
+    bool bIsDeleted;
+    unsigned int iEpgEventId;
+    int iChannelUid;
+    enum PVR_RECORDING_CHANNEL_TYPE channelType;
+    char strFirstAired[PVR_ADDON_DATE_STRING_LENGTH];
+    unsigned int iFlags;
+    int64_t sizeInBytes;
+  } PVR_RECORDING;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_stream.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_stream.h
new file mode 100644
index 000000000000..805f063b3b71
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_stream.h
@@ -0,0 +1,85 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#ifdef BUILD_KODI_ADDON
+#include "../../../DemuxPacket.h"
+#else
+#include "cores/VideoPlayer/Interface/Addon/DemuxPacket.h"
+#endif
+
+#include <stdint.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  #define PVR_STREAM_MAX_STREAMS 20
+  #define PVR_INVALID_CODEC_ID 0
+  #define PVR_INVALID_CODEC \
+    { \
+      PVR_CODEC_TYPE_UNKNOWN, PVR_INVALID_CODEC_ID \
+    }
+
+  typedef enum PVR_CODEC_TYPE
+  {
+    PVR_CODEC_TYPE_UNKNOWN = -1,
+    PVR_CODEC_TYPE_VIDEO,
+    PVR_CODEC_TYPE_AUDIO,
+    PVR_CODEC_TYPE_DATA,
+    PVR_CODEC_TYPE_SUBTITLE,
+    PVR_CODEC_TYPE_RDS,
+
+    PVR_CODEC_TYPE_NB
+  } PVR_CODEC_TYPE;
+
+  typedef struct PVR_CODEC
+  {
+    enum PVR_CODEC_TYPE codec_type;
+    unsigned int codec_id;
+  } PVR_CODEC;
+
+  typedef struct PVR_STREAM_PROPERTIES
+  {
+    unsigned int iStreamCount;
+    struct PVR_STREAM
+    {
+      unsigned int iPID;
+      enum PVR_CODEC_TYPE iCodecType;
+      unsigned int iCodecId;
+      char strLanguage[4];
+      int iSubtitleInfo;
+      int iFPSScale;
+      int iFPSRate;
+      int iHeight;
+      int iWidth;
+      float fAspect;
+      int iChannels;
+      int iSampleRate;
+      int iBlockAlign;
+      int iBitRate;
+      int iBitsPerSample;
+    } stream[PVR_STREAM_MAX_STREAMS];
+  } PVR_STREAM_PROPERTIES;
+
+  typedef struct PVR_STREAM_TIMES
+  {
+    time_t startTime;
+    int64_t ptsStart;
+    int64_t ptsBegin;
+    int64_t ptsEnd;
+  } PVR_STREAM_TIMES;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
new file mode 100644
index 000000000000..6bb53130b840
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
@@ -0,0 +1,151 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "pvr_defines.h"
+
+#include <stdbool.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+  #define PVR_TIMER_TYPE_NONE 0
+  #define PVR_TIMER_NO_CLIENT_INDEX 0
+  #define PVR_TIMER_NO_PARENT PVR_TIMER_NO_CLIENT_INDEX
+  #define PVR_TIMER_NO_EPG_UID EPG_TAG_INVALID_UID
+  #define PVR_TIMER_ANY_CHANNEL -1
+
+  typedef enum PVR_TIMER_TYPES
+  {
+    PVR_TIMER_TYPE_ATTRIBUTE_NONE = 0,
+    PVR_TIMER_TYPE_IS_MANUAL = (1 << 0),
+    PVR_TIMER_TYPE_IS_REPEATING = (1 << 1),
+    PVR_TIMER_TYPE_IS_READONLY = (1 << 2),
+    PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES = (1 << 3),
+    PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE = (1 << 4),
+    PVR_TIMER_TYPE_SUPPORTS_CHANNELS = (1 << 5),
+    PVR_TIMER_TYPE_SUPPORTS_START_TIME = (1 << 6),
+    PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH = (1 << 7),
+    PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH = (1 << 8),
+    PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY = (1 << 9),
+    PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS = (1 << 10),
+    PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES = (1 << 11),
+    PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN = (1 << 12),
+    PVR_TIMER_TYPE_SUPPORTS_PRIORITY = (1 << 13),
+    PVR_TIMER_TYPE_SUPPORTS_LIFETIME = (1 << 14),
+    PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS = (1 << 15),
+    PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP = (1 << 16),
+    PVR_TIMER_TYPE_SUPPORTS_END_TIME = (1 << 17),
+    PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME = (1 << 18),
+    PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME = (1 << 19),
+    PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS = (1 << 20),
+    PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE = (1 << 21),
+    PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE = (1 << 22),
+    PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE = (1 << 23),
+    PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL = (1 << 24),
+    PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE = (1 << 25),
+    PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE = (1 << 26),
+    PVR_TIMER_TYPE_IS_REMINDER = (1 << 27),
+    PVR_TIMER_TYPE_SUPPORTS_START_MARGIN = (1 << 28),
+    PVR_TIMER_TYPE_SUPPORTS_END_MARGIN = (1 << 29),
+  } PVR_TIMER_TYPES;
+
+  typedef enum PVR_WEEKDAYS
+  {
+    PVR_WEEKDAY_NONE = 0,
+    PVR_WEEKDAY_MONDAY = (1 << 0),
+    PVR_WEEKDAY_TUESDAY = (1 << 1),
+    PVR_WEEKDAY_WEDNESDAY = (1 << 2),
+    PVR_WEEKDAY_THURSDAY = (1 << 3),
+    PVR_WEEKDAY_FRIDAY = (1 << 4),
+    PVR_WEEKDAY_SATURDAY = (1 << 5),
+    PVR_WEEKDAY_SUNDAY = (1 << 6),
+    PVR_WEEKDAY_ALLDAYS = PVR_WEEKDAY_MONDAY | PVR_WEEKDAY_TUESDAY | PVR_WEEKDAY_WEDNESDAY |
+                          PVR_WEEKDAY_THURSDAY | PVR_WEEKDAY_FRIDAY | PVR_WEEKDAY_SATURDAY |
+                          PVR_WEEKDAY_SUNDAY
+  } PVR_WEEKDAY;
+
+  typedef enum PVR_TIMER_STATE
+  {
+    PVR_TIMER_STATE_NEW = 0,
+    PVR_TIMER_STATE_SCHEDULED = 1,
+    PVR_TIMER_STATE_RECORDING = 2,
+    PVR_TIMER_STATE_COMPLETED = 3,
+    PVR_TIMER_STATE_ABORTED = 4,
+    PVR_TIMER_STATE_CANCELLED = 5,
+    PVR_TIMER_STATE_CONFLICT_OK = 6,
+    PVR_TIMER_STATE_CONFLICT_NOK = 7,
+    PVR_TIMER_STATE_ERROR = 8,
+    PVR_TIMER_STATE_DISABLED = 9,
+  } PVR_TIMER_STATE;
+
+  typedef struct PVR_TIMER
+  {
+    unsigned int iClientIndex;
+    unsigned int iParentClientIndex;
+    int iClientChannelUid;
+    time_t startTime;
+    time_t endTime;
+    bool bStartAnyTime;
+    bool bEndAnyTime;
+    enum PVR_TIMER_STATE state;
+    unsigned int iTimerType;
+    char strTitle[PVR_ADDON_NAME_STRING_LENGTH];
+    char strEpgSearchString[PVR_ADDON_NAME_STRING_LENGTH];
+    bool bFullTextEpgSearch;
+    char strDirectory[PVR_ADDON_URL_STRING_LENGTH];
+    char strSummary[PVR_ADDON_DESC_STRING_LENGTH];
+    int iPriority;
+    int iLifetime;
+    int iMaxRecordings;
+    unsigned int iRecordingGroup;
+    time_t firstDay;
+    unsigned int iWeekdays;
+    unsigned int iPreventDuplicateEpisodes;
+    unsigned int iEpgUid;
+    unsigned int iMarginStart;
+    unsigned int iMarginEnd;
+    int iGenreType;
+    int iGenreSubType;
+    char strSeriesLink[PVR_ADDON_URL_STRING_LENGTH];
+  } PVR_TIMER;
+
+  typedef struct PVR_TIMER_TYPE
+  {
+    unsigned int iId;
+    unsigned int iAttributes;
+    char strDescription[PVR_ADDON_TIMERTYPE_STRING_LENGTH];
+
+    unsigned int iPrioritiesSize;
+    struct PVR_ATTRIBUTE_INT_VALUE priorities[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    int iPrioritiesDefault;
+
+    unsigned int iLifetimesSize;
+    struct PVR_ATTRIBUTE_INT_VALUE lifetimes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    int iLifetimesDefault;
+
+    unsigned int iPreventDuplicateEpisodesSize;
+    struct PVR_ATTRIBUTE_INT_VALUE preventDuplicateEpisodes[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    unsigned int iPreventDuplicateEpisodesDefault;
+
+    unsigned int iRecordingGroupSize;
+    struct PVR_ATTRIBUTE_INT_VALUE recordingGroup[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE];
+    unsigned int iRecordingGroupDefault;
+
+    unsigned int iMaxRecordingsSize;
+    struct PVR_ATTRIBUTE_INT_VALUE maxRecordings[PVR_ADDON_TIMERTYPE_VALUES_ARRAY_SIZE_SMALL];
+    int iMaxRecordingsDefault;
+  } PVR_TIMER_TYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */

From 1e417592f3c27a49678b085762781f744e728892 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 11 May 2020 07:08:20 +0200
Subject: [PATCH 17/27] [addons][pvr] change "C" API to use everywhere
 PVR_ERROR as return

To allow by them a direct handling if e.g. connection error comes.
---
 .../include/kodi/c-api/addon-instance/pvr.h   | 34 ++++----
 xbmc/pvr/addons/PVRClient.cpp                 | 77 +++++++++++--------
 xbmc/pvr/addons/PVRClient.h                   |  5 +-
 3 files changed, 66 insertions(+), 50 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
index c89697894fb5..be78a12bb2e3 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
@@ -46,7 +46,10 @@ extern "C"
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // General callback functions
     void (*AddMenuHook)(void* kodiInstance, struct PVR_MENUHOOK* hook);
-    void (*Recording)(void* kodiInstance, const char* Name, const char* FileName, bool On);
+    void (*RecordingNotification)(void* kodiInstance,
+                                  const char* name,
+                                  const char* fileName,
+                                  bool on);
     void (*ConnectionStateChange)(void* kodiInstance,
                                   const char* strConnectionString,
                                   enum PVR_CONNECTION_STATE newState,
@@ -107,10 +110,10 @@ extern "C"
     // General interface functions
     enum PVR_ERROR(__cdecl* GetCapabilities)(const struct AddonInstance_PVR*,
                                              struct PVR_ADDON_CAPABILITIES*);
-    const char*(__cdecl* GetBackendName)(const struct AddonInstance_PVR*);
-    const char*(__cdecl* GetBackendVersion)(const struct AddonInstance_PVR*);
-    const char*(__cdecl* GetBackendHostname)(const struct AddonInstance_PVR*);
-    const char*(__cdecl* GetConnectionString)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetBackendName)(const struct AddonInstance_PVR*, char*, int);
+    enum PVR_ERROR(__cdecl* GetBackendVersion)(const struct AddonInstance_PVR*, char*, int);
+    enum PVR_ERROR(__cdecl* GetBackendHostname)(const struct AddonInstance_PVR*, char*, int);
+    enum PVR_ERROR(__cdecl* GetConnectionString)(const struct AddonInstance_PVR*, char*, int);
     enum PVR_ERROR(__cdecl* GetDriveSpace)(const struct AddonInstance_PVR*, uint64_t*, uint64_t*);
     enum PVR_ERROR(__cdecl* CallSettingsMenuHook)(const struct AddonInstance_PVR*,
                                                   const struct PVR_MENUHOOK*);
@@ -118,7 +121,7 @@ extern "C"
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel interface functions
 
-    int(__cdecl* GetChannelsAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetChannelsAmount)(const struct AddonInstance_PVR*, int*);
     enum PVR_ERROR(__cdecl* GetChannels)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
     enum PVR_ERROR(__cdecl* GetChannelStreamProperties)(const struct AddonInstance_PVR*,
                                                         const struct PVR_CHANNEL*,
@@ -133,7 +136,7 @@ extern "C"
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Channel group interface functions
-    int(__cdecl* GetChannelGroupsAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetChannelGroupsAmount)(const struct AddonInstance_PVR*, int*);
     enum PVR_ERROR(__cdecl* GetChannelGroups)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
     enum PVR_ERROR(__cdecl* GetChannelGroupMembers)(const struct AddonInstance_PVR*,
                                                     ADDON_HANDLE,
@@ -179,7 +182,7 @@ extern "C"
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Recording interface functions
-    int(__cdecl* GetRecordingsAmount)(const struct AddonInstance_PVR*, bool);
+    enum PVR_ERROR(__cdecl* GetRecordingsAmount)(const struct AddonInstance_PVR*, bool, int*);
     enum PVR_ERROR(__cdecl* GetRecordings)(const struct AddonInstance_PVR*, ADDON_HANDLE, bool);
     enum PVR_ERROR(__cdecl* DeleteRecording)(const struct AddonInstance_PVR*,
                                              const struct PVR_RECORDING*);
@@ -196,8 +199,9 @@ extern "C"
     enum PVR_ERROR(__cdecl* SetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
                                                             const struct PVR_RECORDING*,
                                                             int);
-    int(__cdecl* GetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
-                                                 const struct PVR_RECORDING*);
+    enum PVR_ERROR(__cdecl* GetRecordingLastPlayedPosition)(const struct AddonInstance_PVR*,
+                                                            const struct PVR_RECORDING*,
+                                                            int*);
     enum PVR_ERROR(__cdecl* GetRecordingEdl)(const struct AddonInstance_PVR*,
                                              const struct PVR_RECORDING*,
                                              struct PVR_EDL_ENTRY[],
@@ -218,7 +222,7 @@ extern "C"
     enum PVR_ERROR(__cdecl* GetTimerTypes)(const struct AddonInstance_PVR*,
                                            struct PVR_TIMER_TYPE[],
                                            int*);
-    int(__cdecl* GetTimersAmount)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* GetTimersAmount)(const struct AddonInstance_PVR*, int*);
     enum PVR_ERROR(__cdecl* GetTimers)(const struct AddonInstance_PVR*, ADDON_HANDLE);
     enum PVR_ERROR(__cdecl* AddTimer)(const struct AddonInstance_PVR*, const struct PVR_TIMER*);
     enum PVR_ERROR(__cdecl* DeleteTimer)(const struct AddonInstance_PVR*,
@@ -231,10 +235,10 @@ extern "C"
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Powersaving interface functions
-    void(__cdecl* OnSystemSleep)(const struct AddonInstance_PVR*);
-    void(__cdecl* OnSystemWake)(const struct AddonInstance_PVR*);
-    void(__cdecl* OnPowerSavingActivated)(const struct AddonInstance_PVR*);
-    void(__cdecl* OnPowerSavingDeactivated)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* OnSystemSleep)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* OnSystemWake)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* OnPowerSavingActivated)(const struct AddonInstance_PVR*);
+    enum PVR_ERROR(__cdecl* OnPowerSavingDeactivated)(const struct AddonInstance_PVR*);
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // Live stream read interface functions
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index c732826189c1..92705b289864 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -130,7 +130,7 @@ void CPVRClient::ResetProperties(int iClientId /* = PVR_INVALID_CLIENT_ID */)
   m_struct.toKodi->TransferTimerEntry = cb_transfer_timer_entry;
   m_struct.toKodi->TransferRecordingEntry = cb_transfer_recording_entry;
   m_struct.toKodi->AddMenuHook = cb_add_menu_hook;
-  m_struct.toKodi->Recording = cb_recording;
+  m_struct.toKodi->RecordingNotification = cb_recording_notification;
   m_struct.toKodi->TriggerChannelUpdate = cb_trigger_channel_update;
   m_struct.toKodi->TriggerChannelGroupsUpdate = cb_trigger_channel_groups_update;
   m_struct.toKodi->TriggerTimerUpdate = cb_trigger_timer_update;
@@ -368,7 +368,11 @@ void CPVRClient::WriteClientChannelInfo(const std::shared_ptr<CPVRChannel>& xbmc
 
 bool CPVRClient::GetAddonProperties()
 {
-  std::string strBackendName, strConnectionString, strFriendlyName, strBackendVersion, strBackendHostname;
+  char strBackendName[PVR_ADDON_NAME_STRING_LENGTH] = {0};
+  char strConnectionString[PVR_ADDON_NAME_STRING_LENGTH] = {0};
+  char strBackendVersion[PVR_ADDON_NAME_STRING_LENGTH] = {0};
+  char strBackendHostname[PVR_ADDON_NAME_STRING_LENGTH] = {0};
+  std::string strFriendlyName;
   PVR_ADDON_CAPABILITIES addonCapabilities = {};
   std::vector<std::shared_ptr<CPVRTimerType>> timerTypes;
 
@@ -381,32 +385,43 @@ bool CPVRClient::GetAddonProperties()
     return false;
 
   /* get the name of the backend */
-  DoAddonCall(__FUNCTION__, [&strBackendName](const AddonInstance* addon) {
-    strBackendName = addon->toAddon->GetBackendName(addon);
-    return PVR_ERROR_NO_ERROR;
+  retVal = DoAddonCall(__FUNCTION__, [&strBackendName](const AddonInstance* addon) {
+    return addon->toAddon->GetBackendName(addon, strBackendName, sizeof(strBackendName));
   }, true, false);
 
+  if (retVal != PVR_ERROR_NO_ERROR)
+    return false;
+
   /* get the connection string */
-  DoAddonCall(__FUNCTION__, [&strConnectionString](const AddonInstance* addon) {
-    strConnectionString = addon->toAddon->GetConnectionString(addon);
-    return PVR_ERROR_NO_ERROR;
+  retVal = DoAddonCall(__FUNCTION__, [&strConnectionString](const AddonInstance* addon) {
+    return addon->toAddon->GetConnectionString(addon, strConnectionString,
+                                               sizeof(strConnectionString));
   }, true, false);
 
+  if (retVal != PVR_ERROR_NO_ERROR && retVal != PVR_ERROR_NOT_IMPLEMENTED)
+    return false;
+
   /* display name = backend name:connection string */
-  strFriendlyName = StringUtils::Format("%s:%s", strBackendName.c_str(), strConnectionString.c_str());
+  strFriendlyName = StringUtils::Format("%s:%s", strBackendName, strConnectionString);
 
   /* backend version number */
-  DoAddonCall(__FUNCTION__, [&strBackendVersion](const AddonInstance* addon) {
-    strBackendVersion = addon->toAddon->GetBackendVersion(addon);
-    return PVR_ERROR_NO_ERROR;
+  retVal = DoAddonCall(__FUNCTION__, [&strBackendVersion](const AddonInstance* addon) {
+    return addon->toAddon->GetBackendVersion(addon, strBackendVersion,
+                                             sizeof(strBackendVersion));
   }, true, false);
 
+  if (retVal != PVR_ERROR_NO_ERROR)
+    return false;
+
   /* backend hostname */
-  DoAddonCall(__FUNCTION__, [&strBackendHostname](const AddonInstance* addon) {
-    strBackendHostname = addon->toAddon->GetBackendHostname(addon);
-    return PVR_ERROR_NO_ERROR;
+  retVal = DoAddonCall(__FUNCTION__, [&strBackendHostname](const AddonInstance* addon) {
+    return addon->toAddon->GetBackendHostname(addon, strBackendHostname,
+                                              sizeof(strBackendHostname));
   }, true, false);
 
+  if (retVal != PVR_ERROR_NO_ERROR && retVal != PVR_ERROR_NOT_IMPLEMENTED)
+    return false;
+
   /* timer types */
   retVal = DoAddonCall(__FUNCTION__, [this, strFriendlyName, &addonCapabilities, &timerTypes](const AddonInstance* addon) {
     std::unique_ptr<PVR_TIMER_TYPE[]> types_array(new PVR_TIMER_TYPE[PVR_ADDON_TIMERTYPE_ARRAY_SIZE]);
@@ -761,8 +776,7 @@ PVR_ERROR CPVRClient::GetChannelGroupsAmount(int& iGroups)
 {
   iGroups = -1;
   return DoAddonCall(__FUNCTION__, [&iGroups](const AddonInstance* addon) {
-    iGroups = addon->toAddon->GetChannelGroupsAmount(addon);
-    return (iGroups == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
+    return addon->toAddon->GetChannelGroupsAmount(addon, &iGroups);
   }, m_clientCapabilities.SupportsChannelGroups());
 }
 
@@ -793,8 +807,7 @@ PVR_ERROR CPVRClient::GetChannelsAmount(int& iChannels)
 {
   iChannels = -1;
   return DoAddonCall(__FUNCTION__, [&iChannels](const AddonInstance* addon) {
-    iChannels = addon->toAddon->GetChannelsAmount(addon);
-    return (iChannels == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
+    return addon->toAddon->GetChannelsAmount(addon, &iChannels);
   });
 }
 
@@ -812,8 +825,7 @@ PVR_ERROR CPVRClient::GetRecordingsAmount(bool deleted, int& iRecordings)
 {
   iRecordings = -1;
   return DoAddonCall(__FUNCTION__, [deleted, &iRecordings](const AddonInstance* addon) {
-    iRecordings = addon->toAddon->GetRecordingsAmount(addon, deleted);
-    return (iRecordings == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
+    return addon->toAddon->GetRecordingsAmount(addon, deleted, &iRecordings);
   }, m_clientCapabilities.SupportsRecordings() && (!deleted || m_clientCapabilities.SupportsRecordingsUndelete()));
 }
 
@@ -895,8 +907,7 @@ PVR_ERROR CPVRClient::GetRecordingLastPlayedPosition(const CPVRRecording& record
   return DoAddonCall(__FUNCTION__, [&recording, &iPosition](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(recording, tag);
-    iPosition = addon->toAddon->GetRecordingLastPlayedPosition(addon, &tag);
-    return (iPosition == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
+    return addon->toAddon->GetRecordingLastPlayedPosition(addon, &tag, &iPosition);
   }, m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
 }
 
@@ -933,8 +944,7 @@ PVR_ERROR CPVRClient::GetTimersAmount(int& iTimers)
 {
   iTimers = -1;
   return DoAddonCall(__FUNCTION__, [&iTimers](const AddonInstance* addon) {
-    iTimers = addon->toAddon->GetTimersAmount(addon);
-    return (iTimers == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
+    return addon->toAddon->GetTimersAmount(addon, &iTimers);
   }, m_clientCapabilities.SupportsTimers());
 }
 
@@ -1324,32 +1334,28 @@ PVR_ERROR CPVRClient::IsRealTimeStream(bool& bRealTime) const
 PVR_ERROR CPVRClient::OnSystemSleep()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->OnSystemSleep(addon);
-    return PVR_ERROR_NO_ERROR;
+    return addon->toAddon->OnSystemSleep(addon);
   });
 }
 
 PVR_ERROR CPVRClient::OnSystemWake()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->OnSystemWake(addon);
-    return PVR_ERROR_NO_ERROR;
+    return addon->toAddon->OnSystemWake(addon);
   });
 }
 
 PVR_ERROR CPVRClient::OnPowerSavingActivated()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->OnPowerSavingActivated(addon);
-    return PVR_ERROR_NO_ERROR;
+    return addon->toAddon->OnPowerSavingActivated(addon);
   });
 }
 
 PVR_ERROR CPVRClient::OnPowerSavingDeactivated()
 {
   return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->OnPowerSavingDeactivated(addon);
-    return PVR_ERROR_NO_ERROR;
+    return addon->toAddon->OnPowerSavingDeactivated(addon);
   });
 }
 
@@ -1609,7 +1615,10 @@ void CPVRClient::cb_add_menu_hook(void* kodiInstance, PVR_MENUHOOK* hook)
   client->GetMenuHooks()->AddHook(*hook);
 }
 
-void CPVRClient::cb_recording(void* kodiInstance, const char* strName, const char* strFileName, bool bOnOff)
+void CPVRClient::cb_recording_notification(void* kodiInstance,
+                                           const char* strName,
+                                           const char* strFileName,
+                                           bool bOnOff)
 {
   CPVRClient* client = static_cast<CPVRClient*>(kodiInstance);
   if (!client || !strFileName)
diff --git a/xbmc/pvr/addons/PVRClient.h b/xbmc/pvr/addons/PVRClient.h
index 71aae30d1a4b..91ae5a4a561d 100644
--- a/xbmc/pvr/addons/PVRClient.h
+++ b/xbmc/pvr/addons/PVRClient.h
@@ -1046,7 +1046,10 @@ namespace PVR
      * @param strFileName The filename of the recording
      * @param bOnOff True when recording started, false when it stopped
      */
-    static void cb_recording(void* kodiInstance, const char* strName, const char* strFileName, bool bOnOff);
+    static void cb_recording_notification(void* kodiInstance,
+                                          const char* strName,
+                                          const char* strFileName,
+                                          bool bOnOff);
 
     /*!
      * @brief Request Kodi to update it's list of channels

From 9362b3947121ac7abca41c00b0f044081af3b062 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 8 Jun 2020 18:51:00 +0200
Subject: [PATCH 18/27] [addons][pvr] use uint64_t for timer types

Before was already 29 bits used where the unsigned int comes to his end.
This use now a 64 bit for them.
---
 .../c-api/addon-instance/pvr/pvr_timers.h     |  3 ++-
 xbmc/pvr/timers/PVRTimerInfoTag.cpp           | 21 ++++++++++---------
 xbmc/pvr/timers/PVRTimerType.cpp              | 13 ++++++------
 xbmc/pvr/timers/PVRTimerType.h                | 12 +++++++----
 4 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
index 6bb53130b840..d9e12375b57e 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
@@ -11,6 +11,7 @@
 #include "pvr_defines.h"
 
 #include <stdbool.h>
+#include <stdint.h>
 #include <time.h>
 
 #ifdef __cplusplus
@@ -122,7 +123,7 @@ extern "C"
   typedef struct PVR_TIMER_TYPE
   {
     unsigned int iId;
-    unsigned int iAttributes;
+    uint64_t iAttributes;
     char strDescription[PVR_ADDON_TIMERTYPE_STRING_LENGTH];
 
     unsigned int iPrioritiesSize;
diff --git a/xbmc/pvr/timers/PVRTimerInfoTag.cpp b/xbmc/pvr/timers/PVRTimerInfoTag.cpp
index 7bcec2063c96..401c46eda717 100644
--- a/xbmc/pvr/timers/PVRTimerInfoTag.cpp
+++ b/xbmc/pvr/timers/PVRTimerInfoTag.cpp
@@ -51,8 +51,9 @@ CPVRTimerInfoTag::CPVRTimerInfoTag(bool bRadio /* = false */) :
   m_StopTime(m_StartTime + CDateTimeSpan(0, 2, 0, 0)),
   m_FirstDay(m_StartTime)
 {
-  static const unsigned int iMustHaveAttr = PVR_TIMER_TYPE_IS_MANUAL;
-  static const unsigned int iMustNotHaveAttr = PVR_TIMER_TYPE_IS_REPEATING | PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES;
+  static const uint64_t iMustHaveAttr = PVR_TIMER_TYPE_IS_MANUAL;
+  static const uint64_t iMustNotHaveAttr =
+      PVR_TIMER_TYPE_IS_REPEATING | PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES;
 
   std::shared_ptr<CPVRTimerType> type;
 
@@ -127,8 +128,8 @@ CPVRTimerInfoTag::CPVRTimerInfoTag(const PVR_TIMER& timer, const std::shared_ptr
     if (timer.iTimerType == PVR_TIMER_TYPE_NONE)
     {
       // Create type according to certain timer values.
-      unsigned int iMustHave = PVR_TIMER_TYPE_ATTRIBUTE_NONE;
-      unsigned int iMustNotHave = PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES;
+      uint64_t iMustHave = PVR_TIMER_TYPE_ATTRIBUTE_NONE;
+      uint64_t iMustNotHave = PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES;
 
       if (timer.iEpgUid == PVR_TIMER_NO_EPG_UID && timer.iWeekdays != PVR_WEEKDAY_NONE)
         iMustHave |= PVR_TIMER_TYPE_IS_REPEATING;
@@ -775,7 +776,7 @@ std::shared_ptr<CPVRTimerInfoTag> CPVRTimerInfoTag::CreateFromDate(
     newTimer->m_iClientId = channel->ClientID();
     newTimer->m_bIsRadio = channel->IsRadio();
 
-    int iMustHaveAttribs = PVR_TIMER_TYPE_IS_MANUAL;
+    uint64_t iMustHaveAttribs = PVR_TIMER_TYPE_IS_MANUAL;
     if (bCreateReminder)
       iMustHaveAttribs |= PVR_TIMER_TYPE_IS_REMINDER;
     if (bReadOnly)
@@ -892,15 +893,15 @@ std::shared_ptr<CPVRTimerInfoTag> CPVRTimerInfoTag::CreateFromEpg(
   newTag->SetStartFromUTC(tag->StartAsUTC());
   newTag->SetEndFromUTC(tag->EndAsUTC());
 
-  const int iMustNotHaveAttribs = PVR_TIMER_TYPE_IS_MANUAL |
-                                  PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES |
-                                  PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE;
+  const uint64_t iMustNotHaveAttribs = PVR_TIMER_TYPE_IS_MANUAL |
+                                       PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES |
+                                       PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE;
   std::shared_ptr<CPVRTimerType> timerType;
   if (bCreateRule)
   {
     // create epg-based timer rule, prefer rule using series link if available.
 
-    int iMustHaveAttribs = PVR_TIMER_TYPE_IS_REPEATING;
+    uint64_t iMustHaveAttribs = PVR_TIMER_TYPE_IS_REPEATING;
     if (bCreateReminder)
       iMustHaveAttribs |= PVR_TIMER_TYPE_IS_REMINDER;
     if (bReadOnly)
@@ -931,7 +932,7 @@ std::shared_ptr<CPVRTimerInfoTag> CPVRTimerInfoTag::CreateFromEpg(
   {
     // create one-shot epg-based timer
 
-    int iMustHaveAttribs = PVR_TIMER_TYPE_ATTRIBUTE_NONE;
+    uint64_t iMustHaveAttribs = PVR_TIMER_TYPE_ATTRIBUTE_NONE;
     if (bCreateReminder)
       iMustHaveAttribs |= PVR_TIMER_TYPE_IS_REMINDER;
     if (bReadOnly)
diff --git a/xbmc/pvr/timers/PVRTimerType.cpp b/xbmc/pvr/timers/PVRTimerType.cpp
index e61dad968d41..567cfe533149 100644
--- a/xbmc/pvr/timers/PVRTimerType.cpp
+++ b/xbmc/pvr/timers/PVRTimerType.cpp
@@ -135,8 +135,9 @@ std::shared_ptr<CPVRTimerType> CPVRTimerType::CreateFromIds(unsigned int iTypeId
   return {};
 }
 
-std::shared_ptr<CPVRTimerType> CPVRTimerType::CreateFromAttributes(
-  unsigned int iMustHaveAttr, unsigned int iMustNotHaveAttr, int iClientId)
+std::shared_ptr<CPVRTimerType> CPVRTimerType::CreateFromAttributes(uint64_t iMustHaveAttr,
+                                                                   uint64_t iMustNotHaveAttr,
+                                                                   int iClientId)
 {
   const std::vector<std::shared_ptr<CPVRTimerType>> types = GetAllTypes();
   for (const auto& type : types)
@@ -175,10 +176,10 @@ CPVRTimerType::CPVRTimerType(const PVR_TIMER_TYPE& type, int iClientId) :
   InitAttributeValues(type);
 }
 
-CPVRTimerType::CPVRTimerType(unsigned int iTypeId, unsigned int iAttributes, const std::string& strDescription) :
-  m_iTypeId(iTypeId),
-  m_iAttributes(iAttributes),
-  m_strDescription(strDescription)
+CPVRTimerType::CPVRTimerType(unsigned int iTypeId,
+                             uint64_t iAttributes,
+                             const std::string& strDescription)
+  : m_iTypeId(iTypeId), m_iAttributes(iAttributes), m_strDescription(strDescription)
 {
   InitDescription();
 }
diff --git a/xbmc/pvr/timers/PVRTimerType.h b/xbmc/pvr/timers/PVRTimerType.h
index a757660a9781..cc419a892234 100644
--- a/xbmc/pvr/timers/PVRTimerType.h
+++ b/xbmc/pvr/timers/PVRTimerType.h
@@ -56,11 +56,15 @@ namespace PVR
      * @param iClientId the PVR client id.
      * @return A timer type instance.
      */
-    static std::shared_ptr<CPVRTimerType> CreateFromAttributes(unsigned int iMustHaveAttr, unsigned int iMustNotHaveAttr, int iClientId);
+    static std::shared_ptr<CPVRTimerType> CreateFromAttributes(uint64_t iMustHaveAttr,
+                                                               uint64_t iMustNotHaveAttr,
+                                                               int iClientId);
 
     CPVRTimerType();
     CPVRTimerType(const PVR_TIMER_TYPE& type, int iClientId);
-    CPVRTimerType(unsigned int iTypeId, unsigned int iAttributes, const std::string& strDescription = "");
+    CPVRTimerType(unsigned int iTypeId,
+                  uint64_t iAttributes,
+                  const std::string& strDescription = "");
 
     virtual ~CPVRTimerType();
 
@@ -92,7 +96,7 @@ namespace PVR
      * @brief Get the attributes of this type.
      * @return The attributes.
      */
-    unsigned int GetAttributes() const { return m_iAttributes; }
+    uint64_t GetAttributes() const { return m_iAttributes; }
 
     /*!
      * @brief Check whether this type is for timer rules or one time timers.
@@ -391,7 +395,7 @@ namespace PVR
 
     int m_iClientId = -1;
     unsigned int m_iTypeId;
-    unsigned int m_iAttributes;
+    uint64_t m_iAttributes;
     std::string m_strDescription;
     std::vector< std::pair<std::string, int> > m_priorityValues;
     int m_iPriorityDefault = DEFAULT_RECORDING_PRIORITY;

From f9a6f80f211bbe36831d0581a9c222e9f767ffbc Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 8 Jun 2020 14:45:34 +0200
Subject: [PATCH 19/27] [addons][pvr] add C++ PVR instance class

This add the new instance class for PVR system. There everything
supported like before but now on easier way on addons.

This are splittet to separate files.
---
 cmake/treedata/common/subdirs.txt             |    1 +
 .../include/kodi/addon-instance/PVR.h         | 1125 +++++++++++++++++
 .../kodi/addon-instance/pvr/CMakeLists.txt    |   13 +
 .../kodi/addon-instance/pvr/ChannelGroups.h   |  119 ++
 .../kodi/addon-instance/pvr/Channels.h        |  215 ++++
 .../include/kodi/addon-instance/pvr/EDL.h     |   42 +
 .../include/kodi/addon-instance/pvr/EPG.h     |  219 ++++
 .../include/kodi/addon-instance/pvr/General.h |  224 ++++
 .../kodi/addon-instance/pvr/MenuHook.h        |   57 +
 .../kodi/addon-instance/pvr/Recordings.h      |  207 +++
 .../include/kodi/addon-instance/pvr/Stream.h  |  133 ++
 .../include/kodi/addon-instance/pvr/Timers.h  |  381 ++++++
 .../c-api/addon-instance/pvr/CMakeLists.txt   |    3 +-
 13 files changed, 2737 insertions(+), 2 deletions(-)
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/CMakeLists.txt
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/ChannelGroups.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Channels.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EDL.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EPG.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/General.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/MenuHook.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Stream.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h

diff --git a/cmake/treedata/common/subdirs.txt b/cmake/treedata/common/subdirs.txt
index c1fe784d0e86..813111329665 100644
--- a/cmake/treedata/common/subdirs.txt
+++ b/cmake/treedata/common/subdirs.txt
@@ -8,6 +8,7 @@ xbmc/addons/interfaces/gui/controls             addons_interfaces_gui_controls
 xbmc/addons/interfaces/gui/dialogs              addons_interfaces_gui_dialogs
 xbmc/addons/kodi-addon-dev-kit/include/kodi     addons_kodi-addon-dev-kit_include_kodi
 xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance addons_kodi-addon-dev-kit_include_kodi_addon-instance
+xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr addons_kodi-addon-dev-kit_include_kodi_addon-instance_pvr
 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api addons_kodi-addon-dev-kit_include_kodi_c-api
 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance addons_kodi-addon-dev-kit_include_kodi_c-api_addon-instance
 xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr addons_kodi-addon-dev-kit_include_kodi_c-api_addon-instance_pvr
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index 5cb608ed1110..ea0fb0f9bec5 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -9,3 +9,1128 @@
 #pragma once
 
 #include "../c-api/addon-instance/pvr.h"
+#include "pvr/ChannelGroups.h"
+#include "pvr/Channels.h"
+#include "pvr/EDL.h"
+#include "pvr/EPG.h"
+#include "pvr/General.h"
+#include "pvr/MenuHook.h"
+#include "pvr/Recordings.h"
+#include "pvr/Stream.h"
+#include "pvr/Timers.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class CInstancePVRClient : public IAddonInstance
+{
+public:
+  CInstancePVRClient() : IAddonInstance(ADDON_INSTANCE_PVR, GetKodiTypeVersion(ADDON_INSTANCE_PVR))
+  {
+    if (CAddonBase::m_interface->globalSingleInstance != nullptr)
+      throw std::logic_error("kodi::addon::CInstancePVRClient: Creation of more as one in single "
+                             "instance way is not allowed!");
+
+    SetAddonStruct(CAddonBase::m_interface->firstKodiInstance, m_kodiVersion);
+    CAddonBase::m_interface->globalSingleInstance = this;
+  }
+
+  explicit CInstancePVRClient(KODI_HANDLE instance, const std::string& kodiVersion = "")
+    : IAddonInstance(ADDON_INSTANCE_PVR,
+                     !kodiVersion.empty() ? kodiVersion : GetKodiTypeVersion(ADDON_INSTANCE_PVR))
+  {
+    if (CAddonBase::m_interface->globalSingleInstance != nullptr)
+      throw std::logic_error("kodi::addon::CInstancePVRClient: Creation of multiple together with "
+                             "single instance way is not allowed!");
+
+    SetAddonStruct(instance, m_kodiVersion);
+  }
+
+  ~CInstancePVRClient() override = default;
+
+  virtual PVR_ERROR GetCapabilities(kodi::addon::PVRCapabilities& capabilities) = 0;
+  virtual PVR_ERROR GetBackendName(std::string& name) = 0;
+  virtual PVR_ERROR GetBackendVersion(std::string& version) = 0;
+  virtual PVR_ERROR GetBackendHostname(std::string& hostname) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR GetConnectionString(std::string& connection)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetDriveSpace(uint64_t& total, uint64_t& used)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR CallSettingsMenuHook(const kodi::addon::PVRMenuhook& menuhook)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  inline void AddMenuHook(kodi::addon::PVRMenuhook& hook)
+  {
+    m_instanceData->toKodi->AddMenuHook(m_instanceData->toKodi->kodiInstance, hook);
+  }
+  inline void ConnectionStateChange(const std::string& connectionString,
+                                    PVR_CONNECTION_STATE newState,
+                                    const std::string& message)
+  {
+    m_instanceData->toKodi->ConnectionStateChange(
+        m_instanceData->toKodi->kodiInstance, connectionString.c_str(), newState, message.c_str());
+  }
+  inline std::string UserPath() const { return m_instanceData->props->strUserPath; }
+  inline std::string ClientPath() const { return m_instanceData->props->strClientPath; }
+
+  virtual PVR_ERROR GetChannelsAmount(int& amount) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR GetChannels(bool radio, kodi::addon::PVRChannelsResultSet& results)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetChannelStreamProperties(
+      const kodi::addon::PVRChannel& channel,
+      std::vector<kodi::addon::PVRStreamProperty>& properties)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetSignalStatus(int channelUid, kodi::addon::PVRSignalStatus& signalStatus)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetDescrambleInfo(int channelUid,
+                                      kodi::addon::PVRDescrambleInfo& descrambleInfo)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  inline void TriggerChannelUpdate()
+  {
+    m_instanceData->toKodi->TriggerChannelUpdate(m_instanceData->toKodi->kodiInstance);
+  }
+
+  virtual PVR_ERROR GetChannelGroupsAmount(int& amount) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR GetChannelGroups(bool radio, kodi::addon::PVRChannelGroupsResultSet& results)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetChannelGroupMembers(const kodi::addon::PVRChannelGroup& group,
+                                           kodi::addon::PVRChannelGroupMembersResultSet& results)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  inline void TriggerChannelGroupsUpdate()
+  {
+    m_instanceData->toKodi->TriggerChannelGroupsUpdate(m_instanceData->toKodi->kodiInstance);
+  }
+
+  virtual PVR_ERROR DeleteChannel(const kodi::addon::PVRChannel& channel)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR RenameChannel(const kodi::addon::PVRChannel& channel)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR OpenDialogChannelSettings(const kodi::addon::PVRChannel& channel)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR OpenDialogChannelAdd(const kodi::addon::PVRChannel& channel)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR OpenDialogChannelScan() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR CallChannelMenuHook(const kodi::addon::PVRMenuhook& menuhook,
+                                        const kodi::addon::PVRChannel& item)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+
+  virtual PVR_ERROR GetEPGForChannel(int channelUid,
+                                     time_t start,
+                                     time_t end,
+                                     kodi::addon::PVREPGTagsResultSet& results)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR IsEPGTagRecordable(const kodi::addon::PVREPGTag& tag, bool& isRecordable)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR IsEPGTagPlayable(const kodi::addon::PVREPGTag& tag, bool& isPlayable)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetEPGTagEdl(const kodi::addon::PVREPGTag& tag,
+                                 std::vector<kodi::addon::PVREDLEntry>& edl)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetEPGTagStreamProperties(
+      const kodi::addon::PVREPGTag& tag, std::vector<kodi::addon::PVRStreamProperty>& properties)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR SetEPGTimeFrame(int days) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR CallEPGMenuHook(const kodi::addon::PVRMenuhook& menuhook,
+                                    const kodi::addon::PVREPGTag& tag)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  inline int EpgMaxDays() const { return m_instanceData->props->iEpgMaxDays; }
+  inline void TriggerEpgUpdate(unsigned int channelUid)
+  {
+    m_instanceData->toKodi->TriggerEpgUpdate(m_instanceData->toKodi->kodiInstance, channelUid);
+  }
+  inline void EpgEventStateChange(kodi::addon::PVREPGTag& tag, EPG_EVENT_STATE newState)
+  {
+    m_instanceData->toKodi->EpgEventStateChange(m_instanceData->toKodi->kodiInstance, tag.GetTag(),
+                                                newState);
+  }
+
+  virtual PVR_ERROR GetRecordingsAmount(bool deleted, int& amount)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetRecordings(bool deleted, kodi::addon::PVRRecordingsResultSet& results)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR DeleteRecording(const kodi::addon::PVRRecording& recording)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR UndeleteRecording(const kodi::addon::PVRRecording& recording)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR DeleteAllRecordingsFromTrash() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR RenameRecording(const kodi::addon::PVRRecording& recording)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR SetRecordingLifetime(const kodi::addon::PVRRecording& recording)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR SetRecordingPlayCount(const kodi::addon::PVRRecording& recording, int count)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR SetRecordingLastPlayedPosition(const kodi::addon::PVRRecording& recording,
+                                                   int lastplayedposition)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetRecordingLastPlayedPosition(const kodi::addon::PVRRecording& recording,
+                                                   int& position)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetRecordingEdl(const kodi::addon::PVRRecording& recording,
+                                    std::vector<kodi::addon::PVREDLEntry>& edl)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetRecordingSize(const kodi::addon::PVRRecording& recording, int64_t& size)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetRecordingStreamProperties(
+      const kodi::addon::PVRRecording& recording,
+      std::vector<kodi::addon::PVRStreamProperty>& properties)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR CallRecordingMenuHook(const kodi::addon::PVRMenuhook& menuhook,
+                                          const kodi::addon::PVRRecording& item)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  inline void RecordingNotification(const std::string& recordingName,
+                                    const std::string& fileName,
+                                    bool on)
+  {
+    m_instanceData->toKodi->RecordingNotification(m_instanceData->toKodi->kodiInstance,
+                                                  recordingName.c_str(), fileName.c_str(), on);
+  }
+  inline void TriggerRecordingUpdate()
+  {
+    m_instanceData->toKodi->TriggerRecordingUpdate(m_instanceData->toKodi->kodiInstance);
+  }
+
+  virtual PVR_ERROR GetTimerTypes(std::vector<kodi::addon::PVRTimerType>& types)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetTimersAmount(int& amount) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR GetTimers(kodi::addon::PVRTimersResultSet& results)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR AddTimer(const kodi::addon::PVRTimer& timer)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR DeleteTimer(const kodi::addon::PVRTimer& timer, bool forceDelete)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR UpdateTimer(const kodi::addon::PVRTimer& timer)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR CallTimerMenuHook(const kodi::addon::PVRMenuhook& menuhook,
+                                      const kodi::addon::PVRTimer& item)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  inline void TriggerTimerUpdate()
+  {
+    m_instanceData->toKodi->TriggerTimerUpdate(m_instanceData->toKodi->kodiInstance);
+  }
+
+  virtual PVR_ERROR OnSystemSleep() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR OnSystemWake() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR OnPowerSavingActivated() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  virtual PVR_ERROR OnPowerSavingDeactivated() { return PVR_ERROR_NOT_IMPLEMENTED; }
+
+  virtual bool OpenLiveStream(const kodi::addon::PVRChannel& channel) { return false; }
+  virtual void CloseLiveStream() {}
+  virtual int ReadLiveStream(unsigned char* buffer, unsigned int size) { return 0; }
+  virtual int64_t SeekLiveStream(int64_t position, int whence) { return 0; }
+  virtual int64_t LengthLiveStream() { return 0; }
+  virtual PVR_ERROR GetStreamProperties(std::vector<kodi::addon::PVRStreamProperties>& properties)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual DemuxPacket* DemuxRead() { return nullptr; }
+  virtual void DemuxReset() {}
+  virtual void DemuxAbort() {}
+  virtual void DemuxFlush() {}
+  virtual void SetSpeed(int speed) {}
+  virtual void FillBuffer(bool mode) {}
+  virtual bool SeekTime(double time, bool backwards, double& startpts) { return false; }
+  inline PVRCodec GetCodecByName(const std::string& codecName) const
+  {
+    return PVRCodec(m_instanceData->toKodi->GetCodecByName(m_instanceData->toKodi->kodiInstance,
+                                                           codecName.c_str()));
+  }
+  inline DemuxPacket* AllocateDemuxPacket(int iDataSize)
+  {
+    return m_instanceData->toKodi->AllocateDemuxPacket(m_instanceData->toKodi->kodiInstance,
+                                                       iDataSize);
+  }
+  inline void FreeDemuxPacket(DemuxPacket* pPacket)
+  {
+    m_instanceData->toKodi->FreeDemuxPacket(m_instanceData->toKodi->kodiInstance, pPacket);
+  }
+
+  virtual bool OpenRecordedStream(const kodi::addon::PVRRecording& recording) { return false; }
+  virtual void CloseRecordedStream() {}
+  virtual int ReadRecordedStream(unsigned char* buffer, unsigned int size) { return 0; }
+  virtual int64_t SeekRecordedStream(int64_t position, int whence) { return 0; }
+  virtual int64_t LengthRecordedStream() { return 0; }
+
+  virtual bool CanPauseStream() { return false; }
+  virtual bool CanSeekStream() { return false; }
+  virtual void PauseStream(bool paused) {}
+  virtual bool IsRealTimeStream() { return false; }
+  virtual PVR_ERROR GetStreamTimes(kodi::addon::PVRStreamTimes& times)
+  {
+    return PVR_ERROR_NOT_IMPLEMENTED;
+  }
+  virtual PVR_ERROR GetStreamReadChunkSize(int& chunksize) { return PVR_ERROR_NOT_IMPLEMENTED; }
+
+private:
+  void SetAddonStruct(KODI_HANDLE instance, const std::string& kodiVersion)
+  {
+    if (instance == nullptr)
+      throw std::logic_error("kodi::addon::CInstancePVRClient: Creation with empty addon "
+                             "structure not allowed, table must be given from Kodi!");
+
+    m_instanceData = static_cast<AddonInstance_PVR*>(instance);
+    m_instanceData->toAddon->addonInstance = this;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->GetCapabilities = ADDON_GetCapabilities;
+    m_instanceData->toAddon->GetConnectionString = ADDON_GetConnectionString;
+    m_instanceData->toAddon->GetBackendName = ADDON_GetBackendName;
+    m_instanceData->toAddon->GetBackendVersion = ADDON_GetBackendVersion;
+    m_instanceData->toAddon->GetBackendHostname = ADDON_GetBackendHostname;
+    m_instanceData->toAddon->GetDriveSpace = ADDON_GetDriveSpace;
+    m_instanceData->toAddon->CallSettingsMenuHook = ADDON_CallSettingsMenuHook;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->GetChannelsAmount = ADDON_GetChannelsAmount;
+    m_instanceData->toAddon->GetChannels = ADDON_GetChannels;
+    m_instanceData->toAddon->GetChannelStreamProperties = ADDON_GetChannelStreamProperties;
+    m_instanceData->toAddon->GetSignalStatus = ADDON_GetSignalStatus;
+    m_instanceData->toAddon->GetDescrambleInfo = ADDON_GetDescrambleInfo;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->GetChannelGroupsAmount = ADDON_GetChannelGroupsAmount;
+    m_instanceData->toAddon->GetChannelGroups = ADDON_GetChannelGroups;
+    m_instanceData->toAddon->GetChannelGroupMembers = ADDON_GetChannelGroupMembers;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->DeleteChannel = ADDON_DeleteChannel;
+    m_instanceData->toAddon->RenameChannel = ADDON_RenameChannel;
+    m_instanceData->toAddon->OpenDialogChannelSettings = ADDON_OpenDialogChannelSettings;
+    m_instanceData->toAddon->OpenDialogChannelAdd = ADDON_OpenDialogChannelAdd;
+    m_instanceData->toAddon->OpenDialogChannelScan = ADDON_OpenDialogChannelScan;
+    m_instanceData->toAddon->CallChannelMenuHook = ADDON_CallChannelMenuHook;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->GetEPGForChannel = ADDON_GetEPGForChannel;
+    m_instanceData->toAddon->IsEPGTagRecordable = ADDON_IsEPGTagRecordable;
+    m_instanceData->toAddon->IsEPGTagPlayable = ADDON_IsEPGTagPlayable;
+    m_instanceData->toAddon->GetEPGTagEdl = ADDON_GetEPGTagEdl;
+    m_instanceData->toAddon->GetEPGTagStreamProperties = ADDON_GetEPGTagStreamProperties;
+    m_instanceData->toAddon->SetEPGTimeFrame = ADDON_SetEPGTimeFrame;
+    m_instanceData->toAddon->CallEPGMenuHook = ADDON_CallEPGMenuHook;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->GetRecordingsAmount = ADDON_GetRecordingsAmount;
+    m_instanceData->toAddon->GetRecordings = ADDON_GetRecordings;
+    m_instanceData->toAddon->DeleteRecording = ADDON_DeleteRecording;
+    m_instanceData->toAddon->UndeleteRecording = ADDON_UndeleteRecording;
+    m_instanceData->toAddon->DeleteAllRecordingsFromTrash = ADDON_DeleteAllRecordingsFromTrash;
+    m_instanceData->toAddon->RenameRecording = ADDON_RenameRecording;
+    m_instanceData->toAddon->SetRecordingLifetime = ADDON_SetRecordingLifetime;
+    m_instanceData->toAddon->SetRecordingPlayCount = ADDON_SetRecordingPlayCount;
+    m_instanceData->toAddon->SetRecordingLastPlayedPosition = ADDON_SetRecordingLastPlayedPosition;
+    m_instanceData->toAddon->GetRecordingLastPlayedPosition = ADDON_GetRecordingLastPlayedPosition;
+    m_instanceData->toAddon->GetRecordingEdl = ADDON_GetRecordingEdl;
+    m_instanceData->toAddon->GetRecordingSize = ADDON_GetRecordingSize;
+    m_instanceData->toAddon->GetRecordingStreamProperties = ADDON_GetRecordingStreamProperties;
+    m_instanceData->toAddon->CallRecordingMenuHook = ADDON_CallRecordingMenuHook;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->GetTimerTypes = ADDON_GetTimerTypes;
+    m_instanceData->toAddon->GetTimersAmount = ADDON_GetTimersAmount;
+    m_instanceData->toAddon->GetTimers = ADDON_GetTimers;
+    m_instanceData->toAddon->AddTimer = ADDON_AddTimer;
+    m_instanceData->toAddon->DeleteTimer = ADDON_DeleteTimer;
+    m_instanceData->toAddon->UpdateTimer = ADDON_UpdateTimer;
+    m_instanceData->toAddon->CallTimerMenuHook = ADDON_CallTimerMenuHook;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->OnSystemSleep = ADDON_OnSystemSleep;
+    m_instanceData->toAddon->OnSystemWake = ADDON_OnSystemWake;
+    m_instanceData->toAddon->OnPowerSavingActivated = ADDON_OnPowerSavingActivated;
+    m_instanceData->toAddon->OnPowerSavingDeactivated = ADDON_OnPowerSavingDeactivated;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->OpenLiveStream = ADDON_OpenLiveStream;
+    m_instanceData->toAddon->CloseLiveStream = ADDON_CloseLiveStream;
+    m_instanceData->toAddon->ReadLiveStream = ADDON_ReadLiveStream;
+    m_instanceData->toAddon->SeekLiveStream = ADDON_SeekLiveStream;
+    m_instanceData->toAddon->LengthLiveStream = ADDON_LengthLiveStream;
+    m_instanceData->toAddon->GetStreamProperties = ADDON_GetStreamProperties;
+    m_instanceData->toAddon->GetStreamReadChunkSize = ADDON_GetStreamReadChunkSize;
+    m_instanceData->toAddon->IsRealTimeStream = ADDON_IsRealTimeStream;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->OpenRecordedStream = ADDON_OpenRecordedStream;
+    m_instanceData->toAddon->CloseRecordedStream = ADDON_CloseRecordedStream;
+    m_instanceData->toAddon->ReadRecordedStream = ADDON_ReadRecordedStream;
+    m_instanceData->toAddon->SeekRecordedStream = ADDON_SeekRecordedStream;
+    m_instanceData->toAddon->LengthRecordedStream = ADDON_LengthRecordedStream;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->DemuxReset = ADDON_DemuxReset;
+    m_instanceData->toAddon->DemuxAbort = ADDON_DemuxAbort;
+    m_instanceData->toAddon->DemuxFlush = ADDON_DemuxFlush;
+    m_instanceData->toAddon->DemuxRead = ADDON_DemuxRead;
+    //--==----==----==----==----==----==----==----==----==----==----==----==----==
+    m_instanceData->toAddon->CanPauseStream = ADDON_CanPauseStream;
+    m_instanceData->toAddon->PauseStream = ADDON_PauseStream;
+    m_instanceData->toAddon->CanSeekStream = ADDON_CanSeekStream;
+    m_instanceData->toAddon->SeekTime = ADDON_SeekTime;
+    m_instanceData->toAddon->SetSpeed = ADDON_SetSpeed;
+    m_instanceData->toAddon->FillBuffer = ADDON_FillBuffer;
+    m_instanceData->toAddon->GetStreamTimes = ADDON_GetStreamTimes;
+  }
+
+  inline static PVR_ERROR ADDON_GetCapabilities(const AddonInstance_PVR* instance,
+                                                PVR_ADDON_CAPABILITIES* capabilities)
+  {
+    PVRCapabilities cppCapabilities(capabilities);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetCapabilities(cppCapabilities);
+  }
+
+  inline static PVR_ERROR ADDON_GetBackendName(const AddonInstance_PVR* instance,
+                                               char* str,
+                                               int memSize)
+  {
+    std::string backendName;
+    PVR_ERROR err = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                        ->GetBackendName(backendName);
+    if (err == PVR_ERROR_NO_ERROR)
+      strncpy(str, backendName.c_str(), memSize);
+    return err;
+  }
+
+  inline static PVR_ERROR ADDON_GetBackendVersion(const AddonInstance_PVR* instance,
+                                                  char* str,
+                                                  int memSize)
+  {
+    std::string backendVersion;
+    PVR_ERROR err = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                        ->GetBackendVersion(backendVersion);
+    if (err == PVR_ERROR_NO_ERROR)
+      strncpy(str, backendVersion.c_str(), memSize);
+    return err;
+  }
+
+  inline static PVR_ERROR ADDON_GetBackendHostname(const AddonInstance_PVR* instance,
+                                                   char* str,
+                                                   int memSize)
+  {
+    std::string backendHostname;
+    PVR_ERROR err = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                        ->GetBackendHostname(backendHostname);
+    if (err == PVR_ERROR_NO_ERROR)
+      strncpy(str, backendHostname.c_str(), memSize);
+    return err;
+  }
+
+  inline static PVR_ERROR ADDON_GetConnectionString(const AddonInstance_PVR* instance,
+                                                    char* str,
+                                                    int memSize)
+  {
+    std::string connectionString;
+    PVR_ERROR err = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                        ->GetConnectionString(connectionString);
+    if (err == PVR_ERROR_NO_ERROR)
+      strncpy(str, connectionString.c_str(), memSize);
+    return err;
+  }
+
+  inline static PVR_ERROR ADDON_GetDriveSpace(const AddonInstance_PVR* instance,
+                                              uint64_t* total,
+                                              uint64_t* used)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetDriveSpace(*total, *used);
+  }
+
+  inline static PVR_ERROR ADDON_CallSettingsMenuHook(const AddonInstance_PVR* instance,
+                                                     const PVR_MENUHOOK* menuhook)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->CallSettingsMenuHook(menuhook);
+  }
+
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+  inline static PVR_ERROR ADDON_GetChannelsAmount(const AddonInstance_PVR* instance, int* amount)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetChannelsAmount(*amount);
+  }
+
+  inline static PVR_ERROR ADDON_GetChannels(const AddonInstance_PVR* instance,
+                                            ADDON_HANDLE handle,
+                                            bool radio)
+  {
+    PVRChannelsResultSet result(instance, handle);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetChannels(radio, result);
+  }
+
+  inline static PVR_ERROR ADDON_GetChannelStreamProperties(const AddonInstance_PVR* instance,
+                                                           const PVR_CHANNEL* channel,
+                                                           PVR_NAMED_VALUE* properties,
+                                                           unsigned int* propertiesCount)
+  {
+    *propertiesCount = 0;
+    std::vector<PVRStreamProperty> propertiesList;
+    PVR_ERROR error = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                          ->GetChannelStreamProperties(channel, propertiesList);
+    if (error == PVR_ERROR_NO_ERROR)
+    {
+      for (const auto& property : propertiesList)
+      {
+        strncpy(properties[*propertiesCount].strName, property.GetCStructure()->strName,
+                sizeof(properties[*propertiesCount].strName) - 1);
+        strncpy(properties[*propertiesCount].strValue, property.GetCStructure()->strValue,
+                sizeof(properties[*propertiesCount].strValue) - 1);
+        ++*propertiesCount;
+        if (*propertiesCount > STREAM_MAX_PROPERTY_COUNT)
+          break;
+      }
+    }
+    return error;
+  }
+
+  inline static PVR_ERROR ADDON_GetSignalStatus(const AddonInstance_PVR* instance,
+                                                int channelUid,
+                                                PVR_SIGNAL_STATUS* signalStatus)
+  {
+    PVRSignalStatus cppSignalStatus(signalStatus);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetSignalStatus(channelUid, cppSignalStatus);
+  }
+
+  inline static PVR_ERROR ADDON_GetDescrambleInfo(const AddonInstance_PVR* instance,
+                                                  int channelUid,
+                                                  PVR_DESCRAMBLE_INFO* descrambleInfo)
+  {
+    PVRDescrambleInfo cppDescrambleInfo(descrambleInfo);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetDescrambleInfo(channelUid, cppDescrambleInfo);
+  }
+
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+  inline static PVR_ERROR ADDON_GetChannelGroupsAmount(const AddonInstance_PVR* instance,
+                                                       int* amount)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetChannelGroupsAmount(*amount);
+  }
+
+  inline static PVR_ERROR ADDON_GetChannelGroups(const AddonInstance_PVR* instance,
+                                                 ADDON_HANDLE handle,
+                                                 bool radio)
+  {
+    PVRChannelGroupsResultSet result(instance, handle);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetChannelGroups(radio, result);
+  }
+
+  inline static PVR_ERROR ADDON_GetChannelGroupMembers(const AddonInstance_PVR* instance,
+                                                       ADDON_HANDLE handle,
+                                                       const PVR_CHANNEL_GROUP* group)
+  {
+    PVRChannelGroupMembersResultSet result(instance, handle);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetChannelGroupMembers(group, result);
+  }
+
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+  inline static PVR_ERROR ADDON_DeleteChannel(const AddonInstance_PVR* instance,
+                                              const PVR_CHANNEL* channel)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->DeleteChannel(channel);
+  }
+
+  inline static PVR_ERROR ADDON_RenameChannel(const AddonInstance_PVR* instance,
+                                              const PVR_CHANNEL* channel)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->RenameChannel(channel);
+  }
+
+  inline static PVR_ERROR ADDON_OpenDialogChannelSettings(const AddonInstance_PVR* instance,
+                                                          const PVR_CHANNEL* channel)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->OpenDialogChannelSettings(channel);
+  }
+
+  inline static PVR_ERROR ADDON_OpenDialogChannelAdd(const AddonInstance_PVR* instance,
+                                                     const PVR_CHANNEL* channel)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->OpenDialogChannelAdd(channel);
+  }
+
+  inline static PVR_ERROR ADDON_OpenDialogChannelScan(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->OpenDialogChannelScan();
+  }
+
+  inline static PVR_ERROR ADDON_CallChannelMenuHook(const AddonInstance_PVR* instance,
+                                                    const PVR_MENUHOOK* menuhook,
+                                                    const PVR_CHANNEL* channel)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->CallChannelMenuHook(menuhook, channel);
+  }
+
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+  inline static PVR_ERROR ADDON_GetEPGForChannel(const AddonInstance_PVR* instance,
+                                                 ADDON_HANDLE handle,
+                                                 int channelUid,
+                                                 time_t start,
+                                                 time_t end)
+  {
+    PVREPGTagsResultSet result(instance, handle);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetEPGForChannel(channelUid, start, end, result);
+  }
+
+  inline static PVR_ERROR ADDON_IsEPGTagRecordable(const AddonInstance_PVR* instance,
+                                                   const EPG_TAG* tag,
+                                                   bool* isRecordable)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->IsEPGTagRecordable(tag, *isRecordable);
+  }
+
+  inline static PVR_ERROR ADDON_IsEPGTagPlayable(const AddonInstance_PVR* instance,
+                                                 const EPG_TAG* tag,
+                                                 bool* isPlayable)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->IsEPGTagPlayable(tag, *isPlayable);
+  }
+
+  inline static PVR_ERROR ADDON_GetEPGTagEdl(const AddonInstance_PVR* instance,
+                                             const EPG_TAG* tag,
+                                             PVR_EDL_ENTRY* edl,
+                                             int* size)
+  {
+    *size = 0;
+    std::vector<PVREDLEntry> edlList;
+    PVR_ERROR error = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                          ->GetEPGTagEdl(tag, edlList);
+    if (error == PVR_ERROR_NO_ERROR)
+    {
+      for (const auto& edlEntry : edlList)
+      {
+        edl[*size] = *edlEntry;
+        ++*size;
+      }
+    }
+    return error;
+  }
+
+  inline static PVR_ERROR ADDON_GetEPGTagStreamProperties(const AddonInstance_PVR* instance,
+                                                          const EPG_TAG* tag,
+                                                          PVR_NAMED_VALUE* properties,
+                                                          unsigned int* propertiesCount)
+  {
+    *propertiesCount = 0;
+    std::vector<PVRStreamProperty> propertiesList;
+    PVR_ERROR error = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                          ->GetEPGTagStreamProperties(tag, propertiesList);
+    if (error == PVR_ERROR_NO_ERROR)
+    {
+      for (const auto& property : propertiesList)
+      {
+        strncpy(properties[*propertiesCount].strName, property.GetCStructure()->strName,
+                sizeof(properties[*propertiesCount].strName) - 1);
+        strncpy(properties[*propertiesCount].strValue, property.GetCStructure()->strValue,
+                sizeof(properties[*propertiesCount].strValue) - 1);
+        ++*propertiesCount;
+        if (*propertiesCount > STREAM_MAX_PROPERTY_COUNT)
+          break;
+      }
+    }
+    return error;
+  }
+
+  inline static PVR_ERROR ADDON_SetEPGTimeFrame(const AddonInstance_PVR* instance, int days)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->SetEPGTimeFrame(days);
+  }
+
+  inline static PVR_ERROR ADDON_CallEPGMenuHook(const AddonInstance_PVR* instance,
+                                                const PVR_MENUHOOK* menuhook,
+                                                const EPG_TAG* tag)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->CallEPGMenuHook(menuhook, tag);
+  }
+
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+  inline static PVR_ERROR ADDON_GetRecordingsAmount(const AddonInstance_PVR* instance,
+                                                    bool deleted,
+                                                    int* amount)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetRecordingsAmount(deleted, *amount);
+  }
+
+  inline static PVR_ERROR ADDON_GetRecordings(const AddonInstance_PVR* instance,
+                                              ADDON_HANDLE handle,
+                                              bool deleted)
+  {
+    PVRRecordingsResultSet result(instance, handle);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetRecordings(deleted, result);
+  }
+
+  inline static PVR_ERROR ADDON_DeleteRecording(const AddonInstance_PVR* instance,
+                                                const PVR_RECORDING* recording)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->DeleteRecording(recording);
+  }
+
+  inline static PVR_ERROR ADDON_UndeleteRecording(const AddonInstance_PVR* instance,
+                                                  const PVR_RECORDING* recording)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->UndeleteRecording(recording);
+  }
+
+  inline static PVR_ERROR ADDON_DeleteAllRecordingsFromTrash(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->DeleteAllRecordingsFromTrash();
+  }
+
+  inline static PVR_ERROR ADDON_RenameRecording(const AddonInstance_PVR* instance,
+                                                const PVR_RECORDING* recording)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->RenameRecording(recording);
+  }
+
+  inline static PVR_ERROR ADDON_SetRecordingLifetime(const AddonInstance_PVR* instance,
+                                                     const PVR_RECORDING* recording)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->SetRecordingLifetime(recording);
+  }
+
+  inline static PVR_ERROR ADDON_SetRecordingPlayCount(const AddonInstance_PVR* instance,
+                                                      const PVR_RECORDING* recording,
+                                                      int count)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->SetRecordingPlayCount(recording, count);
+  }
+
+  inline static PVR_ERROR ADDON_SetRecordingLastPlayedPosition(const AddonInstance_PVR* instance,
+                                                               const PVR_RECORDING* recording,
+                                                               int lastplayedposition)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->SetRecordingLastPlayedPosition(recording, lastplayedposition);
+  }
+
+  inline static PVR_ERROR ADDON_GetRecordingLastPlayedPosition(const AddonInstance_PVR* instance,
+                                                               const PVR_RECORDING* recording,
+                                                               int* position)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetRecordingLastPlayedPosition(recording, *position);
+  }
+
+  inline static PVR_ERROR ADDON_GetRecordingEdl(const AddonInstance_PVR* instance,
+                                                const PVR_RECORDING* recording,
+                                                PVR_EDL_ENTRY* edl,
+                                                int* size)
+  {
+    *size = 0;
+    std::vector<PVREDLEntry> edlList;
+    PVR_ERROR error = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                          ->GetRecordingEdl(recording, edlList);
+    if (error == PVR_ERROR_NO_ERROR)
+    {
+      for (const auto& edlEntry : edlList)
+      {
+        edl[*size] = *edlEntry;
+        ++*size;
+      }
+    }
+    return error;
+  }
+
+  inline static PVR_ERROR ADDON_GetRecordingSize(const AddonInstance_PVR* instance,
+                                                 const PVR_RECORDING* recording,
+                                                 int64_t* size)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetRecordingSize(recording, *size);
+  }
+
+  inline static PVR_ERROR ADDON_GetRecordingStreamProperties(const AddonInstance_PVR* instance,
+                                                             const PVR_RECORDING* recording,
+                                                             PVR_NAMED_VALUE* properties,
+                                                             unsigned int* propertiesCount)
+  {
+    *propertiesCount = 0;
+    std::vector<PVRStreamProperty> propertiesList;
+    PVR_ERROR error = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                          ->GetRecordingStreamProperties(recording, propertiesList);
+    if (error == PVR_ERROR_NO_ERROR)
+    {
+      for (const auto& property : propertiesList)
+      {
+        strncpy(properties[*propertiesCount].strName, property.GetCStructure()->strName,
+                sizeof(properties[*propertiesCount].strName) - 1);
+        strncpy(properties[*propertiesCount].strValue, property.GetCStructure()->strValue,
+                sizeof(properties[*propertiesCount].strValue) - 1);
+        ++*propertiesCount;
+        if (*propertiesCount > STREAM_MAX_PROPERTY_COUNT)
+          break;
+      }
+    }
+    return error;
+  }
+
+  inline static PVR_ERROR ADDON_CallRecordingMenuHook(const AddonInstance_PVR* instance,
+                                                      const PVR_MENUHOOK* menuhook,
+                                                      const PVR_RECORDING* recording)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->CallRecordingMenuHook(menuhook, recording);
+  }
+
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+
+  inline static PVR_ERROR ADDON_GetTimerTypes(const AddonInstance_PVR* instance,
+                                              PVR_TIMER_TYPE* types,
+                                              int* typesCount)
+  {
+    *typesCount = 0;
+    std::vector<PVRTimerType> timerTypes;
+    PVR_ERROR error = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                          ->GetTimerTypes(timerTypes);
+    if (error == PVR_ERROR_NO_ERROR)
+    {
+      for (const auto& timerType : timerTypes)
+      {
+        types[*typesCount] = *timerType;
+        ++*typesCount;
+        if (*typesCount >= PVR_ADDON_TIMERTYPE_ARRAY_SIZE)
+          break;
+      }
+    }
+    return error;
+  }
+
+  inline static PVR_ERROR ADDON_GetTimersAmount(const AddonInstance_PVR* instance, int* amount)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetTimersAmount(*amount);
+  }
+
+  inline static PVR_ERROR ADDON_GetTimers(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
+  {
+    PVRTimersResultSet result(instance, handle);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->GetTimers(result);
+  }
+
+  inline static PVR_ERROR ADDON_AddTimer(const AddonInstance_PVR* instance, const PVR_TIMER* timer)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->AddTimer(timer);
+  }
+
+  inline static PVR_ERROR ADDON_DeleteTimer(const AddonInstance_PVR* instance,
+                                            const PVR_TIMER* timer,
+                                            bool forceDelete)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->DeleteTimer(timer, forceDelete);
+  }
+
+  inline static PVR_ERROR ADDON_UpdateTimer(const AddonInstance_PVR* instance,
+                                            const PVR_TIMER* timer)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->UpdateTimer(timer);
+  }
+
+  inline static PVR_ERROR ADDON_CallTimerMenuHook(const AddonInstance_PVR* instance,
+                                                  const PVR_MENUHOOK* menuhook,
+                                                  const PVR_TIMER* timer)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->CallTimerMenuHook(menuhook, timer);
+  }
+
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+  inline static PVR_ERROR ADDON_OnSystemSleep(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->OnSystemSleep();
+  }
+
+  inline static PVR_ERROR ADDON_OnSystemWake(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->OnSystemWake();
+  }
+
+  inline static PVR_ERROR ADDON_OnPowerSavingActivated(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->OnPowerSavingActivated();
+  }
+
+  inline static PVR_ERROR ADDON_OnPowerSavingDeactivated(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->OnPowerSavingDeactivated();
+  }
+
+  inline static bool ADDON_OpenLiveStream(const AddonInstance_PVR* instance,
+                                          const PVR_CHANNEL* channel)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->OpenLiveStream(channel);
+  }
+
+  inline static void ADDON_CloseLiveStream(const AddonInstance_PVR* instance)
+  {
+    static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->CloseLiveStream();
+  }
+
+  inline static int ADDON_ReadLiveStream(const AddonInstance_PVR* instance,
+                                         unsigned char* buffer,
+                                         unsigned int size)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->ReadLiveStream(buffer, size);
+  }
+
+  inline static int64_t ADDON_SeekLiveStream(const AddonInstance_PVR* instance,
+                                             int64_t position,
+                                             int whence)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->SeekLiveStream(position, whence);
+  }
+
+  inline static int64_t ADDON_LengthLiveStream(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->LengthLiveStream();
+  }
+
+  inline static PVR_ERROR ADDON_GetStreamProperties(const AddonInstance_PVR* instance,
+                                                    PVR_STREAM_PROPERTIES* properties)
+  {
+    properties->iStreamCount = 0;
+    std::vector<PVRStreamProperties> cppProperties;
+    PVR_ERROR err = static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+                        ->GetStreamProperties(cppProperties);
+    if (err == PVR_ERROR_NO_ERROR)
+    {
+      for (unsigned int i = 0; i < cppProperties.size(); ++i)
+      {
+        memcpy(&properties->stream[i],
+               static_cast<PVR_STREAM_PROPERTIES::PVR_STREAM*>(cppProperties[i]),
+               sizeof(PVR_STREAM_PROPERTIES::PVR_STREAM));
+        ++properties->iStreamCount;
+
+        if (properties->iStreamCount >= PVR_STREAM_MAX_STREAMS)
+        {
+          kodi::Log(
+              ADDON_LOG_ERROR,
+              "CInstancePVRClient::%s: Addon given with '%li' more allowed streams where '%i'",
+              __func__, cppProperties.size(), PVR_STREAM_MAX_STREAMS);
+          break;
+        }
+      }
+    }
+
+    return err;
+  }
+
+  inline static PVR_ERROR ADDON_GetStreamReadChunkSize(const AddonInstance_PVR* instance,
+                                                       int* chunksize)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetStreamReadChunkSize(*chunksize);
+  }
+
+  inline static bool ADDON_IsRealTimeStream(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->IsRealTimeStream();
+  }
+
+  inline static bool ADDON_OpenRecordedStream(const AddonInstance_PVR* instance,
+                                              const PVR_RECORDING* recording)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->OpenRecordedStream(recording);
+  }
+
+  inline static void ADDON_CloseRecordedStream(const AddonInstance_PVR* instance)
+  {
+    static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->CloseRecordedStream();
+  }
+
+  inline static int ADDON_ReadRecordedStream(const AddonInstance_PVR* instance,
+                                             unsigned char* buffer,
+                                             unsigned int size)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->ReadRecordedStream(buffer, size);
+  }
+
+  inline static int64_t ADDON_SeekRecordedStream(const AddonInstance_PVR* instance,
+                                                 int64_t position,
+                                                 int whence)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->SeekRecordedStream(position, whence);
+  }
+
+  inline static int64_t ADDON_LengthRecordedStream(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->LengthRecordedStream();
+  }
+
+  inline static void ADDON_DemuxReset(const AddonInstance_PVR* instance)
+  {
+    static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->DemuxReset();
+  }
+
+  inline static void ADDON_DemuxAbort(const AddonInstance_PVR* instance)
+  {
+    static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->DemuxAbort();
+  }
+
+  inline static void ADDON_DemuxFlush(const AddonInstance_PVR* instance)
+  {
+    static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->DemuxFlush();
+  }
+
+  inline static DemuxPacket* ADDON_DemuxRead(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->DemuxRead();
+  }
+
+  inline static bool ADDON_CanPauseStream(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->CanPauseStream();
+  }
+
+  inline static bool ADDON_CanSeekStream(const AddonInstance_PVR* instance)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->CanSeekStream();
+  }
+
+  inline static void ADDON_PauseStream(const AddonInstance_PVR* instance, bool bPaused)
+  {
+    static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->PauseStream(bPaused);
+  }
+
+  inline static bool ADDON_SeekTime(const AddonInstance_PVR* instance,
+                                    double time,
+                                    bool backwards,
+                                    double* startpts)
+  {
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->SeekTime(time, backwards, *startpts);
+  }
+
+  inline static void ADDON_SetSpeed(const AddonInstance_PVR* instance, int speed)
+  {
+    static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->SetSpeed(speed);
+  }
+
+  inline static void ADDON_FillBuffer(const AddonInstance_PVR* instance, bool mode)
+  {
+    static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)->FillBuffer(mode);
+  }
+
+  inline static PVR_ERROR ADDON_GetStreamTimes(const AddonInstance_PVR* instance,
+                                               PVR_STREAM_TIMES* times)
+  {
+    PVRStreamTimes cppTimes(times);
+    return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
+        ->GetStreamTimes(cppTimes);
+  }
+
+  AddonInstance_PVR* m_instanceData = nullptr;
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/CMakeLists.txt
new file mode 100644
index 000000000000..946849e9f4fb
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/CMakeLists.txt
@@ -0,0 +1,13 @@
+set(HEADERS ChannelGroups.h
+            Channels.h
+            EDL.h
+            EPG.h
+            General.h
+            MenuHook.h
+            Recordings.h
+            Stream.h
+            Timers.h)
+
+if(NOT ENABLE_STATIC_LIBS)
+  core_add_library(addons_kodi-addon-dev-kit_include_kodi_addon-instance_pvr)
+endif()
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/ChannelGroups.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/ChannelGroups.h
new file mode 100644
index 000000000000..b77ef01d2b0a
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/ChannelGroups.h
@@ -0,0 +1,119 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVRChannelGroup : public CStructHdl<PVRChannelGroup, PVR_CHANNEL_GROUP>
+{
+public:
+  PVRChannelGroup() { memset(m_cStructure, 0, sizeof(PVR_CHANNEL_GROUP)); }
+  PVRChannelGroup(const PVRChannelGroup& channel) : CStructHdl(channel) {}
+  PVRChannelGroup(const PVR_CHANNEL_GROUP* channel) : CStructHdl(channel) {}
+  PVRChannelGroup(PVR_CHANNEL_GROUP* channel) : CStructHdl(channel) {}
+
+  void SetGroupName(const std::string& groupName)
+  {
+    strncpy(m_cStructure->strGroupName, groupName.c_str(), sizeof(m_cStructure->strGroupName) - 1);
+  }
+  std::string GetGroupName() const { return m_cStructure->strGroupName; }
+
+  void SetIsRadio(bool isRadio) { m_cStructure->bIsRadio = isRadio; }
+  bool GetIsRadio() const { return m_cStructure->bIsRadio; }
+
+  void SetPosition(unsigned int position) { m_cStructure->iPosition = position; }
+  unsigned int GetPosition() const { return m_cStructure->iPosition; }
+};
+
+class PVRChannelGroupsResultSet
+{
+public:
+  PVRChannelGroupsResultSet() = delete;
+  PVRChannelGroupsResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
+    : m_instance(instance), m_handle(handle)
+  {
+  }
+
+  void Add(const kodi::addon::PVRChannelGroup& tag)
+  {
+    m_instance->toKodi->TransferChannelGroup(m_instance->toKodi->kodiInstance, m_handle, tag);
+  }
+
+private:
+  const AddonInstance_PVR* m_instance = nullptr;
+  const ADDON_HANDLE m_handle;
+};
+
+class PVRChannelGroupMember : public CStructHdl<PVRChannelGroupMember, PVR_CHANNEL_GROUP_MEMBER>
+{
+public:
+  PVRChannelGroupMember() { memset(m_cStructure, 0, sizeof(PVR_CHANNEL_GROUP_MEMBER)); }
+  PVRChannelGroupMember(const PVRChannelGroupMember& channel) : CStructHdl(channel) {}
+  PVRChannelGroupMember(const PVR_CHANNEL_GROUP_MEMBER* channel) : CStructHdl(channel) {}
+  PVRChannelGroupMember(PVR_CHANNEL_GROUP_MEMBER* channel) : CStructHdl(channel) {}
+
+  void SetGroupName(const std::string& groupName)
+  {
+    strncpy(m_cStructure->strGroupName, groupName.c_str(), sizeof(m_cStructure->strGroupName) - 1);
+  }
+  std::string GetGroupName() const { return m_cStructure->strGroupName; }
+
+  void SetChannelUniqueId(unsigned int channelUniqueId)
+  {
+    m_cStructure->iChannelUniqueId = channelUniqueId;
+  }
+  unsigned int GetChannelUniqueId() const { return m_cStructure->iChannelUniqueId; }
+
+  void SetChannelNumber(unsigned int channelNumber)
+  {
+    m_cStructure->iChannelNumber = channelNumber;
+  }
+  unsigned int GetChannelNumber() const { return m_cStructure->iChannelNumber; }
+
+  void SetSubChannelNumber(unsigned int subChannelNumber)
+  {
+    m_cStructure->iSubChannelNumber = subChannelNumber;
+  }
+  unsigned int GetSubChannelNumber() const { return m_cStructure->iSubChannelNumber; }
+
+  void SetOrder(bool order) { m_cStructure->iOrder = order; }
+  bool GetOrder() const { return m_cStructure->iOrder; }
+};
+
+class PVRChannelGroupMembersResultSet
+{
+public:
+  PVRChannelGroupMembersResultSet() = delete;
+  PVRChannelGroupMembersResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
+    : m_instance(instance), m_handle(handle)
+  {
+  }
+
+  void Add(const kodi::addon::PVRChannelGroupMember& tag)
+  {
+    m_instance->toKodi->TransferChannelGroupMember(m_instance->toKodi->kodiInstance, m_handle, tag);
+  }
+
+private:
+  const AddonInstance_PVR* m_instance = nullptr;
+  const ADDON_HANDLE m_handle;
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Channels.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Channels.h
new file mode 100644
index 000000000000..e284f2e7d5fb
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Channels.h
@@ -0,0 +1,215 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVRChannel : public CStructHdl<PVRChannel, PVR_CHANNEL>
+{
+public:
+  PVRChannel() { memset(m_cStructure, 0, sizeof(PVR_CHANNEL)); }
+  PVRChannel(const PVRChannel& channel) : CStructHdl(channel) {}
+  PVRChannel(const PVR_CHANNEL* channel) : CStructHdl(channel) {}
+  PVRChannel(PVR_CHANNEL* channel) : CStructHdl(channel) {}
+
+  void SetUniqueId(unsigned int uniqueId) { m_cStructure->iUniqueId = uniqueId; }
+  unsigned int GetUniqueId() const { return m_cStructure->iUniqueId; }
+
+  void SetIsRadio(bool isRadio) { m_cStructure->bIsRadio = isRadio; }
+  bool GetIsRadio() const { return m_cStructure->bIsRadio; }
+
+  void SetChannelNumber(unsigned int channelNumber)
+  {
+    m_cStructure->iChannelNumber = channelNumber;
+  }
+  unsigned int GetChannelNumber() const { return m_cStructure->iChannelNumber; }
+
+  void SetSubChannelNumber(unsigned int subChannelNumber)
+  {
+    m_cStructure->iSubChannelNumber = subChannelNumber;
+  }
+  unsigned int GetSubChannelNumber() const { return m_cStructure->iSubChannelNumber; }
+
+  void SetChannelName(const std::string& channelName)
+  {
+    strncpy(m_cStructure->strChannelName, channelName.c_str(),
+            sizeof(m_cStructure->strChannelName) - 1);
+  }
+  std::string GetChannelName() const { return m_cStructure->strChannelName; }
+
+  void SetMimeType(const std::string& inputFormat)
+  {
+    strncpy(m_cStructure->strMimeType, inputFormat.c_str(), sizeof(m_cStructure->strMimeType) - 1);
+  }
+  std::string GetMimeType() const { return m_cStructure->strMimeType; }
+
+  void SetEncryptionSystem(unsigned int encryptionSystem)
+  {
+    m_cStructure->iEncryptionSystem = encryptionSystem;
+  }
+  unsigned int GetEncryptionSystem() const { return m_cStructure->iEncryptionSystem; }
+
+  void SetIconPath(const std::string& iconPath)
+  {
+    strncpy(m_cStructure->strIconPath, iconPath.c_str(), sizeof(m_cStructure->strIconPath) - 1);
+  }
+  std::string GetIconPath() const { return m_cStructure->strIconPath; }
+
+  void SetIsHidden(bool isHidden) { m_cStructure->bIsHidden = isHidden; }
+  bool GetIsHidden() const { return m_cStructure->bIsHidden; }
+
+  void SetHasArchive(bool hasArchive) { m_cStructure->bHasArchive = hasArchive; }
+  bool GetHasArchive() const { return m_cStructure->bHasArchive; }
+
+  void SetOrder(bool order) { m_cStructure->iOrder = order; }
+  bool GetOrder() const { return m_cStructure->iOrder; }
+};
+
+class PVRChannelsResultSet
+{
+public:
+  PVRChannelsResultSet() = delete;
+  PVRChannelsResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
+    : m_instance(instance), m_handle(handle)
+  {
+  }
+
+  void Add(const kodi::addon::PVRChannel& tag)
+  {
+    m_instance->toKodi->TransferChannelEntry(m_instance->toKodi->kodiInstance, m_handle, tag);
+  }
+
+private:
+  const AddonInstance_PVR* m_instance = nullptr;
+  const ADDON_HANDLE m_handle;
+};
+
+class PVRSignalStatus : public CStructHdl<PVRSignalStatus, PVR_SIGNAL_STATUS>
+{
+public:
+  PVRSignalStatus() = default;
+  PVRSignalStatus(const PVRSignalStatus& type) : CStructHdl(type) {}
+  PVRSignalStatus(const PVR_SIGNAL_STATUS* type) : CStructHdl(type) {}
+  PVRSignalStatus(PVR_SIGNAL_STATUS* type) : CStructHdl(type) {}
+
+  void SetAdapterName(const std::string& adapterName)
+  {
+    strncpy(m_cStructure->strAdapterName, adapterName.c_str(),
+            sizeof(m_cStructure->strAdapterName) - 1);
+  }
+  std::string GetAdapterName() const { return m_cStructure->strAdapterName; }
+
+  void SetAdapterStatus(const std::string& adapterStatus)
+  {
+    strncpy(m_cStructure->strAdapterStatus, adapterStatus.c_str(),
+            sizeof(m_cStructure->strAdapterStatus) - 1);
+  }
+  std::string GetAdapterStatus() const { return m_cStructure->strAdapterStatus; }
+
+  void SetServiceName(const std::string& serviceName)
+  {
+    strncpy(m_cStructure->strServiceName, serviceName.c_str(),
+            sizeof(m_cStructure->strServiceName) - 1);
+  }
+  std::string GetServiceName() const { return m_cStructure->strServiceName; }
+
+  void SetProviderName(const std::string& providerName)
+  {
+    strncpy(m_cStructure->strProviderName, providerName.c_str(),
+            sizeof(m_cStructure->strProviderName) - 1);
+  }
+  std::string GetProviderName() const { return m_cStructure->strProviderName; }
+
+  void SetMuxName(const std::string& muxName)
+  {
+    strncpy(m_cStructure->strMuxName, muxName.c_str(), sizeof(m_cStructure->strMuxName) - 1);
+  }
+  std::string GetMuxName() const { return m_cStructure->strMuxName; }
+
+  void SetSNR(int snr) { m_cStructure->iSNR = snr; }
+  int GetSNR() const { return m_cStructure->iSNR; }
+
+  void SetSignal(int signal) { m_cStructure->iSignal = signal; }
+  int GetSignal() const { return m_cStructure->iSignal; }
+
+  void SetBER(long ber) { m_cStructure->iBER = ber; }
+  long GetBER() const { return m_cStructure->iBER; }
+
+  void SetUNC(long unc) { m_cStructure->iUNC = unc; }
+  long GetUNC() const { return m_cStructure->iUNC; }
+};
+
+class PVRDescrambleInfo : public CStructHdl<PVRDescrambleInfo, PVR_DESCRAMBLE_INFO>
+{
+public:
+  PVRDescrambleInfo()
+  {
+    m_cStructure->iPid = PVR_DESCRAMBLE_INFO_NOT_AVAILABLE;
+    m_cStructure->iCaid = PVR_DESCRAMBLE_INFO_NOT_AVAILABLE;
+    m_cStructure->iProvid = PVR_DESCRAMBLE_INFO_NOT_AVAILABLE;
+    m_cStructure->iEcmTime = PVR_DESCRAMBLE_INFO_NOT_AVAILABLE;
+    m_cStructure->iHops = PVR_DESCRAMBLE_INFO_NOT_AVAILABLE;
+  }
+  PVRDescrambleInfo(const PVRDescrambleInfo& type) : CStructHdl(type) {}
+  PVRDescrambleInfo(const PVR_DESCRAMBLE_INFO* type) : CStructHdl(type) {}
+  PVRDescrambleInfo(PVR_DESCRAMBLE_INFO* type) : CStructHdl(type) {}
+
+  void SetPID(int pid) { m_cStructure->iPid = pid; }
+  int GetPID() const { return m_cStructure->iPid; }
+
+  void SetCAID(int iCaid) { m_cStructure->iCaid = iCaid; }
+  int GetCAID() const { return m_cStructure->iCaid; }
+
+  void SetProviderID(int provid) { m_cStructure->iProvid = provid; }
+  int GetProviderID() const { return m_cStructure->iProvid; }
+
+  void SetECMTime(int ecmTime) { m_cStructure->iEcmTime = ecmTime; }
+  int GetECMTime() const { return m_cStructure->iEcmTime; }
+
+  void SetHops(int hops) { m_cStructure->iHops = hops; }
+  int GetHops() const { return m_cStructure->iHops; }
+
+  void SetCardSystem(const std::string& cardSystem)
+  {
+    strncpy(m_cStructure->strCardSystem, cardSystem.c_str(),
+            sizeof(m_cStructure->strCardSystem) - 1);
+  }
+  std::string GetCardSystem() const { return m_cStructure->strCardSystem; }
+
+  void SetReader(const std::string& reader)
+  {
+    strncpy(m_cStructure->strReader, reader.c_str(), sizeof(m_cStructure->strReader) - 1);
+  }
+  std::string GetReader() const { return m_cStructure->strReader; }
+
+  void SetFrom(const std::string& from)
+  {
+    strncpy(m_cStructure->strFrom, from.c_str(), sizeof(m_cStructure->strFrom) - 1);
+  }
+  std::string GetFrom() const { return m_cStructure->strFrom; }
+
+  void SetProtocol(const std::string& protocol)
+  {
+    strncpy(m_cStructure->strProtocol, protocol.c_str(), sizeof(m_cStructure->strProtocol) - 1);
+  }
+  std::string GetProtocol() const { return m_cStructure->strProtocol; }
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EDL.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EDL.h
new file mode 100644
index 000000000000..6ff9b1756b0c
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EDL.h
@@ -0,0 +1,42 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr/pvr_edl.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVREDLEntry : public CStructHdl<PVREDLEntry, PVR_EDL_ENTRY>
+{
+public:
+  PVREDLEntry() { memset(m_cStructure, 0, sizeof(PVR_EDL_ENTRY)); }
+  PVREDLEntry(const PVREDLEntry& type) : CStructHdl(type) {}
+  PVREDLEntry(const PVR_EDL_ENTRY* type) : CStructHdl(type) {}
+  PVREDLEntry(PVR_EDL_ENTRY* type) : CStructHdl(type) {}
+
+  void SetStart(int64_t start) { m_cStructure->start = start; }
+  int64_t GetStart() const { return m_cStructure->start; }
+
+  void SetEnd(int64_t end) { m_cStructure->end = end; }
+  int64_t GetEnd() const { return m_cStructure->end; }
+
+  void SetType(PVR_EDL_TYPE type) { m_cStructure->type = type; }
+  PVR_EDL_TYPE GetType() const { return m_cStructure->type; }
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EPG.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EPG.h
new file mode 100644
index 000000000000..6facd2ac5712
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EPG.h
@@ -0,0 +1,219 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVREPGTag : public CStructHdl<PVREPGTag, EPG_TAG>
+{
+public:
+  PVREPGTag()
+  {
+    memset(m_cStructure, 0, sizeof(EPG_TAG));
+    m_cStructure->iSeriesNumber = EPG_TAG_INVALID_SERIES_EPISODE;
+    m_cStructure->iEpisodeNumber = EPG_TAG_INVALID_SERIES_EPISODE;
+    m_cStructure->iEpisodePartNumber = EPG_TAG_INVALID_SERIES_EPISODE;
+  }
+  PVREPGTag(const PVREPGTag& epg) : CStructHdl(epg)
+  {
+    m_title = epg.m_title;
+    m_plotOutline = epg.m_plotOutline;
+    m_plot = epg.m_plot;
+    m_originalTitle = epg.m_originalTitle;
+    m_cast = epg.m_cast;
+    m_director = epg.m_director;
+    m_writer = epg.m_writer;
+    m_IMDBNumber = epg.m_IMDBNumber;
+    m_iconPath = epg.m_iconPath;
+    m_genreDescription = epg.m_genreDescription;
+    m_episodeName = epg.m_episodeName;
+    m_seriesLink = epg.m_seriesLink;
+    m_firstAired = epg.m_firstAired;
+  }
+  PVREPGTag(const EPG_TAG* epg) : CStructHdl(epg) { SetData(epg); }
+  PVREPGTag(EPG_TAG* epg) : CStructHdl(epg) { SetData(epg); }
+
+  void SetUniqueBroadcastId(unsigned int uniqueBroadcastId)
+  {
+    m_cStructure->iUniqueBroadcastId = uniqueBroadcastId;
+  }
+  unsigned int GetUniqueBroadcastId() const { return m_cStructure->iUniqueBroadcastId; }
+
+  void SetUniqueChannelId(unsigned int uniqueChannelId)
+  {
+    m_cStructure->iUniqueChannelId = uniqueChannelId;
+  }
+  unsigned int GetUniqueChannelId() const { return m_cStructure->iUniqueChannelId; }
+
+  void SetTitle(const std::string& title) { m_title = title; }
+  std::string GetTitle() const { return m_title; }
+
+  void SetStartTime(time_t startTime) { m_cStructure->startTime = startTime; }
+  time_t GetStartTime() const { return m_cStructure->startTime; }
+
+  void SetEndTime(time_t endTime) { m_cStructure->endTime = endTime; }
+  time_t GetEndTime() const { return m_cStructure->endTime; }
+
+  void SetPlotOutline(const std::string& plotOutline) { m_plotOutline = plotOutline; }
+  std::string GetPlotOutline() const { return m_plotOutline; }
+
+  void SetPlot(const std::string& plot) { m_plot = plot; }
+  std::string GetPlot() const { return m_plot; }
+
+  void SetOriginalTitle(const std::string& originalTitle) { m_originalTitle = originalTitle; }
+  std::string GetOriginalTitle() const { return m_originalTitle; }
+
+  void SetCast(const std::string& cast) { m_cast = cast; }
+  std::string GetCast() const { return m_cast; }
+
+  void SetDirector(const std::string& director) { m_director = director; }
+  std::string GetDirector() const { return m_director; }
+
+  void SetWriter(const std::string& writer) { m_writer = writer; }
+  std::string GetWriter() const { return m_writer; }
+
+  void SetYear(int year) { m_cStructure->iYear = year; }
+  int GetYear() const { return m_cStructure->iYear; }
+
+  void SetIMDBNumber(const std::string& IMDBNumber) { m_IMDBNumber = IMDBNumber; }
+  std::string GetIMDBNumber() const { return m_IMDBNumber; }
+
+  void SetIconPath(const std::string& iconPath) { m_iconPath = iconPath; }
+  std::string GetIconPath() const { return m_iconPath; }
+
+  void SetGenreType(int genreType) { m_cStructure->iGenreType = genreType; }
+  int GetGenreType() const { return m_cStructure->iGenreType; }
+
+  void SetGenreSubType(int genreSubType) { m_cStructure->iGenreSubType = genreSubType; }
+  int GetGenreSubType() const { return m_cStructure->iGenreSubType; }
+
+  void SetGenreDescription(const std::string& genreDescription)
+  {
+    m_genreDescription = genreDescription;
+  }
+  std::string GetGenreDescription() const { return m_genreDescription; }
+
+  void SetFirstAired(const std::string& firstAired) { m_firstAired = firstAired; }
+  std::string GetFirstAired() const { return m_firstAired; }
+
+  void SetParentalRating(int parentalRating) { m_cStructure->iParentalRating = parentalRating; }
+  int GetParentalRating() const { return m_cStructure->iParentalRating; }
+
+  void SetStarRating(int starRating) { m_cStructure->iStarRating = starRating; }
+  int GetStarRating() const { return m_cStructure->iStarRating; }
+
+  void SetSeriesNumber(int seriesNumber) { m_cStructure->iSeriesNumber = seriesNumber; }
+  int GetSeriesNumber() const { return m_cStructure->iSeriesNumber; }
+
+  void SetEpisodeNumber(int episodeNumber) { m_cStructure->iEpisodeNumber = episodeNumber; }
+  int GetEpisodeNumber() const { return m_cStructure->iEpisodeNumber; }
+
+  void SetEpisodePartNumber(int episodePartNumber)
+  {
+    m_cStructure->iEpisodePartNumber = episodePartNumber;
+  }
+  int GetEpisodePartNumber() const { return m_cStructure->iEpisodePartNumber; }
+
+  void SetEpisodeName(const std::string& episodeName) { m_episodeName = episodeName; }
+  std::string GetEpisodeName() const { return m_episodeName; }
+
+  void SetFlags(unsigned int flags) { m_cStructure->iFlags = flags; }
+  unsigned int GetFlags() const { return m_cStructure->iFlags; }
+
+  void SetSeriesLink(const std::string& seriesLink) { m_seriesLink = seriesLink; }
+  std::string GetSeriesLink() const { return m_seriesLink; }
+
+  EPG_TAG* GetTag() const
+  {
+    m_cStructure->strTitle = m_title.c_str();
+    m_cStructure->strPlotOutline = m_plotOutline.c_str();
+    m_cStructure->strPlot = m_plot.c_str();
+    m_cStructure->strOriginalTitle = m_originalTitle.c_str();
+    m_cStructure->strCast = m_cast.c_str();
+    m_cStructure->strDirector = m_director.c_str();
+    m_cStructure->strWriter = m_writer.c_str();
+    m_cStructure->strIMDBNumber = m_IMDBNumber.c_str();
+    m_cStructure->strIconPath = m_iconPath.c_str();
+    m_cStructure->strGenreDescription = m_genreDescription.c_str();
+    m_cStructure->strEpisodeName = m_episodeName.c_str();
+    m_cStructure->strSeriesLink = m_seriesLink.c_str();
+    m_cStructure->strFirstAired = m_firstAired.c_str();
+
+    return m_cStructure;
+  }
+
+private:
+  // prevent the use of them
+  const PVREPGTag& operator=(const PVREPGTag& right);
+  const PVREPGTag& operator=(const EPG_TAG& right);
+  operator EPG_TAG*();
+
+  std::string m_title;
+  std::string m_plotOutline;
+  std::string m_plot;
+  std::string m_originalTitle;
+  std::string m_cast;
+  std::string m_director;
+  std::string m_writer;
+  std::string m_IMDBNumber;
+  std::string m_episodeName;
+  std::string m_iconPath;
+  std::string m_seriesLink;
+  std::string m_genreDescription;
+  std::string m_firstAired;
+
+  void SetData(const EPG_TAG* tag)
+  {
+    m_title = tag->strTitle;
+    m_plotOutline = tag->strPlotOutline;
+    m_plot = tag->strPlot;
+    m_originalTitle = tag->strOriginalTitle;
+    m_cast = tag->strCast;
+    m_director = tag->strDirector;
+    m_writer = tag->strWriter;
+    m_IMDBNumber = tag->strIMDBNumber;
+    m_iconPath = tag->strIconPath;
+    m_genreDescription = tag->strGenreDescription;
+    m_episodeName = tag->strEpisodeName;
+    m_seriesLink = tag->strSeriesLink;
+    m_firstAired = tag->strFirstAired;
+  }
+};
+
+class PVREPGTagsResultSet
+{
+public:
+  PVREPGTagsResultSet() = delete;
+  PVREPGTagsResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
+    : m_instance(instance), m_handle(handle)
+  {
+  }
+
+  void Add(const kodi::addon::PVREPGTag& tag)
+  {
+    m_instance->toKodi->TransferEpgEntry(m_instance->toKodi->kodiInstance, m_handle, tag.GetTag());
+  }
+
+private:
+  const AddonInstance_PVR* m_instance = nullptr;
+  const ADDON_HANDLE m_handle;
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/General.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/General.h
new file mode 100644
index 000000000000..35f232422999
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/General.h
@@ -0,0 +1,224 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr/pvr_general.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVRTypeIntValue : public CStructHdl<PVRTypeIntValue, PVR_ATTRIBUTE_INT_VALUE>
+{
+public:
+  PVRTypeIntValue(const PVRTypeIntValue& data) : CStructHdl(data) {}
+  PVRTypeIntValue(const PVR_ATTRIBUTE_INT_VALUE* data) : CStructHdl(data) {}
+  PVRTypeIntValue(PVR_ATTRIBUTE_INT_VALUE* data) : CStructHdl(data) {}
+
+  PVRTypeIntValue() = default;
+  PVRTypeIntValue(int value, const std::string& description)
+  {
+    SetValue(value);
+    SetDescription(description);
+  }
+
+  void SetValue(int value) { m_cStructure->iValue = value; }
+
+  int GetValue() const { return m_cStructure->iValue; }
+
+  void SetDescription(const std::string& description)
+  {
+    strncpy(m_cStructure->strDescription, description.c_str(),
+            sizeof(m_cStructure->strDescription) - 1);
+  }
+
+  std::string GetDescription() const { return m_cStructure->strDescription; }
+};
+
+class PVRCapabilities
+{
+public:
+  explicit PVRCapabilities() = delete;
+  PVRCapabilities(PVR_ADDON_CAPABILITIES* capabilities) : m_capabilities(capabilities) {}
+
+  void SetSupportsEPG(bool supportsEPG) { m_capabilities->bSupportsEPG = supportsEPG; }
+  bool GetSupportsEPG() const { return m_capabilities->bSupportsEPG; }
+
+  void SetSupportsEPGEdl(bool supportsEPGEdl) { m_capabilities->bSupportsEPGEdl = supportsEPGEdl; }
+  bool GetSupportsEPGEdl() const { return m_capabilities->bSupportsEPGEdl; }
+
+  void SetSupportsTV(bool supportsTV) { m_capabilities->bSupportsTV = supportsTV; }
+  bool GetSupportsTV() const { return m_capabilities->bSupportsTV; }
+
+  void SetSupportsRadio(bool supportsRadio) { m_capabilities->bSupportsRadio = supportsRadio; }
+  bool GetSupportsRadio() const { return m_capabilities->bSupportsRadio; }
+
+  void SetSupportsRecordings(bool supportsRecordings)
+  {
+    m_capabilities->bSupportsRecordings = supportsRecordings;
+  }
+  bool GetSupportsRecordings() const { return m_capabilities->bSupportsRecordings; }
+
+  void SetSupportsRecordingsUndelete(bool supportsRecordingsUndelete)
+  {
+    m_capabilities->bSupportsRecordingsUndelete = supportsRecordingsUndelete;
+  }
+  bool GetSupportsRecordingsUndelete() const { return m_capabilities->bSupportsRecordingsUndelete; }
+
+  void SetSupportsTimers(bool supportsTimers) { m_capabilities->bSupportsTimers = supportsTimers; }
+  bool GetSupportsTimers() const { return m_capabilities->bSupportsTimers; }
+
+  void SetSupportsChannelGroups(bool supportsChannelGroups)
+  {
+    m_capabilities->bSupportsChannelGroups = supportsChannelGroups;
+  }
+  bool GetSupportsChannelGroups() const { return m_capabilities->bSupportsChannelGroups; }
+
+  void SetSupportsChannelScan(bool supportsChannelScan)
+  {
+    m_capabilities->bSupportsChannelScan = supportsChannelScan;
+  }
+  bool GetSupportsChannelScan() const { return m_capabilities->bSupportsChannelScan; }
+
+  void SetSupportsChannelSettings(bool supportsChannelSettings)
+  {
+    m_capabilities->bSupportsChannelSettings = supportsChannelSettings;
+  }
+  bool GetSupportsChannelSettings() const { return m_capabilities->bSupportsChannelSettings; }
+
+  void SetHandlesInputStream(bool handlesInputStream)
+  {
+    m_capabilities->bHandlesInputStream = handlesInputStream;
+  }
+  bool GetHandlesInputStream() const { return m_capabilities->bHandlesInputStream; }
+
+  void SetHandlesDemuxing(bool handlesDemuxing)
+  {
+    m_capabilities->bHandlesDemuxing = handlesDemuxing;
+  }
+  bool GetHandlesDemuxing() const { return m_capabilities->bHandlesDemuxing; }
+
+  void SetSupportsRecordingPlayCount(bool supportsRecordingPlayCount)
+  {
+    m_capabilities->bSupportsRecordingPlayCount = supportsRecordingPlayCount;
+  }
+  bool GetSupportsRecordingPlayCount() const { return m_capabilities->bSupportsRecordingPlayCount; }
+
+  void SetSupportsLastPlayedPosition(bool supportsLastPlayedPosition)
+  {
+    m_capabilities->bSupportsLastPlayedPosition = supportsLastPlayedPosition;
+  }
+  bool GetSupportsLastPlayedPosition() const { return m_capabilities->bSupportsLastPlayedPosition; }
+
+  void SetSupportsRecordingEdl(bool supportsRecordingEdl)
+  {
+    m_capabilities->bSupportsRecordingEdl = supportsRecordingEdl;
+  }
+  bool GetSupportsRecordingEdl() const { return m_capabilities->bSupportsRecordingEdl; }
+
+  void SetSupportsRecordingsRename(bool supportsRecordingsRename)
+  {
+    m_capabilities->bSupportsRecordingsRename = supportsRecordingsRename;
+  }
+  bool GetSupportsRecordingsRename() const { return m_capabilities->bSupportsRecordingsRename; }
+
+  void SetSupportsRecordingsLifetimeChange(bool supportsRecordingsLifetimeChange)
+  {
+    m_capabilities->bSupportsRecordingsLifetimeChange = supportsRecordingsLifetimeChange;
+  }
+  bool GetSupportsRecordingsLifetimeChange() const
+  {
+    return m_capabilities->bSupportsRecordingsLifetimeChange;
+  }
+
+  void SetSupportsDescrambleInfo(bool supportsDescrambleInfo)
+  {
+    m_capabilities->bSupportsDescrambleInfo = supportsDescrambleInfo;
+  }
+  bool GetSupportsDescrambleInfo() const { return m_capabilities->bSupportsDescrambleInfo; }
+
+  void SetSupportsAsyncEPGTransfer(bool supportsAsyncEPGTransfer)
+  {
+    m_capabilities->bSupportsAsyncEPGTransfer = supportsAsyncEPGTransfer;
+  }
+  bool GetSupportsAsyncEPGTransfer() const { return m_capabilities->bSupportsAsyncEPGTransfer; }
+
+  void SetSupportsRecordingSize(bool supportsRecordingSize)
+  {
+    m_capabilities->bSupportsRecordingSize = supportsRecordingSize;
+  }
+  bool GetSupportsRecordingSize() const { return m_capabilities->bSupportsRecordingSize; }
+
+  void SetRecordingsLifetimeValues(
+      const std::vector<PVRTypeIntValue>& recordingsLifetimeValues)
+  {
+    m_capabilities->iRecordingsLifetimesSize = 0;
+    for (unsigned int i = 0; i < recordingsLifetimeValues.size() &&
+                             i < sizeof(m_capabilities->recordingsLifetimeValues);
+         ++i)
+    {
+      m_capabilities->recordingsLifetimeValues[i].iValue =
+          recordingsLifetimeValues[i].GetCStructure()->iValue;
+      strncpy(m_capabilities->recordingsLifetimeValues[i].strDescription,
+              recordingsLifetimeValues[i].GetCStructure()->strDescription,
+              sizeof(m_capabilities->recordingsLifetimeValues[i].strDescription) - 1);
+      ++m_capabilities->iRecordingsLifetimesSize;
+    }
+  }
+  std::vector<PVRTypeIntValue> GetRecordingsLifetimeValues() const
+  {
+    std::vector<PVRTypeIntValue> recordingsLifetimeValues;
+    for (unsigned int i = 0; i < m_capabilities->iRecordingsLifetimesSize; ++i)
+      recordingsLifetimeValues.emplace_back(
+          m_capabilities->recordingsLifetimeValues[i].iValue,
+          m_capabilities->recordingsLifetimeValues[i].strDescription);
+    return recordingsLifetimeValues;
+  }
+
+private:
+  PVR_ADDON_CAPABILITIES* m_capabilities;
+};
+
+class PVRStreamProperty : public CStructHdl<PVRStreamProperty, PVR_NAMED_VALUE>
+{
+public:
+  PVRStreamProperty(const PVRStreamProperty& data) : CStructHdl(data) {}
+  PVRStreamProperty(const PVR_NAMED_VALUE* data) : CStructHdl(data) {}
+  PVRStreamProperty(PVR_NAMED_VALUE* data) : CStructHdl(data) {}
+
+  PVRStreamProperty() = default;
+  PVRStreamProperty(const std::string& name, const std::string& value)
+  {
+    SetName(name);
+    SetValue(value);
+  }
+
+  void SetName(const std::string& name)
+  {
+    strncpy(m_cStructure->strName, name.c_str(), sizeof(m_cStructure->strName) - 1);
+  }
+
+  std::string GetName() const { return m_cStructure->strName; }
+
+  void SetValue(const std::string& value)
+  {
+    strncpy(m_cStructure->strValue, value.c_str(), sizeof(m_cStructure->strValue) - 1);
+  }
+
+  std::string GetValue() const { return m_cStructure->strValue; }
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/MenuHook.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/MenuHook.h
new file mode 100644
index 000000000000..00fbd1559379
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/MenuHook.h
@@ -0,0 +1,57 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr/pvr_menu_hook.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVRMenuhook : public CStructHdl<PVRMenuhook, PVR_MENUHOOK>
+{
+public:
+  PVRMenuhook(unsigned int hookId, unsigned int localizedStringId, PVR_MENUHOOK_CAT category)
+  {
+    m_cStructure->iHookId = hookId;
+    m_cStructure->iLocalizedStringId = localizedStringId;
+    m_cStructure->category = category;
+  }
+
+  PVRMenuhook()
+  {
+    m_cStructure->iHookId = 0;
+    m_cStructure->iLocalizedStringId = 0;
+    m_cStructure->category = PVR_MENUHOOK_UNKNOWN;
+  }
+  PVRMenuhook(const PVRMenuhook& data) : CStructHdl(data) {}
+  PVRMenuhook(const PVR_MENUHOOK* data) : CStructHdl(data) {}
+  PVRMenuhook(PVR_MENUHOOK* data) : CStructHdl(data) {}
+
+  void SetHookId(unsigned int hookId) { m_cStructure->iHookId = hookId; }
+  unsigned int GetHookId() const { return m_cStructure->iHookId; }
+
+  void SetLocalizedStringId(unsigned int localizedStringId)
+  {
+    m_cStructure->iLocalizedStringId = localizedStringId;
+  }
+  unsigned int GetLocalizedStringId() const { return m_cStructure->iLocalizedStringId; }
+
+  void SetCategory(PVR_MENUHOOK_CAT category) { m_cStructure->category = category; }
+  PVR_MENUHOOK_CAT GetCategory() const { return m_cStructure->category; }
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
new file mode 100644
index 000000000000..151ec2a19f67
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
@@ -0,0 +1,207 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVRRecording : public CStructHdl<PVRRecording, PVR_RECORDING>
+{
+public:
+  PVRRecording()
+  {
+    m_cStructure->iSeriesNumber = PVR_RECORDING_INVALID_SERIES_EPISODE;
+    m_cStructure->iEpisodeNumber = PVR_RECORDING_INVALID_SERIES_EPISODE;
+    m_cStructure->recordingTime = 0;
+    m_cStructure->iDuration = -1;
+    m_cStructure->iPriority = -1;
+    m_cStructure->iLifetime = -1;
+    m_cStructure->iGenreType = -1;
+    m_cStructure->iGenreSubType = -1;
+    m_cStructure->iPlayCount = -1;
+    m_cStructure->iLastPlayedPosition = -1;
+    m_cStructure->bIsDeleted = false;
+    m_cStructure->iEpgEventId = 0;
+    m_cStructure->iChannelUid = -1;
+    m_cStructure->channelType = PVR_RECORDING_CHANNEL_TYPE_UNKNOWN;
+    m_cStructure->iFlags = 0;
+    m_cStructure->sizeInBytes = -1;
+  }
+  PVRRecording(const PVRRecording& recording) : CStructHdl(recording) {}
+  PVRRecording(const PVR_RECORDING* recording) : CStructHdl(recording) {}
+  PVRRecording(PVR_RECORDING* recording) : CStructHdl(recording) {}
+
+  void SetRecordingId(const std::string& recordingId)
+  {
+    strncpy(m_cStructure->strRecordingId, recordingId.c_str(),
+            sizeof(m_cStructure->strRecordingId) - 1);
+  }
+  std::string GetRecordingId() const { return m_cStructure->strRecordingId; }
+
+  void SetTitle(const std::string& title)
+  {
+    strncpy(m_cStructure->strTitle, title.c_str(), sizeof(m_cStructure->strTitle) - 1);
+  }
+  std::string GetTitle() const { return m_cStructure->strTitle; }
+
+  void SetEpisodeName(const std::string& episodeName)
+  {
+    strncpy(m_cStructure->strEpisodeName, episodeName.c_str(),
+            sizeof(m_cStructure->strEpisodeName) - 1);
+  }
+  std::string GetEpisodeName() const { return m_cStructure->strEpisodeName; }
+
+  void SetSeriesNumber(int seriesNumber) { m_cStructure->iSeriesNumber = seriesNumber; }
+  int GetSeriesNumber() const { return m_cStructure->iSeriesNumber; }
+
+  void SetEpisodeNumber(int episodeNumber) { m_cStructure->iEpisodeNumber = episodeNumber; }
+  int GetEpisodeNumber() const { return m_cStructure->iEpisodeNumber; }
+
+  void SetYear(int year) { m_cStructure->iYear = year; }
+  int GetYear() const { return m_cStructure->iYear; }
+
+  void SetDirectory(const std::string& directory)
+  {
+    strncpy(m_cStructure->strDirectory, directory.c_str(), sizeof(m_cStructure->strDirectory) - 1);
+  }
+  std::string GetDirectory() const { return m_cStructure->strDirectory; }
+
+  void SetPlotOutline(const std::string& plotOutline)
+  {
+    strncpy(m_cStructure->strPlotOutline, plotOutline.c_str(),
+            sizeof(m_cStructure->strPlotOutline) - 1);
+  }
+  std::string GetPlotOutline() const { return m_cStructure->strPlotOutline; }
+
+  void SetPlot(const std::string& plot)
+  {
+    strncpy(m_cStructure->strPlot, plot.c_str(), sizeof(m_cStructure->strPlot) - 1);
+  }
+  std::string GetPlot() const { return m_cStructure->strPlot; }
+
+  void SetChannelName(const std::string& channelName)
+  {
+    strncpy(m_cStructure->strChannelName, channelName.c_str(),
+            sizeof(m_cStructure->strChannelName) - 1);
+  }
+  std::string GetChannelName() const { return m_cStructure->strChannelName; }
+
+  void SetIconPath(const std::string& iconPath)
+  {
+    strncpy(m_cStructure->strIconPath, iconPath.c_str(), sizeof(m_cStructure->strIconPath) - 1);
+  }
+  std::string GetIconPath() const { return m_cStructure->strIconPath; }
+
+  void SetThumbnailPath(const std::string& thumbnailPath)
+  {
+    strncpy(m_cStructure->strThumbnailPath, thumbnailPath.c_str(),
+            sizeof(m_cStructure->strThumbnailPath) - 1);
+  }
+  std::string GetThumbnailPath() const { return m_cStructure->strThumbnailPath; }
+
+  void SetFanartPath(const std::string& fanartPath)
+  {
+    strncpy(m_cStructure->strFanartPath, fanartPath.c_str(),
+            sizeof(m_cStructure->strFanartPath) - 1);
+  }
+  std::string GetFanartPath() const { return m_cStructure->strFanartPath; }
+
+  void SetRecordingTime(time_t recordingTime) { m_cStructure->recordingTime = recordingTime; }
+  time_t GetRecordingTime() const { return m_cStructure->recordingTime; }
+
+  void SetDuration(int duration) { m_cStructure->iDuration = duration; }
+  int GetDuration() const { return m_cStructure->iDuration; }
+
+  void SetPriority(int priority) { m_cStructure->iPriority = priority; }
+  int GetPriority() const { return m_cStructure->iPriority; }
+
+  void SetLifetime(int lifetime) { m_cStructure->iLifetime = lifetime; }
+  int GetLifetime() const { return m_cStructure->iLifetime; }
+
+  void SetGenreType(int genreType) { m_cStructure->iGenreType = genreType; }
+  int GetGenreType() const { return m_cStructure->iGenreType; }
+
+  void SetGenreSubType(int genreSubType) { m_cStructure->iGenreSubType = genreSubType; }
+  int GetGenreSubType() const { return m_cStructure->iGenreSubType; }
+
+  void SetGenreDescription(const std::string& genreDescription)
+  {
+    strncpy(m_cStructure->strGenreDescription, genreDescription.c_str(),
+            sizeof(m_cStructure->strGenreDescription) - 1);
+  }
+  std::string GetGenreDescription() const { return m_cStructure->strGenreDescription; }
+
+  void SetPlayCount(int playCount) { m_cStructure->iPlayCount = playCount; }
+  int GetPlayCount() const { return m_cStructure->iPlayCount; }
+
+  void SetLastPlayedPosition(int lastPlayedPosition)
+  {
+    m_cStructure->iLastPlayedPosition = lastPlayedPosition;
+  }
+  int GetLastPlayedPosition() const { return m_cStructure->iLastPlayedPosition; }
+
+  void SetIsDeleted(int isDeleted) { m_cStructure->bIsDeleted = isDeleted; }
+  int GetIsDeleted() const { return m_cStructure->bIsDeleted; }
+
+  void SetEPGEventId(unsigned int epgEventId) { m_cStructure->iEpgEventId = epgEventId; }
+  unsigned int GetEPGEventId() const { return m_cStructure->iEpgEventId; }
+
+  void SetChannelUid(int channelUid) { m_cStructure->iChannelUid = channelUid; }
+  int GetChannelUid() const { return m_cStructure->iChannelUid; }
+
+  void SetChannelType(PVR_RECORDING_CHANNEL_TYPE channelType)
+  {
+    m_cStructure->channelType = channelType;
+  }
+  PVR_RECORDING_CHANNEL_TYPE GetChannelType() const { return m_cStructure->channelType; }
+
+  void SetFirstAired(const std::string& firstAired)
+  {
+    strncpy(m_cStructure->strFirstAired, firstAired.c_str(),
+            sizeof(m_cStructure->strFirstAired) - 1);
+  }
+  std::string GetFirstAired() const { return m_cStructure->strFirstAired; }
+
+  void SetFlags(unsigned int flags) { m_cStructure->iFlags = flags; }
+  unsigned int GetFlags() const { return m_cStructure->iFlags; }
+
+  void SetSizeInBytes(int64_t sizeInBytes) { m_cStructure->sizeInBytes = sizeInBytes; }
+  int64_t GetSizeInBytes() const { return m_cStructure->sizeInBytes; }
+};
+
+class PVRRecordingsResultSet
+{
+public:
+  PVRRecordingsResultSet() = delete;
+  PVRRecordingsResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
+    : m_instance(instance), m_handle(handle)
+  {
+  }
+
+  void Add(const kodi::addon::PVRRecording& tag)
+  {
+    m_instance->toKodi->TransferRecordingEntry(m_instance->toKodi->kodiInstance, m_handle, tag);
+  }
+
+private:
+  const AddonInstance_PVR* m_instance = nullptr;
+  const ADDON_HANDLE m_handle;
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Stream.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Stream.h
new file mode 100644
index 000000000000..81cef4f91f79
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Stream.h
@@ -0,0 +1,133 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr/pvr_stream.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVRCodec : public CStructHdl<PVRCodec, PVR_CODEC>
+{
+public:
+  PVRCodec()
+  {
+    m_cStructure->codec_type = PVR_CODEC_TYPE_UNKNOWN;
+    m_cStructure->codec_id = PVR_INVALID_CODEC_ID;
+  }
+  PVRCodec(const PVRCodec& type) : CStructHdl(type) {}
+  PVRCodec(const PVR_CODEC& type) : CStructHdl(&type) {}
+  PVRCodec(const PVR_CODEC* type) : CStructHdl(type) {}
+  PVRCodec(PVR_CODEC* type) : CStructHdl(type) {}
+
+  void SetCodecType(PVR_CODEC_TYPE codecType) { m_cStructure->codec_type = codecType; }
+  PVR_CODEC_TYPE GetCodecType() const { return m_cStructure->codec_type; }
+
+  void SetCodecId(unsigned int codecId) { m_cStructure->codec_id = codecId; }
+  unsigned int GetCodecId() const { return m_cStructure->codec_id; }
+};
+
+class PVRStreamProperties
+  : public CStructHdl<PVRStreamProperties, PVR_STREAM_PROPERTIES::PVR_STREAM>
+{
+public:
+  PVRStreamProperties() { memset(m_cStructure, 0, sizeof(PVR_STREAM_PROPERTIES::PVR_STREAM)); }
+  PVRStreamProperties(const PVRStreamProperties& type) : CStructHdl(type) {}
+  PVRStreamProperties(const PVR_STREAM_PROPERTIES::PVR_STREAM* type) : CStructHdl(type) {}
+  PVRStreamProperties(PVR_STREAM_PROPERTIES::PVR_STREAM* type) : CStructHdl(type) {}
+
+  void SetPID(unsigned int pid) { m_cStructure->iPID = pid; }
+  unsigned int GetPID() const { return m_cStructure->iPID; }
+
+  void SetCodecType(PVR_CODEC_TYPE codecType) { m_cStructure->iCodecType = codecType; }
+  PVR_CODEC_TYPE GetCodecType() const { return m_cStructure->iCodecType; }
+
+  void SetCodecId(unsigned int codecId) { m_cStructure->iCodecId = codecId; }
+  unsigned int GetCodecId() const { return m_cStructure->iCodecId; }
+
+  void SetLanguage(const std::string& language)
+  {
+    if (language.size() > 3)
+    {
+      kodi::Log(ADDON_LOG_ERROR,
+                "PVRStreamProperties::%s: Language string size '%li' higher as needed 3", __func__,
+                language.size());
+      return;
+    }
+    m_cStructure->strLanguage[0] = language[0];
+    m_cStructure->strLanguage[1] = language[1];
+    m_cStructure->strLanguage[2] = language[2];
+    m_cStructure->strLanguage[2] = 0;
+  }
+  std::string GetLanguage() const { return m_cStructure->strLanguage; }
+
+  void SetSubtitleInfo(int subtitleInfo) { m_cStructure->iSubtitleInfo = subtitleInfo; }
+  int GetSubtitleInfo() const { return m_cStructure->iSubtitleInfo; }
+
+  void SetFPSScale(int fpsScale) { m_cStructure->iFPSScale = fpsScale; }
+  int GetFPSScale() const { return m_cStructure->iFPSScale; }
+
+  void SetFPSRate(int fpsRate) { m_cStructure->iFPSRate = fpsRate; }
+  int GetFPSRate() const { return m_cStructure->iFPSRate; }
+
+  void SetHeight(int height) { m_cStructure->iHeight = height; }
+  int GetHeight() const { return m_cStructure->iHeight; }
+
+  void SetWidth(int width) { m_cStructure->iWidth = width; }
+  int GetWidth() const { return m_cStructure->iWidth; }
+
+  void SetAspect(float aspect) { m_cStructure->fAspect = aspect; }
+  float GetAspect() const { return m_cStructure->fAspect; }
+
+  void SetChannels(int channels) { m_cStructure->iChannels = channels; }
+  int GetChannels() const { return m_cStructure->iChannels; }
+
+  void SetSampleRate(int sampleRate) { m_cStructure->iSampleRate = sampleRate; }
+  int GetSampleRate() const { return m_cStructure->iSampleRate; }
+
+  void SetBlockAlign(int blockAlign) { m_cStructure->iBlockAlign = blockAlign; }
+  int GetBlockAlign() const { return m_cStructure->iBlockAlign; }
+
+  void SetBitRate(int bitRate) { m_cStructure->iBitRate = bitRate; }
+  int GetBitRate() const { return m_cStructure->iBitRate; }
+
+  void SetBitsPerSample(int bitsPerSample) { m_cStructure->iBitsPerSample = bitsPerSample; }
+  int GetBitsPerSample() const { return m_cStructure->iBitsPerSample; }
+};
+
+class PVRStreamTimes : public CStructHdl<PVRStreamTimes, PVR_STREAM_TIMES>
+{
+public:
+  PVRStreamTimes() { memset(m_cStructure, 0, sizeof(PVR_STREAM_TIMES)); }
+  PVRStreamTimes(const PVRStreamTimes& type) : CStructHdl(type) {}
+  PVRStreamTimes(const PVR_STREAM_TIMES* type) : CStructHdl(type) {}
+  PVRStreamTimes(PVR_STREAM_TIMES* type) : CStructHdl(type) {}
+
+  void SetStartTime(time_t startTime) { m_cStructure->startTime = startTime; }
+  time_t GetStartTime() const { return m_cStructure->startTime; }
+
+  void SetPTSStart(int64_t ptsStart) { m_cStructure->ptsStart = ptsStart; }
+  int64_t GetPTSStart() const { return m_cStructure->ptsStart; }
+
+  void SetPTSBegin(int64_t ptsBegin) { m_cStructure->ptsBegin = ptsBegin; }
+  int64_t GetPTSBegin() const { return m_cStructure->ptsBegin; }
+
+  void SetPTSEnd(int64_t ptsEnd) { m_cStructure->ptsEnd = ptsEnd; }
+  int64_t GetPTSEnd() const { return m_cStructure->ptsEnd; }
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h
new file mode 100644
index 000000000000..b5ca8d19b843
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h
@@ -0,0 +1,381 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "General.h"
+#include "../../AddonBase.h"
+#include "../../c-api/addon-instance/pvr.h"
+
+#ifdef __cplusplus
+
+namespace kodi
+{
+namespace addon
+{
+
+class PVRTimer : public CStructHdl<PVRTimer, PVR_TIMER>
+{
+public:
+  PVRTimer()
+  {
+    m_cStructure->iClientIndex = 0;
+    m_cStructure->state = PVR_TIMER_STATE_NEW;
+    m_cStructure->iTimerType = PVR_TIMER_TYPE_NONE;
+    m_cStructure->iParentClientIndex = 0;
+    m_cStructure->iClientChannelUid = -1;
+    m_cStructure->startTime = 0;
+    m_cStructure->endTime = 0;
+    m_cStructure->bStartAnyTime = false;
+    m_cStructure->bEndAnyTime = false;
+    m_cStructure->bFullTextEpgSearch = false;
+    m_cStructure->iPriority = -1;
+    m_cStructure->iLifetime = -1;
+    m_cStructure->iMaxRecordings = -1;
+    m_cStructure->iRecordingGroup = 0;
+    m_cStructure->firstDay = 0;
+    m_cStructure->iWeekdays = PVR_WEEKDAY_NONE;
+    m_cStructure->iPreventDuplicateEpisodes = 0;
+    m_cStructure->iEpgUid = 0;
+    m_cStructure->iMarginStart = 0;
+    m_cStructure->iMarginEnd = 0;
+    m_cStructure->iGenreType = -1;
+    m_cStructure->iGenreSubType = -1;
+  }
+  PVRTimer(const PVRTimer& data) : CStructHdl(data) {}
+  PVRTimer(const PVR_TIMER* data) : CStructHdl(data) {}
+  PVRTimer(PVR_TIMER* data) : CStructHdl(data) {}
+
+  void SetClientIndex(unsigned int clientIndex) { m_cStructure->iClientIndex = clientIndex; }
+  unsigned int GetClientIndex() const { return m_cStructure->iClientIndex; }
+
+  void SetState(PVR_TIMER_STATE state) { m_cStructure->state = state; }
+  PVR_TIMER_STATE GetState() const { return m_cStructure->state; }
+
+  void SetTimerType(unsigned int timerType) { m_cStructure->iTimerType = timerType; }
+  unsigned int GetTimerType() const { return m_cStructure->iTimerType; }
+
+  void SetTitle(const std::string& title)
+  {
+    strncpy(m_cStructure->strTitle, title.c_str(), sizeof(m_cStructure->strTitle) - 1);
+  }
+  std::string GetTitle() const { return m_cStructure->strTitle; }
+
+  void SetParentClientIndex(unsigned int parentClientIndex)
+  {
+    m_cStructure->iParentClientIndex = parentClientIndex;
+  }
+  unsigned int GetParentClientIndex() const { return m_cStructure->iParentClientIndex; }
+
+  void SetClientChannelUid(int clientChannelUid)
+  {
+    m_cStructure->iClientChannelUid = clientChannelUid;
+  }
+  int GetClientChannelUid() const { return m_cStructure->iClientChannelUid; }
+
+  void SetStartTime(time_t startTime) { m_cStructure->startTime = startTime; }
+  time_t GetStartTime() const { return m_cStructure->startTime; }
+
+  void SetEndTime(time_t endTime) { m_cStructure->endTime = endTime; }
+  time_t GetEndTime() const { return m_cStructure->endTime; }
+
+  void SetStartAnyTime(bool startAnyTime) { m_cStructure->bStartAnyTime = startAnyTime; }
+  bool GetStartAnyTime() const { return m_cStructure->bStartAnyTime; }
+
+  void SetEndAnyTime(bool endAnyTime) { m_cStructure->bEndAnyTime = endAnyTime; }
+  bool GetEndAnyTime() const { return m_cStructure->bEndAnyTime; }
+
+  void SetEPGSearchString(const std::string& epgSearchString)
+  {
+    strncpy(m_cStructure->strEpgSearchString, epgSearchString.c_str(),
+            sizeof(m_cStructure->strEpgSearchString) - 1);
+  }
+  std::string GetEPGSearchString() const { return m_cStructure->strEpgSearchString; }
+
+  void SetFullTextEpgSearch(bool fullTextEpgSearch)
+  {
+    m_cStructure->bFullTextEpgSearch = fullTextEpgSearch;
+  }
+  bool GetFullTextEpgSearch() const { return m_cStructure->bFullTextEpgSearch; }
+
+  void SetDirectory(const std::string& directory)
+  {
+    strncpy(m_cStructure->strDirectory, directory.c_str(), sizeof(m_cStructure->strDirectory) - 1);
+  }
+  std::string GetDirectory() const { return m_cStructure->strDirectory; }
+
+  void SetSummary(const std::string& summary)
+  {
+    strncpy(m_cStructure->strSummary, summary.c_str(), sizeof(m_cStructure->strSummary) - 1);
+  }
+  std::string GetSummary() const { return m_cStructure->strSummary; }
+
+  void SetPriority(int priority) { m_cStructure->iPriority = priority; }
+  int GetPriority() const { return m_cStructure->iPriority; }
+
+  void SetLifetime(int priority) { m_cStructure->iLifetime = priority; }
+  int GetLifetime() const { return m_cStructure->iLifetime; }
+
+  void SetMaxRecordings(int maxRecordings) { m_cStructure->iMaxRecordings = maxRecordings; }
+  int GetMaxRecordings() const { return m_cStructure->iMaxRecordings; }
+
+  void SetRecordingGroup(unsigned int recordingGroup)
+  {
+    m_cStructure->iRecordingGroup = recordingGroup;
+  }
+  unsigned int GetRecordingGroup() const { return m_cStructure->iRecordingGroup; }
+
+  void SetFirstDay(time_t firstDay) { m_cStructure->firstDay = firstDay; }
+  time_t GetFirstDay() const { return m_cStructure->firstDay; }
+
+  void SetWeekdays(unsigned int weekdays) { m_cStructure->iWeekdays = weekdays; }
+  unsigned int GetWeekdays() const { return m_cStructure->iWeekdays; }
+
+  void SetPreventDuplicateEpisodes(unsigned int preventDuplicateEpisodes)
+  {
+    m_cStructure->iPreventDuplicateEpisodes = preventDuplicateEpisodes;
+  }
+  unsigned int GetPreventDuplicateEpisodes() const
+  {
+    return m_cStructure->iPreventDuplicateEpisodes;
+  }
+
+  void SetEPGUid(unsigned int epgUid) { m_cStructure->iEpgUid = epgUid; }
+  unsigned int GetEPGUid() const { return m_cStructure->iEpgUid; }
+
+  void SetMarginStart(unsigned int marginStart) { m_cStructure->iMarginStart = marginStart; }
+  unsigned int GetMarginStart() const { return m_cStructure->iMarginStart; }
+
+  void SetMarginEnd(unsigned int marginEnd) { m_cStructure->iMarginEnd = marginEnd; }
+  unsigned int GetMarginEnd() const { return m_cStructure->iMarginEnd; }
+
+  void SetGenreType(int genreType) { m_cStructure->iGenreType = genreType; }
+  int GetGenreType() const { return m_cStructure->iGenreType; }
+
+  void SetGenreSubType(int genreSubType) { m_cStructure->iGenreSubType = genreSubType; }
+  int GetGenreSubType() const { return m_cStructure->iGenreSubType; }
+
+  void SetSeriesLink(const std::string& seriesLink)
+  {
+    strncpy(m_cStructure->strSeriesLink, seriesLink.c_str(),
+            sizeof(m_cStructure->strSeriesLink) - 1);
+  }
+
+  std::string GetSeriesLink() const { return m_cStructure->strSeriesLink; }
+};
+
+class PVRTimersResultSet
+{
+public:
+  PVRTimersResultSet() = delete;
+  PVRTimersResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
+    : m_instance(instance), m_handle(handle)
+  {
+  }
+
+  void Add(const kodi::addon::PVRTimer& tag)
+  {
+    m_instance->toKodi->TransferTimerEntry(m_instance->toKodi->kodiInstance, m_handle, tag);
+  }
+
+private:
+  const AddonInstance_PVR* m_instance = nullptr;
+  const ADDON_HANDLE m_handle;
+};
+
+class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
+{
+public:
+  PVRTimerType()
+  {
+    memset(m_cStructure, 0, sizeof(PVR_TIMER_TYPE));
+    m_cStructure->iPrioritiesDefault = -1;
+    m_cStructure->iLifetimesDefault = -1;
+    m_cStructure->iPreventDuplicateEpisodesDefault = -1;
+    m_cStructure->iRecordingGroupDefault = -1;
+    m_cStructure->iMaxRecordingsDefault = -1;
+  }
+  PVRTimerType(const PVRTimerType& type) : CStructHdl(type) {}
+  PVRTimerType(const PVR_TIMER_TYPE* type) : CStructHdl(type) {}
+  PVRTimerType(PVR_TIMER_TYPE* type) : CStructHdl(type) {}
+
+  void SetId(unsigned int id) { m_cStructure->iId = id; }
+  unsigned int GetId() const { return m_cStructure->iId; }
+
+  void SetAttributes(uint64_t attributes) { m_cStructure->iAttributes = attributes; }
+  uint64_t GetAttributes() const { return m_cStructure->iAttributes; }
+
+  void SetDescription(const std::string& description)
+  {
+    strncpy(m_cStructure->strDescription, description.c_str(),
+            sizeof(m_cStructure->strDescription) - 1);
+  }
+  std::string GetDescription() const { return m_cStructure->strDescription; }
+
+  void SetPriorities(const std::vector<PVRTypeIntValue>& priorities,
+                     int prioritiesDefault = -1)
+  {
+    m_cStructure->iPrioritiesSize = priorities.size();
+    for (unsigned int i = 0;
+         i < m_cStructure->iPrioritiesSize && i < sizeof(m_cStructure->priorities); ++i)
+    {
+      m_cStructure->priorities[i].iValue = priorities[i].GetCStructure()->iValue;
+      strncpy(m_cStructure->priorities[i].strDescription,
+              priorities[i].GetCStructure()->strDescription,
+              sizeof(m_cStructure->priorities[i].strDescription) - 1);
+    }
+    if (prioritiesDefault != -1)
+      m_cStructure->iPrioritiesDefault = prioritiesDefault;
+  }
+  std::vector<PVRTypeIntValue> GetPriorities() const
+  {
+    std::vector<PVRTypeIntValue> ret;
+    for (unsigned int i = 0; i < m_cStructure->iPrioritiesSize; ++i)
+      ret.emplace_back(m_cStructure->priorities[i].iValue,
+                       m_cStructure->priorities[i].strDescription);
+    return ret;
+  }
+
+  void SetPrioritiesDefault(int prioritiesDefault)
+  {
+    m_cStructure->iPrioritiesDefault = prioritiesDefault;
+  }
+
+  /// @brief To get with @ref SetPrioritiesDefault changed values.
+  int GetPrioritiesDefault() const { return m_cStructure->iPrioritiesDefault; }
+
+  void SetLifetimes(const std::vector<PVRTypeIntValue>& lifetimes, int lifetimesDefault = -1)
+  {
+    m_cStructure->iLifetimesSize = lifetimes.size();
+    for (unsigned int i = 0;
+         i < m_cStructure->iLifetimesSize && i < sizeof(m_cStructure->lifetimes); ++i)
+    {
+      m_cStructure->lifetimes[i].iValue = lifetimes[i].GetCStructure()->iValue;
+      strncpy(m_cStructure->lifetimes[i].strDescription,
+              lifetimes[i].GetCStructure()->strDescription,
+              sizeof(m_cStructure->lifetimes[i].strDescription) - 1);
+    }
+    if (lifetimesDefault != -1)
+      m_cStructure->iLifetimesDefault = lifetimesDefault;
+  }
+  std::vector<PVRTypeIntValue> GetLifetimes() const
+  {
+    std::vector<PVRTypeIntValue> ret;
+    for (unsigned int i = 0; i < m_cStructure->iLifetimesSize; ++i)
+      ret.emplace_back(m_cStructure->lifetimes[i].iValue,
+                       m_cStructure->lifetimes[i].strDescription);
+    return ret;
+  }
+
+  void SetLifetimesDefault(int lifetimesDefault)
+  {
+    m_cStructure->iLifetimesDefault = lifetimesDefault;
+  }
+  int GetLifetimesDefault() const { return m_cStructure->iLifetimesDefault; }
+
+  void SetPreventDuplicateEpisodes(
+      const std::vector<PVRTypeIntValue>& preventDuplicateEpisodes,
+      int preventDuplicateEpisodesDefault = -1)
+  {
+    m_cStructure->iPreventDuplicateEpisodesSize = preventDuplicateEpisodes.size();
+    for (unsigned int i = 0; i < m_cStructure->iPreventDuplicateEpisodesSize &&
+                             i < sizeof(m_cStructure->preventDuplicateEpisodes);
+         ++i)
+    {
+      m_cStructure->preventDuplicateEpisodes[i].iValue =
+          preventDuplicateEpisodes[i].GetCStructure()->iValue;
+      strncpy(m_cStructure->preventDuplicateEpisodes[i].strDescription,
+              preventDuplicateEpisodes[i].GetCStructure()->strDescription,
+              sizeof(m_cStructure->preventDuplicateEpisodes[i].strDescription) - 1);
+    }
+    if (preventDuplicateEpisodesDefault != -1)
+      m_cStructure->iPreventDuplicateEpisodesDefault = preventDuplicateEpisodesDefault;
+  }
+  std::vector<PVRTypeIntValue> GetPreventDuplicateEpisodes() const
+  {
+    std::vector<PVRTypeIntValue> ret;
+    for (unsigned int i = 0; i < m_cStructure->iPreventDuplicateEpisodesSize; ++i)
+      ret.emplace_back(m_cStructure->preventDuplicateEpisodes[i].iValue,
+                       m_cStructure->preventDuplicateEpisodes[i].strDescription);
+    return ret;
+  }
+
+  void SetPreventDuplicateEpisodesDefault(int preventDuplicateEpisodesDefault)
+  {
+    m_cStructure->iPreventDuplicateEpisodesDefault = preventDuplicateEpisodesDefault;
+  }
+  int GetPreventDuplicateEpisodesDefault() const
+  {
+    return m_cStructure->iPreventDuplicateEpisodesDefault;
+  }
+
+  void SetRecordingGroups(const std::vector<PVRTypeIntValue>& recordingGroup,
+                          int recordingGroupDefault = -1)
+  {
+    m_cStructure->iRecordingGroupSize = recordingGroup.size();
+    for (unsigned int i = 0;
+         i < m_cStructure->iRecordingGroupSize && i < sizeof(m_cStructure->recordingGroup); ++i)
+    {
+      m_cStructure->recordingGroup[i].iValue = recordingGroup[i].GetCStructure()->iValue;
+      strncpy(m_cStructure->recordingGroup[i].strDescription,
+              recordingGroup[i].GetCStructure()->strDescription,
+              sizeof(m_cStructure->recordingGroup[i].strDescription) - 1);
+    }
+    if (recordingGroupDefault != -1)
+      m_cStructure->iRecordingGroupDefault = recordingGroupDefault;
+  }
+  std::vector<PVRTypeIntValue> GetRecordingGroups() const
+  {
+    std::vector<PVRTypeIntValue> ret;
+    for (unsigned int i = 0; i < m_cStructure->iRecordingGroupSize; ++i)
+      ret.emplace_back(m_cStructure->recordingGroup[i].iValue,
+                       m_cStructure->recordingGroup[i].strDescription);
+    return ret;
+  }
+
+  void SetRecordingGroupDefault(int recordingGroupDefault)
+  {
+    m_cStructure->iRecordingGroupDefault = recordingGroupDefault;
+  }
+  int GetRecordingGroupDefault() const { return m_cStructure->iRecordingGroupDefault; }
+
+  void SetMaxRecordings(const std::vector<PVRTypeIntValue>& maxRecordings,
+                        int maxRecordingsDefault = -1)
+  {
+    m_cStructure->iMaxRecordingsSize = maxRecordings.size();
+    for (unsigned int i = 0;
+         i < m_cStructure->iMaxRecordingsSize && i < sizeof(m_cStructure->maxRecordings); ++i)
+    {
+      m_cStructure->maxRecordings[i].iValue = maxRecordings[i].GetCStructure()->iValue;
+      strncpy(m_cStructure->maxRecordings[i].strDescription,
+              maxRecordings[i].GetCStructure()->strDescription,
+              sizeof(m_cStructure->maxRecordings[i].strDescription) - 1);
+    }
+    if (maxRecordingsDefault != -1)
+      m_cStructure->iMaxRecordingsDefault = maxRecordingsDefault;
+  }
+  std::vector<PVRTypeIntValue> GetMaxRecordings() const
+  {
+    std::vector<PVRTypeIntValue> ret;
+    for (unsigned int i = 0; i < m_cStructure->iMaxRecordingsSize; ++i)
+      ret.emplace_back(m_cStructure->maxRecordings[i].iValue,
+                       m_cStructure->maxRecordings[i].strDescription);
+    return ret;
+  }
+
+  void SetMaxRecordingsDefault(int maxRecordingsDefault)
+  {
+    m_cStructure->iMaxRecordingsDefault = maxRecordingsDefault;
+  }
+  int GetMaxRecordingsDefault() const { return m_cStructure->iMaxRecordingsDefault; }
+};
+
+} /* namespace addon */
+} /* namespace kodi */
+
+#endif /* __cplusplus */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/CMakeLists.txt
index b561784806cb..661708492cd7 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/CMakeLists.txt
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/CMakeLists.txt
@@ -1,5 +1,4 @@
-set(HEADERS pvr.h
-            pvr_channel_groups.h
+set(HEADERS pvr_channel_groups.h
             pvr_channels.h
             pvr_defines.h
             pvr_edl.h

From 63330cfe7e7d7d216d39326da580d8279da9c947 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 25 May 2020 10:46:30 +0200
Subject: [PATCH 20/27] [addons][pvr] set -1 by defines on recordings and
 timers

This use "PVR_[TIMER][RECORDING]_VALUE_NOT_AVAILABLE" to define it as -1.
---
 .../kodi/addon-instance/pvr/Recordings.h       | 18 +++++++++---------
 .../include/kodi/addon-instance/pvr/Timers.h   | 12 ++++++------
 .../c-api/addon-instance/pvr/pvr_recordings.h  |  1 +
 .../kodi/c-api/addon-instance/pvr/pvr_timers.h |  1 +
 4 files changed, 17 insertions(+), 15 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
index 151ec2a19f67..a214cdb195a1 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
@@ -26,19 +26,19 @@ class PVRRecording : public CStructHdl<PVRRecording, PVR_RECORDING>
     m_cStructure->iSeriesNumber = PVR_RECORDING_INVALID_SERIES_EPISODE;
     m_cStructure->iEpisodeNumber = PVR_RECORDING_INVALID_SERIES_EPISODE;
     m_cStructure->recordingTime = 0;
-    m_cStructure->iDuration = -1;
-    m_cStructure->iPriority = -1;
-    m_cStructure->iLifetime = -1;
-    m_cStructure->iGenreType = -1;
-    m_cStructure->iGenreSubType = -1;
-    m_cStructure->iPlayCount = -1;
-    m_cStructure->iLastPlayedPosition = -1;
+    m_cStructure->iDuration = PVR_RECORDING_VALUE_NOT_AVAILABLE;
+    m_cStructure->iPriority = PVR_RECORDING_VALUE_NOT_AVAILABLE;
+    m_cStructure->iLifetime = PVR_RECORDING_VALUE_NOT_AVAILABLE;
+    m_cStructure->iGenreType = PVR_RECORDING_VALUE_NOT_AVAILABLE;
+    m_cStructure->iGenreSubType = PVR_RECORDING_VALUE_NOT_AVAILABLE;
+    m_cStructure->iPlayCount = PVR_RECORDING_VALUE_NOT_AVAILABLE;
+    m_cStructure->iLastPlayedPosition = PVR_RECORDING_VALUE_NOT_AVAILABLE;
     m_cStructure->bIsDeleted = false;
     m_cStructure->iEpgEventId = 0;
-    m_cStructure->iChannelUid = -1;
+    m_cStructure->iChannelUid = PVR_RECORDING_VALUE_NOT_AVAILABLE;
     m_cStructure->channelType = PVR_RECORDING_CHANNEL_TYPE_UNKNOWN;
     m_cStructure->iFlags = 0;
-    m_cStructure->sizeInBytes = -1;
+    m_cStructure->sizeInBytes = PVR_RECORDING_VALUE_NOT_AVAILABLE;
   }
   PVRRecording(const PVRRecording& recording) : CStructHdl(recording) {}
   PVRRecording(const PVR_RECORDING* recording) : CStructHdl(recording) {}
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h
index b5ca8d19b843..8dc364df6f4b 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h
@@ -28,15 +28,15 @@ class PVRTimer : public CStructHdl<PVRTimer, PVR_TIMER>
     m_cStructure->state = PVR_TIMER_STATE_NEW;
     m_cStructure->iTimerType = PVR_TIMER_TYPE_NONE;
     m_cStructure->iParentClientIndex = 0;
-    m_cStructure->iClientChannelUid = -1;
+    m_cStructure->iClientChannelUid = PVR_TIMER_VALUE_NOT_AVAILABLE;
     m_cStructure->startTime = 0;
     m_cStructure->endTime = 0;
     m_cStructure->bStartAnyTime = false;
     m_cStructure->bEndAnyTime = false;
     m_cStructure->bFullTextEpgSearch = false;
-    m_cStructure->iPriority = -1;
-    m_cStructure->iLifetime = -1;
-    m_cStructure->iMaxRecordings = -1;
+    m_cStructure->iPriority = PVR_TIMER_VALUE_NOT_AVAILABLE;
+    m_cStructure->iLifetime = PVR_TIMER_VALUE_NOT_AVAILABLE;
+    m_cStructure->iMaxRecordings = PVR_TIMER_VALUE_NOT_AVAILABLE;
     m_cStructure->iRecordingGroup = 0;
     m_cStructure->firstDay = 0;
     m_cStructure->iWeekdays = PVR_WEEKDAY_NONE;
@@ -44,8 +44,8 @@ class PVRTimer : public CStructHdl<PVRTimer, PVR_TIMER>
     m_cStructure->iEpgUid = 0;
     m_cStructure->iMarginStart = 0;
     m_cStructure->iMarginEnd = 0;
-    m_cStructure->iGenreType = -1;
-    m_cStructure->iGenreSubType = -1;
+    m_cStructure->iGenreType = PVR_TIMER_VALUE_NOT_AVAILABLE;
+    m_cStructure->iGenreSubType = PVR_TIMER_VALUE_NOT_AVAILABLE;
   }
   PVRTimer(const PVRTimer& data) : CStructHdl(data) {}
   PVRTimer(const PVR_TIMER* data) : CStructHdl(data) {}
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
index 7130b7e3e3bf..93f24246732b 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
@@ -30,6 +30,7 @@ extern "C"
   } PVR_RECORDING_FLAG;
 
   #define PVR_RECORDING_INVALID_SERIES_EPISODE EPG_TAG_INVALID_SERIES_EPISODE
+  #define PVR_RECORDING_VALUE_NOT_AVAILABLE -1
 
   typedef enum PVR_RECORDING_CHANNEL_TYPE
   {
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
index d9e12375b57e..b64c59a5bda5 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
@@ -24,6 +24,7 @@ extern "C"
   #define PVR_TIMER_NO_PARENT PVR_TIMER_NO_CLIENT_INDEX
   #define PVR_TIMER_NO_EPG_UID EPG_TAG_INVALID_UID
   #define PVR_TIMER_ANY_CHANNEL -1
+  #define PVR_TIMER_VALUE_NOT_AVAILABLE -1
 
   typedef enum PVR_TIMER_TYPES
   {

From 980a31a173ab0d9ddfae3d36c7125b48c6b6d4e3 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 25 May 2020 18:23:08 +0200
Subject: [PATCH 21/27] [addons][pvr] add complete reworked documentation

This add back the on first commit removed docs in a good usable
doxygen style and much increased on most places.
---
 .../include/kodi/addon-instance/PVR.h         | 2168 ++++++++++++++++-
 .../kodi/addon-instance/pvr/ChannelGroups.h   |  144 ++
 .../kodi/addon-instance/pvr/Channels.h        |  303 ++-
 .../include/kodi/addon-instance/pvr/EDL.h     |   44 +
 .../include/kodi/addon-instance/pvr/EPG.h     |  283 ++-
 .../include/kodi/addon-instance/pvr/General.h |  288 ++-
 .../kodi/addon-instance/pvr/MenuHook.h        |   70 +
 .../kodi/addon-instance/pvr/Recordings.h      |  313 ++-
 .../include/kodi/addon-instance/pvr/Stream.h  |  185 ++
 .../include/kodi/addon-instance/pvr/Timers.h  |  516 +++-
 .../include/kodi/c-api/addon-instance/pvr.h   |   32 +
 .../addon-instance/pvr/pvr_channel_groups.h   |   16 +
 .../c-api/addon-instance/pvr/pvr_channels.h   |   37 +
 .../c-api/addon-instance/pvr/pvr_defines.h    |   17 +
 .../kodi/c-api/addon-instance/pvr/pvr_edl.h   |   25 +
 .../kodi/c-api/addon-instance/pvr/pvr_epg.h   |  424 ++++
 .../c-api/addon-instance/pvr/pvr_general.h    |  201 ++
 .../c-api/addon-instance/pvr/pvr_menu_hook.h  |   33 +
 .../c-api/addon-instance/pvr/pvr_recordings.h |   66 +
 .../c-api/addon-instance/pvr/pvr_stream.h     |   70 +
 .../c-api/addon-instance/pvr/pvr_timers.h     |  254 ++
 21 files changed, 5468 insertions(+), 21 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index ea0fb0f9bec5..f01918af9964 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -21,14 +21,413 @@
 
 #ifdef __cplusplus
 
+/*!
+ * @internal
+ * @brief PVR "C++" API interface
+ *
+ * In this field are the pure addon-side C++ data.
+ *
+ * @note Changes can be made without problems and have no influence on other
+ * PVR addons that have already been created.\n
+ * \n
+ * Therefore, @ref ADDON_INSTANCE_VERSION_PVR_MIN can be ignored for these
+ * fields and only the @ref ADDON_INSTANCE_VERSION_PVR needs to be increased.\n
+ * \n
+ * Only must be min version increased if a new compile of addon breaks after
+ * changes here.
+ *
+ * Have by add of new parts a look about **Doxygen** `\\ingroup`, so that
+ * added parts included in documentation.
+ *
+ * If you add addon side related documentation, where his dev need know, use `///`.
+ * For parts only for Kodi make it like here.
+ *
+ * @endinternal
+ */
+
 namespace kodi
 {
 namespace addon
 {
 
+//
+// "C++" Doxygen group set for the definitions
+//{{{
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs Definitions, structures and enumerators
+/// @ingroup cpp_kodi_addon_pvr
+/// @brief **PVR client add-on instance definition values**\n
+/// All PVR functions associated data structures.
+///
+/// Used to exchange the available options between Kodi and addon.\n
+/// The groups described here correspond to the groups of functions on PVR
+/// instance class.
+///
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_General 1. General
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **PVR add-on general variables**\n
+/// Used to exchange the available options between Kodi and addon.
+///
+/// This group also includes @ref cpp_kodi_addon_pvr_Defs_PVRCapabilities with
+/// which Kodi an @ref kodi::addon::CInstancePVRClient::GetCapabilities()
+/// queries the supported **modules** of the addon.
+///
+/// The standard values are also below, once for error messages and once to
+/// @ref kodi::addon::CInstancePVRClient::ConnectionStateChange() to give Kodi
+/// any information.
+///
+///@{
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_General_Inputstream class PVRStreamProperty & definition PVR_STREAM_PROPERTY
+/// @ingroup cpp_kodi_addon_pvr_Defs_General
+/// @brief **Inputstream variables**\n
+/// This includes values related to the outside of PVR available inputstream
+/// system.
+///
+/// This can be by separate instance on same addon, by handling in Kodi itself
+/// or to reference of another addon where support needed inputstream.
+///
+/// @note This is complete independent from own system included here
+/// @ref cpp_kodi_addon_pvr_Streams "inputstream".
+///
+//------------------------------------------------------------------------------
+///@}
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_Channel 2. Channel
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **PVR add-on channel**\n
+/// Used to exchange the available channel options between Kodi and addon.
+///
+/// Modules here are mainly intended for @ref cpp_kodi_addon_pvr_Channels "channels",
+/// but are also used on other modules to identify the respective TV/radio
+/// channel.
+///
+/// Because of @ref cpp_kodi_addon_pvr_Defs_Channel_PVRSignalStatus and
+/// @ref cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo is a special case at
+/// this point. This is currently only used on running streams, but it may be
+/// possible that this must always be usable in connection with PiP in the
+/// future.
+///
+//------------------------------------------------------------------------------
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_ChannelGroup 3. Channel Group
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **PVR add-on channel group**\n
+/// This group contains data classes and values which are used in PVR on
+/// @ref cpp_kodi_addon_pvr_supportsChannelGroups "channel groups".
+///
+//------------------------------------------------------------------------------
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_epg 4. EPG Tag
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **PVR add-on EPG data**\n
+/// Used on @ref cpp_kodi_addon_pvr_EPGTag "EPG methods in PVR instance class".
+///
+/// See related modules about, also below in this view are few macros where
+/// default values of associated places.
+///
+//------------------------------------------------------------------------------
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_Recording 5. Recording
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **Representation of a recording**\n
+/// Used to exchange the available recording data between Kodi and addon on
+/// @ref cpp_kodi_addon_pvr_Recordings "Recordings methods in PVR instance class".
+///
+//------------------------------------------------------------------------------
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_Timer 6. Timer
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **PVR add-on timer data**\n
+/// Used to exchange the available timer data between Kodi and addon on
+/// @ref cpp_kodi_addon_pvr_Timers "Timers methods in PVR instance class".
+///
+//------------------------------------------------------------------------------
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_Menuhook 7. Menuhook
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **PVR Context menu data**\n
+/// Define data for the context menus available to the user
+///
+//------------------------------------------------------------------------------
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_EDLEntry 8. Edit decision list (EDL)
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **An edit decision list or EDL is used in the post-production process
+/// of film editing and video editing**\n
+/// Used on @ref kodi::addon::CInstancePVRClient::GetEPGTagEdl and
+/// @ref kodi::addon::CInstancePVRClient::GetRecordingEdl
+///
+//------------------------------------------------------------------------------
+
+//##############################################################################
+/// @defgroup cpp_kodi_addon_pvr_Defs_Stream 9. Inputstream
+/// @ingroup cpp_kodi_addon_pvr_Defs
+/// @brief **Inputstream**\n
+/// This includes classes and values that are used in the PVR inputstream.
+///
+/// Used on @ref cpp_kodi_addon_pvr_Streams "Inputstream methods in PVR instance class".
+///
+/// @note The parts here will be removed in the future and replaced by the
+/// separate @ref cpp_kodi_addon_inputstream "inputstream addon instance".
+/// If there is already a possibility, new addons should do it via the
+/// inputstream instance.
+///
+//------------------------------------------------------------------------------
+
+//}}}
+//______________________________________________________________________________
+
+//
+// "C++" PVR addon instance class
+//{{{
+
+//==============================================================================
+/// @addtogroup cpp_kodi_addon_pvr
+/// @brief \cpp_class{ kodi::addon::CInstancePVRClient }
+/// **PVR client add-on instance**
+///
+/// Kodi features powerful [Live TV](https://kodi.wiki/view/Live_TV) and
+/// [video recording (DVR/PVR)](http://en.wikipedia.org/wiki/Digital_video_recorder)
+/// abilities using a very flexible distributed application structure. That is, by
+/// leveraging other existing third-party
+/// [PVR backend applications](https://kodi.wiki/view/PVR_backend) or
+/// [DVR devices](https://kodi.wiki/view/PVR_backend)
+/// that specialize in receiving television signals and also support the same type
+/// of [clientserver model](http://en.wikipedia.org/wiki/client%E2%80%93server_model)
+/// which Kodi uses, (following a [frontend-backend](http://en.wikipedia.org/wiki/Front_and_back_ends)
+/// design principle for [separation of concerns](http://en.wikipedia.org/wiki/Separation_of_concerns)),
+/// these PVR features in Kodi allow you to watch Live TV, listen to radio, view an EPG TV-Guide
+/// and schedule recordings, and also enables many other TV related features, all using
+/// Kodi as your primary interface once the initial pairing connection and
+/// configuration have been done.
+///
+/// @note It is very important to understand that with "Live TV" in the reference
+/// to PVR in Kodi, we do not mean [streaming video](http://en.wikipedia.org/wiki/Streaming_media)
+/// from the internet via websites providing [free content](https://kodi.wiki/view/Free_content)
+/// or online services such as Netflix, Hulu, Vudu and similar, no matter if that
+/// content is actually streamed live or not. If that is what you are looking for
+/// then you might want to look into [Video Addons](https://kodi.wiki/view/Add-ons)
+/// for Kodi instead, (which again is not the same as the "PVR" or "Live TV" we
+/// discuss in this article), but remember that [Kodi does not provide any video
+/// content or video streaming services](https://kodi.wiki/view/Free_content).
+///
+/// The use of the PVR is based on the @ref CInstancePVRClient.
+///
+/// Include the header @ref PVR.h "#include <kodi/addon-instance/PVR.h>"
+/// to use this class.
+///
+///
+/// ----------------------------------------------------------------------------
+///
+/// Here is an example of what the <b>`addon.xml.in`</b> would look like for an PVR addon:
+///
+/// ~~~~~~~~~~~~~{.xml}
+/// <?xml version="1.0" encoding="UTF-8"?>
+/// <addon
+///   id="pvr.myspecialnamefor"
+///   version="1.0.0"
+///   name="My special PVR addon"
+///   provider-name="Your Name">
+///   <requires>@ADDON_DEPENDS@</requires>
+///   <extension
+///     point="xbmc.pvrclient"
+///     library_@PLATFORM@="@LIBRARY_FILENAME@"/>
+///   <extension point="xbmc.addon.metadata">
+///     <summary lang="en_GB">My PVR addon addon</summary>
+///     <description lang="en_GB">My PVR addon description</description>
+///     <platform>@PLATFORM@</platform>
+///   </extension>
+/// </addon>
+/// ~~~~~~~~~~~~~
+///
+///
+/// At <b>`<extension point="xbmc.pvrclient" ...>`</b> the basic instance definition is declared, this is intended to identify the addon as an PVR and to see its supported types:
+/// | Name | Description
+/// |------|----------------------
+/// | <b>`point`</b> | The identification of the addon instance to inputstream is mandatory <b>`xbmc.pvrclient`</b>. In addition, the instance declared in the first <b>`<extension ... />`</b> is also the main type of addon.
+/// | <b>`library_@PLATFORM@`</b> | The runtime library used for the addon. This is usually declared by cmake and correctly displayed in the translated `addon.xml`.
+///
+///
+/// @remark For more detailed description of the <b>`addon.xml`</b>, see also https://kodi.wiki/view/Addon.xml.
+///
+///
+/// --------------------------------------------------------------------------
+///
+/// **Example:**
+///
+/// ~~~~~~~~~~~~~{.cpp}
+/// #include <kodi/addon-instance/PVR.h>
+///
+/// class CMyPVRClient : public ::kodi::addon::CInstancePVRClient
+/// {
+/// public:
+///   CMyPVRClient(KODI_HANDLE instance, const std::string& kodiVersion);
+///
+///   PVR_ERROR GetCapabilities(kodi::addon::PVRCapabilities& capabilities) override;
+///   PVR_ERROR GetBackendName(std::string& name) override;
+///   PVR_ERROR GetBackendVersion(std::string& version) override;
+///
+///   PVR_ERROR GetChannelsAmount(int& amount) override;
+///   PVR_ERROR GetChannels(bool radio, std::vector<kodi::addon::PVRChannel>& channels) override;
+///   PVR_ERROR GetChannelStreamProperties(const kodi::addon::PVRChannel&	channel,
+///                                        std::vector<kodi::addon::PVRStreamProperty>& properties) override;
+///
+/// private:
+///   std::vector<kodi::addon::PVRChannel> m_myChannels;
+/// };
+///
+/// CMyPVRClient::CMyPVRClient(KODI_HANDLE instance, const std::string& kodiVersion)
+///   : CInstancePVRClient(instance, kodiVersion)
+/// {
+///   kodi::addon::PVRChannel channel;
+///   channel.SetUniqueId(123);
+///   channel.SetChannelNumber(1);
+///   channel.SetChannelName("My test channel");
+///   m_myChannels.push_back(channel);
+/// }
+///
+/// PVR_ERROR CMyPVRClient::GetCapabilities(kodi::addon::PVRCapabilities& capabilities)
+/// {
+///   capabilities.SetSupportsTV(true);
+///   return PVR_ERROR_NO_ERROR;
+/// }
+///
+/// PVR_ERROR CMyPVRClient::GetBackendName(std::string& name)
+/// {
+///   name = "My special PVR client";
+///   return PVR_ERROR_NO_ERROR;
+/// }
+///
+/// PVR_ERROR CMyPVRClient::GetBackendVersion(std::string& version)
+/// {
+///   version = "1.0.0";
+///   return PVR_ERROR_NO_ERROR;
+/// }
+///
+/// PVR_ERROR CMyInstance::GetChannelsAmount(int& amount)
+/// {
+///   amount = m_myChannels.size();
+///   return PVR_ERROR_NO_ERROR;
+/// }
+///
+/// PVR_ERROR CMyPVRClient::GetChannels(bool radio, std::vector<kodi::addon::PVRChannel>& channels)
+/// {
+///   channels = m_myChannels;
+///   return PVR_ERROR_NO_ERROR;
+/// }
+///
+/// PVR_ERROR CMyPVRClient::GetChannelStreamProperties(const kodi::addon::PVRChannel& channel,
+///                                                    std::vector<kodi::addon::PVRStreamProperty>& properties)
+/// {
+///   if (channel.GetUniqueId() == 123)
+///   {
+///     properties.push_back(PVR_STREAM_PROPERTY_STREAMURL, "http://distribution.bbb3d.renderfarming.net/video/mp4/bbb_sunflower_1080p_30fps_normal.mp4");
+///     properties.push_back(PVR_STREAM_PROPERTY_ISREALTIMESTREAM, "true");
+///     return PVR_ERROR_NO_ERROR;
+///   }
+///   return PVR_ERROR_UNKNOWN;
+/// }
+///
+/// ...
+///
+/// //----------------------------------------------------------------------
+///
+/// class CMyAddon : public ::kodi::addon::CAddonBase
+/// {
+/// public:
+///   CMyAddon() = default;
+///   ADDON_STATUS CreateInstance(int instanceType,
+///                               const std::string& instanceID,
+///                               KODI_HANDLE instance,
+///                               const std::string& version,
+///                               KODI_HANDLE& addonInstance) override;
+/// };
+///
+/// // If you use only one instance in your add-on, can be instanceType and
+/// // instanceID ignored
+/// ADDON_STATUS CMyAddon::CreateInstance(int instanceType,
+///                                       const std::string& instanceID,
+///                                       KODI_HANDLE instance,
+///                                       const std::string& version,
+///                                       KODI_HANDLE& addonInstance)
+/// {
+///   if (instanceType == ADDON_INSTANCE_PVR)
+///   {
+///     kodi::Log(ADDON_LOG_NOTICE, "Creating my PVR client instance");
+///     addonInstance = new CMyPVRClient(instance, version);
+///     return ADDON_STATUS_OK;
+///   }
+///   else if (...)
+///   {
+///     ...
+///   }
+///   return ADDON_STATUS_UNKNOWN;
+/// }
+///
+/// ADDONCREATOR(CMyAddon)
+/// ~~~~~~~~~~~~~
+///
+/// The destruction of the example class `CMyPVRClient` is called from
+/// Kodi's header. Manually deleting the add-on instance is not required.
+///
 class CInstancePVRClient : public IAddonInstance
 {
 public:
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Base 1. Basic functions
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief **Functions to manage the addon and get basic information about it**\n
+  /// These are e.g. @ref GetCapabilities to know supported groups at
+  /// this addon or the others to get information about the source of the PVR
+  /// stream.
+  ///
+  /// The with "Valid implementation required." declared functions are mandatory,
+  /// all others are an option.
+  ///@{
+
+  //============================================================================
+  /// @brief PVR client class constructor.
+  ///
+  /// Used by an add-on that only supports only PVR and only in one instance.
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Here's example about the use of this:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// #include <kodi/addon-instance/PVR.h>
+  /// ...
+  ///
+  /// class ATTRIBUTE_HIDDEN CPVRExample
+  ///   : public kodi::addon::CAddonBase,
+  ///     public kodi::addon::CInstancePVRClient
+  /// {
+  /// public:
+  ///   CPVRExample()
+  ///   {
+  ///   }
+  ///
+  ///   ~CPVRExample() override;
+  ///   {
+  ///   }
+  ///
+  ///   ...
+  /// };
+  ///
+  /// ADDONCREATOR(CPVRExample)
+  /// ~~~~~~~~~~~~~
+  ///
   CInstancePVRClient() : IAddonInstance(ADDON_INSTANCE_PVR, GetKodiTypeVersion(ADDON_INSTANCE_PVR))
   {
     if (CAddonBase::m_interface->globalSingleInstance != nullptr)
@@ -38,7 +437,48 @@ class CInstancePVRClient : public IAddonInstance
     SetAddonStruct(CAddonBase::m_interface->firstKodiInstance, m_kodiVersion);
     CAddonBase::m_interface->globalSingleInstance = this;
   }
-
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief PVR client class constructor used to support multiple instance
+  /// types.
+  ///
+  /// @param[in] instance The instance value given to
+  ///                     <b>`kodi::addon::CAddonBase::CreateInstance(...)`</b>.
+  /// @param[in] kodiVersion [opt] Version used in Kodi for this instance, to
+  ///                        allow compatibility to older Kodi versions.
+  ///
+  /// @note Recommended to set <b>`kodiVersion`</b>.
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Here's example about the use of this:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// class CMyPVRClient : public ::kodi::addon::CInstancePVRClient
+  /// {
+  /// public:
+  ///   CMyPVRClient(KODI_HANDLE instance, const std::string& kodiVersion)
+  ///     : CInstancePVRClient(instance, kodiVersion)
+  ///   {
+  ///      ...
+  ///   }
+  ///
+  ///   ...
+  /// };
+  ///
+  /// ADDON_STATUS CMyAddon::CreateInstance(int instanceType,
+  ///                                       const std::string& instanceID,
+  ///                                       KODI_HANDLE instance,
+  ///                                       const std::string& version,
+  ///                                       KODI_HANDLE& addonInstance)
+  /// {
+  ///   kodi::Log(ADDON_LOG_NOTICE, "Creating my PVR client instance");
+  ///   addonInstance = new CMyPVRClient(instance, version);
+  ///   return ADDON_STATUS_OK;
+  /// }
+  /// ~~~~~~~~~~~~~
+  ///
   explicit CInstancePVRClient(KODI_HANDLE instance, const std::string& kodiVersion = "")
     : IAddonInstance(ADDON_INSTANCE_PVR,
                      !kodiVersion.empty() ? kodiVersion : GetKodiTypeVersion(ADDON_INSTANCE_PVR))
@@ -49,29 +489,269 @@ class CInstancePVRClient : public IAddonInstance
 
     SetAddonStruct(instance, m_kodiVersion);
   }
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @brief Destructor
+  ///
   ~CInstancePVRClient() override = default;
+  //----------------------------------------------------------------------------
+
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @brief Get the list of features that this add-on provides.
+  ///
+  /// Called by Kodi to query the add-on's capabilities.
+  /// Used to check which options should be presented in the UI, which methods to call, etc.
+  /// All capabilities that the add-on supports should be set to true.
+  ///
+  /// @param capabilities The with @ref cpp_kodi_addon_pvr_Defs_PVRCapabilities defined add-on's capabilities.
+  /// @return @ref PVR_ERROR_NO_ERROR if the properties were fetched successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_PVRCapabilities_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// PVR_ERROR CMyPVRClient::GetCapabilities(kodi::addon::PVRCapabilities& capabilities)
+  /// {
+  ///   capabilities.SetSupportsTV(true);
+  ///   capabilities.SetSupportsEPG(true);
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ~~~~~~~~~~~~~
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @note Valid implementation required.
+  ///
   virtual PVR_ERROR GetCapabilities(kodi::addon::PVRCapabilities& capabilities) = 0;
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the name reported by the backend that will be displayed in the UI.
+  ///
+  /// @param[out] name The name reported by the backend that will be displayed in the UI.
+  /// @return @ref PVR_ERROR_NO_ERROR if successfully done
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// PVR_ERROR CMyPVRClient::GetBackendName(std::string& name)
+  /// {
+  ///   name = "My special PVR client";
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ~~~~~~~~~~~~~
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @note Valid implementation required.
+  ///
   virtual PVR_ERROR GetBackendName(std::string& name) = 0;
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the version string reported by the backend that will be
+  /// displayed in the UI.
+  ///
+  /// @param[out] version The version string reported by the backend that will be
+  ///                     displayed in the UI.
+  /// @return @ref PVR_ERROR_NO_ERROR if successfully done
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// PVR_ERROR CMyPVRClient::GetBackendVersion(std::string& version)
+  /// {
+  ///   version = "1.0.0";
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ~~~~~~~~~~~~~
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @note Valid implementation required.
+  ///
   virtual PVR_ERROR GetBackendVersion(std::string& version) = 0;
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the hostname of the pvr backend server
+  ///
+  /// @param[out] hostname Hostname as ip address or alias. If backend does not
+  ///                      utilize a server, return empty string.
+  /// @return @ref PVR_ERROR_NO_ERROR if successfully done
+  ///
   virtual PVR_ERROR GetBackendHostname(std::string& hostname) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief To get the connection string reported by the backend that will be
+  /// displayed in the UI.
+  ///
+  /// @param[out] connection The connection string reported by the backend that
+  ///                        will be displayed in the UI.
+  /// @return @ref PVR_ERROR_NO_ERROR if successfully done
+  ///
   virtual PVR_ERROR GetConnectionString(std::string& connection)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the disk space reported by the backend (if supported).
+  ///
+  /// @param[in] total The total disk space in bytes.
+  /// @param[in] used The used disk space in bytes.
+  /// @return @ref PVR_ERROR_NO_ERROR if the drive space has been fetched
+  ///         successfully.
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// PVR_ERROR CMyPVRClient::GetDriveSpace(uint64_t& total, uint64_t& used)
+  /// {
+  ///   total = 10 * 1024 * 1024 * 1024; // To set complete size of drive in bytes
+  ///   used =  122324243; // To set the used amount
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetDriveSpace(uint64_t& total, uint64_t& used)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Call one of the settings related menu hooks (if supported).
+  ///
+  /// Supported @ref cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook "menu hook "
+  /// instances have to be added in `constructor()`, by calling @ref AddMenuHook()
+  /// on the callback.
+  ///
+  /// @param[in] menuhook The hook to call.
+  /// @return @ref PVR_ERROR_NO_ERROR if the hook was called successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// PVR_ERROR CMyPVRClient::CallSettingsMenuHook(const kodi::addon::PVRMenuhook& menuhook)
+  /// {
+  ///   if (menuhook.GetHookId() == 2)
+  ///     kodi::QueueNotification(QUEUE_INFO, "", kodi::GetLocalizedString(menuhook.GetLocalizedStringId()));
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR CallSettingsMenuHook(const kodi::addon::PVRMenuhook& menuhook)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief **Callback to Kodi Function**\nAdd or replace a menu hook for the context menu for this add-on
+  ///
+  /// This is a callback function, called from addon to give Kodi his context menu's.
+  ///
+  /// @param[in] menuhook The with @ref cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook defined hook to add
+  ///
+  /// @remarks Only called from addon itself
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Here's an example of the use of it:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// #include <kodi/addon-instance/PVR.h>
+  /// ...
+  ///
+  /// {
+  ///   kodi::addon::PVRMenuhook hook;
+  ///   hook.SetHookId(1);
+  ///   hook.SetCategory(PVR_MENUHOOK_CHANNEL);
+  ///   hook.SetLocalizedStringId(30000);
+  ///   AddMenuHook(hook);
+  /// }
+  ///
+  /// {
+  ///   kodi::addon::PVRMenuhook hook;
+  ///   hook.SetHookId(2);
+  ///   hook.SetCategory(PVR_MENUHOOK_SETTING);
+  ///   hook.SetLocalizedStringId(30001);
+  ///   AddMenuHook(hook);
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  /// **Here another way:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// #include <kodi/addon-instance/PVR.h>
+  /// ...
+  ///
+  /// AddMenuHook(kodi::addon::PVRMenuhook(1, 30000, PVR_MENUHOOK_CHANNEL));
+  /// AddMenuHook(kodi::addon::PVRMenuhook(2, 30001, PVR_MENUHOOK_SETTING));
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   inline void AddMenuHook(kodi::addon::PVRMenuhook& hook)
   {
     m_instanceData->toKodi->AddMenuHook(m_instanceData->toKodi->kodiInstance, hook);
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Notify a state change for a PVR backend connection.
+  ///
+  /// @param[in] connectionString The connection string reported by the backend
+  ///                             that can be displayed in the UI.
+  /// @param[in] newState The by @ref PVR_CONNECTION_STATE defined new state.
+  /// @param[in] message A localized addon-defined string representing the new
+  ///                    state, that can be displayed in the UI or **empty** if
+  ///                    the Kodi-defined default string for the new state
+  ///                    shall be displayed.
+  ///
+  /// @remarks Only called from addon itself
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  ///
+  /// **Here's an example of the use of it:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// #include <kodi/addon-instance/PVR.h>
+  /// #include <kodi/General.h> /* for kodi::GetLocalizedString(...) */
+  /// ...
+  ///
+  ///   ConnectionStateChange("PVR demo connection lost", PVR_CONNECTION_STATE_DISCONNECTED, kodi::GetLocalizedString(30005, "Lost connection to Server"););
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   inline void ConnectionStateChange(const std::string& connectionString,
                                     PVR_CONNECTION_STATE newState,
                                     const std::string& message)
@@ -79,72 +759,567 @@ class CInstancePVRClient : public IAddonInstance
     m_instanceData->toKodi->ConnectionStateChange(
         m_instanceData->toKodi->kodiInstance, connectionString.c_str(), newState, message.c_str());
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Get user data path of the PVR addon.
+  ///
+  /// @return Path of current Kodi user
+  ///
+  /// @remarks Only called from addon itself
+  ///
+  /// @note Alternatively, @ref kodi::GetAddonPath() can be used for this.
+  ///
   inline std::string UserPath() const { return m_instanceData->props->strUserPath; }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Get main client path of the PVR addon.
+  ///
+  /// @return Path of addon client
+  ///
+  /// @remarks Only called from addon itself.
+  ///
+  /// @note Alternatively, @ref kodi::GetBaseUserPath() can be used for this.
+  ///
   inline std::string ClientPath() const { return m_instanceData->props->strClientPath; }
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Channels 2. Channels (required)
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief **Functions to get available TV or Radio channels**\n
+  /// These are mandatory functions for using this addon to get the available
+  /// channels.
+  ///
+  /// @remarks Either @ref PVRCapabilities::SetSupportsTV "SetSupportsTV()" or
+  /// @ref PVRCapabilities::SetSupportsRadio "SetSupportsRadio()" is required to
+  /// be set to <b>`true`</b>.\n
+  /// If a channel changes after the initial import, or if a new one was added,
+  /// then the add-on should call @ref TriggerChannelUpdate().
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief The total amount of channels on the backend
+  ///
+  /// @param[out] amount The total amount of channels on the backend
+  /// @return @ref PVR_ERROR_NO_ERROR if the amount has been fetched successfully.
+  ///
+  /// @remarks Valid implementation required.
+  ///
   virtual PVR_ERROR GetChannelsAmount(int& amount) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Request the list of all channels from the backend.
+  ///
+  /// @param[in] radio True to get the radio channels, false to get the TV channels.
+  /// @param[out] results The channels defined with @ref cpp_kodi_addon_pvr_Defs_Channel_PVRChannel
+  ///                     and available at the addon, them transfered with
+  ///                     @ref cpp_kodi_addon_pvr_Defs_Channel_PVRChannelsResultSet.
+  /// @return @ref PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Channel_PVRChannel_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @remarks
+  /// If @ref PVRCapabilities::SetSupportsTV() is set to
+  /// <b>`true`</b>, a valid result set needs to be provided for <b>`radio = false`</b>.\n
+  /// If @ref PVRCapabilities::SetSupportsRadio() is set to
+  /// <b>`true`</b>, a valid result set needs to be provided for <b>`radio = true`</b>.
+  /// At least one of these two must provide a valid result set.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetChannels(bool radio, kodi::addon::PVRChannelsResultSet& results)
+  /// {
+  ///   // Minimal demo example, in reality bigger and loop to transfer all
+  ///   kodi::addon::PVRChannel channel;
+  ///   channel.SetUniqueId(123);
+  ///   channel.SetIsRadio(false);
+  ///   channel.SetChannelNumber(1);
+  ///   channel.SetChannelName("My channel name");
+  ///   ...
+  ///
+  ///   // Give it now to Kodi
+  ///   results.Add(channel);
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetChannels(bool radio, kodi::addon::PVRChannelsResultSet& results)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the stream properties for a channel from the backend.
+  ///
+  /// @param[in] channel The channel to get the stream properties for.
+  /// @param[out] properties the properties required to play the stream.
+  /// @return @ref PVR_ERROR_NO_ERROR if the stream is available.
+  ///
+  /// @remarks If @ref PVRCapabilities::SetSupportsTV "SetSupportsTV" or
+  /// @ref PVRCapabilities::SetSupportsRadio "SetSupportsRadio" are set to true
+  /// and @ref PVRCapabilities::SetHandlesInputStream "SetHandlesInputStream" is
+  /// set to false.\n\n
+  /// In this case the implementation must fill the property @ref PVR_STREAM_PROPERTY_STREAMURL
+  /// with the URL Kodi should resolve to playback the channel.
+  ///
+  /// @note The value directly related to inputstream must always begin with the
+  /// name of the associated add-on, e.g. <b>`"inputstream.adaptive.manifest_update_parameter"`</b>.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetChannelStreamProperties(const kodi::addon::PVRChannel& channel,
+  ///                                                      std::vector<kodi::addon::PVRStreamProperty>& properties)
+  /// {
+  ///   ...
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_INPUTSTREAM, "inputstream.adaptive");
+  ///   properties.emplace_back("inputstream.adaptive.manifest_type", "mpd");
+  ///   properties.emplace_back("inputstream.adaptive.manifest_update_parameter", "full");
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_MIMETYPE, "application/xml+dash");
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetChannelStreamProperties(
       const kodi::addon::PVRChannel& channel,
       std::vector<kodi::addon::PVRStreamProperty>& properties)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the signal status of the stream that's currently open.
+  ///
+  /// @param[out] signalStatus The signal status.
+  /// @return @ref PVR_ERROR_NO_ERROR if the signal status has been read successfully, false otherwise.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetHandlesInputStream "SetHandlesInputStream"
+  /// is set to true.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Channel_PVRSignalStatus_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  ///
+  /// **Here's example about the use of this:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// #include <kodi/addon-instance/PVR.h>
+  /// ...
+  ///
+  /// class ATTRIBUTE_HIDDEN CPVRExample
+  ///   : public kodi::addon::CAddonBase,
+  ///     public kodi::addon::CInstancePVRClient
+  /// {
+  /// public:
+  ///   ...
+  ///   PVR_ERROR SignalStatus(PVRSignalStatus &signalStatus) override
+  ///   {
+  ///     signalStatus.SetAapterName("Example adapter 1");
+  ///     signalStatus.SetAdapterStatus("OK");
+  ///     signalStatus.SetSignal(0xFFFF); // 100%
+  ///
+  ///     return PVR_ERROR_NO_ERROR;
+  ///   }
+  /// };
+  ///
+  /// ADDONCREATOR(CPVRExample)
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetSignalStatus(int channelUid, kodi::addon::PVRSignalStatus& signalStatus)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the descramble information of the stream that's currently open.
+  ///
+  /// @param[out] descrambleInfo The descramble information.
+  /// @return @ref PVR_ERROR_NO_ERROR if the descramble information has been
+  ///         read successfully, false otherwise.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsDescrambleInfo "supportsDescrambleInfo"
+  /// is set to true.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo_Help
+  ///
   virtual PVR_ERROR GetDescrambleInfo(int channelUid,
                                       kodi::addon::PVRDescrambleInfo& descrambleInfo)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Request Kodi to update it's list of channels.
+  ///
+  /// @remarks Only called from addon itself.
+  ///
   inline void TriggerChannelUpdate()
   {
     m_instanceData->toKodi->TriggerChannelUpdate(m_instanceData->toKodi->kodiInstance);
   }
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_supportsChannelGroups 3. Channel Groups (optional)
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief <b>Bring in this functions if you have set @ref PVRCapabilities::SetSupportsChannelGroups "supportsChannelGroups"
+  /// to true</b>\n
+  /// This is used to divide available addon channels into groups, which can
+  /// then be selected by the user.
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief Get the total amount of channel groups on the backend if it supports channel groups.
+  ///
+  /// @param[out] amount The total amount of channel groups on the backend
+  /// @return @ref PVR_ERROR_NO_ERROR if the amount has been fetched successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsChannelGroups "supportsChannelGroups"  is set to true.
+  ///
   virtual PVR_ERROR GetChannelGroupsAmount(int& amount) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get a list of available channel groups on addon
+  ///
+  /// Request the list of all channel groups from the backend if it supports
+  /// channel groups.
+  ///
+  /// @param[in] radio True to get the radio channel groups, false to get the
+  ///                  TV channel groups.
+  /// @param[out] results List of available groups on addon defined with
+  ///                     @ref cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup,
+  ///                     them transfered with
+  ///                     @ref cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupsResultSet.
+  /// @return @ref PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsChannelGroups "supportsChannelGroups"
+  /// is set to true.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetChannelGroups(bool radio, kodi::addon::PVRChannelGroupsResultSet& groups)
+  /// {
+  ///   kodi::addon::PVRChannelGroup group;
+  ///   group.SetIsRadio(false);
+  ///   group.SetGroupName("My group name");
+  ///   group.SetPosition(1);
+  ///   ...
+  ///
+  ///   // Give it now to Kodi
+  ///   results.Add(group);
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetChannelGroups(bool radio, kodi::addon::PVRChannelGroupsResultSet& results)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get a list of members on a group
+  ///
+  /// Request the list of all group members of a group from the backend if it
+  /// supports channel groups.
+  ///
+  /// @param[in] group The group to get the members for.
+  /// @param[out] results List of available group member channels defined with
+  ///                     @ref cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember,
+  ///                     them transfered with
+  ///                     @ref PVRChannelGroupMembersResultSet.
+  /// @return @ref PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember_Help
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsChannelGroups "supportsChannelGroups"
+  /// is set to true.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetChannelGroupMembers(const kodi::addon::PVRChannelGroup& group,
+  ///                                                  kodi::addon::PVRChannelGroupMembersResultSet& results)
+  /// {
+  ///   for (const auto& myGroup : m_myGroups)
+  ///   {
+  ///     if (myGroup.strGroupName == group.GetGroupName())
+  ///     {
+  ///       for (unsigned int iChannelPtr = 0; iChannelPtr < myGroup.members.size(); iChannelPtr++)
+  ///       {
+  ///         int iId = myGroup.members.at(iChannelPtr) - 1;
+  ///         if (iId < 0 || iId > (int)m_channels.size() - 1)
+  ///           continue;
+  ///
+  ///         PVRDemoChannel &channel = m_channels.at(iId);
+  ///         kodi::addon::PVRChannelGroupMember kodiGroupMember;
+  ///         kodiGroupMember.SetGroupName(group.GetGroupName());
+  ///         kodiGroupMember.SetChannelUniqueId(channel.iUniqueId);
+  ///         kodiGroupMember.SetChannelNumber(channel.iChannelNumber);
+  ///         kodiGroupMember.SetSubChannelNumber(channel.iSubChannelNumber);
+  ///
+  ///         results.Add(kodiGroupMember);
+  ///       }
+  ///     }
+  ///   }
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetChannelGroupMembers(const kodi::addon::PVRChannelGroup& group,
                                            kodi::addon::PVRChannelGroupMembersResultSet& results)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Request Kodi to update it's list of channel groups.
+  ///
+  /// @remarks Only called from addon itself
+  ///
   inline void TriggerChannelGroupsUpdate()
   {
     m_instanceData->toKodi->TriggerChannelGroupsUpdate(m_instanceData->toKodi->kodiInstance);
   }
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_supportsChannelEdit 4. Channel edit (optional)
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief <b>Bring in this functions if you have set @ref PVRCapabilities::SetSupportsChannelSettings "supportsChannelSettings"
+  /// to true or for @ref OpenDialogChannelScan() set @ref PVRCapabilities::SetSupportsChannelScan "supportsChannelScan"
+  /// to true</b>\n
+  /// The support of this is a pure option and not mandatory.
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief Delete a channel from the backend.
+  ///
+  /// @param[in] channel The channel to delete.
+  /// @return @ref PVR_ERROR_NO_ERROR if the channel has been deleted successfully.
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsChannelSettings "supportsChannelSettings"
+  /// is set to true.
+  ///
   virtual PVR_ERROR DeleteChannel(const kodi::addon::PVRChannel& channel)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief Rename a channel on the backend.
+  ///
+  /// @param[in] channel The channel to rename, containing the new channel name.
+  /// @return @ref PVR_ERROR_NO_ERROR if the channel has been renamed successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Channel_PVRChannel_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsChannelSettings "supportsChannelSettings"
+  /// is set to true.
+  ///
   virtual PVR_ERROR RenameChannel(const kodi::addon::PVRChannel& channel)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief Show the channel settings dialog, if supported by the backend.
+  ///
+  /// @param[in] channel The channel to show the dialog for.
+  /// @return @ref PVR_ERROR_NO_ERROR if the dialog has been displayed successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsChannelSettings "supportsChannelSettings" is set to true.
+  /// @note Use @ref cpp_kodi_gui_CWindow "kodi::gui::CWindow" to create dialog for them.
+  ///
   virtual PVR_ERROR OpenDialogChannelSettings(const kodi::addon::PVRChannel& channel)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief Show the dialog to add a channel on the backend, if supported by the backend.
+  ///
+  /// @param[in] channel The channel to add.
+  /// @return @ref PVR_ERROR_NO_ERROR if the channel has been added successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsChannelSettings "supportsChannelSettings" is set to true.
+  /// @note Use @ref cpp_kodi_gui_CWindow "kodi::gui::CWindow" to create dialog for them.
+  ///
   virtual PVR_ERROR OpenDialogChannelAdd(const kodi::addon::PVRChannel& channel)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief Show the channel scan dialog if this backend supports it.
+  ///
+  /// @return @ref PVR_ERROR_NO_ERROR if the dialog was displayed successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsChannelScan "supportsChannelScan" is set to true.
+  /// @note Use @ref cpp_kodi_gui_CWindow "kodi::gui::CWindow" to create dialog for them.
+  ///
   virtual PVR_ERROR OpenDialogChannelScan() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief Call one of the channel related menu hooks (if supported).
+  ///
+  /// Supported @ref cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook instances have to be added in
+  /// `constructor()`, by calling @ref AddMenuHook() on the callback.
+  ///
+  /// @param[in] menuhook The hook to call.
+  /// @param[in] item The selected channel item for which the hook was called.
+  /// @return @ref PVR_ERROR_NO_ERROR if the hook was called successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook_Help
+  ///
   virtual PVR_ERROR CallChannelMenuHook(const kodi::addon::PVRMenuhook& menuhook,
                                         const kodi::addon::PVRChannel& item)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_EPGTag 4. EPG methods (optional)
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief **PVR EPG methods**\n
+  /// These C ++ class functions of are intended for processing EPG information
+  /// and for giving it to Kodi.
+  ///
+  /// The necessary data is transferred with @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag.
+  ///
+  /// @remarks Only used by Kodi if @ref PVRCapabilities::SetSupportsEPG "supportsEPG"
+  /// is set to true.\n\n
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief Request the EPG for a channel from the backend.
+  ///
+  /// @param[in] channelUid The UID of the channel to get the EPG table for.
+  /// @param[in] start Get events after this time (UTC).
+  /// @param[in] end Get events before this time (UTC).
+  /// @param[out] results List where available EPG information becomes
+  ///                     transferred with @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag
+  ///                     and given to Kodi
+  /// @return @ref PVR_ERROR_NO_ERROR if the table has been fetched successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_epg_PVREPGTag_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsEPG "supportsEPG" is set to true.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetEPGForChannel(int channelUid,
+  ///                                            time_t start,
+  ///                                            time_t end,
+  ///                                            kodi::addon::PVREPGTagsResultSet& results)
+  /// {
+  ///   // Minimal demo example, in reality bigger, loop to transfer all and to
+  ///   // match wanted times.
+  ///   kodi::addon::PVREPGTag tag;
+  ///   tag.SetUniqueBroadcastId(123);
+  ///   tag.SetUniqueChannelId(123);
+  ///   tag.SetTitle("My epg entry name");
+  ///   tag.SetGenreType(EPG_EVENT_CONTENTMASK_MOVIEDRAMA);
+  ///   tag.SetStartTime(1589148283); // Seconds elapsed since 00:00 hours, Jan 1, 1970 UTC
+  ///   tag.SetEndTime(1589151913);
+  ///   ...
+  ///
+  ///   // Give it now to Kodi
+  ///   results.Add(tag);
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetEPGForChannel(int channelUid,
                                      time_t start,
                                      time_t end,
@@ -152,100 +1327,528 @@ class CInstancePVRClient : public IAddonInstance
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Check if the given EPG tag can be recorded.
+  ///
+  /// @param[in] tag the @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "epg tag" to check.
+  /// @param[out] isRecordable Set to true if the tag can be recorded.
+  /// @return @ref PVR_ERROR_NO_ERROR if bIsRecordable has been set successfully.
+  ///
+  /// @remarks Optional, it return @ref PVR_ERROR_NOT_IMPLEMENTED by parent to let Kodi decide.
+  ///
   virtual PVR_ERROR IsEPGTagRecordable(const kodi::addon::PVREPGTag& tag, bool& isRecordable)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Check if the given EPG tag can be played.
+  ///
+  /// @param[in] tag the @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "epg tag" to check.
+  /// @param[out] isPlayable Set to true if the tag can be played.
+  /// @return @ref PVR_ERROR_NO_ERROR if bIsPlayable has been set successfully.
+  ///
+  /// @remarks Required if add-on supports playing epg tags.
+  ///
   virtual PVR_ERROR IsEPGTagPlayable(const kodi::addon::PVREPGTag& tag, bool& isPlayable)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Retrieve the edit decision list (EDL) of an EPG tag on the backend.
+  ///
+  /// @param[in] tag The @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "epg tag".
+  /// @param[out] edl The function has to write the EDL into this array.
+  /// @return @ref PVR_ERROR_NO_ERROR if the EDL was successfully read or no EDL exists.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsEPGEdl "supportsEPGEdl" is set to true.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsEPGEdl "supportsEPGEdl" is set to true.
+  ///
   virtual PVR_ERROR GetEPGTagEdl(const kodi::addon::PVREPGTag& tag,
                                  std::vector<kodi::addon::PVREDLEntry>& edl)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the stream properties for an epg tag from the backend.
+  ///
+  /// @param[in] tag The @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "epg tag" to get the stream properties for.
+  /// @param[out] properties the properties required to play the stream.
+  /// @return @ref PVR_ERROR_NO_ERROR if the stream is available.
+  ///
+  /// @remarks Required if add-on supports playing epg tags.
+  /// In this case your implementation must fill the property @ref PVR_STREAM_PROPERTY_STREAMURL
+  /// with the URL Kodi should resolve to playback the epg tag.
+  /// It return @ref PVR_ERROR_NOT_IMPLEMENTED from parent if this add-on won't provide this function.
+  ///
+  /// @note The value directly related to inputstream must always begin with the
+  /// name of the associated add-on, e.g. <b>`"inputstream.adaptive.manifest_update_parameter"`</b>.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetEPGTagStreamProperties(const kodi::addon::PVREPGTag& tag,
+  ///                                                     std::vector<kodi::addon::PVRStreamProperty>& properties)
+  /// {
+  ///   ...
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_INPUTSTREAM, "inputstream.adaptive");
+  ///   properties.emplace_back("inputstream.adaptive.manifest_type", "mpd");
+  ///   properties.emplace_back("inputstream.adaptive.manifest_update_parameter", "full");
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_MIMETYPE, "application/xml+dash");
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetEPGTagStreamProperties(
       const kodi::addon::PVREPGTag& tag, std::vector<kodi::addon::PVRStreamProperty>& properties)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Tell the client the time frame to use when notifying epg events back to Kodi
+  ///
+  /// The client might push epg events asynchronously to Kodi using the callback function
+  /// @ref EpgEventStateChange. To be able to only push events that are actually of
+  /// interest for Kodi, client needs to know about the epg time frame Kodi uses. Kodi
+  /// supplies the current epg time frame value in @ref EpgMaxDays() when creating the
+  /// addon and calls @ref SetEPGTimeFrame later whenever Kodi's epg time frame value
+  /// changes.
+  ///
+  /// @param[in] days number of days from "now". @ref EPG_TIMEFRAME_UNLIMITED means that Kodi
+  ///                 is interested in all epg events, regardless of event times.
+  /// @return @ref PVR_ERROR_NO_ERROR if new value was successfully set.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsEPG "supportsEPG" is set to true.
+  ///
   virtual PVR_ERROR SetEPGTimeFrame(int days) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief Call one of the EPG related menu hooks (if supported).
+  ///
+  /// Supported @ref cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook instances have to be added in
+  /// `constructor()`, by calling @ref AddMenuHook() on the callback.
+  ///
+  /// @param[in] menuhook The hook to call.
+  /// @param[in] tag The selected EPG item for which the hook was called.
+  /// @return @ref PVR_ERROR_NO_ERROR if the hook was called successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook_Help
+  ///
   virtual PVR_ERROR CallEPGMenuHook(const kodi::addon::PVRMenuhook& menuhook,
                                     const kodi::addon::PVREPGTag& tag)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Get the Max days handled by Kodi.
+  ///
+  /// If > @ref EPG_TIMEFRAME_UNLIMITED, in async epg mode, deliver only events
+  /// in the range from 'end time > now' to 'start time < now + EpgMaxDays().
+  /// @ref EPG_TIMEFRAME_UNLIMITED, notify all events.
+  ///
+  /// @return The Max days handled by Kodi
+  ///
   inline int EpgMaxDays() const { return m_instanceData->props->iEpgMaxDays; }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Schedule an EPG update for the given channel channel.
+  ///
+  /// @param[in] channelUid The unique id of the channel for this add-on
+  ///
+  /// @remarks Only called from addon itself
+  ///
   inline void TriggerEpgUpdate(unsigned int channelUid)
   {
     m_instanceData->toKodi->TriggerEpgUpdate(m_instanceData->toKodi->kodiInstance, channelUid);
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Notify a state change for an EPG event.
+  ///
+  /// @param[in] tag The @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "EPG tag" where have event.
+  /// @param[in] newState The new state.
+  /// - For @ref EPG_EVENT_CREATED and @ref EPG_EVENT_UPDATED, tag must be filled with all available event data, not just a delta.
+  /// - For @ref EPG_EVENT_DELETED, it is sufficient to fill @ref kodi::addon::PVREPGTag::SetUniqueBroadcastId
+  ///
+  /// @remarks Only called from addon itself,
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  ///
+  /// void CMyPVRInstance::MyProcessFunction()
+  /// {
+  ///   ...
+  ///   kodi::addon::PVREPGTag tag; // Here as mini add, in real it should be a complete tag
+  ///   tag.SetUniqueId(123);
+  ///
+  ///   // added namespace here not needed to have, only to have more clear for where is
+  ///   kodi::addon::CInstancePVRClient::EpgEventStateChange(tag, EPG_EVENT_UPDATED);
+  ///   ...
+  /// }
+  ///
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   inline void EpgEventStateChange(kodi::addon::PVREPGTag& tag, EPG_EVENT_STATE newState)
   {
     m_instanceData->toKodi->EpgEventStateChange(m_instanceData->toKodi->kodiInstance, tag.GetTag(),
                                                 newState);
   }
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Recordings 5. Recordings (optional)
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief **PVR recording methods**\n
+  /// To transfer available recordings of the PVR backend and to allow possible
+  /// playback.
+  ///
+  /// @remarks Only used by Kodi if @ref PVRCapabilities::SetSupportsRecordings "supportsRecordings"
+  /// is set to true.\n\n
+  /// If a recordings changes after the initial import, or if a new one was added,
+  /// then the add-on should call @ref TriggerRecordingUpdate().
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief To get amount of recording present on backend
+  ///
+  /// @param[in] deleted if set return deleted recording (called if
+  ///                    @ref PVRCapabilities::SetSupportsRecordingsUndelete "supportsRecordingsUndelete"
+  ///                    set to true)
+  /// @param[out] amount The total amount of recordings on the backend
+  /// @return @ref PVR_ERROR_NO_ERROR if the amount has been fetched successfully.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings "supportsRecordings" is set to true.
+  ///
   virtual PVR_ERROR GetRecordingsAmount(bool deleted, int& amount)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Request the list of all recordings from the backend, if supported.
+  ///
+  /// Recording entries are added to Kodi by calling TransferRecordingEntry() on the callback.
+  ///
+  /// @param[in] deleted if set return deleted recording (called if
+  ///                    @ref PVRCapabilities::SetSupportsRecordingsUndelete "supportsRecordingsUndelete"
+  ///                    set to true)
+  /// @param[out] results List of available recordings with @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  ///                     becomes transferred with @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecordingsResultSet
+  ///                     and given to Kodi
+  /// @return @ref PVR_ERROR_NO_ERROR if the recordings have been fetched successfully.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings "supportsRecordings"
+  /// is set to true.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Recording_PVRRecording_Help
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetRecordings(bool deleted, kodi::addon::PVRRecordingsResultSet& results)
+  /// {
+  ///   // Minimal demo example, in reality bigger and loop to transfer all
+  ///   kodi::addon::PVRRecording recording;
+  ///   recording.SetRecordingId(123);
+  ///   recording.SetTitle("My recording name");
+  ///   ...
+  ///
+  ///   // Give it now to Kodi
+  ///   results.Add(recording);
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetRecordings(bool deleted, kodi::addon::PVRRecordingsResultSet& results)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Delete a recording on the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording to delete.
+  /// @return @ref PVR_ERROR_NO_ERROR if the recording has been deleted successfully.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings "supportsRecordings"
+  /// is set to true.
+  ///
   virtual PVR_ERROR DeleteRecording(const kodi::addon::PVRRecording& recording)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Undelete a recording on the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording to undelete.
+  /// @return @ref PVR_ERROR_NO_ERROR if the recording has been undeleted successfully.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordingsUndelete "supportsRecordingsUndelete"
+  /// is set to true.
+  ///
   virtual PVR_ERROR UndeleteRecording(const kodi::addon::PVRRecording& recording)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief  Delete all recordings permanent which in the deleted folder on the backend.
+  ///
+  /// @return @ref PVR_ERROR_NO_ERROR if the recordings has been deleted successfully.
+  ///
   virtual PVR_ERROR DeleteAllRecordingsFromTrash() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Rename a recording on the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  ///                      to rename, containing the new name.
+  /// @return @ref PVR_ERROR_NO_ERROR if the recording has been renamed successfully.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings "supportsRecordings"
+  /// is set to true.
+  ///
   virtual PVR_ERROR RenameRecording(const kodi::addon::PVRRecording& recording)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Set the lifetime of a recording on the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  ///                      to change the lifetime for. recording.iLifetime
+  ///                      contains the new lieftime value.
+  /// @return @ref PVR_ERROR_NO_ERROR if the recording's lifetime has been set
+  ///         successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsRecordingsLifetimeChange "supportsRecordingsLifetimeChange"
+  /// is set to true.
+  ///
   virtual PVR_ERROR SetRecordingLifetime(const kodi::addon::PVRRecording& recording)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Set the play count of a recording on the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  ///                      to change the play count.
+  /// @param[in] count Play count.
+  /// @return @ref PVR_ERROR_NO_ERROR if the recording's play count has been set
+  /// successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsRecordingPlayCount "supportsRecordingPlayCount"
+  /// is set to true.
+  ///
   virtual PVR_ERROR SetRecordingPlayCount(const kodi::addon::PVRRecording& recording, int count)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Set the last watched position of a recording on the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording.
+  /// @param[in] lastplayedposition The last watched position in seconds
+  /// @return @ref PVR_ERROR_NO_ERROR if the position has been stored successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsLastPlayedPosition "supportsLastPlayedPosition"
+  /// is set to true.
+  ///
   virtual PVR_ERROR SetRecordingLastPlayedPosition(const kodi::addon::PVRRecording& recording,
                                                    int lastplayedposition)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Retrieve the last watched position of a recording on the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording.
+  /// @param[out] position The last watched position in seconds
+  /// @return @ref PVR_ERROR_NO_ERROR if the amount has been fetched successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsRecordingPlayCount "supportsRecordingPlayCount"
+  /// is set to true.
+  ///
   virtual PVR_ERROR GetRecordingLastPlayedPosition(const kodi::addon::PVRRecording& recording,
                                                    int& position)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Retrieve the edit decision list (EDL) of a recording on the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording.
+  /// @param[out] edl The function has to write the EDL into this array.
+  /// @return @ref PVR_ERROR_NO_ERROR if the EDL was successfully read or no EDL exists.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsRecordingEdl "supportsRecordingEdl"
+  /// is set to true.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry_Help
+  ///
   virtual PVR_ERROR GetRecordingEdl(const kodi::addon::PVRRecording& recording,
                                     std::vector<kodi::addon::PVREDLEntry>& edl)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Retrieve the size of a recording on the backend.
+  ///
+  /// @param[in] recording The recording to get the size in bytes for.
+  /// @param[out] size The size in bytes of the recording
+  /// @return @ref PVR_ERROR_NO_ERROR if the recording's size has been set successfully.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsRecordingSize "supportsRecordingSize"
+  /// is set to true.
+  ///
   virtual PVR_ERROR GetRecordingSize(const kodi::addon::PVRRecording& recording, int64_t& size)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Get the stream properties for a recording from the backend.
+  ///
+  /// @param[in] recording The @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  ///                      to get the stream properties for.
+  /// @param[out] properties The properties required to play the stream.
+  /// @return @ref PVR_ERROR_NO_ERROR if the stream is available.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetSupportsRecordings "supportsRecordings"
+  /// is set to true and the add-on does not implement recording stream functions
+  /// (@ref OpenRecordedStream, ...).\n
+  /// In this case your implementation must fill the property @ref PVR_STREAM_PROPERTY_STREAMURL
+  /// with the URL Kodi should resolve to playback the recording.
+  ///
+  /// @note The value directly related to inputstream must always begin with the
+  /// name of the associated add-on, e.g. <b>`"inputstream.adaptive.manifest_update_parameter"`</b>.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetRecordingStreamProperties(const kodi::addon::PVRRecording& recording,
+  ///                                                        std::vector<kodi::addon::PVRStreamProperty>& properties)
+  /// {
+  ///   ...
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_INPUTSTREAM, "inputstream.adaptive");
+  ///   properties.emplace_back("inputstream.adaptive.manifest_type", "mpd");
+  ///   properties.emplace_back("inputstream.adaptive.manifest_update_parameter", "full");
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_MIMETYPE, "application/xml+dash");
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetRecordingStreamProperties(
       const kodi::addon::PVRRecording& recording,
       std::vector<kodi::addon::PVRStreamProperty>& properties)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @brief Call one of the recording related menu hooks (if supported).
+  ///
+  /// Supported @ref cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook instances have to be added in
+  /// `constructor()`, by calling @ref AddMenuHook() on the callback.
+  ///
+  /// @param[in] menuhook The hook to call.
+  /// @param[in] item The selected recording item for which the hook was called.
+  /// @return @ref PVR_ERROR_NO_ERROR if the hook was called successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook_Help
+  ///
   virtual PVR_ERROR CallRecordingMenuHook(const kodi::addon::PVRMenuhook& menuhook,
                                           const kodi::addon::PVRRecording& item)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Display a notification in Kodi that a recording started or stopped on the
+  /// server.
+  ///
+  /// @param[in] recordingName The name of the recording to display
+  /// @param[in] fileName The filename of the recording
+  /// @param[in] on True when recording started, false when it stopped
+  ///
+  /// @remarks Only called from addon itself
+  ///
   inline void RecordingNotification(const std::string& recordingName,
                                     const std::string& fileName,
                                     bool on)
@@ -253,93 +1856,650 @@ class CInstancePVRClient : public IAddonInstance
     m_instanceData->toKodi->RecordingNotification(m_instanceData->toKodi->kodiInstance,
                                                   recordingName.c_str(), fileName.c_str(), on);
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Request Kodi to update it's list of recordings.
+  ///
+  /// @remarks Only called from addon itself
+  ///
   inline void TriggerRecordingUpdate()
   {
     m_instanceData->toKodi->TriggerRecordingUpdate(m_instanceData->toKodi->kodiInstance);
   }
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Timers 6. Timers (optional)
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief **PVR timer methods**\n
+  /// For editing and displaying timed work, such as video recording.
+  ///
+  /// @remarks Only used by Kodi if @ref PVRCapabilities::SetSupportsTimers "supportsTimers"
+  /// is set to true.\n\n
+  /// If a timer changes after the initial import, or if a new one was added,
+  /// then the add-on should call @ref TriggerTimerUpdate().
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief Retrieve the timer types supported by the backend.
+  ///
+  /// @param[out] types The function has to write the definition of the
+  ///                   @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType types
+  ///                   into this array.
+  /// @return @ref PVR_ERROR_NO_ERROR if the types were successfully written to
+  ///         the array.
+  ///
+  /// @note Maximal 32 entries are allowed inside.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType_Help
+  ///
   virtual PVR_ERROR GetTimerTypes(std::vector<kodi::addon::PVRTimerType>& types)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief To get total amount of timers on the backend or -1 on error.
+  ///
+  /// @param[out] amount The total amount of timers on the backend
+  /// @return @ref PVR_ERROR_NO_ERROR if the amount has been fetched successfully.
+  ///
+  /// @note Required to use if @ref PVRCapabilities::SetSupportsTimers "supportsTimers"
+  /// is set to true.
+  ///
   virtual PVR_ERROR GetTimersAmount(int& amount) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Request the list of all timers from the backend if supported.
+  ///
+  /// @param[out] results List of available timers with @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimer
+  ///                     becomes transferred with @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimersResultSet
+  ///                     and given to Kodi
+  /// @return @ref PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+  ///
+  /// @note Required to use if @ref PVRCapabilities::SetSupportsTimers "supportsTimers"
+  /// is set to true.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Timer_PVRTimer_Help
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// PVR_ERROR CMyPVRInstance::GetTimers(kodi::addon::PVRTimersResultSet& results)
+  /// {
+  ///   // Minimal demo example, in reality bigger and loop to transfer all
+  ///   kodi::addon::PVRTimer timer;
+  ///   timer.SetClientIndex(123);
+  ///   timer.SetState(PVR_TIMER_STATE_SCHEDULED);
+  ///   timer.SetTitle("My timer name");
+  ///   ...
+  ///
+  ///   // Give it now to Kodi
+  ///   results.Add(timer);
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   virtual PVR_ERROR GetTimers(kodi::addon::PVRTimersResultSet& results)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Add a timer on the backend.
+  ///
+  /// @param[in] timer The timer to add.
+  /// @return @ref PVR_ERROR_NO_ERROR if the timer has been added successfully.
+  ///
+  /// @note Required to use if @ref PVRCapabilities::SetSupportsTimers "supportsTimers"
+  /// is set to true.
+  ///
   virtual PVR_ERROR AddTimer(const kodi::addon::PVRTimer& timer)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Delete a timer on the backend.
+  ///
+  /// @param[in] timer The timer to delete.
+  /// @param[in] forceDelete Set to true to delete a timer that is currently
+  ///                        recording a program.
+  /// @return @ref PVR_ERROR_NO_ERROR if the timer has been deleted successfully.
+  ///
+  /// @note Required to use if @ref PVRCapabilities::SetSupportsTimers "supportsTimers"
+  /// is set to true.
+  ///
   virtual PVR_ERROR DeleteTimer(const kodi::addon::PVRTimer& timer, bool forceDelete)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Update the timer information on the backend.
+  ///
+  /// @param[in] timer The timer to update.
+  /// @return @ref PVR_ERROR_NO_ERROR if the timer has been updated successfully.
+  ///
+  /// @note Required to use if @ref PVRCapabilities::SetSupportsTimers "supportsTimers"
+  /// is set to true.
+  ///
   virtual PVR_ERROR UpdateTimer(const kodi::addon::PVRTimer& timer)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Call one of the timer related menu hooks (if supported).
+  ///
+  /// Supported @ref cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook instances have
+  /// to be added in `constructor()`, by calling @ref AddMenuHook() on the
+  /// callback.
+  ///
+  /// @param[in] menuhook The hook to call.
+  /// @param[in] item The selected timer item for which the hook was called.
+  /// @return @ref PVR_ERROR_NO_ERROR if the hook was called successfully.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook_Help
+  ///
   virtual PVR_ERROR CallTimerMenuHook(const kodi::addon::PVRMenuhook& menuhook,
                                       const kodi::addon::PVRTimer& item)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Request Kodi to update it's list of timers.
+  ///
+  /// @remarks Only called from addon itself
+  ///
   inline void TriggerTimerUpdate()
   {
     m_instanceData->toKodi->TriggerTimerUpdate(m_instanceData->toKodi->kodiInstance);
   }
+  //----------------------------------------------------------------------------
 
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_PowerManagement 7. Power management events (optional)
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief **Used to notify the pvr addon for power management events**\n
+  /// Used to allow any energy savings.
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief To notify addon about system sleep
+  ///
+  /// @return @ref PVR_ERROR_NO_ERROR If successfully done.
+  ///
   virtual PVR_ERROR OnSystemSleep() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief To notify addon about system wake up
+  ///
+  /// @return @ref PVR_ERROR_NO_ERROR If successfully done.
+  ///
   virtual PVR_ERROR OnSystemWake() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief To notify addon power saving on system is activated
+  ///
+  /// @return @ref PVR_ERROR_NO_ERROR If successfully done.
+  ///
   virtual PVR_ERROR OnPowerSavingActivated() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief To notify addon power saving on system is deactivated
+  ///
+  /// @return @ref PVR_ERROR_NO_ERROR If successfully done.
+  ///
   virtual PVR_ERROR OnPowerSavingDeactivated() { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Streams 8. Inputstream
+  /// @ingroup cpp_kodi_addon_pvr
+  /// @brief **PVR Inputstream**\n
+  /// This includes functions that are used in the PVR inputstream.
+  ///
+  /// @warning The parts here will be removed in the future and replaced by the
+  /// separate @ref cpp_kodi_addon_inputstream "inputstream addon instance".
+  /// If there is already a possibility, new addons should do it via the
+  /// inputstream instance.
+  ///
+  ///@{
+
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Streams_TV 8.1. TV stream
+  /// @ingroup cpp_kodi_addon_pvr_Streams
+  /// @brief **PVR TV stream**\n
+  /// Stream processing regarding live TV.
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief Open a live stream on the backend.
+  ///
+  /// @param[in] channel The channel to stream.
+  /// @return True if the stream has been opened successfully, false otherwise.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Channel_PVRChannel_Help
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetHandlesInputStream() or
+  /// @ref PVRCapabilities::SetHandlesDemuxing() is set to true.
+  /// @ref CloseLiveStream() will always be called by Kodi prior to calling this
+  /// function.
+  ///
   virtual bool OpenLiveStream(const kodi::addon::PVRChannel& channel) { return false; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Close an open live stream.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetHandlesInputStream() or
+  /// @ref PVRCapabilities::SetHandlesDemuxing() is set to true.
+  ///
   virtual void CloseLiveStream() {}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Read from an open live stream.
+  ///
+  /// @param[in] pBuffer The buffer to store the data in.
+  /// @param[in] iBufferSize The amount of bytes to read.
+  /// @return The amount of bytes that were actually read from the stream.
+  ///
+  /// @remarks Required if @ref PVRCapabilities::SetHandlesInputStream() is set
+  /// to true.
+  ///
   virtual int ReadLiveStream(unsigned char* buffer, unsigned int size) { return 0; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Seek in a live stream on a backend that supports timeshifting.
+  ///
+  /// @param[in] position The position to seek to.
+  /// @param[in] whence [optional] offset relative to
+  ///                   You can set the value of whence to one of three things:
+  /// |   Value | int | Description |
+  /// |:--------:|:---:|:----------------------------------------------------|
+  /// | SEEK_SET |  0 | position is relative to the beginning of the file. This is probably what you had in mind anyway, and is the most commonly used value for whence.
+  /// | SEEK_CUR |  1 | position is relative to the current file pointer position. So, in effect, you can say, "Move to my current position plus 30 bytes," or, "move to my current position minus 20 bytes."
+  /// | SEEK_END |  2 | position is relative to the end of the file. Just like SEEK_SET except from the other end of the file. Be sure to use negative values for offset if you want to back up from the end of the file, instead of going past the end into oblivion.
+  ///
+  /// @return The new position.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetHandlesInputStream()
+  /// is set to true.
+  ///
   virtual int64_t SeekLiveStream(int64_t position, int whence) { return 0; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Obtain the length of a live stream.
+  ///
+  /// @return The total length of the stream that's currently being read.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetHandlesInputStream()
+  /// is set to true.
+  ///
   virtual int64_t LengthLiveStream() { return 0; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Streams_TV_Demux 8.1.1. Stream demuxing
+  /// @ingroup cpp_kodi_addon_pvr_Streams_TV
+  /// @brief **PVR stream demuxing**\n
+  /// Read TV streams with own demux within addon.
+  ///
+  /// This is only on Live TV streams and only if @ref PVRCapabilities::SetHandlesDemuxing()
+  /// has been set to "true".
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief Get the stream properties of the stream that's currently being read.
+  ///
+  /// @param[in] properties The properties of the currently playing stream.
+  /// @return @ref PVR_ERROR_NO_ERROR if the properties have been fetched successfully.
+  ///
+  /// @remarks Required, and only used if addon has its own demuxer.
+  ///
   virtual PVR_ERROR GetStreamProperties(std::vector<kodi::addon::PVRStreamProperties>& properties)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Read the next packet from the demultiplexer, if there is one.
+  ///
+  /// @return The next packet.
+  /// If there is no next packet, then the add-on should return the packet
+  /// created by calling @ref AllocateDemuxPacket(0) on the callback.
+  /// If the stream changed and Kodi's player needs to be reinitialised, then,
+  /// the add-on should call @ref AllocateDemuxPacket(0) on the callback, and set
+  /// the streamid to @ref DMX_SPECIALID_STREAMCHANGE and return the value.
+  /// The add-on should return `nullptr` if an error occured.
+  ///
+  /// @remarks Required, and only used if addon has its own demuxer.
+  /// Return `nullptr` if this add-on won't provide this function.
+  ///
   virtual DemuxPacket* DemuxRead() { return nullptr; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Reset the demultiplexer in the add-on.
+  ///
+  /// @remarks Required, and only used if addon has its own demuxer.
+  ///
   virtual void DemuxReset() {}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Abort the demultiplexer thread in the add-on.
+  ///
+  /// @remarks Required, and only used if addon has its own demuxer.
+  ///
   virtual void DemuxAbort() {}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Flush all data that's currently in the demultiplexer buffer in the
+  /// add-on.
+  ///
+  /// @remarks Required, and only used if addon has its own demuxer.
+  ///
   virtual void DemuxFlush() {}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Notify the pvr addon/demuxer that Kodi wishes to change playback
+  /// speed.
+  ///
+  /// @param[in] speed The requested playback speed
+  ///
+  /// @remarks Optional, and only used if addon has its own demuxer.
+  ///
   virtual void SetSpeed(int speed) {}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Notify the pvr addon/demuxer that Kodi wishes to fill demux queue.
+  ///
+  /// @param[in] mode The requested filling mode
+  ///
+  /// @remarks Optional, and only used if addon has its own demuxer.
+  ///
   virtual void FillBuffer(bool mode) {}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Notify the pvr addon/demuxer that Kodi wishes to seek the stream by
+  /// time.
+  ///
+  /// @param[in] time The absolute time since stream start
+  /// @param[in] backwards True to seek to keyframe BEFORE time, else AFTER
+  /// @param[in] startpts can be updated to point to where display should start
+  /// @return True if the seek operation was possible
+  ///
+  /// @remarks Optional, and only used if addon has its own demuxer.
+  ///          Return False if this add-on won't provide this function.
+  ///
   virtual bool SeekTime(double time, bool backwards, double& startpts) { return false; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Get the codec id used by Kodi.
+  ///
+  /// @param[in] codecName The name of the codec
+  /// @return The codec_id, or a codec_id with 0 values when not supported
+  ///
+  /// @remarks Only called from addon itself
+  ///
   inline PVRCodec GetCodecByName(const std::string& codecName) const
   {
     return PVRCodec(m_instanceData->toKodi->GetCodecByName(m_instanceData->toKodi->kodiInstance,
                                                            codecName.c_str()));
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Allocate a demux packet. Free with @ref FreeDemuxPacket().
+  ///
+  /// @param[in] iDataSize The size of the data that will go into the packet
+  /// @return The allocated packet
+  ///
+  /// @remarks Only called from addon itself
+  ///
   inline DemuxPacket* AllocateDemuxPacket(int iDataSize)
   {
     return m_instanceData->toKodi->AllocateDemuxPacket(m_instanceData->toKodi->kodiInstance,
                                                        iDataSize);
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief **Callback to Kodi Function**\n
+  /// Free a packet that was allocated with @ref AllocateDemuxPacket().
+  ///
+  /// @param[in] pPacket The packet to free
+  ///
+  /// @remarks Only called from addon itself.
+  ///
   inline void FreeDemuxPacket(DemuxPacket* pPacket)
   {
     m_instanceData->toKodi->FreeDemuxPacket(m_instanceData->toKodi->kodiInstance, pPacket);
   }
+  //----------------------------------------------------------------------------
+  ///@}
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Streams_Recording 8.2. Recording stream
+  /// @ingroup cpp_kodi_addon_pvr_Streams
+  /// @brief **PVR Recording stream**\n
+  /// Stream processing regarding recordings.
+  ///
+  /// @note Demuxing is not possible with the recordings.
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief Open a stream to a recording on the backend.
+  ///
+  /// @param[in] recording The recording to open.
+  /// @return True if the stream has been opened successfully, false otherwise.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings()
+  /// is set to true. @ref CloseRecordedStream() will always be called by Kodi
+  /// prior to calling this function.
+  ///
   virtual bool OpenRecordedStream(const kodi::addon::PVRRecording& recording) { return false; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Close an open stream from a recording.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings()
+  /// is set to true.
+  ///
   virtual void CloseRecordedStream() {}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Read from a recording.
+  ///
+  /// @param[in] buffer The buffer to store the data in.
+  /// @param[in] size The amount of bytes to read.
+  /// @return The amount of bytes that were actually read from the stream.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings()
+  /// is set to true.
+  ///
   virtual int ReadRecordedStream(unsigned char* buffer, unsigned int size) { return 0; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Seek in a recorded stream.
+  ///
+  /// @param[in] position The position to seek to.
+  /// @param[in] whence [optional] offset relative to
+  ///                   You can set the value of whence to one of three things:
+  /// |   Value | int | Description |
+  /// |:--------:|:---:|:----------------------------------------------------|
+  /// | SEEK_SET |  0 | position is relative to the beginning of the file. This is probably what you had in mind anyway, and is the most commonly used value for whence.
+  /// | SEEK_CUR |  1 | position is relative to the current file pointer position. So, in effect, you can say, "Move to my current position plus 30 bytes," or, "move to my current position minus 20 bytes."
+  /// | SEEK_END |  2 | position is relative to the end of the file. Just like SEEK_SET except from the other end of the file. Be sure to use negative values for offset if you want to back up from the end of the file, instead of going past the end into oblivion.
+  ///
+  /// @return The new position.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings()
+  /// is set to true.
+  ///
   virtual int64_t SeekRecordedStream(int64_t position, int whence) { return 0; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Obtain the length of a recorded stream.
+  ///
+  /// @return The total length of the stream that's currently being read.
+  ///
+  /// @remarks Optional, and only used if @ref PVRCapabilities::SetSupportsRecordings()
+  /// is true (=> @ref ReadRecordedStream).
+  ///
   virtual int64_t LengthRecordedStream() { return 0; }
+  //----------------------------------------------------------------------------
 
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
+
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Streams_Various 8.3. Various functions
+  /// @ingroup cpp_kodi_addon_pvr_Streams
+  /// @brief **Various other PVR stream related functions**\n
+  /// These apply to all other groups in inputstream and are therefore declared
+  /// as several.
+  ///
+  ///@{
+
+  //============================================================================
+  ///
+  /// @brief Check if the backend support pausing the currently playing stream.
+  ///
+  /// This will enable/disable the pause button in Kodi based on the return
+  /// value.
+  ///
+  /// @return false if the PVR addon/backend does not support pausing, true if
+  ///         possible
+  ///
   virtual bool CanPauseStream() { return false; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  ///
+  /// @brief Check if the backend supports seeking for the currently playing
+  /// stream.
+  ///
+  /// This will enable/disable the rewind/forward buttons in Kodi based on the
+  /// return value.
+  ///
+  /// @return false if the PVR addon/backend does not support seeking, true if
+  ///         possible
+  ///
   virtual bool CanSeekStream() { return false; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  ///
+  /// @brief Notify the pvr addon that Kodi (un)paused the currently playing
+  /// stream.
+  ///
+  /// @param[in] paused To inform by `true` is paused and with `false` playing
+  ///
   virtual void PauseStream(bool paused) {}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  ///
+  /// @brief Check for real-time streaming.
+  ///
+  /// @return true if current stream is real-time
+  ///
   virtual bool IsRealTimeStream() { return false; }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  ///
+  /// @brief Get stream times.
+  ///
+  /// @param[out] times A pointer to the data to be filled by the implementation.
+  /// @return @ref PVR_ERROR_NO_ERROR on success.
+  ///
   virtual PVR_ERROR GetStreamTimes(kodi::addon::PVRStreamTimes& times)
   {
     return PVR_ERROR_NOT_IMPLEMENTED;
   }
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  ///
+  /// @brief Obtain the chunk size to use when reading streams.
+  ///
+  /// @param[out] chunksize must be filled with the chunk size in bytes.
+  /// @return @ref PVR_ERROR_NO_ERROR if the chunk size has been fetched successfully.
+  ///
+  /// @remarks Optional, and only used if not reading from demuxer (=> @ref DemuxRead) and
+  /// @ref PVRCapabilities::SetSupportsRecordings() is true (=> @ref ReadRecordedStream) or
+  /// @ref PVRCapabilities::SetHandlesInputStream() is true (=> @ref ReadLiveStream).
+  ///
   virtual PVR_ERROR GetStreamReadChunkSize(int& chunksize) { return PVR_ERROR_NOT_IMPLEMENTED; }
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //--==----==----==----==----==----==----==----==----==----==----==----==----==
 
 private:
   void SetAddonStruct(KODI_HANDLE instance, const std::string& kodiVersion)
@@ -956,6 +3116,9 @@ class CInstancePVRClient : public IAddonInstance
         ->OnPowerSavingDeactivated();
   }
 
+  // obsolete parts below
+  ///@{
+
   inline static bool ADDON_OpenLiveStream(const AddonInstance_PVR* instance,
                                           const PVR_CHANNEL* channel)
   {
@@ -1126,9 +3289,12 @@ class CInstancePVRClient : public IAddonInstance
     return static_cast<CInstancePVRClient*>(instance->toAddon->addonInstance)
         ->GetStreamTimes(cppTimes);
   }
+  ///@}
 
   AddonInstance_PVR* m_instanceData = nullptr;
 };
+//}}}
+//______________________________________________________________________________
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/ChannelGroups.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/ChannelGroups.h
index b77ef01d2b0a..3464909f6995 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/ChannelGroups.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/ChannelGroups.h
@@ -11,6 +11,8 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr.h"
 
+//
+// "C++" Definitions group 3 - PVR channel group
 #ifdef __cplusplus
 
 namespace kodi
@@ -18,100 +20,242 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup class PVRChannelGroup
+/// @ingroup cpp_kodi_addon_pvr_Defs_ChannelGroup
+/// @brief **PVR add-on channel group**\n
+/// To define a group for channels, this becomes be asked from
+/// @ref kodi::addon::CInstancePVRClient::GetChannelGroups() and used on
+/// @ref kodi::addon::CInstancePVRClient::GetChannelGroupMembers() to get his
+/// content with @ref cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember "PVRChannelGroupMember".
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup_Help
+///
+///@{
 class PVRChannelGroup : public CStructHdl<PVRChannelGroup, PVR_CHANNEL_GROUP>
 {
 public:
+  /*! \cond PRIVATE */
   PVRChannelGroup() { memset(m_cStructure, 0, sizeof(PVR_CHANNEL_GROUP)); }
   PVRChannelGroup(const PVRChannelGroup& channel) : CStructHdl(channel) {}
   PVRChannelGroup(const PVR_CHANNEL_GROUP* channel) : CStructHdl(channel) {}
   PVRChannelGroup(PVR_CHANNEL_GROUP* channel) : CStructHdl(channel) {}
+  /*! \endcond */
 
+  /// @defgroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **Group name** | `std::string` | @ref PVRChannelGroup::SetGroupName "SetGroupName" | @ref PVRChannelGroup::GetGroupName "GetGroupName" | *required to set*
+  /// | **Is radio** | `bool` | @ref PVRChannelGroup::SetIsRadio "SetIsRadio" | @ref PVRChannelGroup::GetIsRadio "GetIsRadio" | *required to set*
+  /// | **Position** | `unsigned int` | @ref PVRChannelGroup::SetPosition "SetPosition" | @ref PVRChannelGroup::GetPosition "GetPosition" | *optional*
+  ///
+
+  /// @ingroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup
+  ///@{
+
+  /// @brief **required**\n
+  /// Name of this channel group.
   void SetGroupName(const std::string& groupName)
   {
     strncpy(m_cStructure->strGroupName, groupName.c_str(), sizeof(m_cStructure->strGroupName) - 1);
   }
+
+  /// @brief To get with @ref SetGroupName changed values.
   std::string GetGroupName() const { return m_cStructure->strGroupName; }
 
+  /// @brief **required**\n
+  /// **true** If this is a radio channel group, **false** otherwise.
   void SetIsRadio(bool isRadio) { m_cStructure->bIsRadio = isRadio; }
+
+  /// @brief To get with @ref SetIsRadio changed values.
   bool GetIsRadio() const { return m_cStructure->bIsRadio; }
 
+  /// @brief **optional**\n
+  /// Sort position of the group (<b>`0`</b> indicates that the backend doesn't
+  /// support sorting of groups).
   void SetPosition(unsigned int position) { m_cStructure->iPosition = position; }
+
+  /// @brief To get with @ref SetPosition changed values.
   unsigned int GetPosition() const { return m_cStructure->iPosition; }
+
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupsResultSet class PVRChannelGroupsResultSet
+/// @ingroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroup
+/// @brief **PVR add-on channel group member transfer class**\n
+/// To transfer the content of @ref kodi::addon::CInstancePVRClient::GetChannelGroups().
+///
+///@{
 class PVRChannelGroupsResultSet
 {
 public:
+  /*! \cond PRIVATE */
   PVRChannelGroupsResultSet() = delete;
   PVRChannelGroupsResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
     : m_instance(instance), m_handle(handle)
   {
   }
+  /*! \endcond */
+
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupsResultSet
+  ///@{
 
+  /// @brief To add and give content from addon to Kodi on related call.
+  ///
+  /// @param[in] tag The to transfered data.
   void Add(const kodi::addon::PVRChannelGroup& tag)
   {
     m_instance->toKodi->TransferChannelGroup(m_instance->toKodi->kodiInstance, m_handle, tag);
   }
 
+  ///@}
+
 private:
   const AddonInstance_PVR* m_instance = nullptr;
   const ADDON_HANDLE m_handle;
 };
+///@}
+//------------------------------------------------------------------------------
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember class PVRChannelGroupMember
+/// @ingroup cpp_kodi_addon_pvr_Defs_ChannelGroup
+/// @brief **PVR add-on channel group member**\n
+/// To define the content of @ref kodi::addon::CInstancePVRClient::GetChannelGroups()
+/// given groups.
+///
+/// This content becomes then requested with @ref kodi::addon::CInstancePVRClient::GetChannelGroupMembers().
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember_Help
+///
+///@{
 class PVRChannelGroupMember : public CStructHdl<PVRChannelGroupMember, PVR_CHANNEL_GROUP_MEMBER>
 {
 public:
+  /*! \cond PRIVATE */
   PVRChannelGroupMember() { memset(m_cStructure, 0, sizeof(PVR_CHANNEL_GROUP_MEMBER)); }
   PVRChannelGroupMember(const PVRChannelGroupMember& channel) : CStructHdl(channel) {}
   PVRChannelGroupMember(const PVR_CHANNEL_GROUP_MEMBER* channel) : CStructHdl(channel) {}
   PVRChannelGroupMember(PVR_CHANNEL_GROUP_MEMBER* channel) : CStructHdl(channel) {}
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |-------|-------|-----------|----------|-----------
+  /// | **Group name** | `std::string` | @ref PVRChannelGroupMember::SetGroupName "SetGroupName" | @ref PVRChannelGroupMember::GetGroupName "GetGroupName" | *required to set*
+  /// | **Channel unique id** | `unsigned int` | @ref PVRChannelGroupMember::SetChannelUniqueId "SetChannelUniqueId" | @ref PVRChannelGroupMember::GetChannelUniqueId "GetChannelUniqueId" | *required to set*
+  /// | **Channel Number** | `unsigned int` | @ref PVRChannelGroupMember::SetChannelNumber "SetChannelNumber" | @ref PVRChannelGroupMember::GetChannelNumber "GetChannelNumber" | *optional*
+  /// | **Sub channel number** | `unsigned int` | @ref PVRChannelGroupMember::SetSubChannelNumber "SetSubChannelNumber"| @ref PVRChannelGroupMember::GetSubChannelNumber "GetSubChannelNumber" | *optional*
+  /// | **Order** | `int` | @ref PVRChannel::SetOrder "SetOrder" | @ref PVRChannel::GetOrder "GetOrder" | *optional*
+  ///
 
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember
+  ///@{
+
+  /// @brief **required**\n
+  /// Name of the channel group to add the channel to.
   void SetGroupName(const std::string& groupName)
   {
     strncpy(m_cStructure->strGroupName, groupName.c_str(), sizeof(m_cStructure->strGroupName) - 1);
   }
+
+  /// @brief To get with @ref SetGroupName changed values.
   std::string GetGroupName() const { return m_cStructure->strGroupName; }
 
+  /// @brief **required**\n
+  /// Unique id of the member.
   void SetChannelUniqueId(unsigned int channelUniqueId)
   {
     m_cStructure->iChannelUniqueId = channelUniqueId;
   }
+
+  /// @brief To get with @ref SetChannelUniqueId changed values.
   unsigned int GetChannelUniqueId() const { return m_cStructure->iChannelUniqueId; }
 
+  /// @brief **optional**\n
+  /// Channel number within the group.
   void SetChannelNumber(unsigned int channelNumber)
   {
     m_cStructure->iChannelNumber = channelNumber;
   }
+
+  /// @brief To get with @ref SetChannelNumber changed values.
   unsigned int GetChannelNumber() const { return m_cStructure->iChannelNumber; }
 
+  /// @brief **optional**\n
+  /// Sub channel number within the group (ATSC).
   void SetSubChannelNumber(unsigned int subChannelNumber)
   {
     m_cStructure->iSubChannelNumber = subChannelNumber;
   }
+
+  /// @brief To get with @ref SetSubChannelNumber changed values.
   unsigned int GetSubChannelNumber() const { return m_cStructure->iSubChannelNumber; }
 
+  /// @brief **optional**\n
+  /// The value denoting the order of this channel in the <b>'All channels'</b> group.
   void SetOrder(bool order) { m_cStructure->iOrder = order; }
+
+  /// @brief To get with @ref SetOrder changed values.
   bool GetOrder() const { return m_cStructure->iOrder; }
+
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMembersResultSet class PVRChannelGroupMembersResultSet
+/// @ingroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMember
+/// @brief **PVR add-on channel group member transfer class**\n
+/// To transfer the content of @ref kodi::addon::CInstancePVRClient::GetChannelGroupMembers().
+///
+///@{
 class PVRChannelGroupMembersResultSet
 {
 public:
+  /*! \cond PRIVATE */
   PVRChannelGroupMembersResultSet() = delete;
   PVRChannelGroupMembersResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
     : m_instance(instance), m_handle(handle)
   {
   }
+  /*! \endcond */
 
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_ChannelGroup_PVRChannelGroupMembersResultSet
+  ///@{
+
+  /// @brief To add and give content from addon to Kodi on related call.
+  ///
+  /// @param[in] tag The to transfered data.
   void Add(const kodi::addon::PVRChannelGroupMember& tag)
   {
     m_instance->toKodi->TransferChannelGroupMember(m_instance->toKodi->kodiInstance, m_handle, tag);
   }
 
+  ///@}
+
 private:
   const AddonInstance_PVR* m_instance = nullptr;
   const ADDON_HANDLE m_handle;
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Channels.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Channels.h
index e284f2e7d5fb..454cd2887513 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Channels.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Channels.h
@@ -11,6 +11,8 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr.h"
 
+//
+// "C++" Definitions group 2 - PVR channel
 #ifdef __cplusplus
 
 namespace kodi
@@ -18,144 +20,354 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Channel_PVRChannel class PVRChannel
+/// @ingroup cpp_kodi_addon_pvr_Defs_Channel
+/// @brief **Channel data structure**\n
+/// Representation of a TV or radio channel.
+///
+/// This is used to store all the necessary TV or radio channel data and can
+/// either provide the necessary data from / to Kodi for the associated
+/// functions or can also be used in the addon to store its data.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Channel_PVRChannel_Help
+///
+///@{
 class PVRChannel : public CStructHdl<PVRChannel, PVR_CHANNEL>
 {
 public:
+  /*! \cond PRIVATE */
   PVRChannel() { memset(m_cStructure, 0, sizeof(PVR_CHANNEL)); }
   PVRChannel(const PVRChannel& channel) : CStructHdl(channel) {}
   PVRChannel(const PVR_CHANNEL* channel) : CStructHdl(channel) {}
   PVRChannel(PVR_CHANNEL* channel) : CStructHdl(channel) {}
-
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Channel_PVRChannel_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Channel_PVRChannel
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Channel_PVRChannel :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **Unique id** | `unsigned int` | @ref PVRChannel::SetUniqueId "SetUniqueId" | @ref PVRChannel::GetUniqueId "GetUniqueId" | *required to set*
+  /// | **Is radio** | `bool` | @ref PVRChannel::SetIsRadio "SetIsRadio" | @ref PVRChannel::GetIsRadio "GetIsRadio" | *required to set*
+  /// | **Channel number** | `unsigned int` | @ref PVRChannel::SetChannelNumber "SetChannelNumber" | @ref PVRChannel::GetChannelNumber "GetChannelNumber" | *optional*
+  /// | **Sub channel number** | `unsigned int` | @ref PVRChannel::SetSubChannelNumber "SetSubChannelNumber" | @ref PVRChannel::GetSubChannelNumber "GetSubChannelNumber" | *optional*
+  /// | **Channel name** | `std::string` | @ref PVRChannel::SetChannelName "SetChannelName" | @ref PVRChannel::GetChannelName "GetChannelName" | *optional*
+  /// | **Mime type** | `std::string` | @ref PVRChannel::SetMimeType "SetMimeType" | @ref PVRChannel::GetMimeType "GetMimeType" | *optional*
+  /// | **Encryption system** | `unsigned int` | @ref PVRChannel::SetEncryptionSystem "SetEncryptionSystem" | @ref PVRChannel::GetEncryptionSystem "GetEncryptionSystem" | *optional*
+  /// | **Icon path** | `std::string` | @ref PVRChannel::SetIconPath "SetIconPath" | @ref PVRChannel::GetIconPath "GetIconPath" | *optional*
+  /// | **Is hidden** | `bool` | @ref PVRChannel::SetIsHidden "SetIsHidden" | @ref PVRChannel::GetIsHidden "GetIsHidden" | *optional*
+  /// | **Has archive** | `bool` | @ref PVRChannel::SetHasArchive "SetHasArchive" | @ref PVRChannel::GetHasArchive "GetHasArchive" | *optional*
+  /// | **Order** | `int` | @ref PVRChannel::SetOrder "SetOrder" | @ref PVRChannel::GetOrder "GetOrder" | *optional*
+  ///
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Channel_PVRChannel
+  ///@{
+
+  /// @brief **required**\n
+  /// Unique identifier for this channel.
   void SetUniqueId(unsigned int uniqueId) { m_cStructure->iUniqueId = uniqueId; }
+
+  /// @brief To get with @ref SetUniqueId changed values.
   unsigned int GetUniqueId() const { return m_cStructure->iUniqueId; }
 
+  /// @brief **required**\n
+  /// **true** if this is a radio channel, **false** if it's a TV channel.
   void SetIsRadio(bool isRadio) { m_cStructure->bIsRadio = isRadio; }
+
+  /// @brief To get with @ref SetIsRadio changed values.
   bool GetIsRadio() const { return m_cStructure->bIsRadio; }
 
+  /// @brief **optional**\n
+  /// Channel number of this channel on the backend.
   void SetChannelNumber(unsigned int channelNumber)
   {
     m_cStructure->iChannelNumber = channelNumber;
   }
+
+  /// @brief To get with @ref SetChannelNumber changed values.
   unsigned int GetChannelNumber() const { return m_cStructure->iChannelNumber; }
 
+  /// @brief **optional**\n
+  /// Sub channel number of this channel on the backend (ATSC).
   void SetSubChannelNumber(unsigned int subChannelNumber)
   {
     m_cStructure->iSubChannelNumber = subChannelNumber;
   }
+
+  /// @brief To get with @ref SetSubChannelNumber changed values.
   unsigned int GetSubChannelNumber() const { return m_cStructure->iSubChannelNumber; }
 
+  /// @brief **optional**\n
+  /// Channel name given to this channel.
   void SetChannelName(const std::string& channelName)
   {
     strncpy(m_cStructure->strChannelName, channelName.c_str(),
             sizeof(m_cStructure->strChannelName) - 1);
   }
+
+  /// @brief To get with @ref SetChannelName changed values.
   std::string GetChannelName() const { return m_cStructure->strChannelName; }
 
+  /// @brief **optional**\n
+  /// Input format mime type.
+  ///
+  /// Available types can be found in https://www.iana.org/assignments/media-types/media-types.xhtml
+  /// on "application" and "video" or leave empty if unknown.
+  ///
   void SetMimeType(const std::string& inputFormat)
   {
     strncpy(m_cStructure->strMimeType, inputFormat.c_str(), sizeof(m_cStructure->strMimeType) - 1);
   }
+
+  /// @brief To get with @ref SetMimeType changed values.
   std::string GetMimeType() const { return m_cStructure->strMimeType; }
 
+  /// @brief **optional**\n
+  /// The encryption ID or CaID of this channel (Conditional access systems).
+  ///
+  /// Lists about available ID's:
+  /// - http://www.dvb.org/index.php?id=174
+  /// - http://en.wikipedia.org/wiki/Conditional_access_system
+  ///
   void SetEncryptionSystem(unsigned int encryptionSystem)
   {
     m_cStructure->iEncryptionSystem = encryptionSystem;
   }
+
+  /// @brief To get with @ref SetEncryptionSystem changed values.
   unsigned int GetEncryptionSystem() const { return m_cStructure->iEncryptionSystem; }
 
+  /// @brief **optional**\n
+  /// Path to the channel icon (if present).
   void SetIconPath(const std::string& iconPath)
   {
     strncpy(m_cStructure->strIconPath, iconPath.c_str(), sizeof(m_cStructure->strIconPath) - 1);
   }
+
+  /// @brief To get with @ref SetIconPath changed values.
   std::string GetIconPath() const { return m_cStructure->strIconPath; }
 
+  /// @brief **optional**\n
+  /// **true** if this channel is marked as hidden.
   void SetIsHidden(bool isHidden) { m_cStructure->bIsHidden = isHidden; }
+
+  /// @brief To get with @ref GetIsRadio changed values.
   bool GetIsHidden() const { return m_cStructure->bIsHidden; }
 
+  /// @brief **optional**\n
+  /// **true** if this channel has a server-side back buffer.
   void SetHasArchive(bool hasArchive) { m_cStructure->bHasArchive = hasArchive; }
+
+  /// @brief To get with @ref GetIsRadio changed values.
   bool GetHasArchive() const { return m_cStructure->bHasArchive; }
 
+  /// @brief **optional**\n
+  /// The value denoting the order of this channel in the 'All channels' group.
   void SetOrder(bool order) { m_cStructure->iOrder = order; }
+
+  /// @brief To get with @ref SetOrder changed values.
   bool GetOrder() const { return m_cStructure->iOrder; }
+  ///@}
 };
-
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Channel_PVRChannelsResultSet class PVRChannelsResultSet
+/// @ingroup cpp_kodi_addon_pvr_Defs_Channel_PVRChannel
+/// @brief **PVR add-on channel transfer class**\n
+/// To transfer the content of @ref kodi::addon::CInstancePVRClient::GetChannels().
+///
+///@{
 class PVRChannelsResultSet
 {
 public:
+  /*! \cond PRIVATE */
   PVRChannelsResultSet() = delete;
   PVRChannelsResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
     : m_instance(instance), m_handle(handle)
   {
   }
+  /*! \endcond */
 
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Channel_PVRChannelsResultSet
+  ///@{
+
+  /// @brief To add and give content from addon to Kodi on related call.
+  ///
+  /// @param[in] tag The to transfered data.
   void Add(const kodi::addon::PVRChannel& tag)
   {
     m_instance->toKodi->TransferChannelEntry(m_instance->toKodi->kodiInstance, m_handle, tag);
   }
 
+  ///@}
+
 private:
   const AddonInstance_PVR* m_instance = nullptr;
   const ADDON_HANDLE m_handle;
 };
-
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Channel_PVRSignalStatus class PVRSignalStatus
+/// @ingroup cpp_kodi_addon_pvr_Defs_Channel
+/// @brief **PVR Signal status information**\n
+/// This class gives current status information from stream to Kodi.
+///
+/// Used to get information for user by call of @ref kodi::addon::CInstancePVRClient::GetSignalStatus()
+/// to see current quality and source.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Channel_PVRSignalStatus_Help
+///
+///@{
 class PVRSignalStatus : public CStructHdl<PVRSignalStatus, PVR_SIGNAL_STATUS>
 {
 public:
+  /*! \cond PRIVATE */
   PVRSignalStatus() = default;
   PVRSignalStatus(const PVRSignalStatus& type) : CStructHdl(type) {}
   PVRSignalStatus(const PVR_SIGNAL_STATUS* type) : CStructHdl(type) {}
   PVRSignalStatus(PVR_SIGNAL_STATUS* type) : CStructHdl(type) {}
-
+  /*! \endcond */
+
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Channel_PVRSignalStatus_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Channel_PVRSignalStatus
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Channel_PVRSignalStatus :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **Adapter name** | `std::string` | @ref PVRSignalStatus::SetAdapterName "SetAdapterName" | @ref PVRSignalStatus::GetAdapterName "GetAdapterName" | *optional*
+  /// | **Adapter status** | `std::string` | @ref PVRSignalStatus::SetAdapterStatus "SetAdapterStatus" | @ref PVRSignalStatus::GetAdapterStatus "GetAdapterStatus" | *optional*
+  /// | **Service name** | `std::string` | @ref PVRSignalStatus::SetServiceName "SetServiceName" | @ref PVRSignalStatus::GetServiceName "GetServiceName" | *optional*
+  /// | **Provider name** | `std::string` | @ref PVRSignalStatus::SetProviderName "SetProviderName" | @ref PVRSignalStatus::GetProviderName "GetProviderName" | *optional*
+  /// | **Mux name** | `std::string` | @ref PVRSignalStatus::SetMuxName "SetMuxName" | @ref PVRSignalStatus::GetMuxName "GetMuxName" | *optional*
+  /// | **Signal/noise ratio** | `int` | @ref PVRSignalStatus::SetSNR "SetSNR" | @ref PVRSignalStatus::GetSNR "GetSNR" | *optional*
+  /// | **Signal strength** | `int` | @ref PVRSignalStatus::SetSignal "SetSignal" | @ref PVRSignalStatus::GetSignal "GetSignal" | *optional*
+  /// | **Bit error rate** | `long` | @ref PVRSignalStatus::SetBER "SetBER" | @ref PVRSignalStatus::GetBER "GetBER" | *optional*
+  /// | **Uncorrected blocks** | `long` | @ref PVRSignalStatus::SetUNC "SetUNC" | @ref PVRSignalStatus::GetUNC "GetUNC" | *optional*
+  ///
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Channel_PVRSignalStatus
+  ///@{
+
+  /// @brief **optional**\n
+  /// Name of the adapter that's being used.
   void SetAdapterName(const std::string& adapterName)
   {
     strncpy(m_cStructure->strAdapterName, adapterName.c_str(),
             sizeof(m_cStructure->strAdapterName) - 1);
   }
+
+  /// @brief To get with @ref SetAdapterName changed values.
   std::string GetAdapterName() const { return m_cStructure->strAdapterName; }
 
+  /// @brief **optional**\n
+  /// Status of the adapter that's being used.
   void SetAdapterStatus(const std::string& adapterStatus)
   {
     strncpy(m_cStructure->strAdapterStatus, adapterStatus.c_str(),
             sizeof(m_cStructure->strAdapterStatus) - 1);
   }
+
+  /// @brief To get with @ref SetAdapterStatus changed values.
   std::string GetAdapterStatus() const { return m_cStructure->strAdapterStatus; }
 
+  /// @brief **optional**\n
+  /// Name of the current service.
   void SetServiceName(const std::string& serviceName)
   {
     strncpy(m_cStructure->strServiceName, serviceName.c_str(),
             sizeof(m_cStructure->strServiceName) - 1);
   }
+
+  /// @brief To get with @ref SetServiceName changed values.
   std::string GetServiceName() const { return m_cStructure->strServiceName; }
 
+  /// @brief **optional**\n
+  /// Name of the current service's provider.
   void SetProviderName(const std::string& providerName)
   {
     strncpy(m_cStructure->strProviderName, providerName.c_str(),
             sizeof(m_cStructure->strProviderName) - 1);
   }
+
+  /// @brief To get with @ref SetProviderName changed values.
   std::string GetProviderName() const { return m_cStructure->strProviderName; }
 
+  /// @brief **optional**\n
+  /// Name of the current mux.
   void SetMuxName(const std::string& muxName)
   {
     strncpy(m_cStructure->strMuxName, muxName.c_str(), sizeof(m_cStructure->strMuxName) - 1);
   }
+
+  /// @brief To get with @ref SetMuxName changed values.
   std::string GetMuxName() const { return m_cStructure->strMuxName; }
 
+  /// @brief **optional**\n
+  /// Signal/noise ratio.
+  ///
+  /// @note 100% is 0xFFFF 65535
   void SetSNR(int snr) { m_cStructure->iSNR = snr; }
+
+  /// @brief To get with @ref SetSNR changed values.
   int GetSNR() const { return m_cStructure->iSNR; }
 
+  /// @brief **optional**\n
+  /// Signal strength.
+  ///
+  /// @note 100% is 0xFFFF 65535
   void SetSignal(int signal) { m_cStructure->iSignal = signal; }
+
+  /// @brief To get with @ref SetSignal changed values.
   int GetSignal() const { return m_cStructure->iSignal; }
 
+  /// @brief **optional**\n
+  /// Bit error rate.
   void SetBER(long ber) { m_cStructure->iBER = ber; }
+
+  /// @brief To get with @ref SetBER changed values.
   long GetBER() const { return m_cStructure->iBER; }
 
+  /// @brief **optional**\n
+  /// Uncorrected blocks:
   void SetUNC(long unc) { m_cStructure->iUNC = unc; }
+
+  /// @brief To get with @ref SetBER changed values.
   long GetUNC() const { return m_cStructure->iUNC; }
+  ///@}
 };
-
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo class PVRDescrambleInfo
+/// @ingroup cpp_kodi_addon_pvr_Defs_Channel
+/// @brief **Data structure for descrample info**\n
+/// Information data to give via this to Kodi.
+///
+/// As description see also here https://en.wikipedia.org/wiki/Conditional_access.
+///
+/// Used on @ref kodi::addon::CInstancePVRClient::GetDescrambleInfo().
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo_Help
+///
+///@{
 class PVRDescrambleInfo : public CStructHdl<PVRDescrambleInfo, PVR_DESCRAMBLE_INFO>
 {
 public:
+  /*! \cond PRIVATE */
   PVRDescrambleInfo()
   {
     m_cStructure->iPid = PVR_DESCRAMBLE_INFO_NOT_AVAILABLE;
@@ -167,47 +379,126 @@ class PVRDescrambleInfo : public CStructHdl<PVRDescrambleInfo, PVR_DESCRAMBLE_IN
   PVRDescrambleInfo(const PVRDescrambleInfo& type) : CStructHdl(type) {}
   PVRDescrambleInfo(const PVR_DESCRAMBLE_INFO* type) : CStructHdl(type) {}
   PVRDescrambleInfo(PVR_DESCRAMBLE_INFO* type) : CStructHdl(type) {}
-
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **Packet identifier** | `int` | @ref PVRDescrambleInfo::SetPID "SetPID" | @ref PVRDescrambleInfo::GetPID "GetPID" | *optional*
+  /// | **Conditional access identifier** | `int` | @ref PVRDescrambleInfo::SetCAID "SetCAID" | @ref PVRDescrambleInfo::GetCAID "GetCAID" | *optional*
+  /// | **Provider-ID** | `int` | @ref PVRDescrambleInfo::SetProviderID "SetProviderID" | @ref PVRDescrambleInfo::GetProviderID "GetProviderID" | *optional*
+  /// | **ECM time** | `int` | @ref PVRDescrambleInfo::SetECMTime "SetECMTime" | @ref PVRDescrambleInfo::GetECMTime "GetECMTime" | *optional*
+  /// | **Hops** | `int` | @ref PVRDescrambleInfo::SetHops "SetHops" | @ref PVRDescrambleInfo::GetHops "GetHops" | *optional*
+  /// | **Descramble card system** | `std::string` | @ref PVRDescrambleInfo::SetHops "SetHops" | @ref PVRDescrambleInfo::GetHops "GetHops" | *optional*
+  /// | **Reader** | `std::string` | @ref PVRDescrambleInfo::SetReader "SetReader" | @ref PVRDescrambleInfo::GetReader "GetReader" | *optional*
+  /// | **From** | `std::string` | @ref PVRDescrambleInfo::SetFrom "SetFrom" | @ref PVRDescrambleInfo::GetFrom "GetFrom" | *optional*
+  /// | **Protocol** | `std::string` | @ref PVRDescrambleInfo::SetProtocol "SetProtocol" | @ref PVRDescrambleInfo::GetProtocol "GetProtocol" | *optional*
+  ///
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo
+  ///@{
+
+  /// @brief **optional**\n
+  /// Packet identifier.
+  ///
+  /// Each table or elementary stream in a transport stream is identified by
+  /// a 13-bit packet identifier (PID).
+  ///
+  /// Is @ref PVR_DESCRAMBLE_INFO_NOT_AVAILABLE as default, if not available
   void SetPID(int pid) { m_cStructure->iPid = pid; }
+
+  /// @brief To get with @ref SetPID changed values
   int GetPID() const { return m_cStructure->iPid; }
 
+  /// @brief **optional**\n
+  /// Conditional access identifier.
+  ///
+  /// Conditional access (abbreviated CA) or conditional access system (abbreviated CAS)
+  /// is the protection of content by requiring certain criteria to be met before granting
+  /// access to the content.
+  ///
+  /// Available CA system ID's listed here https://www.dvbservices.com/identifiers/ca_system_id.
+  ///
+  /// @ref PVR_DESCRAMBLE_INFO_NOT_AVAILABLE if not available.
   void SetCAID(int iCaid) { m_cStructure->iCaid = iCaid; }
+
+  /// @brief To get with @ref SetCAID changed values.
   int GetCAID() const { return m_cStructure->iCaid; }
 
+  /// @brief **optional**\n
+  /// Provider-ID.
+  ///
+  /// Is @ref PVR_DESCRAMBLE_INFO_NOT_AVAILABLE as default, if not available.
   void SetProviderID(int provid) { m_cStructure->iProvid = provid; }
+
+  /// @brief To get with @ref SetProviderID changed values
   int GetProviderID() const { return m_cStructure->iProvid; }
 
+  /// @brief **optional**\n
+  /// ECM time.
+  ///
+  /// Is @ref PVR_DESCRAMBLE_INFO_NOT_AVAILABLE as default, if not available.
   void SetECMTime(int ecmTime) { m_cStructure->iEcmTime = ecmTime; }
+
+  /// @brief To get with @ref SetECMTime changed values.
   int GetECMTime() const { return m_cStructure->iEcmTime; }
 
+  /// @brief **optional**\n
+  /// Hops.
+  ///
+  /// Is @ref PVR_DESCRAMBLE_INFO_NOT_AVAILABLE as default, if not available.
   void SetHops(int hops) { m_cStructure->iHops = hops; }
+
+  /// @brief To get with @ref SetHops changed values.
   int GetHops() const { return m_cStructure->iHops; }
 
+  /// @brief **optional**\n
+  /// Empty string if not available.
   void SetCardSystem(const std::string& cardSystem)
   {
     strncpy(m_cStructure->strCardSystem, cardSystem.c_str(),
             sizeof(m_cStructure->strCardSystem) - 1);
   }
+
+  /// @brief To get with @ref SetCardSystem changed values.
   std::string GetCardSystem() const { return m_cStructure->strCardSystem; }
 
+  /// @brief **optional**\n
+  /// Empty string if not available.
   void SetReader(const std::string& reader)
   {
     strncpy(m_cStructure->strReader, reader.c_str(), sizeof(m_cStructure->strReader) - 1);
   }
+
+  /// @brief To get with @ref SetReader changed values.
   std::string GetReader() const { return m_cStructure->strReader; }
 
+  /// @brief **optional**\n
+  /// Empty string if not available.
   void SetFrom(const std::string& from)
   {
     strncpy(m_cStructure->strFrom, from.c_str(), sizeof(m_cStructure->strFrom) - 1);
   }
+
+  /// @brief To get with @ref SetFrom changed values.
   std::string GetFrom() const { return m_cStructure->strFrom; }
 
+  /// @brief **optional**\n
+  /// Empty string if not available.
   void SetProtocol(const std::string& protocol)
   {
     strncpy(m_cStructure->strProtocol, protocol.c_str(), sizeof(m_cStructure->strProtocol) - 1);
   }
+
+  /// @brief To get with @ref SetProtocol changed values.
   std::string GetProtocol() const { return m_cStructure->strProtocol; }
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EDL.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EDL.h
index 6ff9b1756b0c..0fb31527237a 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EDL.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EDL.h
@@ -11,6 +11,8 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr/pvr_edl.h"
 
+//
+// "C++" Definitions group 8 - PVR Edit definition list (EDL)
 #ifdef __cplusplus
 
 namespace kodi
@@ -18,23 +20,65 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry class PVREDLEntry
+/// @ingroup cpp_kodi_addon_pvr_Defs_EDLEntry
+/// @brief **Edit definition list (EDL) entry**\n
+/// Time places and type of related fields.
+///
+/// This used within @ref cpp_kodi_addon_pvr_EPGTag "EPG" and
+/// @ref cpp_kodi_addon_pvr_Recordings "recordings".
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry_Help
+///
+///@{
 class PVREDLEntry : public CStructHdl<PVREDLEntry, PVR_EDL_ENTRY>
 {
 public:
+  /*! \cond PRIVATE */
   PVREDLEntry() { memset(m_cStructure, 0, sizeof(PVR_EDL_ENTRY)); }
   PVREDLEntry(const PVREDLEntry& type) : CStructHdl(type) {}
   PVREDLEntry(const PVR_EDL_ENTRY* type) : CStructHdl(type) {}
   PVREDLEntry(PVR_EDL_ENTRY* type) : CStructHdl(type) {}
+  /*! \endcond */
 
+  /// @defgroup cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **Start time** | `int64_t` | @ref PVREDLEntry::SetStart "SetStart" | @ref PVREDLEntry::GetStart "GetStart" | *required to set*
+  /// | **End time** | `int64_t` | @ref PVREDLEntry::SetEnd "SetEnd" | @ref PVREDLEntry::GetEnd "GetEnd" | *required to set*
+  /// | **Type** | @ref PVR_EDL_TYPE | @ref PVREDLEntry::SetType "SetType" | @ref PVREDLEntry::GetType "GetType" | *required to set*
+  ///
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry
+  ///@{
+
+  /// @brief Start time in milliseconds.
   void SetStart(int64_t start) { m_cStructure->start = start; }
+
+  /// @brief To get with @ref SetStart() changed values.
   int64_t GetStart() const { return m_cStructure->start; }
 
+  /// @brief End time in milliseconds.
   void SetEnd(int64_t end) { m_cStructure->end = end; }
+
+  /// @brief To get with @ref SetEnd() changed values.
   int64_t GetEnd() const { return m_cStructure->end; }
 
+  /// @brief The with @ref PVR_EDL_TYPE used definition list type.
   void SetType(PVR_EDL_TYPE type) { m_cStructure->type = type; }
+
+  /// @brief To get with @ref SetType() changed values.
   PVR_EDL_TYPE GetType() const { return m_cStructure->type; }
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EPG.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EPG.h
index 6facd2ac5712..cdfb304a8e2b 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EPG.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/EPG.h
@@ -11,6 +11,8 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr.h"
 
+//
+// "C++" Definitions group 4 - PVR EPG
 #ifdef __cplusplus
 
 namespace kodi
@@ -18,9 +20,26 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_epg_PVREPGTag class PVREPGTag
+/// @ingroup cpp_kodi_addon_pvr_Defs_epg
+/// @brief **PVR add-on EPG data tag**\n
+/// Representation of an EPG event.
+///
+/// Herewith all EPG related data are saved in one class whereby the data can
+/// be exchanged with Kodi, or can also be used on the addon to save there.
+///
+/// See @ref cpp_kodi_addon_pvr_EPGTag "EPG methods" about usage.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_epg_PVREPGTag_Help
+///
+///@{
 class PVREPGTag : public CStructHdl<PVREPGTag, EPG_TAG>
 {
 public:
+  /*! \cond PRIVATE */
   PVREPGTag()
   {
     memset(m_cStructure, 0, sizeof(EPG_TAG));
@@ -46,97 +65,334 @@ class PVREPGTag : public CStructHdl<PVREPGTag, EPG_TAG>
   }
   PVREPGTag(const EPG_TAG* epg) : CStructHdl(epg) { SetData(epg); }
   PVREPGTag(EPG_TAG* epg) : CStructHdl(epg) { SetData(epg); }
-
+  /*! \endcond */
+
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_epg_PVREPGTag_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_PVREPGTag
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|---------
+  /// | **Unique broadcast id** | `unsigned int` | @ref PVREPGTag::SetUniqueBroadcastId "SetUniqueBroadcastId" | @ref PVREPGTag::GetUniqueBroadcastId "GetUniqueBroadcastId" | *required to set*
+  /// | **Unique channel id** | `unsigned int` | @ref PVREPGTag::SetUniqueChannelId "SetUniqueChannelId" | @ref PVREPGTag::GetUniqueChannelId "GetUniqueChannelId" | *required to set*
+  /// | **Title** | `std::string` | @ref PVREPGTag::SetTitle "SetTitle" | @ref PVREPGTag::GetTitle "GetTitle" | *required to set*
+  /// | **Start time** | `time_t` | @ref PVREPGTag::SetStartTime "SetStartTime" | @ref PVREPGTag::GetStartTime "GetStartTime" | *required to set*
+  /// | **End time** | `time_t` | @ref PVREPGTag::SetEndTime "SetEndTime" | @ref PVREPGTag::GetEndTime "GetEndTime" | *required to set*
+  /// | **Plot outline** | `std::string` | @ref PVREPGTag::SetPlotOutline "SetPlotOutline" | @ref PVREPGTag::GetPlotOutline "GetPlotOutline" | *optional*
+  /// | **Plot** | `std::string` | @ref PVREPGTag::SetPlot "SetPlot" | @ref PVREPGTag::GetPlot "GetPlot" | *optional*
+  /// | **Original title** | `std::string` | @ref PVREPGTag::SetOriginalTitle "SetOriginalTitle" | @ref PVREPGTag::GetOriginalTitle "GetOriginalTitle" | *optional*
+  /// | **Cast** | `std::string` | @ref PVREPGTag::SetCast "SetCast" | @ref PVREPGTag::GetCast "GetCast" | *optional*
+  /// | **Director** | `std::string` | @ref PVREPGTag::SetDirector "SetDirector" | @ref PVREPGTag::GetDirector "GetDirector" | *optional*
+  /// | **Writer** | `std::string` | @ref PVREPGTag::SetWriter "SetWriter" | @ref PVREPGTag::GetWriter "GetWriter" | *optional*
+  /// | **Year** | `int` | @ref PVREPGTag::SetYear "SetYear" | @ref PVREPGTag::GetYear "GetYear" | *optional*
+  /// | **IMDB number** | `std::string` | @ref PVREPGTag::SetIMDBNumber "SetIMDBNumber" | @ref PVREPGTag::GetIMDBNumber "GetIMDBNumber" | *optional*
+  /// | **Icon path** | `std::string` | @ref PVREPGTag::SetIconPath "SetIconPath" | @ref PVREPGTag::GetIconPath "GetIconPath" | *optional*
+  /// | **Genre type** | `int` | @ref PVREPGTag::SetGenreType "SetGenreType" | @ref PVREPGTag::GetGenreType "GetGenreType" | *optional*
+  /// | **Genre sub type** | `int` | @ref PVREPGTag::SetGenreSubType "SetGenreSubType" | @ref PVREPGTag::GetGenreSubType "GetGenreSubType" | *optional*
+  /// | **Genre description** | `std::string` | @ref PVREPGTag::SetGenreDescription "SetGenreDescription" | @ref PVREPGTag::GetGenreDescription "GetGenreDescription" | *optional*
+  /// | **First aired** | `time_t` | @ref PVREPGTag::SetFirstAired "SetFirstAired" | @ref PVREPGTag::GetFirstAired "GetFirstAired" | *optional*
+  /// | **Parental rating** | `int` | @ref PVREPGTag::SetParentalRating "SetParentalRating" | @ref PVREPGTag::GetParentalRating "GetParentalRating" | *optional*
+  /// | **Star rating** | `int` | @ref PVREPGTag::SetStarRating "SetStarRating" | @ref PVREPGTag::GetStarRating "GetStarRating" | *optional*
+  /// | **Series number** | `int` | @ref PVREPGTag::SetSeriesNumber "SetSeriesNumber" | @ref PVREPGTag::GetSeriesNumber "GetSeriesNumber" | *optional*
+  /// | **Episode number** | `int` | @ref PVREPGTag::SetEpisodeNumber "SetEpisodeNumber" | @ref PVREPGTag::GetEpisodeNumber "GetEpisodeNumber" | *optional*
+  /// | **Episode part number** | `int` | @ref PVREPGTag::SetEpisodePartNumber "SetEpisodePartNumber" | @ref PVREPGTag::GetEpisodePartNumber "GetEpisodePartNumber" | *optional*
+  /// | **Episode name** | `std::string` | @ref PVREPGTag::SetEpisodeName "SetEpisodeName" | @ref PVREPGTag::GetEpisodeName "GetEpisodeName" | *optional*
+  /// | **Flags** | `unsigned int` | @ref PVREPGTag::SetFlags "SetFlags" | @ref PVREPGTag::GetFlags "GetFlags" | *optional*
+  /// | **Series link** | `std::string` | @ref PVREPGTag::SetSeriesLink "SetSeriesLink" | @ref PVREPGTag::GetSeriesLink "GetSeriesLink" | *optional*
+  ///
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_epg_PVREPGTag
+  ///@{
+
+  /// @brief **required**\n
+  /// Identifier for this event. Event uids must be unique for a channel. Valid uids must be greater than @ref EPG_TAG_INVALID_UID.
   void SetUniqueBroadcastId(unsigned int uniqueBroadcastId)
   {
     m_cStructure->iUniqueBroadcastId = uniqueBroadcastId;
   }
+
+  /// @brief To get with @ref SetUniqueBroadcastId changed values.
   unsigned int GetUniqueBroadcastId() const { return m_cStructure->iUniqueBroadcastId; }
 
+  /// @brief **required**\n
+  /// Unique identifier of the channel this event belongs to.
   void SetUniqueChannelId(unsigned int uniqueChannelId)
   {
     m_cStructure->iUniqueChannelId = uniqueChannelId;
   }
+
+  /// @brief To get with @ref SetUniqueChannelId changed values
   unsigned int GetUniqueChannelId() const { return m_cStructure->iUniqueChannelId; }
 
+  /// @brief **required**\n
+  /// This event's title.
   void SetTitle(const std::string& title) { m_title = title; }
+
+  /// @brief To get with @ref SetTitle changed values.
   std::string GetTitle() const { return m_title; }
 
+  /// @brief **required**\n
+  /// Start time in UTC.
+  ///
+  /// Seconds elapsed since 00:00 hours, Jan 1, 1970 UTC.
   void SetStartTime(time_t startTime) { m_cStructure->startTime = startTime; }
+
+  /// @brief To get with @ref SetStartTime changed values.
   time_t GetStartTime() const { return m_cStructure->startTime; }
 
+  /// @brief **required**\n
+  /// End time in UTC.
+  ///
+  /// Seconds elapsed since 00:00 hours, Jan 1, 1970 UTC.
   void SetEndTime(time_t endTime) { m_cStructure->endTime = endTime; }
+
+  /// @brief To get with @ref SetEndTime changed values.
   time_t GetEndTime() const { return m_cStructure->endTime; }
 
+  /// @brief **optional**\n
+  /// Plot outline name.
   void SetPlotOutline(const std::string& plotOutline) { m_plotOutline = plotOutline; }
+
+  /// @brief To get with @ref SetPlotOutline changed values.
   std::string GetPlotOutline() const { return m_plotOutline; }
 
+  /// @brief **optional**\n
+  /// Plot name.
   void SetPlot(const std::string& plot) { m_plot = plot; }
+
+  /// @brief To get with @ref GetPlot changed values.
   std::string GetPlot() const { return m_plot; }
 
+  /// @brief **optional**\n
+  /// Original title.
   void SetOriginalTitle(const std::string& originalTitle) { m_originalTitle = originalTitle; }
+
+  /// @brief To get with @ref SetOriginalTitle changed values
   std::string GetOriginalTitle() const { return m_originalTitle; }
 
+  /// @brief **optional**\n
+  /// Cast name(s).
+  ///
+  /// @note Use @ref EPG_STRING_TOKEN_SEPARATOR to separate different persons.
   void SetCast(const std::string& cast) { m_cast = cast; }
+
+  /// @brief To get with @ref SetCast changed values
   std::string GetCast() const { return m_cast; }
 
+  /// @brief **optional**\n
+  /// Director name(s).
+  ///
+  /// @note Use @ref EPG_STRING_TOKEN_SEPARATOR to separate different persons.
   void SetDirector(const std::string& director) { m_director = director; }
+
+  /// @brief To get with @ref SetDirector changed values.
   std::string GetDirector() const { return m_director; }
 
+  /// @brief **optional**\n
+  /// Writer name(s).
+  ///
+  /// @note Use @ref EPG_STRING_TOKEN_SEPARATOR to separate different persons.
   void SetWriter(const std::string& writer) { m_writer = writer; }
+
+  /// @brief To get with @ref SetDirector changed values
   std::string GetWriter() const { return m_writer; }
 
+  /// @brief **optional**\n
+  /// Year.
   void SetYear(int year) { m_cStructure->iYear = year; }
+
+  /// @brief To get with @ref SetYear changed values.
   int GetYear() const { return m_cStructure->iYear; }
 
+  /// @brief **optional**\n
+  /// [IMDB](https://en.wikipedia.org/wiki/IMDb) identification number.
   void SetIMDBNumber(const std::string& IMDBNumber) { m_IMDBNumber = IMDBNumber; }
+
+  /// @brief To get with @ref SetIMDBNumber changed values.
   std::string GetIMDBNumber() const { return m_IMDBNumber; }
 
+  /// @brief **optional**\n
+  /// Icon path.
   void SetIconPath(const std::string& iconPath) { m_iconPath = iconPath; }
+
+  /// @brief To get with @ref SetIconPath changed values.
   std::string GetIconPath() const { return m_iconPath; }
 
+  /// @brief **optional**\n
+  /// Genre type.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails EPG_EVENT_CONTENTMASK
+  ///
+  /// Use @ref EPG_GENRE_USE_STRING if type becomes given by @ref SetGenreDescription.
+  ///
+  /// @note If confirmed that backend brings the types in [ETSI EN 300 468](https://www.etsi.org/deliver/etsi_en/300400_300499/300468/01.14.01_60/en_300468v011401p.pdf)
+  /// conform values, can be @ref EPG_EVENT_CONTENTMASK ignored and to set here
+  /// with backend value.
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example 1:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVREPGTag tag;
+  /// tag.SetGenreType(EPG_EVENT_CONTENTMASK_MOVIEDRAMA);
+  /// ~~~~~~~~~~~~~
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example 2** (in case of other, not ETSI EN 300 468 conform genre types):
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVREPGTag tag;
+  /// tag.SetGenreType(EPG_GENRE_USE_STRING);
+  /// tag.SetGenreDescription("My special genre name"); // Should use (if possible) kodi::GetLocalizedString(...) to have match user language.
+  /// ~~~~~~~~~~~~~
+  ///
   void SetGenreType(int genreType) { m_cStructure->iGenreType = genreType; }
+
+  /// @brief To get with @ref SetGenreType changed values
   int GetGenreType() const { return m_cStructure->iGenreType; }
 
+  /// @brief **optional**\n
+  /// Genre sub type.
+  ///
+  /// @copydetails EPG_EVENT_CONTENTMASK
+  ///
+  /// Subtypes groups related to set by @ref SetGenreType:
+  /// | Main genre type | List with available sub genre types
+  /// |-----------------|-----------------------------------------
+  /// | @ref EPG_EVENT_CONTENTMASK_UNDEFINED | Nothing, should be 0
+  /// | @ref EPG_EVENT_CONTENTMASK_MOVIEDRAMA | @ref EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA
+  /// | @ref EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS | @ref EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS
+  /// | @ref EPG_EVENT_CONTENTMASK_SHOW | @ref EPG_EVENT_CONTENTSUBMASK_SHOW
+  /// | @ref EPG_EVENT_CONTENTMASK_SPORTS | @ref EPG_EVENT_CONTENTSUBMASK_SPORTS
+  /// | @ref EPG_EVENT_CONTENTMASK_CHILDRENYOUTH | @ref EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH
+  /// | @ref EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE | @ref EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE
+  /// | @ref EPG_EVENT_CONTENTMASK_ARTSCULTURE | @ref EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE
+  /// | @ref EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS | @ref EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS
+  /// | @ref EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE | @ref EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE
+  /// | @ref EPG_EVENT_CONTENTMASK_LEISUREHOBBIES | @ref EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES
+  /// | @ref EPG_EVENT_CONTENTMASK_SPECIAL | @ref EPG_EVENT_CONTENTSUBMASK_SPECIAL
+  /// | @ref EPG_EVENT_CONTENTMASK_USERDEFINED | Can be defined by you
+  /// | @ref EPG_GENRE_USE_STRING | **Kodi's own value**, which declares that the type with @ref SetGenreDescription is given.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVREPGTag tag;
+  /// tag.SetGenreType(EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE);
+  /// tag.SetGenreSubType(EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_JAZZ);
+  /// ~~~~~~~~~~~~~
+  ///
   void SetGenreSubType(int genreSubType) { m_cStructure->iGenreSubType = genreSubType; }
+
+  /// @brief To get with @ref SetGenreSubType changed values.
   int GetGenreSubType() const { return m_cStructure->iGenreSubType; }
 
+  /// @brief **optional**\n genre. Will be used only when genreType == @ref EPG_GENRE_USE_STRING
+  /// or genreSubType == @ref EPG_GENRE_USE_STRING.
+  ///
+  /// Use @ref EPG_STRING_TOKEN_SEPARATOR to separate different genres.
+  ///
+  /// In case of other, not [ETSI EN 300 468](https://www.etsi.org/deliver/etsi_en/300400_300499/300468/01.14.01_60/en_300468v011401p.pdf)
+  /// conform genre types or something special.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVREPGTag tag;
+  /// tag.SetGenreType(EPG_GENRE_USE_STRING);
+  /// tag.SetGenreDescription("Action" + EPG_STRING_TOKEN_SEPARATOR + "Thriller");
+  /// ~~~~~~~~~~~~~
+  ///
   void SetGenreDescription(const std::string& genreDescription)
   {
     m_genreDescription = genreDescription;
   }
+
+  /// @brief To get with @ref SetGenreDescription changed values.
   std::string GetGenreDescription() const { return m_genreDescription; }
 
+  /// @brief **optional**\n
+  /// First aired in UTC.
   void SetFirstAired(const std::string& firstAired) { m_firstAired = firstAired; }
+
+  /// @brief To get with @ref SetFirstAired changed values.
   std::string GetFirstAired() const { return m_firstAired; }
 
+  /// @brief **optional**\n
+  /// Parental rating.
   void SetParentalRating(int parentalRating) { m_cStructure->iParentalRating = parentalRating; }
+
+  /// @brief To get with @ref SetParentalRatinge changed values.
   int GetParentalRating() const { return m_cStructure->iParentalRating; }
 
+  /// @brief **optional**\n
+  /// Star rating.
   void SetStarRating(int starRating) { m_cStructure->iStarRating = starRating; }
+
+  /// @brief To get with @ref SetStarRating changed values.
   int GetStarRating() const { return m_cStructure->iStarRating; }
 
+  /// @brief **optional**\n
+  /// Series number.
   void SetSeriesNumber(int seriesNumber) { m_cStructure->iSeriesNumber = seriesNumber; }
+
+  /// @brief To get with @ref SetSeriesNumber changed values.
   int GetSeriesNumber() const { return m_cStructure->iSeriesNumber; }
 
+  /// @brief **optional**\n
+  /// Episode number.
   void SetEpisodeNumber(int episodeNumber) { m_cStructure->iEpisodeNumber = episodeNumber; }
+
+  /// @brief To get with @ref SetEpisodeNumber changed values.
   int GetEpisodeNumber() const { return m_cStructure->iEpisodeNumber; }
 
+  /// @brief **optional**\n
+  /// Episode part number.
   void SetEpisodePartNumber(int episodePartNumber)
   {
     m_cStructure->iEpisodePartNumber = episodePartNumber;
   }
+
+  /// @brief To get with @ref SetEpisodePartNumber changed values.
   int GetEpisodePartNumber() const { return m_cStructure->iEpisodePartNumber; }
 
+  /// @brief **optional**\n
+  /// Episode name.
   void SetEpisodeName(const std::string& episodeName) { m_episodeName = episodeName; }
+
+  /// @brief To get with @ref SetEpisodeName changed values.
   std::string GetEpisodeName() const { return m_episodeName; }
 
+  /// @brief **optional**\n
+  /// Bit field of independent flags associated with the EPG entry.
+  ///
+  /// See @ref cpp_kodi_addon_pvr_Defs_epg_EPG_TAG_FLAG for available bit flags.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_epg_EPG_TAG_FLAG
+  ///
   void SetFlags(unsigned int flags) { m_cStructure->iFlags = flags; }
+
+  /// @brief To get with @ref SetFlags changed values.
   unsigned int GetFlags() const { return m_cStructure->iFlags; }
 
+  /// @brief **optional**\n
+  /// Series link for this event.
   void SetSeriesLink(const std::string& seriesLink) { m_seriesLink = seriesLink; }
+
+  /// @brief To get with @ref SetSeriesLink changed values.
   std::string GetSeriesLink() const { return m_seriesLink; }
 
+  ///@}
+
+  // Internal used, as this have own memory for strings and to translate them to "C"
   EPG_TAG* GetTag() const
   {
     m_cStructure->strTitle = m_title.c_str();
@@ -193,25 +449,48 @@ class PVREPGTag : public CStructHdl<PVREPGTag, EPG_TAG>
     m_firstAired = tag->strFirstAired;
   }
 };
-
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_epg_PVREPGTagsResultSet class PVREPGTagsResultSet
+/// @ingroup cpp_kodi_addon_pvr_Defs_epg_PVREPGTag
+/// @brief **PVR add-on EPG entry transfer class**\n
+/// To transfer the content of @ref kodi::addon::CInstancePVRClient::GetEPGForChannel().
+///
+/// @note This becomes only be used on addon call above, not usable outside on
+/// addon itself.
+///@{
 class PVREPGTagsResultSet
 {
 public:
+  /*! \cond PRIVATE */
   PVREPGTagsResultSet() = delete;
   PVREPGTagsResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
     : m_instance(instance), m_handle(handle)
   {
   }
+  /*! \endcond */
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_epg_PVREPGTagsResultSet
+  ///@{
 
+  /// @brief To add and give content from addon to Kodi on related call.
+  ///
+  /// @param[in] tag The to transfered data.
   void Add(const kodi::addon::PVREPGTag& tag)
   {
     m_instance->toKodi->TransferEpgEntry(m_instance->toKodi->kodiInstance, m_handle, tag.GetTag());
   }
 
+  ///@}
+
 private:
   const AddonInstance_PVR* m_instance = nullptr;
   const ADDON_HANDLE m_handle;
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/General.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/General.h
index 35f232422999..3b0eec2bad1e 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/General.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/General.h
@@ -11,6 +11,8 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr/pvr_general.h"
 
+//
+// "C++" Definitions group 1 - General PVR
 #ifdef __cplusplus
 
 namespace kodi
@@ -18,147 +20,339 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_PVRTypeIntValue class PVRTypeIntValue
+/// @ingroup cpp_kodi_addon_pvr_Defs_General
+/// @brief **PVR add-on type value**\n
+/// Representation of a <b>`<int, std::string>`</b> event related value.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_PVRTypeIntValue_Help
+///
+///@{
 class PVRTypeIntValue : public CStructHdl<PVRTypeIntValue, PVR_ATTRIBUTE_INT_VALUE>
 {
 public:
+  /*! \cond PRIVATE */
   PVRTypeIntValue(const PVRTypeIntValue& data) : CStructHdl(data) {}
   PVRTypeIntValue(const PVR_ATTRIBUTE_INT_VALUE* data) : CStructHdl(data) {}
   PVRTypeIntValue(PVR_ATTRIBUTE_INT_VALUE* data) : CStructHdl(data) {}
-
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_PVRTypeIntValue_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_PVRTypeIntValue
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_PVRTypeIntValue :</b>
+  /// | Name | Type | Set call | Get call
+  /// |------|------|----------|----------
+  /// | **Value** | `int` | @ref PVRTypeIntValue::SetValue "SetValue" | @ref PVRTypeIntValue::GetValue "GetValue"
+  /// | **Description** | `std::string` | @ref PVRTypeIntValue::SetDescription "SetDescription" | @ref PVRTypeIntValue::GetDescription "GetDescription"
+  ///
+  /// @remark Further can there be used his class constructor to set values.
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_PVRTypeIntValue
+  ///@{
+
+  /// @brief Default class constructor.
+  ///
+  /// @note Values must be set afterwards.
   PVRTypeIntValue() = default;
+
+  /// @brief Class constructor with integrated value set.
+  ///
+  /// @param[in] value Type identification value
+  /// @param[in] description Type description text
   PVRTypeIntValue(int value, const std::string& description)
   {
     SetValue(value);
     SetDescription(description);
   }
 
+  /// @brief To set with the identification value.
   void SetValue(int value) { m_cStructure->iValue = value; }
 
+  /// @brief To get with the identification value.
   int GetValue() const { return m_cStructure->iValue; }
 
+  /// @brief To set with the description text of the value.
   void SetDescription(const std::string& description)
   {
     strncpy(m_cStructure->strDescription, description.c_str(),
             sizeof(m_cStructure->strDescription) - 1);
   }
 
+  /// @brief To get with the description text of the value.
   std::string GetDescription() const { return m_cStructure->strDescription; }
-};
 
+  ///@}
+};
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_PVRCapabilities class PVRCapabilities
+/// @ingroup cpp_kodi_addon_pvr_Defs_General
+/// @brief **PVR add-on capabilities**\n
+/// This class is needed to tell Kodi which options are supported on the addon.
+///
+/// If a capability is set to **true**, then the corresponding methods from
+/// @ref cpp_kodi_addon_pvr "kodi::addon::CInstancePVRClient" need to be
+/// implemented.
+///
+/// As default them all set to **false**.
+///
+/// Used on @ref kodi::addon::CInstancePVRClient::GetCapabilities().
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_PVRCapabilities_Help
+///
+///@{
 class PVRCapabilities
 {
 public:
+  /*! \cond PRIVATE */
   explicit PVRCapabilities() = delete;
   PVRCapabilities(PVR_ADDON_CAPABILITIES* capabilities) : m_capabilities(capabilities) {}
-
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_PVRCapabilities_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_PVRCapabilities
+  /// ----------------------------------------------------------------------------
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_PVRCapabilities :</b>
+  /// | Name | Type | Set call | Get call
+  /// |------|------|----------|----------
+  /// | **Supports EPG** | `boolean` | @ref PVRCapabilities::SetSupportsEPG "SetSupportsEPG" | @ref PVRCapabilities::GetSupportsEPG "GetSupportsEPG"
+  /// | **Supports EPG EDL** | `boolean` | @ref PVRCapabilities::SetSupportsEPGEdl "SetSupportsEPGEdl" | @ref PVRCapabilities::GetSupportsEPGEdl "GetSupportsEPGEdl"
+  /// | **Supports TV** | `boolean` | @ref PVRCapabilities::SetSupportsTV "SetSupportsTV" | @ref PVRCapabilities::GetSupportsTV "GetSupportsTV"
+  /// | **Supports radio** | `boolean` | @ref PVRCapabilities::SetSupportsRadio "SetSupportsRadio" | @ref PVRCapabilities::GetSupportsRadio "GetSupportsRadio"
+  /// | **Supports recordings** | `boolean` | @ref PVRCapabilities::SetSupportsRecordings "SetSupportsRecordings" | @ref PVRCapabilities::GetSupportsRecordings "GetSupportsRecordings"
+  /// | **Supports recordings undelete** | `boolean` | @ref PVRCapabilities::SetSupportsRecordingsUndelete "SetSupportsRecordingsUndelete" | @ref PVRCapabilities::GetSupportsRecordingsUndelete "SetSupportsRecordingsUndelete"
+  /// | **Supports timers** | `boolean` | @ref PVRCapabilities::SetSupportsTimers "SetSupportsTimers" | @ref PVRCapabilities::GetSupportsTimers "GetSupportsTimers"
+  /// | **Supports channel groups** | `boolean` | @ref PVRCapabilities::SetSupportsChannelGroups "SetSupportsChannelGroups" | @ref PVRCapabilities::GetSupportsChannelGroups "GetSupportsChannelGroups"
+  /// | **Supports channel scan** | `boolean` | @ref PVRCapabilities::SetSupportsChannelScan "SetSupportsChannelScan" | @ref PVRCapabilities::GetSupportsChannelScan "GetSupportsChannelScan"
+  /// | **Supports channel settings** | `boolean` | @ref PVRCapabilities::SetSupportsChannelSettings "SetSupportsChannelSettings" | @ref PVRCapabilities::GetSupportsChannelSettings "GetSupportsChannelSettings"
+  /// | **Handles input stream** | `boolean` | @ref PVRCapabilities::SetHandlesInputStream "SetHandlesInputStream" | @ref PVRCapabilities::GetHandlesInputStream "GetHandlesInputStream"
+  /// | **Handles demuxing** | `boolean` | @ref PVRCapabilities::SetHandlesDemuxing "SetHandlesDemuxing" | @ref PVRCapabilities::GetHandlesDemuxing "GetHandlesDemuxing"
+  /// | **Supports recording play count** | `boolean` | @ref PVRCapabilities::SetSupportsRecordingPlayCount "SetSupportsRecordingPlayCount" | @ref PVRCapabilities::GetSupportsRecordingPlayCount "GetSupportsRecordingPlayCount"
+  /// | **Supports last played position** | `boolean` | @ref PVRCapabilities::SetSupportsLastPlayedPosition "SetSupportsLastPlayedPosition" | @ref PVRCapabilities::GetSupportsLastPlayedPosition "GetSupportsLastPlayedPosition"
+  /// | **Supports recording EDL** | `boolean` | @ref PVRCapabilities::SetSupportsRecordingEdl "SetSupportsRecordingEdl" | @ref PVRCapabilities::GetSupportsRecordingEdl "GetSupportsRecordingEdl"
+  /// | **Supports recordings rename** | `boolean` | @ref PVRCapabilities::SetSupportsRecordingsRename "SetSupportsRecordingsRename" | @ref PVRCapabilities::GetSupportsRecordingsRename "GetSupportsRecordingsRename"
+  /// | **Supports recordings lifetime change** | `boolean` | @ref PVRCapabilities::SetSupportsRecordingsLifetimeChange "SetSupportsRecordingsLifetimeChange" | @ref PVRCapabilities::GetSupportsRecordingsLifetimeChange "GetSupportsRecordingsLifetimeChange"
+  /// | **Supports descramble info** | `boolean` | @ref PVRCapabilities::SetSupportsDescrambleInfo "SetSupportsDescrambleInfo" | @ref PVRCapabilities::GetSupportsDescrambleInfo "GetSupportsDescrambleInfo"
+  /// | **Supports async EPG transfer** | `boolean` | @ref PVRCapabilities::SetSupportsAsyncEPGTransfer "SetSupportsAsyncEPGTransfer" | @ref PVRCapabilities::GetSupportsAsyncEPGTransfer "GetSupportsAsyncEPGTransfer"
+  /// | **Supports recording size** | `boolean` | @ref PVRCapabilities::SetSupportsRecordingSize "SetSupportsRecordingSize" | @ref PVRCapabilities::GetSupportsRecordingSize "GetSupportsRecordingSize"
+  /// | **Recordings lifetime values** | @ref cpp_kodi_addon_pvr_Defs_PVRTypeIntValue "PVRTypeIntValue" | @ref PVRCapabilities::SetRecordingsLifetimeValues "SetRecordingsLifetimeValues" | @ref PVRCapabilities::GetRecordingsLifetimeValues "GetRecordingsLifetimeValues"
+  ///
+  /// @warning This class can not be used outside of @ref kodi::addon::CInstancePVRClient::GetCapabilities()
+  ///
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_PVRCapabilities
+  ///@{
+
+  /// @brief Set **true** if the add-on provides EPG information.
   void SetSupportsEPG(bool supportsEPG) { m_capabilities->bSupportsEPG = supportsEPG; }
+
+  /// @brief To get with @ref SetSupportsEPG changed values.
   bool GetSupportsEPG() const { return m_capabilities->bSupportsEPG; }
 
+  /// @brief Set **true** if the backend supports retrieving an edit decision
+  /// list for an EPG tag.
   void SetSupportsEPGEdl(bool supportsEPGEdl) { m_capabilities->bSupportsEPGEdl = supportsEPGEdl; }
+
+  /// @brief To get with @ref SetSupportsEPGEdl changed values.
   bool GetSupportsEPGEdl() const { return m_capabilities->bSupportsEPGEdl; }
 
+  /// @brief Set **true** if this add-on provides TV channels.
   void SetSupportsTV(bool supportsTV) { m_capabilities->bSupportsTV = supportsTV; }
+
+  /// @brief To get with @ref SetSupportsTV changed values.
   bool GetSupportsTV() const { return m_capabilities->bSupportsTV; }
 
+  /// @brief Set **true** if this add-on provides TV channels.
   void SetSupportsRadio(bool supportsRadio) { m_capabilities->bSupportsRadio = supportsRadio; }
+
+  /// @brief To get with @ref SetSupportsRadio changed values.
   bool GetSupportsRadio() const { return m_capabilities->bSupportsRadio; }
 
+  /// @brief **true** if this add-on supports playback of recordings stored on
+  /// the backend.
   void SetSupportsRecordings(bool supportsRecordings)
   {
     m_capabilities->bSupportsRecordings = supportsRecordings;
   }
+
+  /// @brief To get with @ref SetSupportsRecordings changed values.
   bool GetSupportsRecordings() const { return m_capabilities->bSupportsRecordings; }
 
+  /// @brief Set **true** if this add-on supports undelete of recordings stored
+  /// on the backend.
   void SetSupportsRecordingsUndelete(bool supportsRecordingsUndelete)
   {
     m_capabilities->bSupportsRecordingsUndelete = supportsRecordingsUndelete;
   }
+
+  /// @brief To get with @ref SetSupportsRecordings changed values.
   bool GetSupportsRecordingsUndelete() const { return m_capabilities->bSupportsRecordingsUndelete; }
 
+  /// @brief Set **true** if this add-on supports the creation and editing of
+  /// timers.
   void SetSupportsTimers(bool supportsTimers) { m_capabilities->bSupportsTimers = supportsTimers; }
+
+  /// @brief To get with @ref SetSupportsTimers changed values.
   bool GetSupportsTimers() const { return m_capabilities->bSupportsTimers; }
 
+  /// @brief Set **true** if this add-on supports channel groups.
+  ///
+  /// It use the following functions:
+  /// - @ref kodi::addon::CInstancePVRClient::GetChannelGroupsAmount()
+  /// - @ref kodi::addon::CInstancePVRClient::GetChannelGroups()
+  /// - @ref kodi::addon::CInstancePVRClient::GetChannelGroupMembers()
   void SetSupportsChannelGroups(bool supportsChannelGroups)
   {
     m_capabilities->bSupportsChannelGroups = supportsChannelGroups;
   }
+
+  /// @brief To get with @ref SetSupportsChannelGroups changed values.
   bool GetSupportsChannelGroups() const { return m_capabilities->bSupportsChannelGroups; }
 
+  /// @brief Set **true** if this add-on support scanning for new channels on
+  /// the backend.
+  ///
+  /// It use the following function:
+  /// - @ref kodi::addon::CInstancePVRClient::OpenDialogChannelScan()
   void SetSupportsChannelScan(bool supportsChannelScan)
   {
     m_capabilities->bSupportsChannelScan = supportsChannelScan;
   }
+
+  /// @brief To get with @ref SetSupportsChannelScan changed values.
   bool GetSupportsChannelScan() const { return m_capabilities->bSupportsChannelScan; }
 
+  /// @brief Set **true** if this add-on supports channel edit.
+  ///
+  /// It use the following functions:
+  /// - @ref kodi::addon::CInstancePVRClient::DeleteChannel()
+  /// - @ref kodi::addon::CInstancePVRClient::RenameChannel()
+  /// - @ref kodi::addon::CInstancePVRClient::OpenDialogChannelSettings()
+  /// - @ref kodi::addon::CInstancePVRClient::OpenDialogChannelAdd()
   void SetSupportsChannelSettings(bool supportsChannelSettings)
   {
     m_capabilities->bSupportsChannelSettings = supportsChannelSettings;
   }
+
+  /// @brief To get with @ref SetSupportsChannelSettings changed values.
   bool GetSupportsChannelSettings() const { return m_capabilities->bSupportsChannelSettings; }
 
+  /// @brief Set **true** if this add-on provides an input stream. false if Kodi
+  /// handles the stream.
   void SetHandlesInputStream(bool handlesInputStream)
   {
     m_capabilities->bHandlesInputStream = handlesInputStream;
   }
+
+  /// @brief To get with @ref SetHandlesInputStream changed values.
   bool GetHandlesInputStream() const { return m_capabilities->bHandlesInputStream; }
 
+  /// @brief Set **true** if this add-on demultiplexes packets.
   void SetHandlesDemuxing(bool handlesDemuxing)
   {
     m_capabilities->bHandlesDemuxing = handlesDemuxing;
   }
+
+  /// @brief To get with @ref SetHandlesDemuxing changed values.
   bool GetHandlesDemuxing() const { return m_capabilities->bHandlesDemuxing; }
 
+  /// @brief Set **true** if the backend supports play count for recordings.
   void SetSupportsRecordingPlayCount(bool supportsRecordingPlayCount)
   {
     m_capabilities->bSupportsRecordingPlayCount = supportsRecordingPlayCount;
   }
+
+  /// @brief To get with @ref SetSupportsRecordingPlayCount changed values.
   bool GetSupportsRecordingPlayCount() const { return m_capabilities->bSupportsRecordingPlayCount; }
 
+  /// @brief Set **true** if the backend supports store/retrieve of last played
+  /// position for recordings.
   void SetSupportsLastPlayedPosition(bool supportsLastPlayedPosition)
   {
     m_capabilities->bSupportsLastPlayedPosition = supportsLastPlayedPosition;
   }
+
+  /// @brief To get with @ref SetSupportsLastPlayedPosition changed values.
   bool GetSupportsLastPlayedPosition() const { return m_capabilities->bSupportsLastPlayedPosition; }
 
+  /// @brief Set **true** if the backend supports retrieving an edit decision
+  /// list for recordings.
   void SetSupportsRecordingEdl(bool supportsRecordingEdl)
   {
     m_capabilities->bSupportsRecordingEdl = supportsRecordingEdl;
   }
+
+  /// @brief To get with @ref SetSupportsRecordingEdl changed values.
   bool GetSupportsRecordingEdl() const { return m_capabilities->bSupportsRecordingEdl; }
 
+  /// @brief Set **true** if the backend supports renaming recordings.
   void SetSupportsRecordingsRename(bool supportsRecordingsRename)
   {
     m_capabilities->bSupportsRecordingsRename = supportsRecordingsRename;
   }
+
+  /// @brief To get with @ref SetSupportsRecordingsRename changed values.
   bool GetSupportsRecordingsRename() const { return m_capabilities->bSupportsRecordingsRename; }
 
+  /// @brief Set **true** if the backend supports changing lifetime for
+  /// recordings.
   void SetSupportsRecordingsLifetimeChange(bool supportsRecordingsLifetimeChange)
   {
     m_capabilities->bSupportsRecordingsLifetimeChange = supportsRecordingsLifetimeChange;
   }
+
+  /// @brief To get with @ref SetSupportsRecordingsLifetimeChange changed
+  /// values.
   bool GetSupportsRecordingsLifetimeChange() const
   {
     return m_capabilities->bSupportsRecordingsLifetimeChange;
   }
 
+  /// @brief Set **true** if the backend supports descramble information for
+  /// playing channels.
   void SetSupportsDescrambleInfo(bool supportsDescrambleInfo)
   {
     m_capabilities->bSupportsDescrambleInfo = supportsDescrambleInfo;
   }
+
+  /// @brief To get with @ref SetSupportsDescrambleInfo changed values.
   bool GetSupportsDescrambleInfo() const { return m_capabilities->bSupportsDescrambleInfo; }
 
+  /// @brief Set **true** if this addon-on supports asynchronous transfer of epg
+  /// events to Kodi using the callback function
+  /// @ref kodi::addon::CInstancePVRClient::EpgEventStateChange().
   void SetSupportsAsyncEPGTransfer(bool supportsAsyncEPGTransfer)
   {
     m_capabilities->bSupportsAsyncEPGTransfer = supportsAsyncEPGTransfer;
   }
+
+  /// @brief To get with @ref SetSupportsAsyncEPGTransfer changed values.
   bool GetSupportsAsyncEPGTransfer() const { return m_capabilities->bSupportsAsyncEPGTransfer; }
 
+  /// @brief Set **true** if this addon-on supports retrieving size of recordings.
   void SetSupportsRecordingSize(bool supportsRecordingSize)
   {
     m_capabilities->bSupportsRecordingSize = supportsRecordingSize;
   }
+
+  /// @brief To get with @ref SetSupportsRecordingSize changed values.
   bool GetSupportsRecordingSize() const { return m_capabilities->bSupportsRecordingSize; }
 
+  /// @brief **optional**\n
+  /// Set array containing the possible values for @ref PVRRecording::SetLifetime().
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_PVRTypeIntValue_Help
   void SetRecordingsLifetimeValues(
       const std::vector<PVRTypeIntValue>& recordingsLifetimeValues)
   {
@@ -175,6 +369,8 @@ class PVRCapabilities
       ++m_capabilities->iRecordingsLifetimesSize;
     }
   }
+
+  /// @brief To get with @ref SetRecordingsLifetimeValues changed values.
   std::vector<PVRTypeIntValue> GetRecordingsLifetimeValues() const
   {
     std::vector<PVRTypeIntValue> recordingsLifetimeValues;
@@ -184,39 +380,121 @@ class PVRCapabilities
           m_capabilities->recordingsLifetimeValues[i].strDescription);
     return recordingsLifetimeValues;
   }
+  ///@}
 
 private:
   PVR_ADDON_CAPABILITIES* m_capabilities;
 };
-
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_General_Inputstream_PVRStreamProperty class PVRStreamProperty
+/// @ingroup cpp_kodi_addon_pvr_Defs_General_Inputstream
+/// @brief **PVR stream property value handler**\n
+/// To set for Kodi wanted stream properties.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_General_Inputstream_PVRStreamProperty_Help
+///
+///---------------------------------------------------------------------------
+///
+/// **Example:**
+/// ~~~~~~~~~~~~~{.cpp}
+/// ...
+///
+/// PVR_ERROR CMyPVRInstance::GetChannelStreamProperties(const kodi::addon::PVRChannel& channel,
+///                                                      std::vector<kodi::addon::PVRStreamProperty>& properties)
+/// {
+///   ...
+///   properties.emplace_back(PVR_STREAM_PROPERTY_INPUTSTREAM, "inputstream.adaptive");
+///   return PVR_ERROR_NO_ERROR;
+/// }
+///
+/// ...
+/// ~~~~~~~~~~~~~
+///
+///
+/// **Example 2:**
+/// ~~~~~~~~~~~~~{.cpp}
+/// ...
+///
+/// PVR_ERROR CMyPVRInstance::GetChannelStreamProperties(const kodi::addon::PVRChannel& channel,
+///                                                      std::vector<kodi::addon::PVRStreamProperty>& properties)
+/// {
+///   ...
+///   kodi::addon::PVRStreamProperty property;
+///   property.SetName(PVR_STREAM_PROPERTY_INPUTSTREAM);
+///   property.SetValue("inputstream.adaptive");
+///   properties.emplace_back(property);
+///   return PVR_ERROR_NO_ERROR;
+/// }
+///
+/// ...
+/// ~~~~~~~~~~~~~
+///
+///@{
 class PVRStreamProperty : public CStructHdl<PVRStreamProperty, PVR_NAMED_VALUE>
 {
 public:
+  /*! \cond PRIVATE */
   PVRStreamProperty(const PVRStreamProperty& data) : CStructHdl(data) {}
   PVRStreamProperty(const PVR_NAMED_VALUE* data) : CStructHdl(data) {}
   PVRStreamProperty(PVR_NAMED_VALUE* data) : CStructHdl(data) {}
-
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_General_Inputstream_PVRStreamProperty_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_General_Inputstream_PVRStreamProperty
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_General_Inputstream_PVRStreamProperty :</b>
+  /// | Name | Type | Set call | Get call
+  /// |------|------|----------|----------
+  /// | **Name** | `int` | @ref PVRStreamProperty::SetValue "SetName" | @ref PVRStreamProperty::GetName "GetName"
+  /// | **Value** | `std::string` | @ref PVRStreamProperty::SetValue "SetValue" | @ref PVRStreamProperty::GetValue "GetValue"
+  ///
+  /// @remark Further can there be used his class constructor to set values.
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_General_Inputstream_PVRStreamProperty
+  ///@{
+
+  /// @brief Default class constructor.
+  ///
+  /// @note Values must be set afterwards.
   PVRStreamProperty() = default;
+
+  /// @brief Class constructor with integrated value set.
+  ///
+  /// @param[in] name Type identification
+  /// @param[in] value Type used property value
   PVRStreamProperty(const std::string& name, const std::string& value)
   {
     SetName(name);
     SetValue(value);
   }
 
+  /// @brief To set with the identification name.
   void SetName(const std::string& name)
   {
     strncpy(m_cStructure->strName, name.c_str(), sizeof(m_cStructure->strName) - 1);
   }
 
+  /// @brief To get with the identification name.
   std::string GetName() const { return m_cStructure->strName; }
 
+  /// @brief To set with the used property value.
   void SetValue(const std::string& value)
   {
     strncpy(m_cStructure->strValue, value.c_str(), sizeof(m_cStructure->strValue) - 1);
   }
 
+  /// @brief To get with the used property value.
   std::string GetValue() const { return m_cStructure->strValue; }
+
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/MenuHook.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/MenuHook.h
index 00fbd1559379..b3f65f119911 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/MenuHook.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/MenuHook.h
@@ -11,6 +11,8 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr/pvr_menu_hook.h"
 
+//
+// "C++" Definitions group 7 - Menu hook
 #ifdef __cplusplus
 
 namespace kodi
@@ -18,9 +20,46 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook class PVRMenuhook
+/// @ingroup cpp_kodi_addon_pvr_Defs_Menuhook
+/// @brief **Context menu hook**\n
+/// Menu hooks that are available in the context menus while playing a stream via this add-on.
+/// And in the Live TV settings dialog.
+///
+/// Possible menu's given to Kodi.
+///
+/// This can be becomes used on this, if @ref kodi::addon::CInstancePVRClient::AddMenuHook()
+/// was set to related type:
+/// - @ref kodi::addon::CInstancePVRClient::CallSettingsMenuHook()
+/// - @ref kodi::addon::CInstancePVRClient::CallChannelMenuHook()
+/// - @ref kodi::addon::CInstancePVRClient::CallEPGMenuHook()
+/// - @ref kodi::addon::CInstancePVRClient::CallRecordingMenuHook()
+/// - @ref kodi::addon::CInstancePVRClient::CallTimerMenuHook()
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook_Help
+///
+///@{
 class PVRMenuhook : public CStructHdl<PVRMenuhook, PVR_MENUHOOK>
 {
 public:
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook
+  /// @brief Optional class constructor with value set.
+  ///
+  /// @param[in] hookId This hook's identifier
+  /// @param[in] localizedStringId Localized string identifier
+  /// @param[in] category Category of menu hook, defined with @ref PVR_MENUHOOK_CAT
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// Example:
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// AddMenuHook(kodi::addon::PVRMenuhook(1, 30001, PVR_MENUHOOK_CHANNEL));
+  /// ~~~~~~~~~~~~~
+  ///
   PVRMenuhook(unsigned int hookId, unsigned int localizedStringId, PVR_MENUHOOK_CAT category)
   {
     m_cStructure->iHookId = hookId;
@@ -28,6 +67,7 @@ class PVRMenuhook : public CStructHdl<PVRMenuhook, PVR_MENUHOOK>
     m_cStructure->category = category;
   }
 
+  /*! \cond PRIVATE */
   PVRMenuhook()
   {
     m_cStructure->iHookId = 0;
@@ -37,19 +77,49 @@ class PVRMenuhook : public CStructHdl<PVRMenuhook, PVR_MENUHOOK>
   PVRMenuhook(const PVRMenuhook& data) : CStructHdl(data) {}
   PVRMenuhook(const PVR_MENUHOOK* data) : CStructHdl(data) {}
   PVRMenuhook(PVR_MENUHOOK* data) : CStructHdl(data) {}
+  /*! \endcond */
 
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **This hook's identifier** | `unsigned int` | @ref PVRMenuhook::SetHookId "SetHookId" | @ref PVRMenuhook::GetHookId "GetHookId" | *required to set*
+  /// | **Localized string Identifier** | `unsigned int` | @ref PVRMenuhook::SetLocalizedStringId "SetLocalizedStringId" | @ref PVRMenuhook::GetLocalizedStringId "GetLocalizedStringId" | *required to set*
+  /// | **Category of menu hook** | @ref PVR_MENUHOOK_CAT | @ref PVRMenuhook::SetCategory "SetCategory" | @ref PVRMenuhook::GetCategory "GetCategory" | *required to set*
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Menuhook_PVRMenuhook
+  ///@{
+
+  /// @brief **required**\n
+  /// This hook's identifier.
   void SetHookId(unsigned int hookId) { m_cStructure->iHookId = hookId; }
+
+  /// @brief To get with @ref SetHookId() changed values.
   unsigned int GetHookId() const { return m_cStructure->iHookId; }
 
+  /// @brief **required**\n
+  /// The id of the label for this hook in @ref kodi::GetLocalizedString().
   void SetLocalizedStringId(unsigned int localizedStringId)
   {
     m_cStructure->iLocalizedStringId = localizedStringId;
   }
+
+  /// @brief To get with @ref SetLocalizedStringId() changed values.
   unsigned int GetLocalizedStringId() const { return m_cStructure->iLocalizedStringId; }
 
+  /// @brief **required**\n
+  /// Category of menu hook.
   void SetCategory(PVR_MENUHOOK_CAT category) { m_cStructure->category = category; }
+
+  /// @brief To get with @ref SetCategory() changed values.
   PVR_MENUHOOK_CAT GetCategory() const { return m_cStructure->category; }
+
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
index a214cdb195a1..56feb899d740 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Recordings.h
@@ -11,6 +11,8 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr.h"
 
+//
+// "C++" Definitions group 5 - PVR recordings
 #ifdef __cplusplus
 
 namespace kodi
@@ -18,9 +20,25 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecording class PVRRecording
+/// @ingroup cpp_kodi_addon_pvr_Defs_Recording
+/// @brief **Data structure with available recordings data**\n
+/// With this, recordings related data are transferred between addon and Kodi
+/// and can also be used by the addon itself.
+///
+/// The related values here are automatically initiated to defaults and need
+/// only be set if supported and used.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Recording_PVRRecording_Help
+///
+///@{
 class PVRRecording : public CStructHdl<PVRRecording, PVR_RECORDING>
 {
 public:
+  /*! \cond PRIVATE */
   PVRRecording()
   {
     m_cStructure->iSeriesNumber = PVR_RECORDING_INVALID_SERIES_EPISODE;
@@ -43,163 +61,454 @@ class PVRRecording : public CStructHdl<PVRRecording, PVR_RECORDING>
   PVRRecording(const PVRRecording& recording) : CStructHdl(recording) {}
   PVRRecording(const PVR_RECORDING* recording) : CStructHdl(recording) {}
   PVRRecording(PVR_RECORDING* recording) : CStructHdl(recording) {}
-
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecording_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Recording_PVRRecording :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **Recording id** | `std::string` | @ref PVRRecording::SetRecordingId "SetRecordingId" | @ref PVRRecording::GetRecordingId "GetRecordingId" | *required to set*
+  /// | **Title** | `std::string` | @ref PVRRecording::SetTitle "SetTitle" | @ref PVRRecording::GetTitle "GetTitle" | *required to set*
+  /// | **Episode name** | `std::string` | @ref PVRRecording::SetEpisodeName "SetEpisodeName" | @ref PVRRecording::GetEpisodeName "GetEpisodeName" | *optional*
+  /// | **Series number** | `int` | @ref PVRRecording::SetSeriesNumber "SetSeriesNumber" | @ref PVRRecording::GetSeriesNumber "GetSeriesNumber" | *optional*
+  /// | **Episode number** | `int` | @ref PVRRecording::SetEpisodeNumber "SetEpisodeNumber" | @ref PVRRecording::GetEpisodeNumber "GetEpisodeNumber" | *optional*
+  /// | **Year** | `int` | @ref PVRRecording::SetYear "SetYear" | @ref PVRRecording::GetYear "GetYear" | *optional*
+  /// | **Directory** | `std::string` | @ref PVRRecording::SetDirectory "SetDirectory" | @ref PVRRecording::GetDirectory "GetDirectory" | *optional*
+  /// | **Plot outline** | `std::string` | @ref PVRRecording::SetPlotOutline "SetPlotOutline" | @ref PVRRecording::GetPlotOutline "GetPlotOutline" | *optional*
+  /// | **Plot** | `std::string` | @ref PVRRecording::SetPlot "SetPlot" | @ref PVRRecording::GetPlot "GetPlot" | *optional*
+  /// | **Genre description** | `std::string` | @ref PVRRecording::SetGenreDescription "SetGenreDescription" | @ref PVRRecording::GetGenreDescription "GetGenreDescription" | *optional*
+  /// | **Channel name** | `std::string` | @ref PVRRecording::SetChannelName "SetChannelName" | @ref PVRRecording::GetChannelName "GetChannelName" | *optional*
+  /// | **Icon path** | `std::string` | @ref PVRRecording::SetIconPath "SetIconPath" | @ref PVRRecording::GetIconPath "GetIconPath" | *optional*
+  /// | **Thumbnail path** | `std::string` | @ref PVRRecording::SetThumbnailPath "SetThumbnailPath" | @ref PVRRecording::GetThumbnailPath "GetThumbnailPath" | *optional*
+  /// | **Fanart path** | `std::string` | @ref PVRRecording::SetFanartPath "SetFanartPath" | @ref PVRRecording::GetFanartPath "GetFanartPath" | *optional*
+  /// | **Recording time** | `time_t` | @ref PVRRecording::SetRecordingTime "SetRecordingTime" | @ref PVRRecording::GetRecordingTime "GetRecordingTime" | *optional*
+  /// | **Duration** | `int` | @ref PVRRecording::SetDuration "SetDuration" | @ref PVRRecording::GetDuration "GetDuration" | *optional*
+  /// | **Priority** | `int` | @ref PVRRecording::SetPriority "SetPriority" | @ref PVRRecording::GetPriority "GetPriority" | *optional*
+  /// | **Lifetime** | `int` | @ref PVRRecording::SetLifetime "SetLifetime" | @ref PVRRecording::GetLifetime "GetLifetime" | *optional*
+  /// | **Genre type** | `int` | @ref PVRRecording::SetGenreType "SetGenreType" | @ref PVRRecording::GetGenreType "GetGenreType" | *optional*
+  /// | **Genre sub type** | `int` | @ref PVRRecording::SetGenreSubType "SetGenreSubType" | @ref PVRRecording::GetGenreSubType "GetGenreSubType" | *optional*
+  /// | **Play count** | `int` | @ref PVRRecording::SetPlayCount "SetPlayCount" | @ref PVRRecording::GetPlayCount "GetPlayCount" | *optional*
+  /// | **Last played position** | `int` | @ref PVRRecording::SetLastPlayedPosition "SetLastPlayedPosition" | @ref PVRRecording::GetLastPlayedPosition "GetLastPlayedPosition" | *optional*
+  /// | **Is deleted** | `bool` | @ref PVRRecording::SetIsDeleted "SetIsDeleted" | @ref PVRRecording::GetIsDeleted "GetIsDeleted" | *optional*
+  /// | **EPG event id** | `unsigned int` | @ref PVRRecording::SetEPGEventId "SetEPGEventId" | @ref PVRRecording::GetEPGEventId "GetEPGEventId" | *optional*
+  /// | **Channel unique id** | `int` | @ref PVRRecording::SetChannelUid "SetChannelUid" | @ref PVRRecording::GetChannelUid "GetChannelUid" | *optional*
+  /// | **Channel type** | @ref PVR_RECORDING_CHANNEL_TYPE | @ref PVRRecording::SetChannelType "SetChannelType" | @ref PVRRecording::GetChannelType "GetChannelType" | *optional*
+  /// | **First aired** | `std::string` | @ref PVRRecording::SetFirstAired "SetFirstAired" | @ref PVRRecording::GetFirstAired "GetFirstAired" | *optional*
+  /// | **Flags** | `std::string` | @ref PVRRecording::SetFlags "SetFlags" | @ref PVRRecording::GetFlags "GetFlags" | *optional*
+  /// | **Size in bytes** | `std::string` | @ref PVRRecording::SetSizeInBytes "SetSizeInBytes" | @ref PVRRecording::GetSizeInBytes "GetSizeInBytes" | *optional*
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  ///@{
+
+  /// @brief **required**\n
+  /// Unique identifier of the recording on the client.
   void SetRecordingId(const std::string& recordingId)
   {
     strncpy(m_cStructure->strRecordingId, recordingId.c_str(),
             sizeof(m_cStructure->strRecordingId) - 1);
   }
+
+  /// @brief To get with @ref SetRecordingId changed values.
   std::string GetRecordingId() const { return m_cStructure->strRecordingId; }
 
+  /// @brief **required**\n
+  /// The title of this recording.
   void SetTitle(const std::string& title)
   {
     strncpy(m_cStructure->strTitle, title.c_str(), sizeof(m_cStructure->strTitle) - 1);
   }
+
+  /// @brief To get with @ref SetTitle changed values.
   std::string GetTitle() const { return m_cStructure->strTitle; }
 
+  /// @brief **optional**\n
+  /// Episode name (also known as subtitle).
   void SetEpisodeName(const std::string& episodeName)
   {
     strncpy(m_cStructure->strEpisodeName, episodeName.c_str(),
             sizeof(m_cStructure->strEpisodeName) - 1);
   }
+
+  /// @brief To get with @ref SetEpisodeName changed values.
   std::string GetEpisodeName() const { return m_cStructure->strEpisodeName; }
 
+  /// @brief **optional**\n
+  /// Series number (usually called season).
+  ///
+  /// Set to "0" for specials/pilot. For 'invalid' see @ref SetEpisodeNumber or set to -1.
   void SetSeriesNumber(int seriesNumber) { m_cStructure->iSeriesNumber = seriesNumber; }
+
+  /// @brief To get with @ref SetSeriesNumber changed values.
   int GetSeriesNumber() const { return m_cStructure->iSeriesNumber; }
 
+  /// @brief **optional**\n
+  /// Eepisode number within the "iSeriesNumber" season.
+  ///
+  /// For 'invalid' set to -1 or seriesNumber=episodeNumber=0 to show both are invalid.
   void SetEpisodeNumber(int episodeNumber) { m_cStructure->iEpisodeNumber = episodeNumber; }
+
+  /// @brief To get with @ref SetEpisodeNumber changed values.
   int GetEpisodeNumber() const { return m_cStructure->iEpisodeNumber; }
 
+  /// @brief **optional**\n
+  /// Year of first release (use to identify a specific movie re-make) / first
+  /// airing for TV shows.
+  ///
+  /// Set to '0' for invalid.
   void SetYear(int year) { m_cStructure->iYear = year; }
+
+  /// @brief To get with @ref SetYear changed values.
   int GetYear() const { return m_cStructure->iYear; }
 
+  /// @brief **optional**\n
+  ///
+  /// Directory of this recording on the client.
   void SetDirectory(const std::string& directory)
   {
     strncpy(m_cStructure->strDirectory, directory.c_str(), sizeof(m_cStructure->strDirectory) - 1);
   }
+
+  /// @brief To get with @ref SetDirectory changed values.
   std::string GetDirectory() const { return m_cStructure->strDirectory; }
 
+  /// @brief **optional**\n
+  /// Plot outline name.
   void SetPlotOutline(const std::string& plotOutline)
   {
     strncpy(m_cStructure->strPlotOutline, plotOutline.c_str(),
             sizeof(m_cStructure->strPlotOutline) - 1);
   }
+
+  /// @brief To get with @ref SetPlotOutline changed values.
   std::string GetPlotOutline() const { return m_cStructure->strPlotOutline; }
 
+  /// @brief **optional**\n
+  /// Plot name.
   void SetPlot(const std::string& plot)
   {
     strncpy(m_cStructure->strPlot, plot.c_str(), sizeof(m_cStructure->strPlot) - 1);
   }
+
+  /// @brief To get with @ref SetPlot changed values.
   std::string GetPlot() const { return m_cStructure->strPlot; }
 
+  /// @brief **optional**\n
+  /// Channel name.
   void SetChannelName(const std::string& channelName)
   {
     strncpy(m_cStructure->strChannelName, channelName.c_str(),
             sizeof(m_cStructure->strChannelName) - 1);
   }
+
+  /// @brief To get with @ref SetChannelName changed values.
   std::string GetChannelName() const { return m_cStructure->strChannelName; }
 
+  /// @brief **optional**\n
+  /// Channel logo (icon) path.
   void SetIconPath(const std::string& iconPath)
   {
     strncpy(m_cStructure->strIconPath, iconPath.c_str(), sizeof(m_cStructure->strIconPath) - 1);
   }
+
+  /// @brief To get with @ref SetIconPath changed values.
   std::string GetIconPath() const { return m_cStructure->strIconPath; }
 
+  /// @brief **optional**\n
+  /// Thumbnail path.
   void SetThumbnailPath(const std::string& thumbnailPath)
   {
     strncpy(m_cStructure->strThumbnailPath, thumbnailPath.c_str(),
             sizeof(m_cStructure->strThumbnailPath) - 1);
   }
+
+  /// @brief To get with @ref SetThumbnailPath changed values.
   std::string GetThumbnailPath() const { return m_cStructure->strThumbnailPath; }
 
+  /// @brief **optional**\n
+  /// Fanart path.
   void SetFanartPath(const std::string& fanartPath)
   {
     strncpy(m_cStructure->strFanartPath, fanartPath.c_str(),
             sizeof(m_cStructure->strFanartPath) - 1);
   }
+
+  /// @brief To get with @ref SetFanartPath changed values.
   std::string GetFanartPath() const { return m_cStructure->strFanartPath; }
 
+  /// @brief **optional**\n
+  /// Start time of the recording.
   void SetRecordingTime(time_t recordingTime) { m_cStructure->recordingTime = recordingTime; }
+
+  /// @brief To get with @ref SetRecordingTime changed values.
   time_t GetRecordingTime() const { return m_cStructure->recordingTime; }
 
+  /// @brief **optional**\n
+  /// Duration of the recording in seconds.
   void SetDuration(int duration) { m_cStructure->iDuration = duration; }
+
+  /// @brief To get with @ref SetDuration changed values.
   int GetDuration() const { return m_cStructure->iDuration; }
 
+  /// @brief **optional**\n
+  /// Priority of this recording (from 0 - 100).
   void SetPriority(int priority) { m_cStructure->iPriority = priority; }
+
+  /// @brief To get with @ref SetPriority changed values.
   int GetPriority() const { return m_cStructure->iPriority; }
 
+  /// @brief **optional**\n
+  /// Life time in days of this recording.
   void SetLifetime(int lifetime) { m_cStructure->iLifetime = lifetime; }
+
+  /// @brief To get with @ref SetLifetime changed values.
   int GetLifetime() const { return m_cStructure->iLifetime; }
 
+  /// @brief **optional**\n
+  /// Genre type.
+  ///
+  /// Use @ref EPG_GENRE_USE_STRING if type becomes given by @ref SetGenreDescription.
+  ///
+  /// @note If confirmed that backend brings the types in [ETSI EN 300 468](https://www.etsi.org/deliver/etsi_en/300400_300499/300468/01.14.01_60/en_300468v011401p.pdf)
+  /// conform values, can be @ref EPG_EVENT_CONTENTMASK ignored and to set here
+  /// with backend value.
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example 1:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRRecording tag;
+  /// tag.SetGenreType(EPG_EVENT_CONTENTMASK_MOVIEDRAMA);
+  /// ~~~~~~~~~~~~~
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example 2** (in case of other, not ETSI EN 300 468 conform genre types):
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRRecording tag;
+  /// tag.SetGenreType(EPG_GENRE_USE_STRING);
+  /// tag.SetGenreDescription("My special genre name"); // Should use (if possible) kodi::GetLocalizedString(...) to have match user language.
+  /// ~~~~~~~~~~~~~
+  ///
   void SetGenreType(int genreType) { m_cStructure->iGenreType = genreType; }
+
+  /// @brief To get with @ref SetGenreType changed values.
   int GetGenreType() const { return m_cStructure->iGenreType; }
 
+  /// @brief **optional**\n
+  /// Genre sub type.
+  ///
+  /// Subtypes groups related to set by @ref SetGenreType:
+  /// | Main genre type | List with available sub genre types
+  /// |-----------------|-----------------------------------------
+  /// | @ref EPG_EVENT_CONTENTMASK_UNDEFINED | Nothing, should be 0
+  /// | @ref EPG_EVENT_CONTENTMASK_MOVIEDRAMA | @ref EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA
+  /// | @ref EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS | @ref EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS
+  /// | @ref EPG_EVENT_CONTENTMASK_SHOW | @ref EPG_EVENT_CONTENTSUBMASK_SHOW
+  /// | @ref EPG_EVENT_CONTENTMASK_SPORTS | @ref EPG_EVENT_CONTENTSUBMASK_SPORTS
+  /// | @ref EPG_EVENT_CONTENTMASK_CHILDRENYOUTH | @ref EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH
+  /// | @ref EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE | @ref EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE
+  /// | @ref EPG_EVENT_CONTENTMASK_ARTSCULTURE | @ref EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE
+  /// | @ref EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS | @ref EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS
+  /// | @ref EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE | @ref EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE
+  /// | @ref EPG_EVENT_CONTENTMASK_LEISUREHOBBIES | @ref EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES
+  /// | @ref EPG_EVENT_CONTENTMASK_SPECIAL | @ref EPG_EVENT_CONTENTSUBMASK_SPECIAL
+  /// | @ref EPG_EVENT_CONTENTMASK_USERDEFINED | Can be defined by you
+  /// | @ref EPG_GENRE_USE_STRING | **Kodi's own value**, which declares that the type with @ref SetGenreDescription is given.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRRecording tag;
+  /// tag.SetGenreType(EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE);
+  /// tag.SetGenreSubType(EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_JAZZ);
+  /// ~~~~~~~~~~~~~
+  ///
   void SetGenreSubType(int genreSubType) { m_cStructure->iGenreSubType = genreSubType; }
+
+  /// @brief To get with @ref SetGenreSubType changed values.
   int GetGenreSubType() const { return m_cStructure->iGenreSubType; }
 
+  /// @brief **optional**\n
+  /// To set own genre description name.
+  ///
+  /// Will be used only when genreType == @ref EPG_GENRE_USE_STRING or
+  /// genreSubType == @ref EPG_GENRE_USE_STRING.
+  ///
+  /// Use @ref EPG_STRING_TOKEN_SEPARATOR to separate different genres.
+  ///
+  /// In case of other, not [ETSI EN 300 468](https://www.etsi.org/deliver/etsi_en/300400_300499/300468/01.14.01_60/en_300468v011401p.pdf)
+  /// conform genre types or something special.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRRecording tag;
+  /// tag.SetGenreType(EPG_GENRE_USE_STRING);
+  /// tag.SetGenreDescription("Action" + EPG_STRING_TOKEN_SEPARATOR + "Thriller");
+  /// ~~~~~~~~~~~~~
+  ///
   void SetGenreDescription(const std::string& genreDescription)
   {
     strncpy(m_cStructure->strGenreDescription, genreDescription.c_str(),
             sizeof(m_cStructure->strGenreDescription) - 1);
   }
+
+  /// @brief To get with @ref SetGenreDescription changed values.
   std::string GetGenreDescription() const { return m_cStructure->strGenreDescription; }
 
+  /// @brief **optional**\n
+  /// Play count of this recording on the client.
   void SetPlayCount(int playCount) { m_cStructure->iPlayCount = playCount; }
+
+  /// @brief To get with @ref SetPlayCount changed values.
   int GetPlayCount() const { return m_cStructure->iPlayCount; }
 
+  /// @brief **optional**\n
+  /// Last played position of this recording on the client.
   void SetLastPlayedPosition(int lastPlayedPosition)
   {
     m_cStructure->iLastPlayedPosition = lastPlayedPosition;
   }
+
+  /// @brief To get with @ref SetLastPlayedPosition changed values.
   int GetLastPlayedPosition() const { return m_cStructure->iLastPlayedPosition; }
 
+  /// @brief **optional**\n
+  /// Shows this recording is deleted and can be undelete.
   void SetIsDeleted(int isDeleted) { m_cStructure->bIsDeleted = isDeleted; }
+
+  /// @brief To get with @ref SetIsDeleted changed values.
   int GetIsDeleted() const { return m_cStructure->bIsDeleted; }
 
+  /// @brief **optional**\n
+  /// EPG event id associated with this recording. Valid ids must be greater than @ref EPG_TAG_INVALID_UID.
   void SetEPGEventId(unsigned int epgEventId) { m_cStructure->iEpgEventId = epgEventId; }
+
+  /// @brief To get with @ref SetEPGEventId changed values.
   unsigned int GetEPGEventId() const { return m_cStructure->iEpgEventId; }
 
+  /// @brief **optional**\n
+  /// Unique identifier of the channel for this recording. @ref PVR_CHANNEL_INVALID_UID
+  /// denotes that channel uid is not available.
   void SetChannelUid(int channelUid) { m_cStructure->iChannelUid = channelUid; }
+
+  /// @brief To get with @ref SetChannelUid changed values
   int GetChannelUid() const { return m_cStructure->iChannelUid; }
 
+  /// @brief **optional**\n
+  /// Channel type.
+  ///
+  /// Set to @ref PVR_RECORDING_CHANNEL_TYPE_UNKNOWN if the type cannot be
+  /// determined.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// Example:
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRRecording tag;
+  /// tag.SetChannelType(PVR_RECORDING_CHANNEL_TYPE_TV);
+  /// ~~~~~~~~~~~~~
+  ///
   void SetChannelType(PVR_RECORDING_CHANNEL_TYPE channelType)
   {
     m_cStructure->channelType = channelType;
   }
+
+  /// @brief To get with @ref SetChannelType changed values
   PVR_RECORDING_CHANNEL_TYPE GetChannelType() const { return m_cStructure->channelType; }
 
+  /// @brief **optional**\n
+  /// First aired date of this recording.
+  ///
+  /// Used only for display purposes. Specify in W3C date format "YYYY-MM-DD".
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// Example:
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRRecording tag;
+  /// tag.SetFirstAired(1982-10-22);
+  /// ~~~~~~~~~~~~~
+  ///
   void SetFirstAired(const std::string& firstAired)
   {
     strncpy(m_cStructure->strFirstAired, firstAired.c_str(),
             sizeof(m_cStructure->strFirstAired) - 1);
   }
+
+  /// @brief To get with @ref SetFirstAired changed values
   std::string GetFirstAired() const { return m_cStructure->strFirstAired; }
 
+  /// @brief **optional**\n
+  /// Bit field of independent flags associated with the recording.
+  ///
+  /// See @ref cpp_kodi_addon_pvr_Defs_Recording_PVR_RECORDING_FLAG for
+  /// available bit flags.
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_Recording_PVR_RECORDING_FLAG
+  ///
   void SetFlags(unsigned int flags) { m_cStructure->iFlags = flags; }
+
+  /// @brief To get with @ref SetFlags changed values.
   unsigned int GetFlags() const { return m_cStructure->iFlags; }
 
+  /// @brief **optional**\n
+  /// Size of the recording in bytes.
   void SetSizeInBytes(int64_t sizeInBytes) { m_cStructure->sizeInBytes = sizeInBytes; }
+
+  /// @brief To get with @ref SetSizeInBytes changed values.
   int64_t GetSizeInBytes() const { return m_cStructure->sizeInBytes; }
+  ///@}
 };
-
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecordingsResultSet class PVRRecordingsResultSet
+/// @ingroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+/// @brief **PVR add-on recording transfer class**\n
+/// To transfer the content of @ref kodi::addon::CInstancePVRClient::GetRecordings().
+///
+/// @note This becomes only be used on addon call above, not usable outside on
+/// addon itself.
+///@{
 class PVRRecordingsResultSet
 {
 public:
+  /*! \cond PRIVATE */
   PVRRecordingsResultSet() = delete;
   PVRRecordingsResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
     : m_instance(instance), m_handle(handle)
   {
   }
+  /*! \endcond */
 
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecordingsResultSet
+  ///@{
+
+  /// @brief To add and give content from addon to Kodi on related call.
+  ///
+  /// @param[in] tag The to transfered data.
   void Add(const kodi::addon::PVRRecording& tag)
   {
     m_instance->toKodi->TransferRecordingEntry(m_instance->toKodi->kodiInstance, m_handle, tag);
   }
 
+  ///@}
+
 private:
   const AddonInstance_PVR* m_instance = nullptr;
   const ADDON_HANDLE m_handle;
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Stream.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Stream.h
index 81cef4f91f79..e0de1e810b48 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Stream.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Stream.h
@@ -11,6 +11,10 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr/pvr_stream.h"
 
+//
+// "C++" Definitions group 9 - PVR stream definitions (NOTE: Becomes replaced
+// in future by inputstream addon instance way)
+
 #ifdef __cplusplus
 
 namespace kodi
@@ -18,9 +22,23 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Stream_PVRCodec class PVRCodec
+/// @ingroup cpp_kodi_addon_pvr_Defs_Stream
+/// @brief **PVR codec identifier**\n
+/// Used to exchange the desired codec type between Kodi and addon.
+///
+/// @ref kodi::addon::CInstancePVRClient::GetCodecByName is used to get this data.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Stream_PVRCodec_Help
+///
+///@{
 class PVRCodec : public CStructHdl<PVRCodec, PVR_CODEC>
 {
 public:
+  /*! \cond PRIVATE */
   PVRCodec()
   {
     m_cStructure->codec_type = PVR_CODEC_TYPE_UNKNOWN;
@@ -30,32 +48,108 @@ class PVRCodec : public CStructHdl<PVRCodec, PVR_CODEC>
   PVRCodec(const PVR_CODEC& type) : CStructHdl(&type) {}
   PVRCodec(const PVR_CODEC* type) : CStructHdl(type) {}
   PVRCodec(PVR_CODEC* type) : CStructHdl(type) {}
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Stream_PVRCodec_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Stream_PVRCodec
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Stream_PVRCodec :</b>
+  /// | Name | Type | Set call | Get call
+  /// |------|------|----------|----------
+  /// | **Codec type** | @ref PVR_CODEC_TYPE | @ref PVRCodec::SetCodecType "SetCodecType" | @ref PVRCodec::GetCodecType "GetCodecType"
+  /// | **Codec identifier** | `unsigned int` | @ref PVRCodec::SetCodecId "SetCodecId" | @ref PVRCodec::GetCodecId "GetCodecId"
+  ///
 
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Stream_PVRCodec
+  ///@{
+
+  /// @brief Codec type.
   void SetCodecType(PVR_CODEC_TYPE codecType) { m_cStructure->codec_type = codecType; }
+
+  /// @brief To get with @ref SetCodecType() changed values.
   PVR_CODEC_TYPE GetCodecType() const { return m_cStructure->codec_type; }
 
+  /// @brief Codec id.
+  ///
+  /// Related codec identifier, normally match the ffmpeg id's.
   void SetCodecId(unsigned int codecId) { m_cStructure->codec_id = codecId; }
+
+  /// @brief To get with @ref SetCodecId() changed values.
   unsigned int GetCodecId() const { return m_cStructure->codec_id; }
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties class PVRStreamProperties
+/// @ingroup cpp_kodi_addon_pvr_Defs_Stream
+/// @brief **PVR stream properties**\n
+/// All information about a respective stream is stored in this, so that Kodi
+/// can process the data given by the addon after demux.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties_Help
+///
+///@{
 class PVRStreamProperties
   : public CStructHdl<PVRStreamProperties, PVR_STREAM_PROPERTIES::PVR_STREAM>
 {
 public:
+  /*! \cond PRIVATE */
   PVRStreamProperties() { memset(m_cStructure, 0, sizeof(PVR_STREAM_PROPERTIES::PVR_STREAM)); }
   PVRStreamProperties(const PVRStreamProperties& type) : CStructHdl(type) {}
   PVRStreamProperties(const PVR_STREAM_PROPERTIES::PVR_STREAM* type) : CStructHdl(type) {}
   PVRStreamProperties(PVR_STREAM_PROPERTIES::PVR_STREAM* type) : CStructHdl(type) {}
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties
+  /// ----------------------------------------------------------------------------
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties :</b>
+  /// | Name | Type | Set call | Get call
+  /// |------|------|----------|----------
+  /// | **PID** | `unsigned int` | @ref PVRStreamProperties::SetPID "SetPID" | @ref PVRStreamProperties::GetPID "GetPID"
+  /// | **Codec type** | @ref PVR_CODEC_TYPE | @ref PVRStreamProperties::SetCodecType "SetCodecType" | @ref PVRStreamProperties::GetCodecType "GetCodecType"
+  /// | **Codec identifier** | `unsigned int` | @ref PVRStreamProperties::SetCodecId "SetCodecId" | @ref PVRStreamProperties::GetCodecId "GetCodecId"
+  /// | **Language** | `std::string` | @ref PVRStreamProperties::SetLanguage "SetLanguage" | @ref PVRStreamProperties::GetLanguage "GetLanguage"
+  /// | **Subtitle info** | `int` | @ref PVRStreamProperties::SetSubtitleInfo "SetSubtitleInfo" | @ref PVRStreamProperties::GetSubtitleInfo "GetSubtitleInfo"
+  /// | **FPS scale** | `int` | @ref PVRStreamProperties::SetFPSScale "SetFPSScale" | @ref PVRStreamProperties::GetFPSScale "GetFPSScale"
+  /// | **FPS rate** | `int` | @ref PVRStreamProperties::SetFPSRate "SetFPSRate" | @ref PVRStreamProperties::GetFPSRate "GetFPSRate"
+  /// | **Height** | `int` | @ref PVRStreamProperties::SetHeight "SetHeight" | @ref PVRStreamProperties::GetHeight "GetHeight"
+  /// | **Width** | `int` | @ref PVRStreamProperties::SetWidth "SetWidth" | @ref PVRStreamProperties::GetWidth "GetWidth"
+  /// | **Aspect ratio** | `float` | @ref PVRStreamProperties::SetAspect "SetAspect" | @ref PVRStreamProperties::GetAspect "GetAspect"
+  /// | **Channels** | `int` | @ref PVRStreamProperties::SetChannels "SetChannels" | @ref PVRStreamProperties::GetChannels "GetChannels"
+  /// | **Samplerate** | `int` | @ref PVRStreamProperties::SetSampleRate "SetSampleRate" | @ref PVRStreamProperties::GetSampleRate "GetSampleRate"
+  /// | **Block align** | `int` | @ref PVRStreamProperties::SetBlockAlign "SetBlockAlign" | @ref PVRStreamProperties::GetBlockAlign "GetBlockAlign"
+  /// | **Bit rate** | `int` | @ref PVRStreamProperties::SetBitRate "SetBitRate" | @ref PVRStreamProperties::GetBitRate "GetBitRate"
+  /// | **Bits per sample** | `int` | @ref PVRStreamProperties::SetBitsPerSample "SetBitsPerSample" | @ref PVRStreamProperties::GetBitsPerSample "GetBitsPerSample"
+  ///
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties
+  ///@{
 
+  /// @brief PID.
   void SetPID(unsigned int pid) { m_cStructure->iPID = pid; }
+
+  /// @brief To get with @ref SetPID() changed values.
   unsigned int GetPID() const { return m_cStructure->iPID; }
 
+  /// @brief Codec type this stream.
   void SetCodecType(PVR_CODEC_TYPE codecType) { m_cStructure->iCodecType = codecType; }
+
+  /// @brief To get with @ref SetCodecType() changed values.
   PVR_CODEC_TYPE GetCodecType() const { return m_cStructure->iCodecType; }
 
+  /// @brief Codec id of this stream.
   void SetCodecId(unsigned int codecId) { m_cStructure->iCodecId = codecId; }
+
+  /// @brief To get with @ref SetCodecId() changed values.
   unsigned int GetCodecId() const { return m_cStructure->iCodecId; }
 
+  /// @brief 3 letter language id.
   void SetLanguage(const std::string& language)
   {
     if (language.size() > 3)
@@ -70,62 +164,153 @@ class PVRStreamProperties
     m_cStructure->strLanguage[2] = language[2];
     m_cStructure->strLanguage[2] = 0;
   }
+
+  /// @brief To get with @ref SetLanguage() changed values.
   std::string GetLanguage() const { return m_cStructure->strLanguage; }
 
+  /// @brief Subtitle Info
   void SetSubtitleInfo(int subtitleInfo) { m_cStructure->iSubtitleInfo = subtitleInfo; }
+
+  /// @brief To get with @ref SetSubtitleInfo() changed values.
   int GetSubtitleInfo() const { return m_cStructure->iSubtitleInfo; }
 
+  /// @brief To set scale of 1000 and a rate of 29970 will result in 29.97 fps.
   void SetFPSScale(int fpsScale) { m_cStructure->iFPSScale = fpsScale; }
+
+  /// @brief To get with @ref SetFPSScale() changed values.
   int GetFPSScale() const { return m_cStructure->iFPSScale; }
 
+  /// @brief FPS rate
   void SetFPSRate(int fpsRate) { m_cStructure->iFPSRate = fpsRate; }
+
+  /// @brief To get with @ref SetFPSRate() changed values.
   int GetFPSRate() const { return m_cStructure->iFPSRate; }
 
+  /// @brief Height of the stream reported by the demuxer
   void SetHeight(int height) { m_cStructure->iHeight = height; }
+
+  /// @brief To get with @ref SetHeight() changed values.
   int GetHeight() const { return m_cStructure->iHeight; }
 
+  /// @brief Width of the stream reported by the demuxer.
   void SetWidth(int width) { m_cStructure->iWidth = width; }
+
+  /// @brief To get with @ref SetWidth() changed values.
   int GetWidth() const { return m_cStructure->iWidth; }
 
+  /// @brief Display aspect ratio of the stream.
   void SetAspect(float aspect) { m_cStructure->fAspect = aspect; }
+
+  /// @brief To get with @ref SetAspect() changed values.
   float GetAspect() const { return m_cStructure->fAspect; }
 
+  /// @brief Amount of channels.
   void SetChannels(int channels) { m_cStructure->iChannels = channels; }
+
+  /// @brief To get with @ref SetChannels() changed values.
   int GetChannels() const { return m_cStructure->iChannels; }
 
+  /// @brief Sample rate.
   void SetSampleRate(int sampleRate) { m_cStructure->iSampleRate = sampleRate; }
+
+  /// @brief To get with @ref SetSampleRate() changed values.
   int GetSampleRate() const { return m_cStructure->iSampleRate; }
 
+  /// @brief Block alignment
   void SetBlockAlign(int blockAlign) { m_cStructure->iBlockAlign = blockAlign; }
+
+  /// @brief To get with @ref SetBlockAlign() changed values.
   int GetBlockAlign() const { return m_cStructure->iBlockAlign; }
 
+  /// @brief Bit rate.
   void SetBitRate(int bitRate) { m_cStructure->iBitRate = bitRate; }
+
+  /// @brief To get with @ref SetBitRate() changed values.
   int GetBitRate() const { return m_cStructure->iBitRate; }
 
+  /// @brief Bits per sample.
   void SetBitsPerSample(int bitsPerSample) { m_cStructure->iBitsPerSample = bitsPerSample; }
+
+  /// @brief To get with @ref SetBitsPerSample() changed values.
   int GetBitsPerSample() const { return m_cStructure->iBitsPerSample; }
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Stream_PVRStreamTimes class PVRStreamTimes
+/// @ingroup cpp_kodi_addon_pvr_Defs_Stream
+/// @brief **Times of playing stream (Live TV and recordings)**\n
+/// This class is used to transfer the necessary data when
+/// @ref kodi::addon::PVRStreamProperties::GetStreamTimes is called.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Stream_PVRStreamTimes_Help
+///
+///@{
 class PVRStreamTimes : public CStructHdl<PVRStreamTimes, PVR_STREAM_TIMES>
 {
 public:
+  /*! \cond PRIVATE */
   PVRStreamTimes() { memset(m_cStructure, 0, sizeof(PVR_STREAM_TIMES)); }
   PVRStreamTimes(const PVRStreamTimes& type) : CStructHdl(type) {}
   PVRStreamTimes(const PVR_STREAM_TIMES* type) : CStructHdl(type) {}
   PVRStreamTimes(PVR_STREAM_TIMES* type) : CStructHdl(type) {}
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Stream_PVRStreamTimes_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Stream_PVRStreamTimes
+  /// ----------------------------------------------------------------------------
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamTimes :</b>
+  /// | Name | Type | Set call | Get call
+  /// |------|------|----------|----------
+  /// | **Start time** | `time_t` | @ref PVRStreamTimes::SetStartTime "SetStartTime" | @ref PVRStreamTimes::GetStartTime "GetStartTime"
+  /// | **PTS start** | `int64_t` | @ref PVRStreamTimes::SetPTSStart "SetPTSStart" | @ref PVRStreamTimes::GetPTSStart "GetPTSStart"
+  /// | **PTS begin** | `int64_t` | @ref PVRStreamTimes::SetPTSBegin "SetPTSBegin" | @ref PVRStreamTimes::GetPTSBegin "GetPTSBegin"
+  /// | **PTS end** | `int64_t` | @ref PVRStreamTimes::SetPTSEnd "SetPTSEnd" | @ref PVRStreamTimes::GetPTSEnd "GetPTSEnd"
+  ///
 
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Stream_PVRStreamTimes
+  ///@{
+
+  /// @brief For recordings, this must be zero. For Live TV, this is a reference
+  /// time in units of time_t (UTC) from which time elapsed starts. Ideally start
+  /// of tv show, but can be any other value.
   void SetStartTime(time_t startTime) { m_cStructure->startTime = startTime; }
+
+  /// @brief To get with @ref SetStartTime() changed values.
   time_t GetStartTime() const { return m_cStructure->startTime; }
 
+  /// @brief The pts of startTime.
   void SetPTSStart(int64_t ptsStart) { m_cStructure->ptsStart = ptsStart; }
+
+  /// @brief To get with @ref SetPTSStart() changed values.
   int64_t GetPTSStart() const { return m_cStructure->ptsStart; }
 
+  /// @brief Earliest pts player can seek back. Value is in micro seconds,
+  /// relative to PTS start. For recordings, this must be zero. For Live TV, this
+  /// must be zero if not timeshifting and must point to begin of the timeshift
+  /// buffer, otherwise.
   void SetPTSBegin(int64_t ptsBegin) { m_cStructure->ptsBegin = ptsBegin; }
+
+  /// @brief To get with @ref SetPTSBegin() changed values.
   int64_t GetPTSBegin() const { return m_cStructure->ptsBegin; }
 
+  /// @brief Latest pts player can seek forward. Value is in micro seconds,
+  /// relative to PTS start. For recordings, this must be the total length. For
+  /// Live TV, this must be zero if not timeshifting and must point to end of
+  /// the timeshift buffer, otherwise.
   void SetPTSEnd(int64_t ptsEnd) { m_cStructure->ptsEnd = ptsEnd; }
+
+  /// @brief To get with @ref SetPTSEnd() changed values.
   int64_t GetPTSEnd() const { return m_cStructure->ptsEnd; }
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h
index 8dc364df6f4b..b838f1c08d99 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/pvr/Timers.h
@@ -12,6 +12,8 @@
 #include "../../AddonBase.h"
 #include "../../c-api/addon-instance/pvr.h"
 
+//
+// "C++" Definitions group 6 - PVR timers
 #ifdef __cplusplus
 
 namespace kodi
@@ -19,9 +21,24 @@ namespace kodi
 namespace addon
 {
 
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimer class PVRTimer
+/// @ingroup cpp_kodi_addon_pvr_Defs_Timer
+/// @brief **PVR add-on timer type**\n
+/// Representation of a timer event.
+///
+/// The related values here are automatically initiated to defaults and need
+/// only be set if supported and used.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Timer_PVRTimer_Help
+///
+///@{
 class PVRTimer : public CStructHdl<PVRTimer, PVR_TIMER>
 {
 public:
+  /*! \cond PRIVATE */
   PVRTimer()
   {
     m_cStructure->iClientIndex = 0;
@@ -50,147 +67,465 @@ class PVRTimer : public CStructHdl<PVRTimer, PVR_TIMER>
   PVRTimer(const PVRTimer& data) : CStructHdl(data) {}
   PVRTimer(const PVR_TIMER* data) : CStructHdl(data) {}
   PVRTimer(PVR_TIMER* data) : CStructHdl(data) {}
-
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimer_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimer
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimer :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **Client index** | `unsigned int` | @ref PVRTimer::SetClientIndex "SetClientIndex" | @ref PVRTimer::GetClientIndex "GetClientIndex" | *required to set*
+  /// | **State** | @ref PVR_TIMER_STATE | @ref PVRTimer::SetState "SetState" | @ref PVRTimer::GetState "GetState" | *required to set*
+  /// | **Type** | `unsigned int` | @ref PVRTimer::SetTimerType "SetTimerType" | @ref PVRTimer::GetTimerType "GetTimerType" | *required to set*
+  /// | **Title** | `std::string` | @ref PVRTimer::SetTitle "SetTitle" | @ref PVRTimer::GetTitle "GetTitle" | *required to set*
+  /// | **Parent client index** | `unsigned int` | @ref PVRTimer::SetParentClientIndex "SetParentClientIndex" | @ref PVRTimer::GetParentClientIndex "GetParentClientIndex" | *optional*
+  /// | **Client channel unique identifier** | `int` | @ref PVRTimer::SetClientChannelUid "SetClientChannelUid" | @ref PVRTimer::GetClientChannelUid "GetClientChannelUid" | *optional*
+  /// | **Start time** | `time_t` | @ref PVRTimer::SetStartTime "SetStartTime" | @ref PVRTimer::GetStartTime "GetStartTime" | *optional*
+  /// | **End time** | `time_t` | @ref PVRTimer::SetEndTime "SetEndTime" | @ref PVRTimer::GetEndTime "GetEndTime" | *optional*
+  /// | **Start any time** | `bool` | @ref PVRTimer::SetStartAnyTime "SetStartAnyTime" | @ref PVRTimer::GetStartAnyTime "GetStartAnyTime" | *optional*
+  /// | **End any time** | `bool` | @ref PVRTimer::SetEndAnyTime "SetEndAnyTime" | @ref PVRTimer::GetEndAnyTime "GetEndAnyTime" | *optional*
+  /// | **EPG search string** | `std::string` | @ref PVRTimer::SetEPGSearchString "SetEPGSearchString" | @ref PVRTimer::GetEPGSearchString "GetEPGSearchString" | *optional*
+  /// | **Full text EPG search** | `bool` | @ref PVRTimer::SetFullTextEpgSearch "SetFullTextEpgSearch" | @ref PVRTimer::GetFullTextEpgSearch "GetFullTextEpgSearch" | *optional*
+  /// | **Recording store directory** | `std::string` | @ref PVRTimer::SetDirectory "SetDirectory" | @ref PVRTimer::GetDirectory "GetDirectory" | *optional*
+  /// | **Timer priority** | `int` | @ref PVRTimer::SetPriority "SetPriority" | @ref PVRTimer::GetPriority "GetPriority" | *optional*
+  /// | **Timer lifetime** | `int` | @ref PVRTimer::SetLifetime "SetLifetime" | @ref PVRTimer::GetLifetime "GetLifetime" | *optional*
+  /// | **Max recordings** | `int` | @ref PVRTimer::SetMaxRecordings "SetMaxRecordings" | @ref PVRTimer::GetMaxRecordings "GetMaxRecordings" | *optional*
+  /// | **Recording group** | `unsigned int` | @ref PVRTimer::SetRecordingGroup "SetRecordingGroup" | @ref PVRTimer::GetRecordingGroup "GetRecordingGroup" | *optional*
+  /// | **First start day** | `time_t` | @ref PVRTimer::SetFirstDay "SetFirstDay" | @ref PVRTimer::GetFirstDay "GetFirstDay" | *optional*
+  /// | **Used timer weekdays** | `unsigned int` | @ref PVRTimer::SetWeekdays "SetWeekdays" | @ref PVRTimer::GetWeekdays "GetWeekdays" | *optional*
+  /// | **Prevent duplicate episodes** | `unsigned int` | @ref PVRTimer::SetPreventDuplicateEpisodes "SetPreventDuplicateEpisodes" | @ref PVRTimer::GetPreventDuplicateEpisodes "GetPreventDuplicateEpisodes" | *optional*
+  /// | **EPG unique identifier** | `unsigned int` | @ref PVRTimer::SetEPGUid "SetEPGUid" | @ref PVRTimer::GetEPGUid "GetEPGUid" | *optional*
+  /// | **Margin start** | `unsigned int` | @ref PVRTimer::SetMarginStart "SetMarginStart" | @ref PVRTimer::GetMarginStart "GetMarginStart" | *optional*
+  /// | **Margin end** | `unsigned int` | @ref PVRTimer::SetMarginEnd "SetMarginEnd" | @ref PVRTimer::GetMarginEnd "GetMarginEnd" | *optional*
+  /// | **Genre type** | `int` | @ref PVRTimer::SetGenreType "SetGenreType" | @ref PVRTimer::GetGenreType "GetGenreType" | *optional*
+  /// | **Genre sub type** | `int` | @ref PVRTimer::SetGenreSubType "SetGenreSubType" | @ref PVRTimer::GetGenreSubType "GetGenreSubType" | *optional*
+  /// | **Series link** | `std::string` | @ref PVRTimer::SetSeriesLink "SetSeriesLink" | @ref PVRTimer::GetSeriesLink "GetSeriesLink" | *optional*
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimer
+  ///@{
+
+  /// @brief **required**\n
+  /// The index of this timer given by the client.
+  ///
+  /// @ref PVR_TIMER_NO_CLIENT_INDEX indicates that the index was not yet set
+  /// by the client, for example for new timers created by Kodi and passed the
+  /// first time to the client. A valid index must be greater than
+  /// @ref PVR_TIMER_NO_CLIENT_INDEX.
+  ///
   void SetClientIndex(unsigned int clientIndex) { m_cStructure->iClientIndex = clientIndex; }
+
+  /// @brief To get with @ref SetClientIndex changed values.
   unsigned int GetClientIndex() const { return m_cStructure->iClientIndex; }
 
+  /// @brief **required**\n
+  /// The state of this timer.
+  ///
+  /// @note @ref PVR_TIMER_STATE_NEW is default.
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRTimer tag;
+  /// tag.SetState(PVR_TIMER_STATE_RECORDING);
+  /// ~~~~~~~~~~~~~
+  ///
   void SetState(PVR_TIMER_STATE state) { m_cStructure->state = state; }
+
+  /// @brief To get with @ref SetState changed values.
   PVR_TIMER_STATE GetState() const { return m_cStructure->state; }
 
+  /// @brief **required**\n
+  /// The type of this timer.
+  ///
+  /// It is private to the addon and can be freely defined by the addon.
+  /// The value must be greater than @ref PVR_TIMER_TYPE_NONE.
+  ///
+  /// Kodi does not interpret this value (except for checking for @ref PVR_TIMER_TYPE_NONE),
+  /// but will pass the right id to the addon with every @ref PVRTimer instance,
+  /// thus the addon easily can determine the timer type.
+  ///
+  /// @note @ref PVR_TIMER_TYPE_NONE is default.
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRTimer tag;
+  /// tag.SetTimerType(123);
+  /// ~~~~~~~~~~~~~
+  ///
   void SetTimerType(unsigned int timerType) { m_cStructure->iTimerType = timerType; }
+
+  /// @brief To get with @ref SetTimerType changed values.
   unsigned int GetTimerType() const { return m_cStructure->iTimerType; }
 
+  /// @brief **required**\n
+  /// A title for this timer.
   void SetTitle(const std::string& title)
   {
     strncpy(m_cStructure->strTitle, title.c_str(), sizeof(m_cStructure->strTitle) - 1);
   }
+
+  /// @brief To get with @ref SetTitle changed values.
   std::string GetTitle() const { return m_cStructure->strTitle; }
 
+  /// @brief **optional**\n
+  /// For timers scheduled by a repeating timer.
+  ///
+  /// The index of the repeating timer that scheduled this timer (it's
+  /// @ref clientIndex value). Use @ref PVR_TIMER_NO_PARENT to indicate that
+  /// this timer was no scheduled by a repeating timer.
   void SetParentClientIndex(unsigned int parentClientIndex)
   {
     m_cStructure->iParentClientIndex = parentClientIndex;
   }
+
+  /// @brief To get with @ref SetParentClientIndex changed values.
   unsigned int GetParentClientIndex() const { return m_cStructure->iParentClientIndex; }
 
+  /// @brief **optional**\n
+  /// Unique identifier of the channel to record on.
+  ///
+  /// @ref PVR_TIMER_ANY_CHANNEL will denote "any channel", not a specific one.
+  /// @ref PVR_CHANNEL_INVALID_UID denotes that channel uid is not available.
   void SetClientChannelUid(int clientChannelUid)
   {
     m_cStructure->iClientChannelUid = clientChannelUid;
   }
+
+  /// @brief To get with @ref SetClientChannelUid changed values
   int GetClientChannelUid() const { return m_cStructure->iClientChannelUid; }
 
+  /// @brief **optional**\n
+  /// Start time of the recording in UTC.
+  ///
+  /// Instant timers that are sent to the add-on by Kodi will have this value
+  /// set to 0.
   void SetStartTime(time_t startTime) { m_cStructure->startTime = startTime; }
+
+  /// @brief To get with @ref SetStartTime changed values.
   time_t GetStartTime() const { return m_cStructure->startTime; }
 
+  /// @brief **optional**\n
+  /// End time of the recording in UTC.
   void SetEndTime(time_t endTime) { m_cStructure->endTime = endTime; }
+
+  /// @brief To get with @ref SetEndTime changed values.
   time_t GetEndTime() const { return m_cStructure->endTime; }
 
+  /// @brief **optional**\n
+  /// For EPG based (not Manual) timers indicates startTime does not apply.
+  ///
+  /// Default = false.
   void SetStartAnyTime(bool startAnyTime) { m_cStructure->bStartAnyTime = startAnyTime; }
+
+  /// @brief To get with @ref SetStartAnyTime changed values.
   bool GetStartAnyTime() const { return m_cStructure->bStartAnyTime; }
 
+  /// @brief **optional**\n
+  /// For EPG based (not Manual) timers indicates endTime does not apply.
+  ///
+  /// Default = false
   void SetEndAnyTime(bool endAnyTime) { m_cStructure->bEndAnyTime = endAnyTime; }
+
+  /// @brief To get with @ref SetEndAnyTime changed values.
   bool GetEndAnyTime() const { return m_cStructure->bEndAnyTime; }
 
+  /// @brief **optional**\n
+  /// A string used to search epg data for repeating epg-based timers.
+  ///
+  /// Format is backend-dependent, for example regexp.
   void SetEPGSearchString(const std::string& epgSearchString)
   {
     strncpy(m_cStructure->strEpgSearchString, epgSearchString.c_str(),
             sizeof(m_cStructure->strEpgSearchString) - 1);
   }
+
+  /// @brief To get with @ref SetEPGSearchString changed values
   std::string GetEPGSearchString() const { return m_cStructure->strEpgSearchString; }
 
+  /// @brief **optional**\n
+  /// Indicates, whether @ref SetEPGSearchString() is to match against the epg
+  /// episode title only or also against "other" epg data (backend-dependent).
   void SetFullTextEpgSearch(bool fullTextEpgSearch)
   {
     m_cStructure->bFullTextEpgSearch = fullTextEpgSearch;
   }
+
+  /// @brief To get with @ref SetFullTextEpgSearch changed values.
   bool GetFullTextEpgSearch() const { return m_cStructure->bFullTextEpgSearch; }
 
+  /// @brief **optional**\n
+  /// The (relative) directory where the recording will be stored in.
   void SetDirectory(const std::string& directory)
   {
     strncpy(m_cStructure->strDirectory, directory.c_str(), sizeof(m_cStructure->strDirectory) - 1);
   }
+
+  /// @brief To get with @ref SetDirectory changed values.
   std::string GetDirectory() const { return m_cStructure->strDirectory; }
 
+  /// @brief **optional**\n
+  /// The summary for this timer.
   void SetSummary(const std::string& summary)
   {
     strncpy(m_cStructure->strSummary, summary.c_str(), sizeof(m_cStructure->strSummary) - 1);
   }
+
+  /// @brief To get with @ref SetDirectory changed values.
   std::string GetSummary() const { return m_cStructure->strSummary; }
 
+  /// @brief **optional**\n
+  /// The priority of this timer.
   void SetPriority(int priority) { m_cStructure->iPriority = priority; }
+
+  /// @brief To get with @ref SetPriority changed values.
   int GetPriority() const { return m_cStructure->iPriority; }
 
+  /// @brief **optional**\n
+  /// Lifetime of recordings created by this timer.
+  ///
+  /// Value > 0 days after which recordings will be deleted by the backend, < 0
+  /// addon defined integer list reference, == 0 disabled.
   void SetLifetime(int priority) { m_cStructure->iLifetime = priority; }
+
+  /// @brief To get with @ref SetLifetime changed values.
   int GetLifetime() const { return m_cStructure->iLifetime; }
 
+  /// @brief **optional**\n
+  /// Maximum number of recordings this timer shall create.
+  ///
+  /// Value > 0 number of recordings, < 0 addon defined integer list reference, == 0 disabled.
   void SetMaxRecordings(int maxRecordings) { m_cStructure->iMaxRecordings = maxRecordings; }
+
+  /// @brief To get with @ref SetMaxRecordings changed values.
   int GetMaxRecordings() const { return m_cStructure->iMaxRecordings; }
 
+  /// @brief **optional**\n
+  /// Integer ref to addon/backend defined list of recording groups.
   void SetRecordingGroup(unsigned int recordingGroup)
   {
     m_cStructure->iRecordingGroup = recordingGroup;
   }
+
+  /// @brief To get with @ref SetRecordingGroup changed values.
   unsigned int GetRecordingGroup() const { return m_cStructure->iRecordingGroup; }
 
+  /// @brief **optional**\n
+  /// The first day this timer is active, for repeating timers.
   void SetFirstDay(time_t firstDay) { m_cStructure->firstDay = firstDay; }
+
+  /// @brief To get with @ref SetFirstDay changed values.
   time_t GetFirstDay() const { return m_cStructure->firstDay; }
 
+  /// @brief **optional**\n
+  /// Week days, for repeating timers (see
+  /// @ref cpp_kodi_addon_pvr_Defs_Timer_PVR_WEEKDAY "PVR_WEEKDAY_*" constant values)
+  ///
+  /// @note @ref PVR_WEEKDAY_NONE is default.
+  ///
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// kodi::addon::PVRTimer tag;
+  /// tag.SetWeekdays(PVR_WEEKDAY_MONDAY | PVR_WEEKDAY_SATURDAY);
+  /// ...
+  /// ~~~~~~~~~~~~~
   void SetWeekdays(unsigned int weekdays) { m_cStructure->iWeekdays = weekdays; }
+
+  /// @brief To get with @ref SetFirstDay changed values.
   unsigned int GetWeekdays() const { return m_cStructure->iWeekdays; }
 
+  /// @brief **optional**\n
+  /// Prevent duplicate episodes.
+  ///
+  /// Should 1 if backend should only record new episodes in case of a repeating
+  /// epg-based timer, 0 if all episodes shall be recorded (no duplicate detection).
+  ///
+  /// Actual algorithm for duplicate detection is defined by the backend.
+  /// Addons may define own values for different duplicate detection
+  /// algorithms, thus this is not just a bool.
   void SetPreventDuplicateEpisodes(unsigned int preventDuplicateEpisodes)
   {
     m_cStructure->iPreventDuplicateEpisodes = preventDuplicateEpisodes;
   }
+
+  /// @brief To get with @ref SetPreventDuplicateEpisodes changed values.
   unsigned int GetPreventDuplicateEpisodes() const
   {
     return m_cStructure->iPreventDuplicateEpisodes;
   }
 
+  /// @brief **optional**\n
+  /// EPG event id associated with this timer. Event ids must be unique for a
+  /// channel.
+  ///
+  /// Valid ids must be greater than @ref EPG_TAG_INVALID_UID.
   void SetEPGUid(unsigned int epgUid) { m_cStructure->iEpgUid = epgUid; }
+
+  /// @brief To get with @ref SetEPGUid changed values.
   unsigned int GetEPGUid() const { return m_cStructure->iEpgUid; }
 
+  /// @brief **optional**\n
+  /// If set, the backend starts the recording selected minutes before
+  /// @ref SetStartTime.
   void SetMarginStart(unsigned int marginStart) { m_cStructure->iMarginStart = marginStart; }
+
+  /// @brief To get with @ref SetMarginStart changed values.
   unsigned int GetMarginStart() const { return m_cStructure->iMarginStart; }
 
+  /// @brief **optional**\n
+  /// If set, the backend ends the recording selected minutes after
+  /// @ref SetEndTime.
   void SetMarginEnd(unsigned int marginEnd) { m_cStructure->iMarginEnd = marginEnd; }
+
+  /// @brief To get with @ref SetMarginEnd changed values.
   unsigned int GetMarginEnd() const { return m_cStructure->iMarginEnd; }
 
+  /// @brief **optional**\n
+  /// Genre type.
+  ///
+  /// @copydetails EPG_EVENT_CONTENTMASK
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// kodi::addon::PVRTimer tag;
+  /// tag.SetGenreType(EPG_EVENT_CONTENTMASK_MOVIEDRAMA);
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  /// @note If confirmed that backend brings the types in [ETSI EN 300 468](https://www.etsi.org/deliver/etsi_en/300400_300499/300468/01.14.01_60/en_300468v011401p.pdf)
+  /// conform values, can be @ref EPG_EVENT_CONTENTMASK ignored and to set here
+  /// with backend value.
+  ///
   void SetGenreType(int genreType) { m_cStructure->iGenreType = genreType; }
+
+  /// @brief To get with @ref SetGenreType changed values.
   int GetGenreType() const { return m_cStructure->iGenreType; }
 
+  /// @brief **optional**\n
+  /// Genre sub type.
+  ///
+  /// @copydetails EPG_EVENT_CONTENTMASK
+  ///
+  /// Subtypes groups related to set by @ref SetGenreType:
+  /// | Main genre type | List with available sub genre types
+  /// |-----------------|-----------------------------------------
+  /// | @ref EPG_EVENT_CONTENTMASK_UNDEFINED | Nothing, should be 0
+  /// | @ref EPG_EVENT_CONTENTMASK_MOVIEDRAMA | @ref EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA
+  /// | @ref EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS | @ref EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS
+  /// | @ref EPG_EVENT_CONTENTMASK_SHOW | @ref EPG_EVENT_CONTENTSUBMASK_SHOW
+  /// | @ref EPG_EVENT_CONTENTMASK_SPORTS | @ref EPG_EVENT_CONTENTSUBMASK_SPORTS
+  /// | @ref EPG_EVENT_CONTENTMASK_CHILDRENYOUTH | @ref EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH
+  /// | @ref EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE | @ref EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE
+  /// | @ref EPG_EVENT_CONTENTMASK_ARTSCULTURE | @ref EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE
+  /// | @ref EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS | @ref EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS
+  /// | @ref EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE | @ref EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE
+  /// | @ref EPG_EVENT_CONTENTMASK_LEISUREHOBBIES | @ref EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES
+  /// | @ref EPG_EVENT_CONTENTMASK_SPECIAL | @ref EPG_EVENT_CONTENTSUBMASK_SPECIAL
+  /// | @ref EPG_EVENT_CONTENTMASK_USERDEFINED | Can be defined by you
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// kodi::addon::PVRTimer tag;
+  /// tag.SetGenreType(EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE);
+  /// tag.SetGenreSubType(EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_JAZZ);
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   void SetGenreSubType(int genreSubType) { m_cStructure->iGenreSubType = genreSubType; }
+
+  /// @brief To get with @ref SetGenreType changed values.
   int GetGenreSubType() const { return m_cStructure->iGenreSubType; }
 
+  /// @brief **optional**\n
+  /// Series link for this timer.
+  ///
+  /// If set for an epg-based timer rule, matching events will be found by
+  /// checking with here, instead of @ref SetTitle() (and @ref SetFullTextEpgSearch()).
   void SetSeriesLink(const std::string& seriesLink)
   {
     strncpy(m_cStructure->strSeriesLink, seriesLink.c_str(),
             sizeof(m_cStructure->strSeriesLink) - 1);
   }
 
+  /// @brief To get with @ref SetSeriesLink changed values.
   std::string GetSeriesLink() const { return m_cStructure->strSeriesLink; }
+  ///@}
 };
 
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimersResultSet class PVRTimersResultSet
+/// @ingroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimer
+/// @brief **PVR add-on timer transfer class**\n
+/// To transfer the content of @ref kodi::addon::CInstancePVRClient::GetTimers().
+///
+/// @note This becomes only be used on addon call above, not usable outside on
+/// addon itself.
+///@{
 class PVRTimersResultSet
 {
 public:
+  /*! \cond PRIVATE */
   PVRTimersResultSet() = delete;
   PVRTimersResultSet(const AddonInstance_PVR* instance, ADDON_HANDLE handle)
     : m_instance(instance), m_handle(handle)
   {
   }
+  /*! \endcond */
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimersResultSet
+  ///@{
 
+  /// @brief To add and give content from addon to Kodi on related call.
+  ///
+  /// @param[in] tag The to transfered data.
   void Add(const kodi::addon::PVRTimer& tag)
   {
     m_instance->toKodi->TransferTimerEntry(m_instance->toKodi->kodiInstance, m_handle, tag);
   }
 
+  ///@}
+
 private:
   const AddonInstance_PVR* m_instance = nullptr;
   const ADDON_HANDLE m_handle;
 };
-
+///@}
+//------------------------------------------------------------------------------
+
+//==============================================================================
+/// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType class PVRTimerType
+/// @ingroup cpp_kodi_addon_pvr_Defs_Timer
+/// @brief **PVR add-on timer type**\n
+/// To define the content of @ref kodi::addon::CInstancePVRClient::GetTimerTypes()
+/// given groups.
+///
+/// ----------------------------------------------------------------------------
+///
+/// @copydetails cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType_Help
+///
+///@{
 class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
 {
 public:
+  /*! \cond PRIVATE */
   PVRTimerType()
   {
     memset(m_cStructure, 0, sizeof(PVR_TIMER_TYPE));
@@ -203,22 +538,94 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
   PVRTimerType(const PVRTimerType& type) : CStructHdl(type) {}
   PVRTimerType(const PVR_TIMER_TYPE* type) : CStructHdl(type) {}
   PVRTimerType(PVR_TIMER_TYPE* type) : CStructHdl(type) {}
-
+  /*! \endcond */
+
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType_Help Value Help
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType
+  /// ----------------------------------------------------------------------------
+  ///
+  /// <b>The following table contains values that can be set with @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType :</b>
+  /// | Name | Type | Set call | Get call | Usage
+  /// |------|------|----------|----------|-----------
+  /// | **Identifier** | `unsigned int` | @ref PVRTimerType::SetId "SetId" | @ref PVRTimerType::GetId "GetId" | *required to set*
+  /// | **Attributes** | `unsigned int` | @ref PVRTimerType::SetAttributes "SetAttributes" | @ref PVRTimerType::GetAttributes "GetAttributes" | *required to set*
+  /// | **Description** | `std::string` | @ref PVRTimerType::SetDescription "SetDescription" | @ref PVRTimerType::GetDescription "GetDescription" | *optional*
+  /// | | | | | |
+  /// | **Priority selection** |  @ref cpp_kodi_addon_pvr_Defs_PVRTypeIntValue "PVRTypeIntValue" | @ref PVRTimerType::SetPriorities "SetPriorities" | @ref PVRTimerType::GetPriorities "GetPriorities" | *optional*
+  /// | **Priority default selection** | `int`| @ref PVRTimerType::SetPrioritiesDefault "SetPrioritiesDefault" | @ref PVRTimerType::GetPrioritiesDefault "GetPrioritiesDefault" | *optional*
+  /// | | | | | |
+  /// | **Lifetime selection** |  @ref cpp_kodi_addon_pvr_Defs_PVRTypeIntValue "PVRTypeIntValue" | @ref PVRTimerType::SetLifetimes "SetLifetimes" | @ref PVRTimerType::GetLifetimes "GetLifetimes" | *optional*
+  /// | **Lifetime default selection** | `int`| @ref PVRTimerType::SetLifetimesDefault "SetLifetimesDefault" | @ref PVRTimerType::GetLifetimesDefault "GetLifetimesDefault" | *optional*
+  /// | | | | | |
+  /// | **Prevent duplicate episodes selection** |  @ref cpp_kodi_addon_pvr_Defs_PVRTypeIntValue "PVRTypeIntValue" | @ref PVRTimerType::SetPreventDuplicateEpisodes "SetPreventDuplicateEpisodes" | @ref PVRTimerType::GetPreventDuplicateEpisodes "GetPreventDuplicateEpisodes" | *optional*
+  /// | **Prevent duplicate episodes default** | `int`| @ref PVRTimerType::SetPreventDuplicateEpisodesDefault "SetPreventDuplicateEpisodesDefault" | @ref PVRTimerType::GetPreventDuplicateEpisodesDefault "GetPreventDuplicateEpisodesDefault" | *optional*
+  /// | | | | | |
+  /// | **Recording group selection**|  @ref cpp_kodi_addon_pvr_Defs_PVRTypeIntValue "PVRTypeIntValue" | @ref PVRTimerType::SetRecordingGroups "SetRecordingGroups" | @ref PVRTimerType::GetRecordingGroups "GetRecordingGroups" | *optional*
+  /// | **Recording group default** | `int`| @ref PVRTimerType::SetRecordingGroupDefault "SetRecordingGroupDefault" | @ref PVRTimerType::GetRecordingGroupDefault "GetRecordingGroupDefault" | *optional*
+  /// | | | | | |
+  /// | **Max recordings selection** | @ref cpp_kodi_addon_pvr_Defs_PVRTypeIntValue "PVRTypeIntValue" | @ref PVRTimerType::SetMaxRecordings "SetMaxRecordings" | @ref PVRTimerType::GetMaxRecordings "GetMaxRecordings" | *optional*
+  /// | **Max recordings default** | `int`| @ref PVRTimerType::SetMaxRecordingsDefault "SetMaxRecordingsDefault" | @ref PVRTimerType::GetMaxRecordingsDefault "GetMaxRecordingsDefault" | *optional*
+  ///
+
+  /// @addtogroup cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType
+  ///@{
+
+  /// @brief **required**\n
+  /// This type's identifier. Ids must be > @ref PVR_TIMER_TYPE_NONE.
   void SetId(unsigned int id) { m_cStructure->iId = id; }
+
+  /// @brief To get with @ref SetAttributes changed values.
   unsigned int GetId() const { return m_cStructure->iId; }
 
+  /// @brief **required**\n
+  /// Defines the attributes for this type (@ref cpp_kodi_addon_pvr_Defs_Timer_PVR_TIMER_TYPE "PVR_TIMER_TYPE_*" constants).
+  ///
+  /// To defines the attributes for a type. These values are bit fields that can be
+  /// used together.
+  ///
+  ///--------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRTimerType tag;
+  /// tag.SetAttributes(PVR_TIMER_TYPE_IS_MANUAL | PVR_TIMER_TYPE_IS_REPEATING);
+  /// ~~~~~~~~~~~~~
+  ///
   void SetAttributes(uint64_t attributes) { m_cStructure->iAttributes = attributes; }
+
+  /// @brief To get with @ref SetAttributes changed values.
   uint64_t GetAttributes() const { return m_cStructure->iAttributes; }
 
+  /// @brief **optional**\n
+  /// A short localized string describing the purpose of the type. (e.g.
+  /// "Any time at this channel if title matches").
+  ///
+  /// If left blank, Kodi will generate a description based on the attributes
+  /// REPEATING and MANUAL. (e.g. "Repeating EPG-based.")
   void SetDescription(const std::string& description)
   {
     strncpy(m_cStructure->strDescription, description.c_str(),
             sizeof(m_cStructure->strDescription) - 1);
   }
+
+  /// @brief To get with @ref SetDescription changed values.
   std::string GetDescription() const { return m_cStructure->strDescription; }
 
-  void SetPriorities(const std::vector<PVRTypeIntValue>& priorities,
-                     int prioritiesDefault = -1)
+  //----------------------------------------------------------------------------
+
+  /// @brief **optional**\n
+  /// Priority value definitions.
+  ///
+  /// Array containing the possible values for @ref PVRTimer::SetPriority().
+  ///
+  /// @param[in] priorities List of priority values
+  /// @param[in] prioritiesDefault [opt] The default value in list, can also be
+  ///                              set by @ref SetPrioritiesDefault()
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_PVRTypeIntValue_Help
+  void SetPriorities(const std::vector<PVRTypeIntValue>& priorities, int prioritiesDefault = -1)
   {
     m_cStructure->iPrioritiesSize = priorities.size();
     for (unsigned int i = 0;
@@ -232,6 +639,8 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     if (prioritiesDefault != -1)
       m_cStructure->iPrioritiesDefault = prioritiesDefault;
   }
+
+  /// @brief To get with @ref SetPriorities changed values.
   std::vector<PVRTypeIntValue> GetPriorities() const
   {
     std::vector<PVRTypeIntValue> ret;
@@ -241,6 +650,11 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     return ret;
   }
 
+  /// @brief **optional**\n
+  /// The default value for @ref PVRTimer::SetPriority().
+  ///
+  /// @note Must be filled if @ref SetPriorities contain values and not
+  /// defined there on second function value.
   void SetPrioritiesDefault(int prioritiesDefault)
   {
     m_cStructure->iPrioritiesDefault = prioritiesDefault;
@@ -249,6 +663,20 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
   /// @brief To get with @ref SetPrioritiesDefault changed values.
   int GetPrioritiesDefault() const { return m_cStructure->iPrioritiesDefault; }
 
+  //----------------------------------------------------------------------------
+
+  /// @brief **optional**\n
+  /// Lifetime value definitions.
+  ///
+  /// Array containing the possible values for @ref PVRTimer::SetLifetime().
+  ///
+  /// @param[in] lifetimes List of lifetimes values
+  /// @param[in] lifetimesDefault [opt] The default value in list, can also be
+  ///                             set by @ref SetLifetimesDefault()
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_PVRTypeIntValue_Help
   void SetLifetimes(const std::vector<PVRTypeIntValue>& lifetimes, int lifetimesDefault = -1)
   {
     m_cStructure->iLifetimesSize = lifetimes.size();
@@ -263,6 +691,8 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     if (lifetimesDefault != -1)
       m_cStructure->iLifetimesDefault = lifetimesDefault;
   }
+
+  /// @brief To get with @ref SetLifetimes changed values.
   std::vector<PVRTypeIntValue> GetLifetimes() const
   {
     std::vector<PVRTypeIntValue> ret;
@@ -272,12 +702,35 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     return ret;
   }
 
+  /// @brief **optional**\n
+  /// The default value for @ref SetLifetimes().
+  ///
+  /// @note Must be filled if @ref SetLifetimes contain values and not
+  /// defined there on second function value.
   void SetLifetimesDefault(int lifetimesDefault)
   {
     m_cStructure->iLifetimesDefault = lifetimesDefault;
   }
+
+  /// @brief To get with @ref SetLifetimesDefault changed values.
   int GetLifetimesDefault() const { return m_cStructure->iLifetimesDefault; }
 
+  //----------------------------------------------------------------------------
+
+  /// @brief **optional**\n
+  /// Prevent duplicate episodes value definitions.
+  ///
+  /// Array containing the possible values for @ref PVRTimer::SetPreventDuplicateEpisodes().
+  ///
+  /// @note Must be filled if @ref PVRTimer::SetPreventDuplicateEpisodes() is not empty.
+  ///
+  /// @param[in] preventDuplicateEpisodes List of duplicate episodes values
+  /// @param[in] preventDuplicateEpisodesDefault [opt] The default value in list, can also be
+  ///                                            set by @ref SetPreventDuplicateEpisodesDefault()
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_PVRTypeIntValue_Help
   void SetPreventDuplicateEpisodes(
       const std::vector<PVRTypeIntValue>& preventDuplicateEpisodes,
       int preventDuplicateEpisodesDefault = -1)
@@ -296,6 +749,8 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     if (preventDuplicateEpisodesDefault != -1)
       m_cStructure->iPreventDuplicateEpisodesDefault = preventDuplicateEpisodesDefault;
   }
+
+  /// @brief To get with @ref SetPreventDuplicateEpisodes changed values.
   std::vector<PVRTypeIntValue> GetPreventDuplicateEpisodes() const
   {
     std::vector<PVRTypeIntValue> ret;
@@ -305,15 +760,34 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     return ret;
   }
 
+  /// @brief **optional**\n
+  /// The default value for @ref PVRTimer::SetPreventDuplicateEpisodes().
+  ///
+  /// @note Must be filled if @ref SetPreventDuplicateEpisodes contain values and not
+  /// defined there on second function value.
   void SetPreventDuplicateEpisodesDefault(int preventDuplicateEpisodesDefault)
   {
     m_cStructure->iPreventDuplicateEpisodesDefault = preventDuplicateEpisodesDefault;
   }
+
+  /// @brief To get with @ref SetPreventDuplicateEpisodesDefault changed values.
   int GetPreventDuplicateEpisodesDefault() const
   {
     return m_cStructure->iPreventDuplicateEpisodesDefault;
   }
 
+  //----------------------------------------------------------------------------
+
+  /// @brief **optional**\n
+  /// Array containing the possible values of @ref PVRTimer::SetRecordingGroup()
+  ///
+  /// @param[in] recordingGroup List of recording group values
+  /// @param[in] recordingGroupDefault [opt] The default value in list, can also be
+  ///                                  set by @ref SetRecordingGroupDefault()
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_PVRTypeIntValue_Help
   void SetRecordingGroups(const std::vector<PVRTypeIntValue>& recordingGroup,
                           int recordingGroupDefault = -1)
   {
@@ -329,6 +803,8 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     if (recordingGroupDefault != -1)
       m_cStructure->iRecordingGroupDefault = recordingGroupDefault;
   }
+
+  /// @brief To get with @ref SetRecordingGroups changed values
   std::vector<PVRTypeIntValue> GetRecordingGroups() const
   {
     std::vector<PVRTypeIntValue> ret;
@@ -338,12 +814,31 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     return ret;
   }
 
+  /// @brief **optional**\n
+  /// The default value for @ref PVRTimer::SetRecordingGroup().
+  ///
+  /// @note Must be filled if @ref SetRecordingGroups contain values and not
+  /// defined there on second function value.
   void SetRecordingGroupDefault(int recordingGroupDefault)
   {
     m_cStructure->iRecordingGroupDefault = recordingGroupDefault;
   }
+
+  /// @brief To get with @ref SetRecordingGroupDefault changed values
   int GetRecordingGroupDefault() const { return m_cStructure->iRecordingGroupDefault; }
 
+  //----------------------------------------------------------------------------
+
+  /// @brief **optional**\n
+  /// Array containing the possible values of @ref PVRTimer::SetMaxRecordings().
+  ///
+  /// @param[in] maxRecordings List of lifetimes values
+  /// @param[in] maxRecordingsDefault [opt] The default value in list, can also be
+  ///                                 set by @ref SetMaxRecordingsDefault()
+  ///
+  /// --------------------------------------------------------------------------
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Defs_PVRTypeIntValue_Help
   void SetMaxRecordings(const std::vector<PVRTypeIntValue>& maxRecordings,
                         int maxRecordingsDefault = -1)
   {
@@ -359,6 +854,8 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     if (maxRecordingsDefault != -1)
       m_cStructure->iMaxRecordingsDefault = maxRecordingsDefault;
   }
+
+  /// @brief To get with @ref SetMaxRecordings changed values
   std::vector<PVRTypeIntValue> GetMaxRecordings() const
   {
     std::vector<PVRTypeIntValue> ret;
@@ -368,12 +865,21 @@ class PVRTimerType : public CStructHdl<PVRTimerType, PVR_TIMER_TYPE>
     return ret;
   }
 
+  /// @brief **optional**\n
+  /// The default value for @ref SetMaxRecordings().
+  ///
+  /// Can be set with here if on @ref SetMaxRecordings not given as second value.
   void SetMaxRecordingsDefault(int maxRecordingsDefault)
   {
     m_cStructure->iMaxRecordingsDefault = maxRecordingsDefault;
   }
+
+  /// @brief To get with @ref SetMaxRecordingsDefault changed values
   int GetMaxRecordingsDefault() const { return m_cStructure->iMaxRecordingsDefault; }
+  ///@}
 };
+///@}
+//------------------------------------------------------------------------------
 
 } /* namespace addon */
 } /* namespace kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
index be78a12bb2e3..9e62916c0d91 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
@@ -20,11 +20,43 @@
 #include "pvr/pvr_stream.h"
 #include "pvr/pvr_timers.h"
 
+//
+// "C" main interface function tables between Kodi and addon
+//
+// Values related to all parts and not used direct on addon, are to define here.
+//
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  /*!
+   * @internal
+   * @brief PVR "C" basis API interface
+   *
+   * This field contains things that are exchanged between Kodi and Addon
+   * and is the basis of the PVR-side "C" API.
+   *
+   * @warning Care should be taken when making changes in this fields!\n
+   * Changes can destroy API in addons that have already been created. If a
+   * necessary change or new feature is added, the version of the PVR
+   * at @ref ADDON_INSTANCE_VERSION_PVR_MIN must be increased too.\n
+   * \n
+   * Conditional changes can be made in some places, without min PVR version
+   * increase. The add-on should then use CreateInstanceEx and add partial tests
+   * for this in the C++ header.
+   *
+   * Have by add of new parts a look about **Doxygen** `\\ingroup`, so that
+   * added parts included in documentation.
+   *
+   * If you add addon side related documentation, where his dev need know,
+   * use `///`. For parts only for Kodi make it like here.
+   *
+   * @endinternal
+   */
+
+  struct AddonInstance_PVR;
+
   /*!
    * @brief Structure to define typical standard values
    */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h
index 87c453c1d56e..36f9ed6fc3f6 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h
@@ -12,11 +12,20 @@
 
 #include <stdbool.h>
 
+//
+// "C" Definitions group 3 - PVR channel group
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  /*!
+   * @brief "C" PVR add-on channel group.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVRChannelGroup for description of values.
+   */
   typedef struct PVR_CHANNEL_GROUP
   {
     char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
@@ -24,6 +33,13 @@ extern "C"
     unsigned int iPosition;
   } PVR_CHANNEL_GROUP;
 
+  /*!
+   * @brief "C" PVR add-on channel group member.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVRChannelGroupMember for description of values.
+   */
   typedef struct PVR_CHANNEL_GROUP_MEMBER
   {
     char strGroupName[PVR_ADDON_NAME_STRING_LENGTH];
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h
index 470e5d315230..a2ce591b4bac 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h
@@ -12,13 +12,30 @@
 
 #include <stdbool.h>
 
+//
+// "C" Definitions group 2 - PVR channel
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Channel
+  /// @brief Denotes that no channel uid is available.
+  ///
+  /// Special @ref kodi::addon::PVRTimer::SetClientChannelUid() and
+  /// @ref kodi::addon::PVRRecording::SetChannelUid() value to indicate that no
+  /// channel uid is available.
   #define PVR_CHANNEL_INVALID_UID -1
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief "C" PVR add-on channel.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVRChannel for description of values.
+   */
   typedef struct PVR_CHANNEL
   {
     unsigned int iUniqueId;
@@ -34,6 +51,13 @@ extern "C"
     int iOrder;
   } PVR_CHANNEL;
 
+  /*!
+   * @brief "C" PVR add-on signal status information.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVRSignalStatus for description of values.
+   */
   typedef struct PVR_SIGNAL_STATUS
   {
     char strAdapterName[PVR_ADDON_NAME_STRING_LENGTH];
@@ -47,8 +71,21 @@ extern "C"
     long iUNC;
   } PVR_SIGNAL_STATUS;
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo
+  /// @brief Special @ref cpp_kodi_addon_pvr_Defs_Channel_PVRDescrambleInfo
+  /// value to indicate that a struct member's value is not available
+  ///
   #define PVR_DESCRAMBLE_INFO_NOT_AVAILABLE -1
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief "C" PVR add-on descramble information.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVRDescrambleInfo for description of values.
+   */
   typedef struct PVR_DESCRAMBLE_INFO
   {
     int iPid;
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_defines.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_defines.h
index 7045ed36fa2f..af1daae67ce6 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_defines.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_defines.h
@@ -8,11 +8,21 @@
 
 #pragma once
 
+//
+// "C" Standard PVR definitions
+//
+// Values related to all parts and not used direct on addon, are to define here.
+//
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  /*!
+   * @brief API array sizes which are used for data exchange between
+   * Kodi and addon.
+   */
+  ///@{
   #define PVR_ADDON_NAME_STRING_LENGTH 1024
   #define PVR_ADDON_URL_STRING_LENGTH 1024
   #define PVR_ADDON_DESC_STRING_LENGTH 1024
@@ -26,13 +36,20 @@ extern "C"
   #define PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE 512
   #define PVR_ADDON_DESCRAMBLE_INFO_STRING_LENGTH 64
   #define PVR_ADDON_DATE_STRING_LENGTH 32
+  ///@}
 
+  /*!
+   * @brief "C" Representation of a general attribute integer value.
+   */
   typedef struct PVR_ATTRIBUTE_INT_VALUE
   {
     int iValue;
     char strDescription[PVR_ADDON_ATTRIBUTE_DESC_LENGTH];
   } PVR_ATTRIBUTE_INT_VALUE;
 
+  /*!
+   * @brief "C" Representation of a named value.
+   */
   typedef struct PVR_NAMED_VALUE
   {
     char strName[PVR_ADDON_NAME_STRING_LENGTH];
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h
index e32c906e1b25..8378eaf6b46e 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h
@@ -12,19 +12,44 @@
 
 #include <stdint.h>
 
+//
+// "C" Definitions group 8 - PVR Edit definition list (EDL)
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_EDLEntry_PVR_EDL_TYPE enum PVR_EDL_TYPE
+  /// @ingroup cpp_kodi_addon_pvr_Defs_EDLEntry
+  /// @brief **Edit definition list types**\n
+  /// Possible type values for @ref cpp_kodi_addon_pvr_Defs_EDLEntry_PVREDLEntry.
+  ///
+  ///@{
   typedef enum PVR_EDL_TYPE
   {
+    /// @brief __0__  : cut (completely remove content)
     PVR_EDL_TYPE_CUT = 0,
+
+    /// @brief __1__  : mute audio
     PVR_EDL_TYPE_MUTE = 1,
+
+    /// @brief __2__  : scene markers (chapter seeking)
     PVR_EDL_TYPE_SCENE = 2,
+
+    /// @brief __3__  : commercial breaks
     PVR_EDL_TYPE_COMBREAK = 3
   } PVR_EDL_TYPE;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief "C" Edit definition list entry.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVREDLEntry for description of values.
+   */
   typedef struct PVR_EDL_ENTRY
   {
     int64_t start;
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h
index 33259229b0f2..57c603f689e7 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h
@@ -12,188 +12,612 @@
 
 #include <time.h>
 
+//
+// "C" Definitions group 4 - PVR EPG
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT enum EPG_EVENT_CONTENTMASK (and sub types)
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg
+  /// @brief **EPG entry content event types.**\n
+  /// These ID's come from the DVB-SI EIT table "content descriptor"
+  /// Also known under the name "E-book genre assignments".
+  ///
+  /// See [ETSI EN 300 468 V1.14.1 (2014-05)](https://www.etsi.org/deliver/etsi_en/300400_300499/300468/01.14.01_60/en_300468v011401p.pdf)
+  /// about.
+  ///
+  /// Values used by this functions:
+  /// - @ref kodi::addon::PVREPGTag::SetGenreType()
+  /// - @ref kodi::addon::PVREPGTag::SetGenreSubType()
+  /// - @ref kodi::addon::PVRRecording::SetGenreType()
+  /// - @ref kodi::addon::PVRRecording::SetGenreSubType()
+  ///
+  /// Following types are listed here:
+  /// | emum Type | Description
+  /// |-----------|--------------------
+  /// | @ref EPG_EVENT_CONTENTMASK | EPG entry main content to use.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_MOVIEDRAMA event types for sub type of <b>"Movie/Drama"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS event types for sub type of <b>"News/Current affairs"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_SHOW | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_SHOW event types for sub type of <b>"Show/Game show"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_SPORTS | @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_SPORTS event types for sub type of <b>"Sports"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_CHILDRENYOUTH event types for sub type of <b>"Children's/Youth programmes"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE event types for sub type of <b>"Music/Ballet/Dance"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_ARTSCULTURE event types for sub type of <b>"Arts/Culture (without music)"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS event types for sub type of <b>"Social/Political issues/Economics"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE event types for sub type of <b>"Education/Science/Factual topics"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_LEISUREHOBBIES event types for sub type of <b>"Leisure hobbies"</b>.
+  /// | @ref EPG_EVENT_CONTENTSUBMASK_SPECIAL | EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_SPECIAL event types for sub type of <b>"Special characteristics"</b>.
+  ///@{
+
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry main content to use.
+  ///
+  ///@{
   typedef enum EPG_EVENT_CONTENTMASK
   {
+    /// @brief __0x00__ : Undefined content mask entry.
     EPG_EVENT_CONTENTMASK_UNDEFINED = 0x00,
+
+    /// @brief __0x10__ : Movie/Drama.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA about related sub types.
     EPG_EVENT_CONTENTMASK_MOVIEDRAMA = 0x10,
+
+    /// @brief __0x20__ : News/Current affairs.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS about related sub types.
     EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS = 0x20,
+
+    /// @brief __0x30__ : Show/Game show.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_SHOW about related sub types.
     EPG_EVENT_CONTENTMASK_SHOW = 0x30,
+
+    /// @brief __0x40__ : Sports.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_SPORTS about related sub types.
     EPG_EVENT_CONTENTMASK_SPORTS = 0x40,
+
+    /// @brief __0x50__ : Children's/Youth programmes.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH about related sub types.
     EPG_EVENT_CONTENTMASK_CHILDRENYOUTH = 0x50,
+
+    /// @brief __0x60__ : Music/Ballet/Dance.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE about related sub types.
     EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE = 0x60,
+
+    /// @brief __0x70__ : Arts/Culture (without music).\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE about related sub types.
     EPG_EVENT_CONTENTMASK_ARTSCULTURE = 0x70,
+
+    /// @brief __0x80__ : Social/Political issues/Economics.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS about related sub types.
     EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS = 0x80,
+
+    /// @brief __0x90__ : Education/Science/Factual topics.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE about related sub types.
     EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE = 0x90,
+
+    /// @brief __0xA0__ : Leisure hobbies.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES about related sub types.
     EPG_EVENT_CONTENTMASK_LEISUREHOBBIES = 0xA0,
+
+    /// @brief __0xB0__ : Special characteristics.\n
+    /// \n
+    /// See @ref EPG_EVENT_CONTENTSUBMASK_SPECIAL about related sub types.
     EPG_EVENT_CONTENTMASK_SPECIAL = 0xB0,
+
+    /// @brief __0xF0__ User defined.
     EPG_EVENT_CONTENTMASK_USERDEFINED = 0xF0,
+
+    /// @brief Used to override standard genre types with a own name about.\n
+    /// \n
+    /// Set to this value @ref EPG_GENRE_USE_STRING on following places:
+    /// - @ref kodi::addon::PVREPGTag::SetGenreType()
+    /// - @ref kodi::addon::PVREPGTag::SetGenreSubType()
+    /// - @ref kodi::addon::PVRRecording::SetGenreType()
+    /// - @ref kodi::addon::PVRRecording::SetGenreSubType()
+    ///
+    /// @warning Value here is not a [ETSI EN 300 468 V1.14.1 (2014-05)](https://www.etsi.org/deliver/etsi_en/300400_300499/300468/01.14.01_60/en_300468v011401p.pdf)
+    /// conform.
+    ///
+    /// @note This is a own Kodi definition to set that genre is given by own
+    /// string. Used on @ref kodi::addon::PVREPGTag::SetGenreDescription() and
+    /// @ref kodi::addon::PVRRecording::SetGenreDescription()
     EPG_GENRE_USE_STRING = 0x100
   } EPG_EVENT_CONTENTMASK;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_MOVIEDRAMA event
+  /// types for sub type of <b>"Movie/Drama"</b>.
+  ///
+  ///@{
   typedef enum EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA
   {
+    /// @brief __0x0__ : Movie/drama (general).
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Detective/thriller.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_DETECTIVE_THRILLER = 0x1,
+
+    /// @brief __0x2__ : Adventure/western/war.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ADVENTURE_WESTERN_WAR = 0x2,
+
+    /// @brief __0x3__ : Science fiction/fantasy/horror.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SCIENCEFICTION_FANTASY_HORROR = 0x3,
+
+    /// @brief __0x4__ : Comedy.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_COMEDY = 0x4,
+
+    /// @brief __0x5__ : Soap/melodrama/folkloric.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SOAP_MELODRAMA_FOLKLORIC = 0x5,
+
+    /// @brief __0x6__ : Romance.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ROMANCE = 0x6,
+
+    /// @brief __0x7__ : Serious/classical/religious/historical movie/drama.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_SERIOUS_CLASSICAL_RELIGIOUS_HISTORICAL = 0x7,
+
+    /// @brief __0x8__ : Adult movie/drama.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_ADULT = 0x8,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_MOVIEDRAMA;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS event
+  /// types for sub type of <b>"News/Current affairs"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS
   {
+    /// @brief __0x0__ : News/current affairs (general).
     EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_GENERAL = 0x0,
+
+    /// @brief __0x1__ : News/weather report.
     EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_WEATHER = 0x1,
+
+    /// @brief __0x2__ : News magazine.
     EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_MAGAZINE = 0x2,
+
+    /// @brief __0x3__ : Documentary.
     EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_DOCUMENTARY = 0x3,
+
+    /// @brief __0x4__ : Discussion/interview/debate
     EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_DISCUSSION_INTERVIEW_DEBATE = 0x4,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_NEWSCURRENTAFFAIRS;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_SHOW event
+  /// types for sub type of <b>"Show/Game show"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_SHOW
   {
+    /// @brief __0x0__ : Show/game show (general).
     EPG_EVENT_CONTENTSUBMASK_SHOW_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Game show/quiz/contest.
     EPG_EVENT_CONTENTSUBMASK_SHOW_GAMESHOW_QUIZ_CONTEST = 0x1,
+
+    /// @brief __0x2__ : Variety show.
     EPG_EVENT_CONTENTSUBMASK_SHOW_VARIETY_SHOW = 0x2,
+
+    /// @brief __0x3__ : Talk show.
     EPG_EVENT_CONTENTSUBMASK_SHOW_TALK_SHOW = 0x3,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_SHOW_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_SHOW;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_SPORTS event
+  /// types for sub type of <b>"Sports"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_SPORTS
   {
+    /// @brief __0x0__ : Sports (general).
     EPG_EVENT_CONTENTSUBMASK_SPORTS_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Special events (Olympic Games, World Cup, etc.).
     EPG_EVENT_CONTENTSUBMASK_SPORTS_OLYMPICGAMES_WORLDCUP = 0x1,
+
+    /// @brief __0x2__ : Sports magazines.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_SPORTS_MAGAZINES = 0x2,
+
+    /// @brief __0x3__ : Football/soccer.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_FOOTBALL_SOCCER = 0x3,
+
+    /// @brief __0x4__ : Tennis/squash.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_TENNIS_SQUASH = 0x4,
+
+    /// @brief __0x5__ : Team sports (excluding football).
     EPG_EVENT_CONTENTSUBMASK_SPORTS_TEAMSPORTS = 0x5,
+
+    /// @brief __0x6__ : Athletics.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_ATHLETICS = 0x6,
+
+    /// @brief __0x7__ : Motor sport.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_MOTORSPORT = 0x7,
+
+    /// @brief __0x8__ : Water sport.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_WATERSPORT = 0x8,
+
+    /// @brief __0x9__ : Winter sports.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_WINTERSPORTS = 0x9,
+
+    /// @brief __0xA__ : Equestrian.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_EQUESTRIAN = 0xA,
+
+    /// @brief __0xB__ : Martial sports.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_MARTIALSPORTS = 0xB,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_SPORTS_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_SPORTS;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_CHILDRENYOUTH event
+  /// types for sub type of <b>"Children's/Youth programmes"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH
   {
+    /// @brief __0x0__ : Children's/youth programmes (general).
     EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Pre-school children's programmes.
     EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_PRESCHOOL_CHILDREN = 0x1,
+
+    /// @brief __0x2__ : Entertainment programmes for 6 to 14.
     EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_ENTERTAIN_6TO14 = 0x2,
+
+    /// @brief __0x3__ : Entertainment programmes for 10 to 16.
     EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_ENTERTAIN_10TO16 = 0x3,
+
+    /// @brief __0x4__ : Informational/educational/school programmes.
     EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_INFORMATIONAL_EDUCATIONAL_SCHOOL = 0x4,
+
+    /// @brief __0x5__ : Cartoons/puppets.
     EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_CARTOONS_PUPPETS = 0x5,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_CHILDRENYOUTH;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE event
+  /// types for sub type of <b>"Music/Ballet/Dance"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE
   {
+    /// @brief __0x0__ : Music/ballet/dance (general).
     EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Rock/pop.
     EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_ROCKPOP = 0x1,
+
+    /// @brief __0x2__ : Serious music/classical music.
     EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_SERIOUSMUSIC_CLASSICALMUSIC = 0x2,
+
+    /// @brief __0x3__ : Folk/traditional music.
     EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_FOLK_TRADITIONAL_MUSIC = 0x3,
+
+    /// @brief __0x4__ : Jazz.
     EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_JAZZ = 0x4,
+
+    /// @brief __0x5__ : Musical/opera.
     EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_MUSICAL_OPERA = 0x5,
+
+    /// @brief __0x6__ : Ballet.
     EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_BALLET = 0x6,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_MUSICBALLETDANCE;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_ARTSCULTURE event
+  /// types for sub type of <b>"Arts/Culture (without music)"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE
   {
+    /// @brief __0x0__ : Arts/culture (without music, general).
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Performing arts.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_PERFORMINGARTS = 0x1,
+
+    /// @brief __0x2__ : Fine arts.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FINEARTS = 0x2,
+
+    /// @brief __0x3__ : Religion.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_RELIGION = 0x3,
+
+    /// @brief __0x4__ : Popular culture/traditional arts.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_POPULARCULTURE_TRADITIONALARTS = 0x4,
+
+    /// @brief __0x5__ : Literature.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_LITERATURE = 0x5,
+
+    /// @brief __0x6__ : Film/cinema.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FILM_CINEMA = 0x6,
+
+    /// @brief __0x7__ : Experimental film/video.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_EXPERIMENTALFILM_VIDEO = 0x7,
+
+    /// @brief __0x8__ : Broadcasting/press.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_BROADCASTING_PRESS = 0x8,
+
+    /// @brief __0x9__ : New media.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_NEWMEDIA = 0x9,
+
+    /// @brief __0xA__ : Arts/culture magazines.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_ARTS_CULTUREMAGAZINES = 0xA,
+
+    /// @brief __0xB__ : Fashion.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_FASHION = 0xB,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_ARTSCULTURE;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS event
+  /// types for sub type of <b>"Social/Political issues/Economics"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS
   {
+    /// @brief __0x0__ : Social/political issues/economics (general).
     EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Magazines/reports/documentary.
     EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_MAGAZINES_REPORTS_DOCUMENTARY = 0x1,
+
+    /// @brief __0x2__ : Economics/social advisory.
     EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_ECONOMICS_SOCIALADVISORY = 0x2,
+
+    /// @brief __0x3__ : Remarkable people.
     EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_REMARKABLEPEOPLE = 0x3,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_SOCIALPOLITICALECONOMICS;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE event
+  /// types for sub type of <b>"Education/Science/Factual topics"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE
   {
+    /// @brief __0x0__ : Education/science/factual topics (general).
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Nature/animals/environment.
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_NATURE_ANIMALS_ENVIRONMENT = 0x1,
+
+    /// @brief __0x2__ : Technology/natural sciences.
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_TECHNOLOGY_NATURALSCIENCES = 0x2,
+
+    /// @brief __0x3__ : Medicine/physiology/psychology.
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_MEDICINE_PHYSIOLOGY_PSYCHOLOGY = 0x3,
+
+    /// @brief __0x4__ : Foreign countries/expeditions.
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_FOREIGNCOUNTRIES_EXPEDITIONS = 0x4,
+
+    /// @brief __0x5__ : Social/spiritual sciences.
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_SOCIAL_SPIRITUALSCIENCES = 0x5,
+
+    /// @brief __0x6__ : Further education.
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_FURTHEREDUCATION = 0x6,
+
+    /// @brief __0x7__ : Languages.
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_LANGUAGES = 0x7,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_EDUCATIONALSCIENCE;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_LEISUREHOBBIES event
+  /// types for sub type of <b>"Leisure hobbies"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES
   {
+    /// @brief __0x0__ : Leisure hobbies (general) .
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Tourism/travel.
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_TOURISM_TRAVEL = 0x1,
+
+    /// @brief __0x2__ : Handicraft.
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_HANDICRAFT = 0x2,
+
+    /// @brief __0x3__ : Motoring.
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_MOTORING = 0x3,
+
+    /// @brief __0x4__ : Fitness and health.
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_FITNESSANDHEALTH = 0x4,
+
+    /// @brief __0x5__ : Cooking.
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_COOKING = 0x5,
+
+    /// @brief __0x6__ : Advertisement/shopping.
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_ADVERTISEMENT_SHOPPING = 0x6,
+
+    /// @brief __0x7__ : Gardening.
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_GARDENING = 0x7,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_LEISUREHOBBIES;
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT
+  /// @brief EPG entry sub content to @ref EPG_EVENT_CONTENTMASK_SPECIAL event
+  /// types for sub type of <b>"Special characteristics"</b>.
+  ///
   typedef enum EPG_EVENT_CONTENTSUBMASK_SPECIAL
   {
+    /// @brief __0x0__ : Special characteristics / Original language (general).
     EPG_EVENT_CONTENTSUBMASK_SPECIAL_GENERAL = 0x0,
+
+    /// @brief __0x1__ : Black and white.
     EPG_EVENT_CONTENTSUBMASK_SPECIAL_BLACKANDWHITE = 0x1,
+
+    /// @brief __0x2__ : Unpublished.
     EPG_EVENT_CONTENTSUBMASK_SPECIAL_UNPUBLISHED = 0x2,
+
+    /// @brief __0x3__ : Live broadcast.
     EPG_EVENT_CONTENTSUBMASK_SPECIAL_LIVEBROADCAST = 0x3,
+
+    /// @brief __0x4__ : Plano-stereoscopic.
     EPG_EVENT_CONTENTSUBMASK_SPECIAL_PLANOSTEREOSCOPIC = 0x4,
+
+    /// @brief __0x5__ : Local or regional.
     EPG_EVENT_CONTENTSUBMASK_SPECIAL_LOCALORREGIONAL = 0x5,
+
+    /// @brief __0xF__ : User defined.
     EPG_EVENT_CONTENTSUBMASK_SPECIAL_USERDEFINED = 0xF
   } EPG_EVENT_CONTENTSUBMASK_SPECIAL;
+  //----------------------------------------------------------------------------
+
+  ///@}
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg
+  /// @brief Separator to use in strings containing different tokens, for example
+  /// writers, directors, actors of an event.
+  ///
   #define EPG_STRING_TOKEN_SEPARATOR ","
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_epg_EPG_TAG_FLAG enum EPG_TAG_FLAG
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg
+  /// @brief <b>Bit field of independent flags associated with the EPG entry.</b>\n
+  /// Values used by @ref kodi::addon::PVREPGTag::SetFlags().
+  ///
+  /// Here's example about the use of this:
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVREPGTag tag;
+  /// tag.SetFlags(EPG_TAG_FLAG_IS_SERIES | EPG_TAG_FLAG_IS_NEW);
+  /// ~~~~~~~~~~~~~
+  ///
+  ///@{
   typedef enum EPG_TAG_FLAG
   {
+    /// @brief __0000 0000__ : Nothing special to say about this entry.
     EPG_TAG_FLAG_UNDEFINED = 0,
+
+    /// @brief __0000 0001__ : This EPG entry is part of a series.
     EPG_TAG_FLAG_IS_SERIES = (1 << 0),
+
+    /// @brief __0000 0010__ : This EPG entry will be flagged as new.
     EPG_TAG_FLAG_IS_NEW = (1 << 1),
+
+    /// @brief __0000 0100__ : This EPG entry will be flagged as a premiere.
     EPG_TAG_FLAG_IS_PREMIERE = (1 << 2),
+
+    /// @brief __0000 1000__ : This EPG entry will be flagged as a finale.
     EPG_TAG_FLAG_IS_FINALE = (1 << 3),
+
+    /// @brief __0001 0000__ : This EPG entry will be flagged as live.
     EPG_TAG_FLAG_IS_LIVE = (1 << 4),
   } EPG_TAG_FLAG;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg
+  /// @brief Special PVREPGTag::SetUniqueBroadcastId value
+  ///
+  /// Special @ref kodi::addon::PVREPGTag::SetUniqueBroadcastId() value to
+  /// indicate that a tag has not a valid EPG event uid.
+  ///
   #define EPG_TAG_INVALID_UID 0
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg
+  /// @brief Special @ref kodi::addon::PVREPGTag::SetSeriesNumber(), @ref kodi::addon::PVREPGTag::SetEpisodeNumber()
+  /// and @ref kodi::addon::PVREPGTag::SetEpisodePartNumber() value to indicate
+  /// it is not to be used.
+  ///
   #define EPG_TAG_INVALID_SERIES_EPISODE -1
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg
+  /// @brief Timeframe value for use with @ref kodi::addon::CInstancePVRClient::SetEPGTimeFrame()
+  /// function to indicate "no timeframe".
+  ///
   #define EPG_TIMEFRAME_UNLIMITED -1
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_epg_EPG_EVENT_STATE enum EPG_EVENT_STATE
+  /// @ingroup cpp_kodi_addon_pvr_Defs_epg
+  /// @brief **EPG event states.**\n
+  /// Used with @ref kodi::addon::CInstancePVRClient::EpgEventStateChange()
+  /// callback.
+  ///
+  ///@{
   typedef enum EPG_EVENT_STATE
   {
+    /// @brief __0__ : Event created.
     EPG_EVENT_CREATED = 0,
+
+    /// @brief __1__ : Event updated.
     EPG_EVENT_UPDATED = 1,
+
+    /// @brief __2__ : Event deleted.
     EPG_EVENT_DELETED = 2,
   } EPG_EVENT_STATE;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief "C" PVR add-on channel group member.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVREPGTag for description of values.
+   */
   typedef struct EPG_TAG
   {
     unsigned int iUniqueBroadcastId;
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h
index 15f7660bd6b4..52787b0fbbc7 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h
@@ -16,45 +16,246 @@
 #include "cores/VideoPlayer/Interface/Addon/InputStreamConstants.h"
 #endif
 
+//
+// "C" Definitions group 1 - General PVR
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_General_PVR_ERROR enum PVR_ERROR
+  /// @ingroup cpp_kodi_addon_pvr_Defs_General
+  /// @brief **PVR add-on error codes**\n
+  /// Used as return values on most PVR related functions.
+  ///
+  /// In this way, a PVR instance signals errors in its processing and, under
+  /// certain conditions, allows Kodi to make corrections.
+  ///
+  ///@{
   typedef enum PVR_ERROR
   {
+    /// @brief __0__ : No error occurred.
     PVR_ERROR_NO_ERROR = 0,
+
+    /// @brief __-1__ : An unknown error occurred.
     PVR_ERROR_UNKNOWN = -1,
+
+    /// @brief __-2__ : The method that Kodi called is not implemented by the add-on.
     PVR_ERROR_NOT_IMPLEMENTED = -2,
+
+    /// @brief __-3__ : The backend reported an error, or the add-on isn't connected.
     PVR_ERROR_SERVER_ERROR = -3,
+
+    /// @brief __-4__ : The command was sent to the backend, but the response timed out.
     PVR_ERROR_SERVER_TIMEOUT = -4,
+
+    /// @brief __-5__ : The command was rejected by the backend.
     PVR_ERROR_REJECTED = -5,
+
+    /// @brief __-6__ : The requested item can not be added, because it's already present.
     PVR_ERROR_ALREADY_PRESENT = -6,
+
+    /// @brief __-7__ : The parameters of the method that was called are invalid for this
+    /// operation.
     PVR_ERROR_INVALID_PARAMETERS = -7,
+
+    /// @brief __-8__ : A recording is running, so the timer can't be deleted without
+    /// doing a forced delete.
     PVR_ERROR_RECORDING_RUNNING = -8,
+
+    /// @brief __-9__ : The command failed.
     PVR_ERROR_FAILED = -9,
   } PVR_ERROR;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_General_PVR_CONNECTION_STATE enum PVR_CONNECTION_STATE
+  /// @ingroup cpp_kodi_addon_pvr_Defs_General
+  /// @brief **PVR backend connection states**\n
+  /// Used with @ref kodi::addon::CInstancePVRClient::ConnectionStateChange() callback.
+  ///
+  /// With this, a PVR instance signals that Kodi should perform special
+  /// operations.
+  ///
+  ///@{
   typedef enum PVR_CONNECTION_STATE
   {
+    /// @brief __0__ : Unknown state (e.g. not yet tried to connect).
     PVR_CONNECTION_STATE_UNKNOWN = 0,
+
+    /// @brief __1__ : Backend server is not reachable (e.g. server not existing or
+    /// network down).
     PVR_CONNECTION_STATE_SERVER_UNREACHABLE = 1,
+
+    /// @brief __2__ : Backend server is reachable, but there is not the expected type of
+    /// server running (e.g. HTSP required, but FTP running at given server:port).
     PVR_CONNECTION_STATE_SERVER_MISMATCH = 2,
+
+    /// @brief __3__ : Backend server is reachable, but server version does not match
+    /// client requirements.
     PVR_CONNECTION_STATE_VERSION_MISMATCH = 3,
+
+    /// @brief __4__ : Backend server is reachable, but denies client access (e.g. due
+    /// to wrong credentials).
     PVR_CONNECTION_STATE_ACCESS_DENIED = 4,
+
+    /// @brief __5__ : Connection to backend server is established.
     PVR_CONNECTION_STATE_CONNECTED = 5,
+
+    /// @brief __6__ : No connection to backend server (e.g. due to network errors or
+    /// client initiated disconnect).
     PVR_CONNECTION_STATE_DISCONNECTED = 6,
+
+    /// @brief __7__ : Connecting to backend.
     PVR_CONNECTION_STATE_CONNECTING = 7,
   } PVR_CONNECTION_STATE;
+  ///@}
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_General_PVR_STREAM_PROPERTY definition PVR_STREAM_PROPERTY
+  /// @ingroup cpp_kodi_addon_pvr_Defs_General_Inputstream
+  /// @brief **PVR related stream property values**\n
+  /// This is used to pass additional data to Kodi on a given PVR stream.
+  ///
+  /// Then transferred to livestream, recordings or EPG Tag stream using the
+  /// properties.
+  ///
+  /// This defines are used by:
+  /// - @ref kodi::addon::CInstancePVRClient::GetChannelStreamProperties()
+  /// - @ref kodi::addon::CInstancePVRClient::GetEPGTagStreamProperties()
+  /// - @ref kodi::addon::CInstancePVRClient::GetRecordingStreamProperties()
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  ///
+  /// PVR_ERROR CMyPVRInstance::GetChannelStreamProperties(const kodi::addon::PVRChannel& channel,
+  ///                                                      std::vector<PVRStreamProperty>& properties)
+  /// {
+  ///   ...
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_INPUTSTREAM, "inputstream.adaptive");
+  ///   properties.emplace_back("inputstream.adaptive.manifest_type", "mpd");
+  ///   properties.emplace_back("inputstream.adaptive.manifest_update_parameter", "full");
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_MIMETYPE, "application/xml+dash");
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  ///
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  ///@{
 
+  /// @brief the URL of the stream that should be played.
+  ///
   #define PVR_STREAM_PROPERTY_STREAMURL "streamurl"
+
+  /// @brief To define in stream properties the name of the inputstream add-on
+  /// that should be used.
+  ///
+  /// Leave blank to use Kodi's built-in playing capabilities or to allow ffmpeg
+  /// to handle directly set to @ref PVR_STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG.
+  ///
   #define PVR_STREAM_PROPERTY_INPUTSTREAM STREAM_PROPERTY_INPUTSTREAM
+
+  /// @brief Identification string for an input stream.
+  ///
+  /// This value can be used in addition to @ref PVR_STREAM_PROPERTY_INPUTSTREAM.
+  /// It is used to provide the respective inpustream addon with additional
+  /// identification.
+  ///
+  /// The difference between this and other stream properties is that it is also
+  /// passed in the associated @ref kodi::addon::CAddonBase::CreateInstance()
+  /// call.
+  ///
+  /// This makes it possible to select different processing classes within the
+  /// associated add-on.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  ///
+  /// // On PVR instance of addon
+  /// PVR_ERROR CMyPVRInstance::GetChannelStreamProperties(const kodi::addon::PVRChannel& channel,
+  ///                                                      std::vector<PVRStreamProperty>& properties)
+  /// {
+  ///   ...
+  ///   // For here on example the inpustream is also inside the PVR addon
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_INPUTSTREAM, "pvr.my_one");
+  ///   properties.emplace_back(PVR_STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID, "my_special_id_1");
+  ///   return PVR_ERROR_NO_ERROR;
+  /// }
+  ///
+  /// ...
+  ///
+  /// // On CAddonBase part of addon
+  /// ADDON_STATUS CMyAddon::CreateInstanceEx(int instanceType,
+  ///                                         std::string instanceID,
+  ///                                         KODI_HANDLE instance,
+  ///                                         KODI_HANDLE& addonInstance
+  ///                                         const std::string& version)
+  /// {
+  ///   if (instanceType == ADDON_INSTANCE_INPUTSTREAM)
+  ///   {
+  ///     kodi::Log(ADDON_LOG_NOTICE, "Creating my special inputstream");
+  ///     if (instanceID == "my_special_id_1")
+  ///       addonInstance = new CMyPVRClientInstance_Type1(instance, version);
+  ///     else if (instanceID == "my_special_id_2")
+  ///       addonInstance = new CMyPVRClientInstance_Type2(instance, version);
+  ///     return ADDON_STATUS_OK;
+  ///   }
+  ///   else if (...)
+  ///   {
+  ///     ...
+  ///   }
+  ///   return ADDON_STATUS_UNKNOWN;
+  /// }
+  ///
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
   #define PVR_STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID STREAM_PROPERTY_INPUTSTREAM_INSTANCE_ID
+
+  /// @brief the MIME type of the stream that should be played.
+  ///
   #define PVR_STREAM_PROPERTY_MIMETYPE "mimetype"
+
+  /// @brief <b>"true"</b> to denote that the stream that should be played is a
+  /// realtime stream.
+  ///
+  /// Any other value indicates that this is no realtime stream.
+  ///
   #define PVR_STREAM_PROPERTY_ISREALTIMESTREAM STREAM_PROPERTY_ISREALTIMESTREAM
+
+  /// @brief <b>"true"</b> to denote that if the stream is from an EPG tag.
+  ///
+  /// It should be played is a live stream. Otherwise if it's a EPG tag it will
+  /// play as normal video.
+  ///
   #define PVR_STREAM_PROPERTY_EPGPLAYBACKASLIVE "epgplaybackaslive"
+
+  /// @brief Special value for @ref PVR_STREAM_PROPERTY_INPUTSTREAM to use
+  /// ffmpeg to directly play a stream URL.
   #define PVR_STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG STREAM_PROPERTY_VALUE_INPUTSTREAMFFMPEG
 
+  ///@}
+  //-----------------------------------------------------------------------------
+
+  /*!
+   * @brief "C" PVR add-on capabilities.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVRCapabilities for description of values.
+   */
   typedef struct PVR_ADDON_CAPABILITIES
   {
     bool bSupportsEPG;
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h
index d372aed68fde..df2216f582c9 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h
@@ -10,23 +10,56 @@
 
 #include "pvr_defines.h"
 
+//
+// "C" Definitions group 7 - Menu hook
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Menuhook_PVR_MENUHOOK_CAT enum PVR_MENUHOOK_CAT
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Menuhook
+  /// @brief **PVR context menu hook categories**\n
+  /// Possible menu types given to Kodi with @ref kodi::addon::CInstancePVRClient::AddMenuHook().
+  ///
+  ///@{
   typedef enum PVR_MENUHOOK_CAT
   {
+    /// @brief __-1__ : Unknown menu hook.
     PVR_MENUHOOK_UNKNOWN = -1,
+
+    /// @brief __0__ : All categories.
     PVR_MENUHOOK_ALL = 0,
+
+    /// @brief __1__ : For channels.
     PVR_MENUHOOK_CHANNEL = 1,
+
+    /// @brief __2__ : For timers.
     PVR_MENUHOOK_TIMER = 2,
+
+    /// @brief __3__ : For EPG.
     PVR_MENUHOOK_EPG = 3,
+
+    /// @brief __4__ : For recordings.
     PVR_MENUHOOK_RECORDING = 4,
+
+    /// @brief __5__ : For deleted recordings.
     PVR_MENUHOOK_DELETED_RECORDING = 5,
+
+    /// @brief __6__ : For settings.
     PVR_MENUHOOK_SETTING = 6,
   } PVR_MENUHOOK_CAT;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief "C" PVR add-on menu hook.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVRMenuhook for description of values.
+   */
   typedef struct PVR_MENUHOOK
   {
     unsigned int iHookId;
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
index 93f24246732b..1a7fc66ec1b9 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h
@@ -14,31 +14,97 @@
 #include <stdint.h>
 #include <time.h>
 
+//
+// "C" Definitions group 5 - PVR recordings
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Recording_PVR_RECORDING_FLAG enum PVR_RECORDING_FLAG
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Recording
+  /// @brief **Bit field of independent flags associated with the EPG entry.**\n
+  /// Values used by @ref kodi::addon::PVRRecording::SetFlags().
+  ///
+  /// Here's example about the use of this:
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRRecording tag;
+  /// tag.SetFlags(PVR_RECORDING_FLAG_IS_SERIES | PVR_RECORDING_FLAG_IS_PREMIERE);
+  /// ~~~~~~~~~~~~~
+  ///
+  ///@{
   typedef enum PVR_RECORDING_FLAG
   {
+    /// @brief __0000 0000__ : Nothing special to say about this recording.
     PVR_RECORDING_FLAG_UNDEFINED = 0,
+
+    /// @brief __0000 0001__ : This recording is part of a series.
     PVR_RECORDING_FLAG_IS_SERIES = (1 << 0),
+
+    /// @brief __0000 0010__ : This recording will be flagged as new.
     PVR_RECORDING_FLAG_IS_NEW = (1 << 1),
+
+    /// @brief __0000 0100__ : This recording will be flagged as a premiere.
     PVR_RECORDING_FLAG_IS_PREMIERE = (1 << 2),
+
+    /// @brief __0000 1000__ : This recording will be flagged as a finale.
     PVR_RECORDING_FLAG_IS_FINALE = (1 << 3),
+
+    /// @brief __0001 0000__ : This recording will be flagged as live.
     PVR_RECORDING_FLAG_IS_LIVE = (1 << 4),
   } PVR_RECORDING_FLAG;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  /// @brief Special @ref kodi::addon::PVRRecording::SetSeriesNumber() and
+  /// @ref kodi::addon::PVRRecording::SetEpisodeNumber() value to indicate it is
+  /// not to be used.
+  ///
+  /// Used if recording has no valid season and/or episode info.
+  ///
   #define PVR_RECORDING_INVALID_SERIES_EPISODE EPG_TAG_INVALID_SERIES_EPISODE
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Recording_PVRRecording
+  /// @brief Value where set in background to inform that related part not used.
+  ///
+  /// Normally this related parts need not to set by this as it is default.
   #define PVR_RECORDING_VALUE_NOT_AVAILABLE -1
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Recording_PVR_RECORDING_CHANNEL_TYPE enum PVR_RECORDING_CHANNEL_TYPE
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Recording
+  /// @brief **PVR recording channel types**\n
+  /// Used on @ref kodi::addon::PVRRecording::SetChannelType() value to set related
+  /// type.
+  ///
+  ///@{
   typedef enum PVR_RECORDING_CHANNEL_TYPE
   {
+    /// @brief __0__ : Unknown type.
     PVR_RECORDING_CHANNEL_TYPE_UNKNOWN = 0,
+
+    /// @brief __1__ : TV channel.
     PVR_RECORDING_CHANNEL_TYPE_TV = 1,
+
+    /// @brief __2__ : Radio channel.
     PVR_RECORDING_CHANNEL_TYPE_RADIO = 2,
   } PVR_RECORDING_CHANNEL_TYPE;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief "C" PVR add-on recording.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref kodi::addon::PVRRecording for description of values.
+   */
   typedef struct PVR_RECORDING
   {
     char strRecordingId[PVR_ADDON_NAME_STRING_LENGTH];
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_stream.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_stream.h
index 805f063b3b71..04b40595b01d 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_stream.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_stream.h
@@ -19,36 +19,99 @@
 #include <stdint.h>
 #include <time.h>
 
+//
+// "C" Definitions group 9 - PVR stream definitions (NOTE: Becomes replaced
+// in future by inputstream addon instance way)
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Stream
+  /// @brief Maximum of allowed streams
+  ///
   #define PVR_STREAM_MAX_STREAMS 20
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Stream
+  /// @brief Invalid codec identifier
+  ///
   #define PVR_INVALID_CODEC_ID 0
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Stream
+  /// @brief Invalid codec
+  ///
   #define PVR_INVALID_CODEC \
     { \
       PVR_CODEC_TYPE_UNKNOWN, PVR_INVALID_CODEC_ID \
     }
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Stream_PVR_CODEC_TYPE enum PVR_CODEC_TYPE
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Stream
+  /// @brief **Inputstream types**\n
+  /// To identify type on stream.
+  ///
+  /// Used on @ref kodi::addon::PVRStreamProperties::SetCodecType and @ref kodi::addon::PVRStreamProperties::SetCodecType.
+  ///
+  ///@{
   typedef enum PVR_CODEC_TYPE
   {
+    /// @brief To set nothing defined.
     PVR_CODEC_TYPE_UNKNOWN = -1,
+
+    /// @brief To identify @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties as Video.
     PVR_CODEC_TYPE_VIDEO,
+
+    /// @brief To identify @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties as Audio.
     PVR_CODEC_TYPE_AUDIO,
+
+    /// @brief To identify @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties as Data.
+    ///
+    /// With codec id related source identified.
     PVR_CODEC_TYPE_DATA,
+
+    /// @brief To identify @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties as Subtitle.
     PVR_CODEC_TYPE_SUBTITLE,
+
+    /// @brief To identify @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties as Radio RDS.
     PVR_CODEC_TYPE_RDS,
 
     PVR_CODEC_TYPE_NB
   } PVR_CODEC_TYPE;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Stream_PVR_CODEC struct PVR_CODEC
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Stream
+  /// @brief **Codec identification structure**\n
+  /// Identifier about stream between Kodi and addon.
+  ///
+  ///@{
   typedef struct PVR_CODEC
   {
+    /// @brief Used codec type for stream.
     enum PVR_CODEC_TYPE codec_type;
+
+    /// @brief Related codec identifier, normally match the ffmpeg id's.
     unsigned int codec_id;
   } PVR_CODEC;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief "C" Stream properties
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamProperties for description of values.
+   */
   typedef struct PVR_STREAM_PROPERTIES
   {
     unsigned int iStreamCount;
@@ -72,6 +135,13 @@ extern "C"
     } stream[PVR_STREAM_MAX_STREAMS];
   } PVR_STREAM_PROPERTIES;
 
+  /*!
+   * @brief "C" Times of playing stream (Live TV and recordings)
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref cpp_kodi_addon_pvr_Defs_Stream_PVRStreamTimes for description of values.
+   */
   typedef struct PVR_STREAM_TIMES
   {
     time_t startTime;
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
index b64c59a5bda5..bc16adbdf3aa 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h
@@ -14,82 +14,328 @@
 #include <stdint.h>
 #include <time.h>
 
+//
+// "C" Definitions group 6 - PVR timers
 #ifdef __cplusplus
 extern "C"
 {
 #endif /* __cplusplus */
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVR_TIMER_ definition PVR_TIMER (various)
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Timer
+  /// @brief **PVR timer various different definitions**\n
+  /// This mostly used on @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimer "kodi::addon::PVRTimer"
+  /// to define default or not available.
+  ///
+  ///@{
+
+  //============================================================================
+  /// @brief Numeric PVR timer type definitions (@ref kodi::addon::PVRTimer::SetTimerType()
+  /// values).
+  ///
+  /// "Null" value for a numeric timer type.
   #define PVR_TIMER_TYPE_NONE 0
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Special @ref kodi::addon::PVRTimer::SetClientIndex() value to indicate
+  /// that a timer has not (yet) a valid client index.
+  ///
+  /// Timer has not (yet) a valid client index.
   #define PVR_TIMER_NO_CLIENT_INDEX 0
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Special @ref kodi::addon::PVRTimer::SetParentClientIndex() value to
+  /// indicate that a timer has no parent.
+  ///
+  /// Timer has no parent; it was not scheduled by a repeating timer.
   #define PVR_TIMER_NO_PARENT PVR_TIMER_NO_CLIENT_INDEX
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Special @ref kodi::addon::PVRTimer::SetEPGUid() value to indicate
+  /// that a timer has no EPG event uid.
+  ///
+  /// Timer has no EPG event unique identifier.
   #define PVR_TIMER_NO_EPG_UID EPG_TAG_INVALID_UID
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Special @ref kodi::addon::PVRTimer::SetClientChannelUid() value to
+  /// indicate "any channel". Useful for some repeating timer types.
+  ///
+  /// denotes "any channel", not a specific one.
+  ///
   #define PVR_TIMER_ANY_CHANNEL -1
+  //----------------------------------------------------------------------------
+
+  //============================================================================
+  /// @brief Value where set in background to inform that related part not used.
+  ///
+  /// Normally this related parts need not to set by this as it is default.
   #define PVR_TIMER_VALUE_NOT_AVAILABLE -1
+  //----------------------------------------------------------------------------
+
+  ///@}
+  //----------------------------------------------------------------------------
 
+
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVR_TIMER_TYPES enum PVR_TIMER_TYPES
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Timer
+  /// @brief **PVR timer type attributes (@ref kodi::addon::PVRTimerType::SetAttributes() values).**\n
+  /// To defines the attributes for a type. These values are bit fields that can be
+  /// used together.
+  ///
+  ///--------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// kodi::addon::PVRTimerType tag;
+  /// tag.SetAttributes(PVR_TIMER_TYPE_IS_MANUAL | PVR_TIMER_TYPE_IS_REPEATING);
+  /// ~~~~~~~~~~~~~
+  ///
+  ///@{
   typedef enum PVR_TIMER_TYPES
   {
+    /// @brief __0000 0000 0000 0000 0000 0000 0000 0000__ :\n Empty attribute value.
     PVR_TIMER_TYPE_ATTRIBUTE_NONE = 0,
+
+    /// @brief __0000 0000 0000 0000 0000 0000 0000 0001__ :\n Defines whether this is a type for
+    /// manual (time-based) or epg-based timers.
     PVR_TIMER_TYPE_IS_MANUAL = (1 << 0),
+
+    /// @brief __0000 0000 0000 0000 0000 0000 0000 0010__ :\n Defines whether this is a type for
+    /// repeating or one-shot timers.
     PVR_TIMER_TYPE_IS_REPEATING = (1 << 1),
+
+    /// @brief __0000 0000 0000 0000 0000 0000 0000 0100__ :\n Timers of this type must not be edited
+    /// by Kodi.
     PVR_TIMER_TYPE_IS_READONLY = (1 << 2),
+
+    /// @brief __0000 0000 0000 0000 0000 0000 0000 1000__ :\n Timers of this type must not be created
+    /// by Kodi. All other operations are allowed, though.
     PVR_TIMER_TYPE_FORBIDS_NEW_INSTANCES = (1 << 3),
+
+    /// @brief __0000 0000 0000 0000 0000 0000 0001 0000__ :\n This type supports enabling/disabling
+    /// of the timer (@ref kodi::addon::PVRTimer::SetState() with
+    /// @ref PVR_TIMER_STATE_SCHEDULED | @ref PVR_TIMER_STATE_DISABLED).
     PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE = (1 << 4),
+
+    /// @brief __0000 0000 0000 0000 0000 0000 0010 0000__ :\n This type supports channels
+    /// (@ref kodi::addon::PVRTimer::SetClientChannelUid()).
     PVR_TIMER_TYPE_SUPPORTS_CHANNELS = (1 << 5),
+
+    /// @brief __0000 0000 0000 0000 0000 0000 0100 0000__ :\n This type supports a recording start
+    /// time (@ref kodi::addon::PVRTimer::SetStartTime()).
     PVR_TIMER_TYPE_SUPPORTS_START_TIME = (1 << 6),
+
+    /// @brief __0000 0000 0000 0000 0000 0000 1000 0000__ :\n This type supports matching epg episode
+    ///  title using@ref kodi::addon::PVRTimer::SetEPGSearchString().
     PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH = (1 << 7),
+
+    /// @brief __0000 0000 0000 0000 0000 0001 0000 0000__ :\n This type supports matching "more" epg
+    /// data (not just episode title) using @ref kodi::addon::PVRTimer::SetEPGSearchString().
+    /// Setting @ref PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH implies
+    /// @ref PVR_TIMER_TYPE_SUPPORTS_TITLE_EPG_MATCH.
     PVR_TIMER_TYPE_SUPPORTS_FULLTEXT_EPG_MATCH = (1 << 8),
+
+    /// @brief __0000 0000 0000 0000 0000 0010 0000 0000__ :\n This type supports a first day the
+    /// timer gets active (@ref kodi::addon::PVRTimer::SetFirstDay()).
     PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY = (1 << 9),
+
+    /// @brief __0000 0000 0000 0000 0000 0100 0000 0000__ :\n This type supports weekdays for
+    /// defining the recording schedule (@ref kodi::addon::PVRTimer::SetWeekdays()).
     PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS = (1 << 10),
+
+    /// @brief __0000 0000 0000 0000 0000 1000 0000 0000__ :\n This type supports the <b>"record only new episodes"</b> feature
+    /// (@ref kodi::addon::PVRTimer::SetPreventDuplicateEpisodes()).
     PVR_TIMER_TYPE_SUPPORTS_RECORD_ONLY_NEW_EPISODES = (1 << 11),
+
+    /// @brief __0000 0000 0000 0000 0001 0000 0000 0000__ :\n This type supports pre and post record time (@ref kodi::addon::PVRTimer::SetMarginStart(),
+    /// @ref kodi::addon::PVRTimer::SetMarginEnd()).
     PVR_TIMER_TYPE_SUPPORTS_START_END_MARGIN = (1 << 12),
+
+    /// @brief __0000 0000 0000 0000 0010 0000 0000 0000__ :\n This type supports recording priority (@ref kodi::addon::PVRTimer::SetPriority()).
     PVR_TIMER_TYPE_SUPPORTS_PRIORITY = (1 << 13),
+
+    /// @brief __0000 0000 0000 0000 0100 0000 0000 0000__ :\n This type supports recording lifetime (@ref kodi::addon::PVRTimer::SetLifetime()).
     PVR_TIMER_TYPE_SUPPORTS_LIFETIME = (1 << 14),
+
+    /// @brief __0000 0000 0000 0000 1000 0000 0000 0000__ :\n This type supports placing recordings in user defined folders
+    /// (@ref kodi::addon::PVRTimer::SetDirectory()).
     PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS = (1 << 15),
+
+    /// @brief __0000 0000 0000 0001 0000 0000 0000 0000__ :\n This type supports a list of recording groups
+    /// (@ref kodi::addon::PVRTimer::SetRecordingGroup()).
     PVR_TIMER_TYPE_SUPPORTS_RECORDING_GROUP = (1 << 16),
+
+    /// @brief __0000 0000 0000 0010 0000 0000 0000 0000__ :\n This type supports a recording end time (@ref kodi::addon::PVRTimer::SetEndTime()).
     PVR_TIMER_TYPE_SUPPORTS_END_TIME = (1 << 17),
+
+    /// @brief __0000 0000 0000 0100 0000 0000 0000 0000__ :\n Enables an 'Any Time' over-ride option for start time
+    /// (using @ref kodi::addon::PVRTimer::SetStartAnyTime()).
     PVR_TIMER_TYPE_SUPPORTS_START_ANYTIME = (1 << 18),
+
+    /// @brief __0000 0000 0000 1000 0000 0000 0000 0000__ :\n Enables a separate <b>'Any Time'</b> over-ride for end time
+    /// (using @ref kodi::addon::PVRTimer::SetEndAnyTime()).
     PVR_TIMER_TYPE_SUPPORTS_END_ANYTIME = (1 << 19),
+
+    /// @brief __0000 0000 0001 0000 0000 0000 0000 0000__ :\n This type supports specifying a maximum recordings setting'
+    /// (@ref kodi::addon::PVRTimer::SetMaxRecordings()).
     PVR_TIMER_TYPE_SUPPORTS_MAX_RECORDINGS = (1 << 20),
+
+    /// @brief __0000 0000 0010 0000 0000 0000 0000 0000__ :\n This type should not appear on any create menus which don't
+    /// provide an associated @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "EPG tag".
     PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE = (1 << 21),
+
+    /// @brief __0000 0000 0100 0000 0000 0000 0000 0000__ :\n This type should not appear on any create menus which provide an
+    /// associated @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "EPG tag".
     PVR_TIMER_TYPE_FORBIDS_EPG_TAG_ON_CREATE = (1 << 22),
+
+    /// @brief __0000 0000 1000 0000 0000 0000 0000 0000__ :\n This type should not appear on any create menus unless associated
+    /// with an @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "EPG tag" with
+    /// 'series' attributes.
+    ///
+    /// Following conditions allow this:
+    /// - @ref kodi::addon::PVREPGTag::SetFlags() have flag @ref EPG_TAG_FLAG_IS_SERIES
+    /// - @ref kodi::addon::PVREPGTag::SetSeriesNumber() > 0
+    /// - @ref kodi::addon::PVREPGTag::SetEpisodeNumber() > 0
+    /// - @ref kodi::addon::PVREPGTag::SetEpisodePartNumber() > 0
+    ///
+    /// Implies @ref PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE.
     PVR_TIMER_TYPE_REQUIRES_EPG_SERIES_ON_CREATE = (1 << 23),
+
+    /// @brief __0000 0001 0000 0000 0000 0000 0000 0000__ :\n This type supports 'any channel', for example when defining a timer
+    /// rule that should match any channel instaed of a particular channel.
     PVR_TIMER_TYPE_SUPPORTS_ANY_CHANNEL = (1 << 24),
+
+    /// @brief __0000 0010 0000 0000 0000 0000 0000 0000__ :\n This type should not appear on any create menus which don't provide
+    /// an associated @ref cpp_kodi_addon_pvr_Defs_epg_PVREPGTag "EPG tag" with
+    /// a series link.
     PVR_TIMER_TYPE_REQUIRES_EPG_SERIESLINK_ON_CREATE = (1 << 25),
+
+    /// @brief __0000 0100 0000 0000 0000 0000 0000 0000__ :\n This type allows deletion of an otherwise read-only timer.
     PVR_TIMER_TYPE_SUPPORTS_READONLY_DELETE = (1 << 26),
+
+    /// @brief __0000 1000 0000 0000 0000 0000 0000 0000__ :\n Timers of this type do trigger a reminder if time is up.
     PVR_TIMER_TYPE_IS_REMINDER = (1 << 27),
+
+    /// @brief __0001 0000 0000 0000 0000 0000 0000 0000__ :\n This type supports pre record time (@ref kodi::addon::PVRTimer::SetMarginStart()).
     PVR_TIMER_TYPE_SUPPORTS_START_MARGIN = (1 << 28),
+
+    /// @brief __0010 0000 0000 0000 0000 0000 0000 0000__ :\n This type supports post record time (@ref kodi::addon::PVRTimer::SetMarginEnd()).
     PVR_TIMER_TYPE_SUPPORTS_END_MARGIN = (1 << 29),
   } PVR_TIMER_TYPES;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVR_WEEKDAY enum PVR_WEEKDAY
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Timer
+  /// @brief **PVR timer weekdays** (@ref kodi::addon::PVRTimer::SetWeekdays() **values**)\n
+  /// Used to select the days of a week you want.
+  ///
+  /// It can be also used to select several days e.g.:
+  /// ~~~~~~~~~~~~~{.cpp}
+  /// ...
+  /// unsigned int day = PVR_WEEKDAY_MONDAY | PVR_WEEKDAY_SATURDAY;
+  /// ...
+  /// ~~~~~~~~~~~~~
+  ///
+  ///@{
   typedef enum PVR_WEEKDAYS
   {
+    /// @brief __0000 0000__ : Nothing selected.
     PVR_WEEKDAY_NONE = 0,
+
+    /// @brief __0000 0001__ : To select Monday.
     PVR_WEEKDAY_MONDAY = (1 << 0),
+
+    /// @brief __0000 0010__ : To select Tuesday.
     PVR_WEEKDAY_TUESDAY = (1 << 1),
+
+    /// @brief __0000 0100__ : To select Wednesday.
     PVR_WEEKDAY_WEDNESDAY = (1 << 2),
+
+    /// @brief __0000 1000__ : To select Thursday.
     PVR_WEEKDAY_THURSDAY = (1 << 3),
+
+    /// @brief __0001 0000__ : To select Friday.
     PVR_WEEKDAY_FRIDAY = (1 << 4),
+
+    /// @brief __0010 0000__ : To select Saturday.
     PVR_WEEKDAY_SATURDAY = (1 << 5),
+
+    /// @brief __0100 0000__ : To select Sunday.
     PVR_WEEKDAY_SUNDAY = (1 << 6),
+
+    /// @brief __0111 1111__ : To select all days of week.
     PVR_WEEKDAY_ALLDAYS = PVR_WEEKDAY_MONDAY | PVR_WEEKDAY_TUESDAY | PVR_WEEKDAY_WEDNESDAY |
                           PVR_WEEKDAY_THURSDAY | PVR_WEEKDAY_FRIDAY | PVR_WEEKDAY_SATURDAY |
                           PVR_WEEKDAY_SUNDAY
   } PVR_WEEKDAY;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  //============================================================================
+  /// @defgroup cpp_kodi_addon_pvr_Defs_Timer_PVR_TIMER_STATE enum PVR_TIMER_STATE
+  /// @ingroup cpp_kodi_addon_pvr_Defs_Timer
+  /// @brief **PVR timer states**\n
+  /// To set within @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimer "kodi::addon::PVRTimer"
+  /// the needed state about.
+  ///
+  ///@{
   typedef enum PVR_TIMER_STATE
   {
+    /// @brief __0__ : The timer was just created on the backend and is not yet active.
+    ///
+    /// This state must not be used for timers just created on the client side.
     PVR_TIMER_STATE_NEW = 0,
+
+    /// @brief __1__ : The timer is scheduled for recording.
     PVR_TIMER_STATE_SCHEDULED = 1,
+
+    /// @brief __2__ : The timer is currently recordings.
     PVR_TIMER_STATE_RECORDING = 2,
+
+    /// @brief __3__ : The recording completed successfully.
     PVR_TIMER_STATE_COMPLETED = 3,
+
+    /// @brief __4__ : Recording started, but was aborted.
     PVR_TIMER_STATE_ABORTED = 4,
+
+    /// @brief __5__ : The timer was scheduled, but was canceled.
     PVR_TIMER_STATE_CANCELLED = 5,
+
+    /// @brief __6__ : The scheduled timer conflicts with another one, but will be
+    /// recorded.
     PVR_TIMER_STATE_CONFLICT_OK = 6,
+
+    /// @brief __7__ : The scheduled timer conflicts with another one and won't be
+    /// recorded.
     PVR_TIMER_STATE_CONFLICT_NOK = 7,
+
+    /// @brief __8__ : The timer is scheduled, but can't be recorded for some reason.
     PVR_TIMER_STATE_ERROR = 8,
+
+    /// @brief __9__ : The timer was disabled by the user, can be enabled via setting
+    /// the state to @ref PVR_TIMER_STATE_SCHEDULED.
     PVR_TIMER_STATE_DISABLED = 9,
   } PVR_TIMER_STATE;
+  ///@}
+  //----------------------------------------------------------------------------
 
+  /*!
+   * @brief "C" PVR add-on timer event.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimer "kodi::addon::PVRTimer" for
+   * description of values.
+   */
   typedef struct PVR_TIMER
   {
     unsigned int iClientIndex;
@@ -121,6 +367,14 @@ extern "C"
     char strSeriesLink[PVR_ADDON_URL_STRING_LENGTH];
   } PVR_TIMER;
 
+  /*!
+   * @brief "C" PVR add-on timer event type.
+   *
+   * Structure used to interface in "C" between Kodi and Addon.
+   *
+   * See @ref cpp_kodi_addon_pvr_Defs_Timer_PVRTimerType "kodi::addon::PVRTimerType" for
+   * description of values.
+   */
   typedef struct PVR_TIMER_TYPE
   {
     unsigned int iId;

From a5ea7ed55ba8d63c390b97f33bc5540ee7d199d5 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Wed, 6 May 2020 00:01:25 +0200
Subject: [PATCH 22/27] [addons][pvr][upload] rename addon id "xbmc.pvrclient"
 to "kodi.pvrclient"

As this is a very big change it makes sense for me to rename them too.
---
 addons/skin.estuary/xml/Home.xml                            | 4 ++--
 addons/webinterface.default/js/kodi-webinterface.js         | 2 +-
 xbmc/addons/addoninfo/AddonInfo.cpp                         | 2 +-
 .../kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h    | 6 +++---
 xbmc/filesystem/AddonsDirectory.cpp                         | 2 +-
 5 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/addons/skin.estuary/xml/Home.xml b/addons/skin.estuary/xml/Home.xml
index b5e1290f52d1..2fe691a11977 100644
--- a/addons/skin.estuary/xml/Home.xml
+++ b/addons/skin.estuary/xml/Home.xml
@@ -437,7 +437,7 @@
 					<include content="ImageWidget" condition="!System.HasPVRAddon">
 						<param name="text_label" value="$LOCALIZE[31143]" />
 						<param name="button_label" value="$LOCALIZE[31144]" />
-						<param name="button_onclick" value="ActivateWindow(addonbrowser,addons://all/xbmc.pvrclient,return)"/>
+						<param name="button_onclick" value="ActivateWindow(addonbrowser,addons://all/kodi.pvrclient,return)"/>
 						<param name="button_id" value="12400"/>
 						<param name="button2_onclick" value="Skin.SetBool(HomeMenuNoTVButton)"/>
 					</include>
@@ -517,7 +517,7 @@
 					<include content="ImageWidget" condition="!System.HasPVRAddon">
 						<param name="text_label" value="$LOCALIZE[31143]" />
 						<param name="button_label" value="$LOCALIZE[31144]" />
-						<param name="button_onclick" value="ActivateWindow(addonbrowser,addons://all/xbmc.pvrclient,return)"/>
+						<param name="button_onclick" value="ActivateWindow(addonbrowser,addons://all/kodi.pvrclient,return)"/>
 						<param name="button_id" value="13400"/>
 						<param name="button2_onclick" value="Skin.SetBool(HomeMenuNoRadioButton)"/>
 					</include>
diff --git a/addons/webinterface.default/js/kodi-webinterface.js b/addons/webinterface.default/js/kodi-webinterface.js
index 7e5160bd2f9a..c0419eb67c7e 100644
--- a/addons/webinterface.default/js/kodi-webinterface.js
+++ b/addons/webinterface.default/js/kodi-webinterface.js
@@ -8053,7 +8053,7 @@ this.Kodi.module("AddonApp.Pvr", function(Pvr, App, Backbone, Marionette, $, _)
   API = {
     isEnabled: function() {
       return App.request("addon:isEnabled", {
-        type: 'xbmc.pvrclient'
+        type: 'kodi.pvrclient'
       });
     }
   };
diff --git a/xbmc/addons/addoninfo/AddonInfo.cpp b/xbmc/addons/addoninfo/AddonInfo.cpp
index 5704cfe42986..96d0acb2e0fa 100644
--- a/xbmc/addons/addoninfo/AddonInfo.cpp
+++ b/xbmc/addons/addoninfo/AddonInfo.cpp
@@ -46,7 +46,7 @@ static const TypeMapping types[] =
    {"xbmc.gui.skin",                     ADDON_SKIN,                  166, "DefaultAddonSkin.png" },
    {"xbmc.webinterface",                 ADDON_WEB_INTERFACE,         199, "DefaultAddonWebSkin.png" },
    {"xbmc.addon.repository",             ADDON_REPOSITORY,          24011, "DefaultAddonRepository.png" },
-   {"xbmc.pvrclient",                    ADDON_PVRDLL,              24019, "DefaultAddonPVRClient.png" },
+   {"kodi.pvrclient",                    ADDON_PVRDLL,              24019, "DefaultAddonPVRClient.png" },
    {"kodi.gameclient",                   ADDON_GAMEDLL,             35049, "DefaultAddonGame.png" },
    {"kodi.peripheral",                   ADDON_PERIPHERALDLL,       35010, "DefaultAddonPeripheral.png" },
    {"xbmc.addon.video",                  ADDON_VIDEO,                1037, "DefaultAddonVideo.png" },
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index f01918af9964..918bf4afd04e 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -241,7 +241,7 @@ namespace addon
 ///   provider-name="Your Name">
 ///   <requires>@ADDON_DEPENDS@</requires>
 ///   <extension
-///     point="xbmc.pvrclient"
+///     point="kodi.pvrclient"
 ///     library_@PLATFORM@="@LIBRARY_FILENAME@"/>
 ///   <extension point="xbmc.addon.metadata">
 ///     <summary lang="en_GB">My PVR addon addon</summary>
@@ -252,10 +252,10 @@ namespace addon
 /// ~~~~~~~~~~~~~
 ///
 ///
-/// At <b>`<extension point="xbmc.pvrclient" ...>`</b> the basic instance definition is declared, this is intended to identify the addon as an PVR and to see its supported types:
+/// At <b>`<extension point="kodi.pvrclient" ...>`</b> the basic instance definition is declared, this is intended to identify the addon as an PVR and to see its supported types:
 /// | Name | Description
 /// |------|----------------------
-/// | <b>`point`</b> | The identification of the addon instance to inputstream is mandatory <b>`xbmc.pvrclient`</b>. In addition, the instance declared in the first <b>`<extension ... />`</b> is also the main type of addon.
+/// | <b>`point`</b> | The identification of the addon instance to inputstream is mandatory <b>`kodi.pvrclient`</b>. In addition, the instance declared in the first <b>`<extension ... />`</b> is also the main type of addon.
 /// | <b>`library_@PLATFORM@`</b> | The runtime library used for the addon. This is usually declared by cmake and correctly displayed in the translated `addon.xml`.
 ///
 ///
diff --git a/xbmc/filesystem/AddonsDirectory.cpp b/xbmc/filesystem/AddonsDirectory.cpp
index 4447fc85612f..5cbe7dd4aa5c 100644
--- a/xbmc/filesystem/AddonsDirectory.cpp
+++ b/xbmc/filesystem/AddonsDirectory.cpp
@@ -700,7 +700,7 @@ bool CAddonsDirectory::GetDirectory(const CURL& url, CFileItemList &items)
     VECADDONS addons;
     ADDON::TYPE type;
 
-    if (path.GetFileName() == "xbmc.pvrclient")
+    if (path.GetFileName() == "kodi.pvrclient")
       type = ADDON_PVRDLL;
     else if (path.GetFileName() == "kodi.vfs")
       type = ADDON_VFS;

From b5b9527a33892675fa49d6fa234c5ed3e3f744c9 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 11 May 2020 06:58:16 +0200
Subject: [PATCH 23/27] [addons][pvr] include only the "C" related headers on
 kodi

Only on PVRClient.cpp is the C++ part included to make a check about.
---
 xbmc/interfaces/json-rpc/FileItemHandler.cpp | 1 +
 xbmc/pvr/PVREdl.cpp                          | 2 +-
 xbmc/pvr/PVRManager.h                        | 2 +-
 xbmc/pvr/PVRStreamProperties.cpp             | 2 +-
 xbmc/pvr/addons/PVRClient.cpp                | 1 +
 xbmc/pvr/addons/PVRClient.h                  | 2 +-
 xbmc/pvr/addons/PVRClientMenuHooks.cpp       | 2 +-
 xbmc/pvr/addons/PVRClients.h                 | 2 +-
 xbmc/pvr/channels/PVRChannel.h               | 2 +-
 xbmc/pvr/channels/PVRChannelGroup.cpp        | 2 +-
 xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h | 2 +-
 xbmc/pvr/epg/Epg.h                           | 2 +-
 xbmc/pvr/epg/EpgContainer.cpp                | 1 +
 xbmc/pvr/epg/EpgContainer.h                  | 2 +-
 xbmc/pvr/epg/EpgInfoTag.cpp                  | 1 -
 xbmc/pvr/epg/EpgSearchData.h                 | 2 +-
 xbmc/pvr/epg/EpgTagsContainer.cpp            | 2 +-
 xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h         | 2 +-
 xbmc/pvr/recordings/PVRRecording.cpp         | 2 +-
 xbmc/pvr/timers/PVRTimerRuleMatcher.cpp      | 1 +
 xbmc/pvr/timers/PVRTimerType.h               | 2 +-
 21 files changed, 20 insertions(+), 17 deletions(-)

diff --git a/xbmc/interfaces/json-rpc/FileItemHandler.cpp b/xbmc/interfaces/json-rpc/FileItemHandler.cpp
index 5fd1e095b82d..5a4811e79358 100644
--- a/xbmc/interfaces/json-rpc/FileItemHandler.cpp
+++ b/xbmc/interfaces/json-rpc/FileItemHandler.cpp
@@ -15,6 +15,7 @@
 #include "VideoLibrary.h"
 #include "filesystem/Directory.h"
 #include "filesystem/File.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h" // EPG_TAG_INVALID_UID
 #include "music/MusicThumbLoader.h"
 #include "music/tags/MusicInfoTag.h"
 #include "pictures/PictureInfoTag.h"
diff --git a/xbmc/pvr/PVREdl.cpp b/xbmc/pvr/PVREdl.cpp
index 39aac8199442..fb63596a3bd5 100644
--- a/xbmc/pvr/PVREdl.cpp
+++ b/xbmc/pvr/PVREdl.cpp
@@ -9,7 +9,7 @@
 #include "PVREdl.h"
 
 #include "FileItem.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_edl.h"
 #include "cores/Cut.h"
 #include "pvr/epg/EpgInfoTag.h"
 #include "pvr/recordings/PVRRecording.h"
diff --git a/xbmc/pvr/PVRManager.h b/xbmc/pvr/PVRManager.h
index a52e09e5573b..ad1c0774365f 100644
--- a/xbmc/pvr/PVRManager.h
+++ b/xbmc/pvr/PVRManager.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h"
 #include "interfaces/IAnnouncer.h"
 #include "pvr/epg/EpgContainer.h"
 #include "pvr/guilib/PVRGUIActionListener.h"
diff --git a/xbmc/pvr/PVRStreamProperties.cpp b/xbmc/pvr/PVRStreamProperties.cpp
index cb736fabf4c7..74a336a8e205 100644
--- a/xbmc/pvr/PVRStreamProperties.cpp
+++ b/xbmc/pvr/PVRStreamProperties.cpp
@@ -8,7 +8,7 @@
 
 #include "PVRStreamProperties.h"
 
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h"
 #include "utils/StringUtils.h"
 
 using namespace PVR;
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index 92705b289864..c67e6405e8dc 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -9,6 +9,7 @@
 #include "PVRClient.h"
 
 #include "ServiceBroker.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h" // added for compile test on related sources only!
 #include "cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.h"
 #include "cores/VideoPlayer/Interface/Addon/InputStreamConstants.h"
 #include "dialogs/GUIDialogKaiToast.h"
diff --git a/xbmc/pvr/addons/PVRClient.h b/xbmc/pvr/addons/PVRClient.h
index 91ae5a4a561d..8f69092c0797 100644
--- a/xbmc/pvr/addons/PVRClient.h
+++ b/xbmc/pvr/addons/PVRClient.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "addons/binary-addons/AddonInstanceHandler.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h"
 
 #include <atomic>
 #include <functional>
diff --git a/xbmc/pvr/addons/PVRClientMenuHooks.cpp b/xbmc/pvr/addons/PVRClientMenuHooks.cpp
index 4a4c7e036d70..05dcbdff148c 100644
--- a/xbmc/pvr/addons/PVRClientMenuHooks.cpp
+++ b/xbmc/pvr/addons/PVRClientMenuHooks.cpp
@@ -8,7 +8,7 @@
 
 #include "PVRClientMenuHooks.h"
 
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_menu_hook.h"
 #include "guilib/LocalizeStrings.h"
 #include "pvr/PVRContextMenus.h"
 #include "utils/log.h"
diff --git a/xbmc/pvr/addons/PVRClients.h b/xbmc/pvr/addons/PVRClients.h
index 775c5ca78334..1ff516491e23 100644
--- a/xbmc/pvr/addons/PVRClients.h
+++ b/xbmc/pvr/addons/PVRClients.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "addons/AddonManager.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_general.h"
 #include "threads/CriticalSection.h"
 
 #include <functional>
diff --git a/xbmc/pvr/channels/PVRChannel.h b/xbmc/pvr/channels/PVRChannel.h
index 5b9acd47fa0e..0375a02423fe 100644
--- a/xbmc/pvr/channels/PVRChannel.h
+++ b/xbmc/pvr/channels/PVRChannel.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h"
 #include "pvr/channels/PVRChannelNumber.h"
 #include "threads/CriticalSection.h"
 #include "utils/ISerializable.h"
diff --git a/xbmc/pvr/channels/PVRChannelGroup.cpp b/xbmc/pvr/channels/PVRChannelGroup.cpp
index 94295ccb31b6..1eac89d88946 100644
--- a/xbmc/pvr/channels/PVRChannelGroup.cpp
+++ b/xbmc/pvr/channels/PVRChannelGroup.cpp
@@ -11,7 +11,7 @@
 #include "PVRChannelGroup.h"
 
 #include "ServiceBroker.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channel_groups.h"
 #include "pvr/PVRDatabase.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClient.h"
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h b/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
index ae8b65487f57..dd1abd054976 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
+++ b/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h" // PVR_CHANNEL_INVALID_UID
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h" // PVR_CHANNEL_INVALID_UID
 #include "settings/SettingConditions.h"
 #include "settings/dialogs/GUIDialogSettingsManualBase.h"
 #include "settings/lib/SettingDependency.h"
diff --git a/xbmc/pvr/epg/Epg.h b/xbmc/pvr/epg/Epg.h
index 0ca49d7f387a..2e1293d296a5 100644
--- a/xbmc/pvr/epg/Epg.h
+++ b/xbmc/pvr/epg/Epg.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "XBDateTime.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h"
 #include "pvr/epg/EpgTagsContainer.h"
 #include "threads/CriticalSection.h"
 #include "utils/EventStream.h"
diff --git a/xbmc/pvr/epg/EpgContainer.cpp b/xbmc/pvr/epg/EpgContainer.cpp
index fc48cb14e788..2282eed965dd 100644
--- a/xbmc/pvr/epg/EpgContainer.cpp
+++ b/xbmc/pvr/epg/EpgContainer.cpp
@@ -9,6 +9,7 @@
 #include "EpgContainer.h"
 
 #include "ServiceBroker.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h" // PVR_CHANNEL_INVALID_UID
 #include "guilib/LocalizeStrings.h"
 #include "pvr/PVRManager.h"
 #include "pvr/epg/Epg.h"
diff --git a/xbmc/pvr/epg/EpgContainer.h b/xbmc/pvr/epg/EpgContainer.h
index 2edde768fb61..353856bafe8a 100644
--- a/xbmc/pvr/epg/EpgContainer.h
+++ b/xbmc/pvr/epg/EpgContainer.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "XBDateTime.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h"
 #include "pvr/settings/PVRSettings.h"
 #include "threads/CriticalSection.h"
 #include "threads/Event.h"
diff --git a/xbmc/pvr/epg/EpgInfoTag.cpp b/xbmc/pvr/epg/EpgInfoTag.cpp
index c6b8255e96e3..492f450b8e2c 100644
--- a/xbmc/pvr/epg/EpgInfoTag.cpp
+++ b/xbmc/pvr/epg/EpgInfoTag.cpp
@@ -9,7 +9,6 @@
 #include "EpgInfoTag.h"
 
 #include "ServiceBroker.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
 #include "pvr/PVRManager.h"
 #include "pvr/PVRPlaybackState.h"
 #include "pvr/addons/PVRClient.h"
diff --git a/xbmc/pvr/epg/EpgSearchData.h b/xbmc/pvr/epg/EpgSearchData.h
index df8d965e7480..03ac4a5d45be 100644
--- a/xbmc/pvr/epg/EpgSearchData.h
+++ b/xbmc/pvr/epg/EpgSearchData.h
@@ -9,7 +9,7 @@
 #pragma once
 
 #include "XBDateTime.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h"
 
 #include <string>
 
diff --git a/xbmc/pvr/epg/EpgTagsContainer.cpp b/xbmc/pvr/epg/EpgTagsContainer.cpp
index bb2034e55c9a..9cd5a3622255 100644
--- a/xbmc/pvr/epg/EpgTagsContainer.cpp
+++ b/xbmc/pvr/epg/EpgTagsContainer.cpp
@@ -8,7 +8,7 @@
 
 #include "EpgTagsContainer.h"
 
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h"
 #include "pvr/epg/EpgDatabase.h"
 #include "pvr/epg/EpgInfoTag.h"
 #include "pvr/epg/EpgTagsCache.h"
diff --git a/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h b/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h
index f06480a9f358..edd4678df926 100644
--- a/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h
+++ b/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h"
 #include "guilib/guiinfo/GUIInfoProvider.h"
 #include "pvr/addons/PVRClients.h"
 #include "pvr/guilib/guiinfo/PVRGUITimerInfo.h"
diff --git a/xbmc/pvr/recordings/PVRRecording.cpp b/xbmc/pvr/recordings/PVRRecording.cpp
index 26f187439b6b..396fce60e29c 100644
--- a/xbmc/pvr/recordings/PVRRecording.cpp
+++ b/xbmc/pvr/recordings/PVRRecording.cpp
@@ -9,7 +9,7 @@
 #include "PVRRecording.h"
 
 #include "ServiceBroker.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_recordings.h"
 #include "guilib/LocalizeStrings.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClient.h"
diff --git a/xbmc/pvr/timers/PVRTimerRuleMatcher.cpp b/xbmc/pvr/timers/PVRTimerRuleMatcher.cpp
index 68cd22f042d6..4c488e8e2af1 100644
--- a/xbmc/pvr/timers/PVRTimerRuleMatcher.cpp
+++ b/xbmc/pvr/timers/PVRTimerRuleMatcher.cpp
@@ -9,6 +9,7 @@
 #include "PVRTimerRuleMatcher.h"
 
 #include "XBDateTime.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_channels.h" // PVR_CHANNEL_INVALID_UID
 #include "pvr/epg/EpgInfoTag.h"
 #include "pvr/timers/PVRTimerInfoTag.h"
 #include "utils/RegExp.h"
diff --git a/xbmc/pvr/timers/PVRTimerType.h b/xbmc/pvr/timers/PVRTimerType.h
index cc419a892234..9d8e7bb5b0a2 100644
--- a/xbmc/pvr/timers/PVRTimerType.h
+++ b/xbmc/pvr/timers/PVRTimerType.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#include "addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_timers.h"
 
 #include <memory>
 #include <string>

From 58f50fb657fc384032985b9bad003521f53130cd Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 8 Jun 2020 19:06:45 +0200
Subject: [PATCH 24/27] [addons][pvr] complete "C" language cleanup of PVR
 changes

Only ignored parts are the "#define"'s within "C" headers , as them
within a 'extern "C"' becomes his parts two spaces but not the define.
---
 xbmc/addons/addoninfo/AddonInfo.cpp           |    6 +-
 .../binary-addons/AddonInstanceHandler.h      |    8 +-
 .../DVDInputStreams/InputStreamPVRBase.cpp    |    3 +-
 xbmc/guilib/GUIWindowManager.cpp              |   66 +-
 xbmc/interfaces/json-rpc/FileItemHandler.cpp  |    2 +-
 xbmc/pvr/addons/PVRClient.cpp                 | 1103 ++++----
 xbmc/pvr/addons/PVRClient.h                   | 2351 +++++++++--------
 xbmc/pvr/addons/PVRClients.cpp                |    2 +-
 xbmc/pvr/channels/PVRChannel.cpp              |   24 +-
 xbmc/pvr/channels/PVRChannel.h                |    3 +-
 10 files changed, 1938 insertions(+), 1630 deletions(-)

diff --git a/xbmc/addons/addoninfo/AddonInfo.cpp b/xbmc/addons/addoninfo/AddonInfo.cpp
index 96d0acb2e0fa..8cc016d5172a 100644
--- a/xbmc/addons/addoninfo/AddonInfo.cpp
+++ b/xbmc/addons/addoninfo/AddonInfo.cpp
@@ -19,11 +19,12 @@ namespace ADDON
 typedef struct
 {
   const char* name;
-  TYPE        type;
-  int         pretty;
+  TYPE type;
+  int pretty;
   const char* icon;
 } TypeMapping;
 
+// clang-format off
 static const TypeMapping types[] =
   {{"unknown",                           ADDON_UNKNOWN,                 0, "" },
    {"xbmc.metadata.scraper.albums",      ADDON_SCRAPER_ALBUMS,      24016, "DefaultAddonAlbumInfo.png" },
@@ -66,6 +67,7 @@ static const TypeMapping types[] =
    {"kodi.vfs",                          ADDON_VFS,                 39013, "DefaultAddonVfs.png" },
    {"kodi.imagedecoder",                 ADDON_IMAGEDECODER,        39015, "DefaultAddonImageDecoder.png" },
   };
+// clang-format on
 
 /**
  * static public helper functions
diff --git a/xbmc/addons/binary-addons/AddonInstanceHandler.h b/xbmc/addons/binary-addons/AddonInstanceHandler.h
index d293fe400e8a..561ed22a17ad 100644
--- a/xbmc/addons/binary-addons/AddonInstanceHandler.h
+++ b/xbmc/addons/binary-addons/AddonInstanceHandler.h
@@ -39,10 +39,10 @@ namespace ADDON
     const AddonDllPtr& Addon() const { return m_addon; }
     BinaryAddonBasePtr GetAddonBase() const { return m_addonBase; };
 
-    virtual void OnPreInstall() { }
-    virtual void OnPostInstall(bool update, bool modal) { }
-    virtual void OnPreUnInstall() { }
-    virtual void OnPostUnInstall() { }
+    virtual void OnPreInstall() {}
+    virtual void OnPostInstall(bool update, bool modal) {}
+    virtual void OnPreUnInstall() {}
+    virtual void OnPostUnInstall() {}
 
   private:
     ADDON_TYPE m_type;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamPVRBase.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamPVRBase.cpp
index b082dcdb3e25..926299953676 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamPVRBase.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamPVRBase.cpp
@@ -329,7 +329,8 @@ void CInputStreamPVRBase::UpdateStreamMap()
       dStream = streamSubtitle;
     }
     else if (stream.iCodecType == PVR_CODEC_TYPE_RDS &&
-             CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool("pvrplayback.enableradiords"))
+             CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+                 "pvrplayback.enableradiords"))
     {
       std::shared_ptr<CDemuxStreamRadioRDS> streamRadioRDS;
 
diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index 69df284e9774..237ad6ef82c5 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -7,57 +7,57 @@
  */
 
 #include "GUIWindowManager.h"
+
+#include "Application.h"
 #include "GUIAudioManager.h"
 #include "GUIDialog.h"
-#include "Application.h"
+#include "GUIInfoManager.h"
+#include "GUIPassword.h"
+#include "GUITexture.h"
+#include "addons/GUIWindowAddonBrowser.h"
+#include "addons/Skin.h"
 #include "addons/interfaces/gui/Window.h"
+#include "events/windows/GUIWindowEventLog.h"
+#include "favourites/GUIDialogFavourites.h"
+#include "input/Key.h"
 #include "messaging/ApplicationMessenger.h"
 #include "messaging/helpers/DialogHelper.h"
-#include "GUIPassword.h"
-#include "GUIInfoManager.h"
-#include "threads/SingleLock.h"
-#include "utils/URIUtils.h"
+#include "music/dialogs/GUIDialogInfoProviderSettings.h"
+#include "music/dialogs/GUIDialogMusicInfo.h"
+#include "music/windows/GUIWindowMusicNav.h"
+#include "music/windows/GUIWindowMusicPlaylist.h"
+#include "music/windows/GUIWindowMusicPlaylistEditor.h"
+#include "music/windows/GUIWindowVisualisation.h"
+#include "pictures/GUIWindowPictures.h"
+#include "pictures/GUIWindowSlideShow.h"
+#include "profiles/windows/GUIWindowSettingsProfile.h"
+#include "programs/GUIWindowPrograms.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/SettingsComponent.h"
-#include "addons/Skin.h"
-#include "GUITexture.h"
-#include "utils/Variant.h"
-#include "input/Key.h"
-#include "utils/log.h"
-#include "utils/StringUtils.h"
-
-#include "windows/GUIWindowHome.h"
-#include "events/windows/GUIWindowEventLog.h"
-#include "favourites/GUIDialogFavourites.h"
 #include "settings/windows/GUIWindowSettings.h"
-#include "windows/GUIWindowFileManager.h"
 #include "settings/windows/GUIWindowSettingsCategory.h"
-#include "music/windows/GUIWindowMusicPlaylist.h"
-#include "music/windows/GUIWindowMusicNav.h"
-#include "music/windows/GUIWindowMusicPlaylistEditor.h"
-#include "video/windows/GUIWindowVideoPlaylist.h"
-#include "music/dialogs/GUIDialogInfoProviderSettings.h"
-#include "music/dialogs/GUIDialogMusicInfo.h"
+#include "settings/windows/GUIWindowSettingsScreenCalibration.h"
+#include "threads/SingleLock.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/Variant.h"
+#include "utils/log.h"
 #include "video/dialogs/GUIDialogVideoInfo.h"
+#include "video/dialogs/GUIDialogVideoOSD.h"
+#include "video/windows/GUIWindowFullScreen.h"
 #include "video/windows/GUIWindowVideoNav.h"
-#include "profiles/windows/GUIWindowSettingsProfile.h"
-#include "settings/windows/GUIWindowSettingsScreenCalibration.h"
-#include "programs/GUIWindowPrograms.h"
-#include "pictures/GUIWindowPictures.h"
+#include "video/windows/GUIWindowVideoPlaylist.h"
 #include "weather/GUIWindowWeather.h"
-#include "windows/GUIWindowLoginScreen.h"
-#include "addons/GUIWindowAddonBrowser.h"
-#include "music/windows/GUIWindowVisualisation.h"
 #include "windows/GUIWindowDebugInfo.h"
+#include "windows/GUIWindowFileManager.h"
+#include "windows/GUIWindowHome.h"
+#include "windows/GUIWindowLoginScreen.h"
 #include "windows/GUIWindowPointer.h"
-#include "windows/GUIWindowSystemInfo.h"
 #include "windows/GUIWindowScreensaver.h"
 #include "windows/GUIWindowScreensaverDim.h"
-#include "pictures/GUIWindowSlideShow.h"
 #include "windows/GUIWindowSplash.h"
 #include "windows/GUIWindowStartup.h"
-#include "video/windows/GUIWindowFullScreen.h"
-#include "video/dialogs/GUIDialogVideoOSD.h"
+#include "windows/GUIWindowSystemInfo.h"
 
 // Dialog includes
 #include "music/dialogs/GUIDialogMusicOSD.h"
diff --git a/xbmc/interfaces/json-rpc/FileItemHandler.cpp b/xbmc/interfaces/json-rpc/FileItemHandler.cpp
index 5a4811e79358..badf8a97d0ac 100644
--- a/xbmc/interfaces/json-rpc/FileItemHandler.cpp
+++ b/xbmc/interfaces/json-rpc/FileItemHandler.cpp
@@ -13,9 +13,9 @@
 #include "TextureDatabase.h"
 #include "Util.h"
 #include "VideoLibrary.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h" // EPG_TAG_INVALID_UID
 #include "filesystem/Directory.h"
 #include "filesystem/File.h"
-#include "addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr/pvr_epg.h" // EPG_TAG_INVALID_UID
 #include "music/MusicThumbLoader.h"
 #include "music/tags/MusicInfoTag.h"
 #include "pictures/PictureInfoTag.h"
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index c67e6405e8dc..934799b66be6 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -255,11 +255,13 @@ int CPVRClient::GetID() const
  * @param xbmcGroup The group on XBMC's side.
  * @param addonGroup The group on the addon's side.
  */
-void CPVRClient::WriteClientGroupInfo(const CPVRChannelGroup& xbmcGroup, PVR_CHANNEL_GROUP& addonGroup)
+void CPVRClient::WriteClientGroupInfo(const CPVRChannelGroup& xbmcGroup,
+                                      PVR_CHANNEL_GROUP& addonGroup)
 {
   addonGroup = {{0}};
   addonGroup.bIsRadio = xbmcGroup.IsRadio();
-  strncpy(addonGroup.strGroupName, xbmcGroup.GroupName().c_str(), sizeof(addonGroup.strGroupName) - 1);
+  strncpy(addonGroup.strGroupName, xbmcGroup.GroupName().c_str(),
+          sizeof(addonGroup.strGroupName) - 1);
 }
 
 /*!
@@ -267,27 +269,40 @@ void CPVRClient::WriteClientGroupInfo(const CPVRChannelGroup& xbmcGroup, PVR_CHA
  * @param xbmcRecording The recording on XBMC's side.
  * @param addonRecording The recording on the addon's side.
  */
-void CPVRClient::WriteClientRecordingInfo(const CPVRRecording& xbmcRecording, PVR_RECORDING& addonRecording)
+void CPVRClient::WriteClientRecordingInfo(const CPVRRecording& xbmcRecording,
+                                          PVR_RECORDING& addonRecording)
 {
   time_t recTime;
   xbmcRecording.RecordingTimeAsUTC().GetAsTime(recTime);
 
   addonRecording = {{0}};
-  strncpy(addonRecording.strRecordingId, xbmcRecording.m_strRecordingId.c_str(), sizeof(addonRecording.strRecordingId) - 1);
-  strncpy(addonRecording.strTitle, xbmcRecording.m_strTitle.c_str(), sizeof(addonRecording.strTitle) - 1);
-  strncpy(addonRecording.strEpisodeName, xbmcRecording.m_strShowTitle.c_str(), sizeof(addonRecording.strEpisodeName) - 1);
+  strncpy(addonRecording.strRecordingId, xbmcRecording.m_strRecordingId.c_str(),
+          sizeof(addonRecording.strRecordingId) - 1);
+  strncpy(addonRecording.strTitle, xbmcRecording.m_strTitle.c_str(),
+          sizeof(addonRecording.strTitle) - 1);
+  strncpy(addonRecording.strEpisodeName, xbmcRecording.m_strShowTitle.c_str(),
+          sizeof(addonRecording.strEpisodeName) - 1);
   addonRecording.iSeriesNumber = xbmcRecording.m_iSeason;
   addonRecording.iEpisodeNumber = xbmcRecording.m_iEpisode;
   addonRecording.iYear = xbmcRecording.GetYear();
-  strncpy(addonRecording.strDirectory, xbmcRecording.m_strDirectory.c_str(), sizeof(addonRecording.strDirectory) - 1);
-  strncpy(addonRecording.strPlotOutline, xbmcRecording.m_strPlotOutline.c_str(), sizeof(addonRecording.strPlotOutline) - 1);
-  strncpy(addonRecording.strPlot, xbmcRecording.m_strPlot.c_str(), sizeof(addonRecording.strPlot) - 1);
-  strncpy(addonRecording.strGenreDescription, xbmcRecording.GetGenresLabel().c_str(), sizeof(addonRecording.strGenreDescription) - 1);
-  strncpy(addonRecording.strChannelName, xbmcRecording.m_strChannelName.c_str(), sizeof(addonRecording.strChannelName) - 1);
-  strncpy(addonRecording.strIconPath, xbmcRecording.m_strIconPath.c_str(), sizeof(addonRecording.strIconPath) - 1);
-  strncpy(addonRecording.strThumbnailPath, xbmcRecording.m_strThumbnailPath.c_str(), sizeof(addonRecording.strThumbnailPath) - 1);
-  strncpy(addonRecording.strFanartPath, xbmcRecording.m_strFanartPath.c_str(), sizeof(addonRecording.strFanartPath) - 1);
-  addonRecording.recordingTime = recTime - CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_iPVRTimeCorrection;
+  strncpy(addonRecording.strDirectory, xbmcRecording.m_strDirectory.c_str(),
+          sizeof(addonRecording.strDirectory) - 1);
+  strncpy(addonRecording.strPlotOutline, xbmcRecording.m_strPlotOutline.c_str(),
+          sizeof(addonRecording.strPlotOutline) - 1);
+  strncpy(addonRecording.strPlot, xbmcRecording.m_strPlot.c_str(),
+          sizeof(addonRecording.strPlot) - 1);
+  strncpy(addonRecording.strGenreDescription, xbmcRecording.GetGenresLabel().c_str(),
+          sizeof(addonRecording.strGenreDescription) - 1);
+  strncpy(addonRecording.strChannelName, xbmcRecording.m_strChannelName.c_str(),
+          sizeof(addonRecording.strChannelName) - 1);
+  strncpy(addonRecording.strIconPath, xbmcRecording.m_strIconPath.c_str(),
+          sizeof(addonRecording.strIconPath) - 1);
+  strncpy(addonRecording.strThumbnailPath, xbmcRecording.m_strThumbnailPath.c_str(),
+          sizeof(addonRecording.strThumbnailPath) - 1);
+  strncpy(addonRecording.strFanartPath, xbmcRecording.m_strFanartPath.c_str(),
+          sizeof(addonRecording.strFanartPath) - 1);
+  addonRecording.recordingTime =
+      recTime - CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_iPVRTimeCorrection;
   addonRecording.iDuration = xbmcRecording.GetDuration();
   addonRecording.iPriority = xbmcRecording.m_iPriority;
   addonRecording.iLifetime = xbmcRecording.m_iLifetime;
@@ -297,7 +312,8 @@ void CPVRClient::WriteClientRecordingInfo(const CPVRRecording& xbmcRecording, PV
   addonRecording.iLastPlayedPosition = lrint(xbmcRecording.GetLocalResumePoint().timeInSeconds);
   addonRecording.bIsDeleted = xbmcRecording.IsDeleted();
   addonRecording.iChannelUid = xbmcRecording.ChannelUid();
-  addonRecording.channelType = xbmcRecording.IsRadio() ? PVR_RECORDING_CHANNEL_TYPE_RADIO : PVR_RECORDING_CHANNEL_TYPE_TV;
+  addonRecording.channelType =
+      xbmcRecording.IsRadio() ? PVR_RECORDING_CHANNEL_TYPE_RADIO : PVR_RECORDING_CHANNEL_TYPE_TV;
   if (xbmcRecording.FirstAired().IsValid())
     strncpy(addonRecording.strFirstAired, xbmcRecording.FirstAired().GetAsW3CDate().c_str(),
             sizeof(addonRecording.strFirstAired) - 1);
@@ -316,18 +332,22 @@ void CPVRClient::WriteClientTimerInfo(const CPVRTimerInfoTag& xbmcTimer, PVR_TIM
   xbmcTimer.FirstDayAsUTC().GetAsTime(firstDay);
   std::shared_ptr<CPVREpgInfoTag> epgTag = xbmcTimer.GetEpgInfoTag();
 
-  int iPVRTimeCorrection = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_iPVRTimeCorrection;
+  int iPVRTimeCorrection =
+      CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_iPVRTimeCorrection;
 
   addonTimer = {0};
   addonTimer.iClientIndex = xbmcTimer.m_iClientIndex;
   addonTimer.iParentClientIndex = xbmcTimer.m_iParentClientIndex;
   addonTimer.state = xbmcTimer.m_state;
-  addonTimer.iTimerType = xbmcTimer.GetTimerType() ? xbmcTimer.GetTimerType()->GetTypeId() : PVR_TIMER_TYPE_NONE;
+  addonTimer.iTimerType =
+      xbmcTimer.GetTimerType() ? xbmcTimer.GetTimerType()->GetTypeId() : PVR_TIMER_TYPE_NONE;
   addonTimer.iClientChannelUid = xbmcTimer.m_iClientChannelUid;
   strncpy(addonTimer.strTitle, xbmcTimer.m_strTitle.c_str(), sizeof(addonTimer.strTitle) - 1);
-  strncpy(addonTimer.strEpgSearchString, xbmcTimer.m_strEpgSearchString.c_str(), sizeof(addonTimer.strEpgSearchString) - 1);
+  strncpy(addonTimer.strEpgSearchString, xbmcTimer.m_strEpgSearchString.c_str(),
+          sizeof(addonTimer.strEpgSearchString) - 1);
   addonTimer.bFullTextEpgSearch = xbmcTimer.m_bFullTextEpgSearch;
-  strncpy(addonTimer.strDirectory, xbmcTimer.m_strDirectory.c_str(), sizeof(addonTimer.strDirectory) - 1);
+  strncpy(addonTimer.strDirectory, xbmcTimer.m_strDirectory.c_str(),
+          sizeof(addonTimer.strDirectory) - 1);
   addonTimer.iPriority = xbmcTimer.m_iPriority;
   addonTimer.iLifetime = xbmcTimer.m_iLifetime;
   addonTimer.iMaxRecordings = xbmcTimer.m_iMaxRecordings;
@@ -345,7 +365,8 @@ void CPVRClient::WriteClientTimerInfo(const CPVRTimerInfoTag& xbmcTimer, PVR_TIM
   addonTimer.iMarginEnd = xbmcTimer.m_iMarginEnd;
   addonTimer.iGenreType = epgTag ? epgTag->GenreType() : 0;
   addonTimer.iGenreSubType = epgTag ? epgTag->GenreSubType() : 0;
-  strncpy(addonTimer.strSeriesLink, xbmcTimer.SeriesLink().c_str(), sizeof(addonTimer.strSeriesLink) - 1);
+  strncpy(addonTimer.strSeriesLink, xbmcTimer.SeriesLink().c_str(),
+          sizeof(addonTimer.strSeriesLink) - 1);
 }
 
 /*!
@@ -353,18 +374,22 @@ void CPVRClient::WriteClientTimerInfo(const CPVRTimerInfoTag& xbmcTimer, PVR_TIM
  * @param xbmcChannel The channel on XBMC's side.
  * @param addonChannel The channel on the addon's side.
  */
-void CPVRClient::WriteClientChannelInfo(const std::shared_ptr<CPVRChannel>& xbmcChannel, PVR_CHANNEL& addonChannel)
+void CPVRClient::WriteClientChannelInfo(const std::shared_ptr<CPVRChannel>& xbmcChannel,
+                                        PVR_CHANNEL& addonChannel)
 {
   addonChannel = {0};
   addonChannel.iUniqueId = xbmcChannel->UniqueID();
   addonChannel.iChannelNumber = xbmcChannel->ClientChannelNumber().GetChannelNumber();
   addonChannel.iSubChannelNumber = xbmcChannel->ClientChannelNumber().GetSubChannelNumber();
-  strncpy(addonChannel.strChannelName, xbmcChannel->ClientChannelName().c_str(), sizeof(addonChannel.strChannelName) - 1);
-  strncpy(addonChannel.strIconPath, xbmcChannel->IconPath().c_str(), sizeof(addonChannel.strIconPath) - 1);
+  strncpy(addonChannel.strChannelName, xbmcChannel->ClientChannelName().c_str(),
+          sizeof(addonChannel.strChannelName) - 1);
+  strncpy(addonChannel.strIconPath, xbmcChannel->IconPath().c_str(),
+          sizeof(addonChannel.strIconPath) - 1);
   addonChannel.iEncryptionSystem = xbmcChannel->EncryptionSystem();
   addonChannel.bIsRadio = xbmcChannel->IsRadio();
   addonChannel.bIsHidden = xbmcChannel->IsHidden();
-  strncpy(addonChannel.strMimeType, xbmcChannel->MimeType().c_str(), sizeof(addonChannel.strMimeType) - 1);
+  strncpy(addonChannel.strMimeType, xbmcChannel->MimeType().c_str(),
+          sizeof(addonChannel.strMimeType) - 1);
 }
 
 bool CPVRClient::GetAddonProperties()
@@ -378,26 +403,35 @@ bool CPVRClient::GetAddonProperties()
   std::vector<std::shared_ptr<CPVRTimerType>> timerTypes;
 
   /* get the capabilities */
-  PVR_ERROR retVal = DoAddonCall(__FUNCTION__, [&addonCapabilities](const AddonInstance* addon) {
-    return addon->toAddon->GetCapabilities(addon, &addonCapabilities);
-  }, true, false);
+  PVR_ERROR retVal = DoAddonCall(
+      __func__,
+      [&addonCapabilities](const AddonInstance* addon) {
+        return addon->toAddon->GetCapabilities(addon, &addonCapabilities);
+      },
+      true, false);
 
   if (retVal != PVR_ERROR_NO_ERROR)
     return false;
 
   /* get the name of the backend */
-  retVal = DoAddonCall(__FUNCTION__, [&strBackendName](const AddonInstance* addon) {
-    return addon->toAddon->GetBackendName(addon, strBackendName, sizeof(strBackendName));
-  }, true, false);
+  retVal = DoAddonCall(
+      __func__,
+      [&strBackendName](const AddonInstance* addon) {
+        return addon->toAddon->GetBackendName(addon, strBackendName, sizeof(strBackendName));
+      },
+      true, false);
 
   if (retVal != PVR_ERROR_NO_ERROR)
     return false;
 
   /* get the connection string */
-  retVal = DoAddonCall(__FUNCTION__, [&strConnectionString](const AddonInstance* addon) {
-    return addon->toAddon->GetConnectionString(addon, strConnectionString,
-                                               sizeof(strConnectionString));
-  }, true, false);
+  retVal = DoAddonCall(
+      __func__,
+      [&strConnectionString](const AddonInstance* addon) {
+        return addon->toAddon->GetConnectionString(addon, strConnectionString,
+                                                   sizeof(strConnectionString));
+      },
+      true, false);
 
   if (retVal != PVR_ERROR_NO_ERROR && retVal != PVR_ERROR_NOT_IMPLEMENTED)
     return false;
@@ -406,107 +440,114 @@ bool CPVRClient::GetAddonProperties()
   strFriendlyName = StringUtils::Format("%s:%s", strBackendName, strConnectionString);
 
   /* backend version number */
-  retVal = DoAddonCall(__FUNCTION__, [&strBackendVersion](const AddonInstance* addon) {
-    return addon->toAddon->GetBackendVersion(addon, strBackendVersion,
-                                             sizeof(strBackendVersion));
-  }, true, false);
+  retVal = DoAddonCall(
+      __func__,
+      [&strBackendVersion](const AddonInstance* addon) {
+        return addon->toAddon->GetBackendVersion(addon, strBackendVersion,
+                                                 sizeof(strBackendVersion));
+      },
+      true, false);
 
   if (retVal != PVR_ERROR_NO_ERROR)
     return false;
 
   /* backend hostname */
-  retVal = DoAddonCall(__FUNCTION__, [&strBackendHostname](const AddonInstance* addon) {
-    return addon->toAddon->GetBackendHostname(addon, strBackendHostname,
-                                              sizeof(strBackendHostname));
-  }, true, false);
+  retVal = DoAddonCall(
+      __func__,
+      [&strBackendHostname](const AddonInstance* addon) {
+        return addon->toAddon->GetBackendHostname(addon, strBackendHostname,
+                                                  sizeof(strBackendHostname));
+      },
+      true, false);
 
   if (retVal != PVR_ERROR_NO_ERROR && retVal != PVR_ERROR_NOT_IMPLEMENTED)
     return false;
 
   /* timer types */
-  retVal = DoAddonCall(__FUNCTION__, [this, strFriendlyName, &addonCapabilities, &timerTypes](const AddonInstance* addon) {
-    std::unique_ptr<PVR_TIMER_TYPE[]> types_array(new PVR_TIMER_TYPE[PVR_ADDON_TIMERTYPE_ARRAY_SIZE]);
-    int size = PVR_ADDON_TIMERTYPE_ARRAY_SIZE;
+  retVal = DoAddonCall(
+      __func__,
+      [this, strFriendlyName, &addonCapabilities, &timerTypes](const AddonInstance* addon) {
+        std::unique_ptr<PVR_TIMER_TYPE[]> types_array(
+            new PVR_TIMER_TYPE[PVR_ADDON_TIMERTYPE_ARRAY_SIZE]);
+        int size = PVR_ADDON_TIMERTYPE_ARRAY_SIZE;
 
-    PVR_ERROR retval = addon->toAddon->GetTimerTypes(addon, types_array.get(), &size);
+        PVR_ERROR retval = addon->toAddon->GetTimerTypes(addon, types_array.get(), &size);
 
-    if (retval == PVR_ERROR_NOT_IMPLEMENTED)
-    {
-      // begin compat section
-      CLog::LogF(LOGWARNING, "Add-on %s does not support timer types. It will work, but not benefit from the timer features introduced with PVR Addon API 2.0.0", strFriendlyName.c_str());
-
-      // Create standard timer types (mostly) matching the timer functionality available in Isengard.
-      // This is for migration only and does not make changes to the addons obsolete. Addons should
-      // work and benefit from some UI changes (e.g. some of the timer settings dialog enhancements),
-      // but all old problems/bugs due to static attributes and values will remain the same as in
-      // Isengard. Also, new features (like epg search) are not available to addons automatically.
-      // This code can be removed once all addons actually support the respective PVR Addon API version.
-
-      size = 0;
-      // manual one time
-      memset(&types_array[size], 0, sizeof(types_array[size]));
-      types_array[size].iId = size + 1;
-      types_array[size].iAttributes = PVR_TIMER_TYPE_IS_MANUAL               |
-                                      PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE |
-                                      PVR_TIMER_TYPE_SUPPORTS_CHANNELS       |
-                                      PVR_TIMER_TYPE_SUPPORTS_START_TIME     |
-                                      PVR_TIMER_TYPE_SUPPORTS_END_TIME       |
-                                      PVR_TIMER_TYPE_SUPPORTS_PRIORITY       |
-                                      PVR_TIMER_TYPE_SUPPORTS_LIFETIME       |
-                                      PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS;
-      ++size;
-
-      // manual timer rule
-      memset(&types_array[size], 0, sizeof(types_array[size]));
-      types_array[size].iId = size + 1;
-      types_array[size].iAttributes = PVR_TIMER_TYPE_IS_MANUAL               |
-                                      PVR_TIMER_TYPE_IS_REPEATING            |
-                                      PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE |
-                                      PVR_TIMER_TYPE_SUPPORTS_CHANNELS       |
-                                      PVR_TIMER_TYPE_SUPPORTS_START_TIME     |
-                                      PVR_TIMER_TYPE_SUPPORTS_END_TIME       |
-                                      PVR_TIMER_TYPE_SUPPORTS_PRIORITY       |
-                                      PVR_TIMER_TYPE_SUPPORTS_LIFETIME       |
-                                      PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY      |
-                                      PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS       |
-                                      PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS;
-      ++size;
-
-      if (addonCapabilities.bSupportsEPG)
-      {
-        // One-shot epg-based
-        memset(&types_array[size], 0, sizeof(types_array[size]));
-        types_array[size].iId = size + 1;
-        types_array[size].iAttributes = PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE    |
-                                        PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE |
-                                        PVR_TIMER_TYPE_SUPPORTS_CHANNELS          |
-                                        PVR_TIMER_TYPE_SUPPORTS_START_TIME        |
-                                        PVR_TIMER_TYPE_SUPPORTS_END_TIME          |
-                                        PVR_TIMER_TYPE_SUPPORTS_PRIORITY          |
-                                        PVR_TIMER_TYPE_SUPPORTS_LIFETIME          |
-                                        PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS;
-        ++size;
-      }
-
-      retval = PVR_ERROR_NO_ERROR;
-      // end compat section
-    }
+        if (retval == PVR_ERROR_NOT_IMPLEMENTED)
+        {
+          // begin compat section
+          CLog::LogF(LOGWARNING,
+                     "Add-on %s does not support timer types. It will work, but not benefit from "
+                     "the timer features introduced with PVR Addon API 2.0.0",
+                     strFriendlyName.c_str());
+
+          // Create standard timer types (mostly) matching the timer functionality available in Isengard.
+          // This is for migration only and does not make changes to the addons obsolete. Addons should
+          // work and benefit from some UI changes (e.g. some of the timer settings dialog enhancements),
+          // but all old problems/bugs due to static attributes and values will remain the same as in
+          // Isengard. Also, new features (like epg search) are not available to addons automatically.
+          // This code can be removed once all addons actually support the respective PVR Addon API version.
+
+          size = 0;
+          // manual one time
+          memset(&types_array[size], 0, sizeof(types_array[size]));
+          types_array[size].iId = size + 1;
+          types_array[size].iAttributes =
+              PVR_TIMER_TYPE_IS_MANUAL | PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE |
+              PVR_TIMER_TYPE_SUPPORTS_CHANNELS | PVR_TIMER_TYPE_SUPPORTS_START_TIME |
+              PVR_TIMER_TYPE_SUPPORTS_END_TIME | PVR_TIMER_TYPE_SUPPORTS_PRIORITY |
+              PVR_TIMER_TYPE_SUPPORTS_LIFETIME | PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS;
+          ++size;
+
+          // manual timer rule
+          memset(&types_array[size], 0, sizeof(types_array[size]));
+          types_array[size].iId = size + 1;
+          types_array[size].iAttributes =
+              PVR_TIMER_TYPE_IS_MANUAL | PVR_TIMER_TYPE_IS_REPEATING |
+              PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE | PVR_TIMER_TYPE_SUPPORTS_CHANNELS |
+              PVR_TIMER_TYPE_SUPPORTS_START_TIME | PVR_TIMER_TYPE_SUPPORTS_END_TIME |
+              PVR_TIMER_TYPE_SUPPORTS_PRIORITY | PVR_TIMER_TYPE_SUPPORTS_LIFETIME |
+              PVR_TIMER_TYPE_SUPPORTS_FIRST_DAY | PVR_TIMER_TYPE_SUPPORTS_WEEKDAYS |
+              PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS;
+          ++size;
+
+          if (addonCapabilities.bSupportsEPG)
+          {
+            // One-shot epg-based
+            memset(&types_array[size], 0, sizeof(types_array[size]));
+            types_array[size].iId = size + 1;
+            types_array[size].iAttributes =
+                PVR_TIMER_TYPE_SUPPORTS_ENABLE_DISABLE | PVR_TIMER_TYPE_REQUIRES_EPG_TAG_ON_CREATE |
+                PVR_TIMER_TYPE_SUPPORTS_CHANNELS | PVR_TIMER_TYPE_SUPPORTS_START_TIME |
+                PVR_TIMER_TYPE_SUPPORTS_END_TIME | PVR_TIMER_TYPE_SUPPORTS_PRIORITY |
+                PVR_TIMER_TYPE_SUPPORTS_LIFETIME | PVR_TIMER_TYPE_SUPPORTS_RECORDING_FOLDERS;
+            ++size;
+          }
+
+          retval = PVR_ERROR_NO_ERROR;
+          // end compat section
+        }
 
-    if (retval == PVR_ERROR_NO_ERROR)
-    {
-      timerTypes.reserve(size);
-      for (int i = 0; i < size; ++i)
-      {
-        if (types_array[i].iId == PVR_TIMER_TYPE_NONE)
+        if (retval == PVR_ERROR_NO_ERROR)
         {
-          CLog::LogF(LOGERROR, "Invalid timer type supplied by add-on '%s'. Please contact the developer of this add-on: %s", GetFriendlyName().c_str(), Author().c_str());
-          continue;
+          timerTypes.reserve(size);
+          for (int i = 0; i < size; ++i)
+          {
+            if (types_array[i].iId == PVR_TIMER_TYPE_NONE)
+            {
+              CLog::LogF(LOGERROR,
+                         "Invalid timer type supplied by add-on '%s'. Please contact the developer "
+                         "of this add-on: %s",
+                         GetFriendlyName().c_str(), Author().c_str());
+              continue;
+            }
+            timerTypes.emplace_back(
+                std::shared_ptr<CPVRTimerType>(new CPVRTimerType(types_array[i], m_iClientId)));
+          }
         }
-        timerTypes.emplace_back(std::shared_ptr<CPVRTimerType>(new CPVRTimerType(types_array[i], m_iClientId)));
-      }
-    }
-    return retval;
-  }, addonCapabilities.bSupportsTimers, false);
+        return retval;
+      },
+      addonCapabilities.bSupportsTimers, false);
 
   if (retVal == PVR_ERROR_NOT_IMPLEMENTED)
     retVal = PVR_ERROR_NO_ERROR; // timer support is optional.
@@ -555,7 +596,7 @@ PVR_ERROR CPVRClient::GetDriveSpace(uint64_t& iTotal, uint64_t& iUsed)
   iTotal = 0;
   iUsed = 0;
 
-  return DoAddonCall(__FUNCTION__, [&iTotal, &iUsed](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&iTotal, &iUsed](const AddonInstance* addon) {
     uint64_t iTotalSpace = 0;
     uint64_t iUsedSpace = 0;
     PVR_ERROR error = addon->toAddon->GetDriveSpace(addon, &iTotalSpace, &iUsedSpace);
@@ -570,68 +611,85 @@ PVR_ERROR CPVRClient::GetDriveSpace(uint64_t& iTotal, uint64_t& iUsed)
 
 PVR_ERROR CPVRClient::StartChannelScan()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    return addon->toAddon->OpenDialogChannelScan(addon);
-  }, m_clientCapabilities.SupportsChannelScan());
+  return DoAddonCall(
+      __func__,
+      [](const AddonInstance* addon) { return addon->toAddon->OpenDialogChannelScan(addon); },
+      m_clientCapabilities.SupportsChannelScan());
 }
 
 PVR_ERROR CPVRClient::OpenDialogChannelAdd(const std::shared_ptr<CPVRChannel>& channel)
 {
-  return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
-    PVR_CHANNEL addonChannel;
-    WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->OpenDialogChannelAdd(addon, &addonChannel);
-  }, m_clientCapabilities.SupportsChannelSettings());
+  return DoAddonCall(
+      __func__,
+      [channel](const AddonInstance* addon) {
+        PVR_CHANNEL addonChannel;
+        WriteClientChannelInfo(channel, addonChannel);
+        return addon->toAddon->OpenDialogChannelAdd(addon, &addonChannel);
+      },
+      m_clientCapabilities.SupportsChannelSettings());
 }
 
 PVR_ERROR CPVRClient::OpenDialogChannelSettings(const std::shared_ptr<CPVRChannel>& channel)
 {
-  return DoAddonCall(__FUNCTION__, [channel] (const AddonInstance* addon){
-    PVR_CHANNEL addonChannel;
-    WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->OpenDialogChannelSettings(addon, &addonChannel);
-  }, m_clientCapabilities.SupportsChannelSettings());
+  return DoAddonCall(
+      __func__,
+      [channel](const AddonInstance* addon) {
+        PVR_CHANNEL addonChannel;
+        WriteClientChannelInfo(channel, addonChannel);
+        return addon->toAddon->OpenDialogChannelSettings(addon, &addonChannel);
+      },
+      m_clientCapabilities.SupportsChannelSettings());
 }
 
 PVR_ERROR CPVRClient::DeleteChannel(const std::shared_ptr<CPVRChannel>& channel)
 {
-  return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
-    PVR_CHANNEL addonChannel;
-    WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->DeleteChannel(addon, &addonChannel);
-  }, m_clientCapabilities.SupportsChannelSettings());
+  return DoAddonCall(
+      __func__,
+      [channel](const AddonInstance* addon) {
+        PVR_CHANNEL addonChannel;
+        WriteClientChannelInfo(channel, addonChannel);
+        return addon->toAddon->DeleteChannel(addon, &addonChannel);
+      },
+      m_clientCapabilities.SupportsChannelSettings());
 }
 
 PVR_ERROR CPVRClient::RenameChannel(const std::shared_ptr<CPVRChannel>& channel)
 {
-  return DoAddonCall(__FUNCTION__, [channel](const AddonInstance* addon) {
-    PVR_CHANNEL addonChannel;
-    WriteClientChannelInfo(channel, addonChannel);
-    return addon->toAddon->RenameChannel(addon, &addonChannel);
-  }, m_clientCapabilities.SupportsChannelSettings());
+  return DoAddonCall(
+      __func__,
+      [channel](const AddonInstance* addon) {
+        PVR_CHANNEL addonChannel;
+        WriteClientChannelInfo(channel, addonChannel);
+        return addon->toAddon->RenameChannel(addon, &addonChannel);
+      },
+      m_clientCapabilities.SupportsChannelSettings());
 }
 
 PVR_ERROR CPVRClient::GetEPGForChannel(int iChannelUid, CPVREpg* epg, time_t start, time_t end)
 {
-  return DoAddonCall(__FUNCTION__, [this, iChannelUid, epg, start, end](const AddonInstance* addon) {
-
-    ADDON_HANDLE_STRUCT handle = {0};
-    handle.callerAddress = this;
-    handle.dataAddress = epg;
+  return DoAddonCall(
+      __func__,
+      [this, iChannelUid, epg, start, end](const AddonInstance* addon) {
+        ADDON_HANDLE_STRUCT handle = {0};
+        handle.callerAddress = this;
+        handle.dataAddress = epg;
 
-    int iPVRTimeCorrection = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_iPVRTimeCorrection;
+        int iPVRTimeCorrection =
+            CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_iPVRTimeCorrection;
 
-    return addon->toAddon->GetEPGForChannel(addon, &handle, iChannelUid,
-                                            start ? start - iPVRTimeCorrection : 0,
-                                            end ? end - iPVRTimeCorrection : 0);
-  }, m_clientCapabilities.SupportsEPG());
+        return addon->toAddon->GetEPGForChannel(addon, &handle, iChannelUid,
+                                                start ? start - iPVRTimeCorrection : 0,
+                                                end ? end - iPVRTimeCorrection : 0);
+      },
+      m_clientCapabilities.SupportsEPG());
 }
 
 PVR_ERROR CPVRClient::SetEPGTimeFrame(int iDays)
 {
-  return DoAddonCall(__FUNCTION__, [iDays](const AddonInstance* addon) {
-    return addon->toAddon->SetEPGTimeFrame(addon, iDays);
-  }, m_clientCapabilities.SupportsEPG());
+  return DoAddonCall(
+      __func__,
+      [iDays](const AddonInstance* addon) { return addon->toAddon->SetEPGTimeFrame(addon, iDays); },
+      m_clientCapabilities.SupportsEPG());
 }
 
 // This class wraps an EPG_TAG (PVR Addon API struct) to ensure that the string members of
@@ -644,19 +702,19 @@ class CAddonEpgTag : public EPG_TAG
 {
 public:
   CAddonEpgTag() = delete;
-  explicit CAddonEpgTag(const std::shared_ptr<const CPVREpgInfoTag> kodiTag) :
-    m_strTitle(kodiTag->Title()),
-    m_strPlotOutline(kodiTag->PlotOutline()),
-    m_strPlot(kodiTag->Plot()),
-    m_strOriginalTitle(kodiTag->OriginalTitle()),
-    m_strCast(kodiTag->DeTokenize(kodiTag->Cast())),
-    m_strDirector(kodiTag->DeTokenize(kodiTag->Directors())),
-    m_strWriter(kodiTag->DeTokenize(kodiTag->Writers())),
-    m_strIMDBNumber(kodiTag->IMDBNumber()),
-    m_strEpisodeName(kodiTag->EpisodeName()),
-    m_strIconPath(kodiTag->Icon()),
-    m_strSeriesLink(kodiTag->SeriesLink()),
-    m_strGenreDescription(kodiTag->GetGenresLabel())
+  explicit CAddonEpgTag(const std::shared_ptr<const CPVREpgInfoTag> kodiTag)
+    : m_strTitle(kodiTag->Title()),
+      m_strPlotOutline(kodiTag->PlotOutline()),
+      m_strPlot(kodiTag->Plot()),
+      m_strOriginalTitle(kodiTag->OriginalTitle()),
+      m_strCast(kodiTag->DeTokenize(kodiTag->Cast())),
+      m_strDirector(kodiTag->DeTokenize(kodiTag->Directors())),
+      m_strWriter(kodiTag->DeTokenize(kodiTag->Writers())),
+      m_strIMDBNumber(kodiTag->IMDBNumber()),
+      m_strEpisodeName(kodiTag->EpisodeName()),
+      m_strIconPath(kodiTag->Icon()),
+      m_strSeriesLink(kodiTag->SeriesLink()),
+      m_strGenreDescription(kodiTag->GetGenresLabel())
   {
     time_t t;
     kodiTag->StartAsUTC().GetAsTime(t);
@@ -712,23 +770,33 @@ class CAddonEpgTag : public EPG_TAG
   std::string m_strFirstAired;
 };
 
-PVR_ERROR CPVRClient::IsRecordable(const std::shared_ptr<const CPVREpgInfoTag>& tag, bool& bIsRecordable) const
+PVR_ERROR CPVRClient::IsRecordable(const std::shared_ptr<const CPVREpgInfoTag>& tag,
+                                   bool& bIsRecordable) const
 {
-  return DoAddonCall(__FUNCTION__, [tag, &bIsRecordable](const AddonInstance* addon) {
-    CAddonEpgTag addonTag(tag);
-    return addon->toAddon->IsEPGTagRecordable(addon, &addonTag, &bIsRecordable);
-  }, m_clientCapabilities.SupportsRecordings() && m_clientCapabilities.SupportsEPG());
+  return DoAddonCall(
+      __func__,
+      [tag, &bIsRecordable](const AddonInstance* addon) {
+        CAddonEpgTag addonTag(tag);
+        return addon->toAddon->IsEPGTagRecordable(addon, &addonTag, &bIsRecordable);
+      },
+      m_clientCapabilities.SupportsRecordings() && m_clientCapabilities.SupportsEPG());
 }
 
-PVR_ERROR CPVRClient::IsPlayable(const std::shared_ptr<const CPVREpgInfoTag>& tag, bool& bIsPlayable) const
+PVR_ERROR CPVRClient::IsPlayable(const std::shared_ptr<const CPVREpgInfoTag>& tag,
+                                 bool& bIsPlayable) const
 {
-  return DoAddonCall(__FUNCTION__, [tag, &bIsPlayable](const AddonInstance* addon) {
-    CAddonEpgTag addonTag(tag);
-    return addon->toAddon->IsEPGTagPlayable(addon, &addonTag, &bIsPlayable);
-  }, m_clientCapabilities.SupportsEPG());
+  return DoAddonCall(
+      __func__,
+      [tag, &bIsPlayable](const AddonInstance* addon) {
+        CAddonEpgTag addonTag(tag);
+        return addon->toAddon->IsEPGTagPlayable(addon, &addonTag, &bIsPlayable);
+      },
+      m_clientCapabilities.SupportsEPG());
 }
 
-void CPVRClient::WriteStreamProperties(const PVR_NAMED_VALUE* properties, unsigned int iPropertyCount, CPVRStreamProperties& props)
+void CPVRClient::WriteStreamProperties(const PVR_NAMED_VALUE* properties,
+                                       unsigned int iPropertyCount,
+                                       CPVRStreamProperties& props)
 {
   for (unsigned int i = 0; i < iPropertyCount; ++i)
   {
@@ -736,9 +804,10 @@ void CPVRClient::WriteStreamProperties(const PVR_NAMED_VALUE* properties, unsign
   }
 }
 
-PVR_ERROR CPVRClient::GetEpgTagStreamProperties(const std::shared_ptr<CPVREpgInfoTag>& tag, CPVRStreamProperties& props)
+PVR_ERROR CPVRClient::GetEpgTagStreamProperties(const std::shared_ptr<CPVREpgInfoTag>& tag,
+                                                CPVRStreamProperties& props)
 {
-  return DoAddonCall(__FUNCTION__, [&tag, &props](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&tag, &props](const AddonInstance* addon) {
     CAddonEpgTag addonTag(tag);
 
     unsigned int iPropertyCount = STREAM_MAX_PROPERTY_COUNT;
@@ -747,243 +816,314 @@ PVR_ERROR CPVRClient::GetEpgTagStreamProperties(const std::shared_ptr<CPVREpgInf
 
     PVR_ERROR error = addon->toAddon->GetEPGTagStreamProperties(addon, &addonTag, properties.get(),
                                                                 &iPropertyCount);
-    if (error ==  PVR_ERROR_NO_ERROR)
+    if (error == PVR_ERROR_NO_ERROR)
       WriteStreamProperties(properties.get(), iPropertyCount, props);
 
     return error;
   });
 }
 
-PVR_ERROR CPVRClient::GetEpgTagEdl(const std::shared_ptr<const CPVREpgInfoTag>& epgTag, std::vector<PVR_EDL_ENTRY>& edls)
+PVR_ERROR CPVRClient::GetEpgTagEdl(const std::shared_ptr<const CPVREpgInfoTag>& epgTag,
+                                   std::vector<PVR_EDL_ENTRY>& edls)
 {
   edls.clear();
-  return DoAddonCall(__FUNCTION__, [&epgTag, &edls](const AddonInstance* addon) {
-    CAddonEpgTag addonTag(epgTag);
-
-    PVR_EDL_ENTRY edl_array[PVR_ADDON_EDL_LENGTH];
-    int size = PVR_ADDON_EDL_LENGTH;
-    PVR_ERROR error = addon->toAddon->GetEPGTagEdl(addon, &addonTag, edl_array, &size);
-    if (error == PVR_ERROR_NO_ERROR)
-    {
-      edls.reserve(size);
-      for (int i = 0; i < size; ++i)
-        edls.emplace_back(edl_array[i]);
-    }
-    return error;
-  }, m_clientCapabilities.SupportsEpgTagEdl());
+  return DoAddonCall(
+      __func__,
+      [&epgTag, &edls](const AddonInstance* addon) {
+        CAddonEpgTag addonTag(epgTag);
+
+        PVR_EDL_ENTRY edl_array[PVR_ADDON_EDL_LENGTH];
+        int size = PVR_ADDON_EDL_LENGTH;
+        PVR_ERROR error = addon->toAddon->GetEPGTagEdl(addon, &addonTag, edl_array, &size);
+        if (error == PVR_ERROR_NO_ERROR)
+        {
+          edls.reserve(size);
+          for (int i = 0; i < size; ++i)
+            edls.emplace_back(edl_array[i]);
+        }
+        return error;
+      },
+      m_clientCapabilities.SupportsEpgTagEdl());
 }
 
 PVR_ERROR CPVRClient::GetChannelGroupsAmount(int& iGroups)
 {
   iGroups = -1;
-  return DoAddonCall(__FUNCTION__, [&iGroups](const AddonInstance* addon) {
-    return addon->toAddon->GetChannelGroupsAmount(addon, &iGroups);
-  }, m_clientCapabilities.SupportsChannelGroups());
+  return DoAddonCall(
+      __func__,
+      [&iGroups](const AddonInstance* addon) {
+        return addon->toAddon->GetChannelGroupsAmount(addon, &iGroups);
+      },
+      m_clientCapabilities.SupportsChannelGroups());
 }
 
 PVR_ERROR CPVRClient::GetChannelGroups(CPVRChannelGroups* groups)
 {
-  return DoAddonCall(__FUNCTION__, [this, groups](const AddonInstance* addon) {
-    ADDON_HANDLE_STRUCT handle = {0};
-    handle.callerAddress = this;
-    handle.dataAddress = groups;
-    return addon->toAddon->GetChannelGroups(addon, &handle, groups->IsRadio());
-  }, m_clientCapabilities.SupportsChannelGroups());
+  return DoAddonCall(
+      __func__,
+      [this, groups](const AddonInstance* addon) {
+        ADDON_HANDLE_STRUCT handle = {0};
+        handle.callerAddress = this;
+        handle.dataAddress = groups;
+        return addon->toAddon->GetChannelGroups(addon, &handle, groups->IsRadio());
+      },
+      m_clientCapabilities.SupportsChannelGroups());
 }
 
 PVR_ERROR CPVRClient::GetChannelGroupMembers(CPVRChannelGroup* group)
 {
-  return DoAddonCall(__FUNCTION__, [this, group](const AddonInstance* addon) {
-    ADDON_HANDLE_STRUCT handle = {0};
-    handle.callerAddress = this;
-    handle.dataAddress = group;
+  return DoAddonCall(
+      __func__,
+      [this, group](const AddonInstance* addon) {
+        ADDON_HANDLE_STRUCT handle = {0};
+        handle.callerAddress = this;
+        handle.dataAddress = group;
 
-    PVR_CHANNEL_GROUP tag;
-    WriteClientGroupInfo(*group, tag);
-    return addon->toAddon->GetChannelGroupMembers(addon, &handle, &tag);
-  }, m_clientCapabilities.SupportsChannelGroups());
+        PVR_CHANNEL_GROUP tag;
+        WriteClientGroupInfo(*group, tag);
+        return addon->toAddon->GetChannelGroupMembers(addon, &handle, &tag);
+      },
+      m_clientCapabilities.SupportsChannelGroups());
 }
 
 PVR_ERROR CPVRClient::GetChannelsAmount(int& iChannels)
 {
   iChannels = -1;
-  return DoAddonCall(__FUNCTION__, [&iChannels](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&iChannels](const AddonInstance* addon) {
     return addon->toAddon->GetChannelsAmount(addon, &iChannels);
   });
 }
 
 PVR_ERROR CPVRClient::GetChannels(CPVRChannelGroup& channels, bool radio)
 {
-  return DoAddonCall(__FUNCTION__, [this, &channels, radio](const AddonInstance* addon) {
-    ADDON_HANDLE_STRUCT handle = {0};
-    handle.callerAddress = this;
-    handle.dataAddress = &channels;
-    return addon->toAddon->GetChannels(addon, &handle, radio);
-  }, (radio && m_clientCapabilities.SupportsRadio()) || (!radio && m_clientCapabilities.SupportsTV()));
+  return DoAddonCall(
+      __func__,
+      [this, &channels, radio](const AddonInstance* addon) {
+        ADDON_HANDLE_STRUCT handle = {0};
+        handle.callerAddress = this;
+        handle.dataAddress = &channels;
+        return addon->toAddon->GetChannels(addon, &handle, radio);
+      },
+      (radio && m_clientCapabilities.SupportsRadio()) ||
+          (!radio && m_clientCapabilities.SupportsTV()));
 }
 
 PVR_ERROR CPVRClient::GetRecordingsAmount(bool deleted, int& iRecordings)
 {
   iRecordings = -1;
-  return DoAddonCall(__FUNCTION__, [deleted, &iRecordings](const AddonInstance* addon) {
-    return addon->toAddon->GetRecordingsAmount(addon, deleted, &iRecordings);
-  }, m_clientCapabilities.SupportsRecordings() && (!deleted || m_clientCapabilities.SupportsRecordingsUndelete()));
+  return DoAddonCall(
+      __func__,
+      [deleted, &iRecordings](const AddonInstance* addon) {
+        return addon->toAddon->GetRecordingsAmount(addon, deleted, &iRecordings);
+      },
+      m_clientCapabilities.SupportsRecordings() &&
+          (!deleted || m_clientCapabilities.SupportsRecordingsUndelete()));
 }
 
-PVR_ERROR CPVRClient::GetRecordings(CPVRRecordings *results, bool deleted)
+PVR_ERROR CPVRClient::GetRecordings(CPVRRecordings* results, bool deleted)
 {
-  return DoAddonCall(__FUNCTION__, [this, results, deleted](const AddonInstance* addon)
-  {
-    ADDON_HANDLE_STRUCT handle = {0};
-    handle.callerAddress = this;
-    handle.dataAddress = results;
-    return addon->toAddon->GetRecordings(addon, &handle, deleted);
-  }, m_clientCapabilities.SupportsRecordings() && (!deleted || m_clientCapabilities.SupportsRecordingsUndelete()));
+  return DoAddonCall(
+      __func__,
+      [this, results, deleted](const AddonInstance* addon) {
+        ADDON_HANDLE_STRUCT handle = {0};
+        handle.callerAddress = this;
+        handle.dataAddress = results;
+        return addon->toAddon->GetRecordings(addon, &handle, deleted);
+      },
+      m_clientCapabilities.SupportsRecordings() &&
+          (!deleted || m_clientCapabilities.SupportsRecordingsUndelete()));
 }
 
 PVR_ERROR CPVRClient::DeleteRecording(const CPVRRecording& recording)
 {
-  return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->DeleteRecording(addon, &tag);
-  }, m_clientCapabilities.SupportsRecordings());
+  return DoAddonCall(
+      __func__,
+      [&recording](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+        return addon->toAddon->DeleteRecording(addon, &tag);
+      },
+      m_clientCapabilities.SupportsRecordings());
 }
 
 PVR_ERROR CPVRClient::UndeleteRecording(const CPVRRecording& recording)
 {
-  return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->UndeleteRecording(addon, &tag);
-  }, m_clientCapabilities.SupportsRecordingsUndelete());
+  return DoAddonCall(
+      __func__,
+      [&recording](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+        return addon->toAddon->UndeleteRecording(addon, &tag);
+      },
+      m_clientCapabilities.SupportsRecordingsUndelete());
 }
 
 PVR_ERROR CPVRClient::DeleteAllRecordingsFromTrash()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    return addon->toAddon->DeleteAllRecordingsFromTrash(addon);
-  }, m_clientCapabilities.SupportsRecordingsUndelete());
+  return DoAddonCall(
+      __func__,
+      [](const AddonInstance* addon) {
+        return addon->toAddon->DeleteAllRecordingsFromTrash(addon);
+      },
+      m_clientCapabilities.SupportsRecordingsUndelete());
 }
 
 PVR_ERROR CPVRClient::RenameRecording(const CPVRRecording& recording)
 {
-  return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->RenameRecording(addon, &tag);
-  }, m_clientCapabilities.SupportsRecordings());
+  return DoAddonCall(
+      __func__,
+      [&recording](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+        return addon->toAddon->RenameRecording(addon, &tag);
+      },
+      m_clientCapabilities.SupportsRecordings());
 }
 
 PVR_ERROR CPVRClient::SetRecordingLifetime(const CPVRRecording& recording)
 {
-  return DoAddonCall(__FUNCTION__, [&recording](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->SetRecordingLifetime(addon, &tag);
-  }, m_clientCapabilities.SupportsRecordingsLifetimeChange());
+  return DoAddonCall(
+      __func__,
+      [&recording](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+        return addon->toAddon->SetRecordingLifetime(addon, &tag);
+      },
+      m_clientCapabilities.SupportsRecordingsLifetimeChange());
 }
 
 PVR_ERROR CPVRClient::SetRecordingPlayCount(const CPVRRecording& recording, int count)
 {
-  return DoAddonCall(__FUNCTION__, [&recording, count](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->SetRecordingPlayCount(addon, &tag, count);
-  }, m_clientCapabilities.SupportsRecordingsPlayCount());
+  return DoAddonCall(
+      __func__,
+      [&recording, count](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+        return addon->toAddon->SetRecordingPlayCount(addon, &tag, count);
+      },
+      m_clientCapabilities.SupportsRecordingsPlayCount());
 }
 
-PVR_ERROR CPVRClient::SetRecordingLastPlayedPosition(const CPVRRecording& recording, int lastplayedposition)
+PVR_ERROR CPVRClient::SetRecordingLastPlayedPosition(const CPVRRecording& recording,
+                                                     int lastplayedposition)
 {
-  return DoAddonCall(__FUNCTION__, [&recording, lastplayedposition](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->SetRecordingLastPlayedPosition(addon, &tag, lastplayedposition);
-  }, m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
- }
+  return DoAddonCall(
+      __func__,
+      [&recording, lastplayedposition](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+        return addon->toAddon->SetRecordingLastPlayedPosition(addon, &tag, lastplayedposition);
+      },
+      m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
+}
 
 PVR_ERROR CPVRClient::GetRecordingLastPlayedPosition(const CPVRRecording& recording, int& iPosition)
 {
   iPosition = -1;
-  return DoAddonCall(__FUNCTION__, [&recording, &iPosition](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->GetRecordingLastPlayedPosition(addon, &tag, &iPosition);
-  }, m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
+  return DoAddonCall(
+      __func__,
+      [&recording, &iPosition](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+        return addon->toAddon->GetRecordingLastPlayedPosition(addon, &tag, &iPosition);
+      },
+      m_clientCapabilities.SupportsRecordingsLastPlayedPosition());
 }
 
-PVR_ERROR CPVRClient::GetRecordingEdl(const CPVRRecording& recording, std::vector<PVR_EDL_ENTRY>& edls)
+PVR_ERROR CPVRClient::GetRecordingEdl(const CPVRRecording& recording,
+                                      std::vector<PVR_EDL_ENTRY>& edls)
 {
   edls.clear();
-  return DoAddonCall(__FUNCTION__, [&recording, &edls](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-
-    PVR_EDL_ENTRY edl_array[PVR_ADDON_EDL_LENGTH];
-    int size = PVR_ADDON_EDL_LENGTH;
-    PVR_ERROR error = addon->toAddon->GetRecordingEdl(addon, &tag, edl_array, &size);
-    if (error == PVR_ERROR_NO_ERROR)
-    {
-      edls.reserve(size);
-      for (int i = 0; i < size; ++i)
-        edls.emplace_back(edl_array[i]);
-    }
-    return error;
-  }, m_clientCapabilities.SupportsRecordingsEdl());
+  return DoAddonCall(
+      __func__,
+      [&recording, &edls](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+
+        PVR_EDL_ENTRY edl_array[PVR_ADDON_EDL_LENGTH];
+        int size = PVR_ADDON_EDL_LENGTH;
+        PVR_ERROR error = addon->toAddon->GetRecordingEdl(addon, &tag, edl_array, &size);
+        if (error == PVR_ERROR_NO_ERROR)
+        {
+          edls.reserve(size);
+          for (int i = 0; i < size; ++i)
+            edls.emplace_back(edl_array[i]);
+        }
+        return error;
+      },
+      m_clientCapabilities.SupportsRecordingsEdl());
 }
 
 PVR_ERROR CPVRClient::GetRecordingSize(const CPVRRecording& recording, int64_t& sizeInBytes)
 {
-  return DoAddonCall(__FUNCTION__, [&recording, &sizeInBytes](const AddonInstance* addon) {
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(recording, tag);
-    return addon->toAddon->GetRecordingSize(addon, &tag, &sizeInBytes);
-  }, m_clientCapabilities.SupportsRecordingsSize());
+  return DoAddonCall(
+      __func__,
+      [&recording, &sizeInBytes](const AddonInstance* addon) {
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(recording, tag);
+        return addon->toAddon->GetRecordingSize(addon, &tag, &sizeInBytes);
+      },
+      m_clientCapabilities.SupportsRecordingsSize());
 }
 
 PVR_ERROR CPVRClient::GetTimersAmount(int& iTimers)
 {
   iTimers = -1;
-  return DoAddonCall(__FUNCTION__, [&iTimers](const AddonInstance* addon) {
-    return addon->toAddon->GetTimersAmount(addon, &iTimers);
-  }, m_clientCapabilities.SupportsTimers());
+  return DoAddonCall(
+      __func__,
+      [&iTimers](const AddonInstance* addon) {
+        return addon->toAddon->GetTimersAmount(addon, &iTimers);
+      },
+      m_clientCapabilities.SupportsTimers());
 }
 
 PVR_ERROR CPVRClient::GetTimers(CPVRTimersContainer* results)
 {
-  return DoAddonCall(__FUNCTION__, [this, results](const AddonInstance* addon) {
-    ADDON_HANDLE_STRUCT handle = {0};
-    handle.callerAddress = this;
-    handle.dataAddress = results;
-    return addon->toAddon->GetTimers(addon, &handle);
-  }, m_clientCapabilities.SupportsTimers());
+  return DoAddonCall(
+      __func__,
+      [this, results](const AddonInstance* addon) {
+        ADDON_HANDLE_STRUCT handle = {0};
+        handle.callerAddress = this;
+        handle.dataAddress = results;
+        return addon->toAddon->GetTimers(addon, &handle);
+      },
+      m_clientCapabilities.SupportsTimers());
 }
 
 PVR_ERROR CPVRClient::AddTimer(const CPVRTimerInfoTag& timer)
 {
-  return DoAddonCall(__FUNCTION__, [&timer](const AddonInstance* addon) {
-    PVR_TIMER tag;
-    WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->AddTimer(addon, &tag);
-  }, m_clientCapabilities.SupportsTimers());
+  return DoAddonCall(
+      __func__,
+      [&timer](const AddonInstance* addon) {
+        PVR_TIMER tag;
+        WriteClientTimerInfo(timer, tag);
+        return addon->toAddon->AddTimer(addon, &tag);
+      },
+      m_clientCapabilities.SupportsTimers());
 }
 
 PVR_ERROR CPVRClient::DeleteTimer(const CPVRTimerInfoTag& timer, bool bForce /* = false */)
 {
-  return DoAddonCall(__FUNCTION__, [&timer, bForce](const AddonInstance* addon) {
-    PVR_TIMER tag;
-    WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->DeleteTimer(addon, &tag, bForce);
-  }, m_clientCapabilities.SupportsTimers());
+  return DoAddonCall(
+      __func__,
+      [&timer, bForce](const AddonInstance* addon) {
+        PVR_TIMER tag;
+        WriteClientTimerInfo(timer, tag);
+        return addon->toAddon->DeleteTimer(addon, &tag, bForce);
+      },
+      m_clientCapabilities.SupportsTimers());
 }
 
 PVR_ERROR CPVRClient::UpdateTimer(const CPVRTimerInfoTag& timer)
 {
-  return DoAddonCall(__FUNCTION__, [&timer](const AddonInstance* addon) {
-    PVR_TIMER tag;
-    WriteClientTimerInfo(timer, tag);
-    return addon->toAddon->UpdateTimer(addon, &tag);
-  }, m_clientCapabilities.SupportsTimers());
+  return DoAddonCall(
+      __func__,
+      [&timer](const AddonInstance* addon) {
+        PVR_TIMER tag;
+        WriteClientTimerInfo(timer, tag);
+        return addon->toAddon->UpdateTimer(addon, &tag);
+      },
+      m_clientCapabilities.SupportsTimers());
 }
 
 PVR_ERROR CPVRClient::GetTimerTypes(std::vector<std::shared_ptr<CPVRTimerType>>& results) const
@@ -995,15 +1135,18 @@ PVR_ERROR CPVRClient::GetTimerTypes(std::vector<std::shared_ptr<CPVRTimerType>>&
 
 PVR_ERROR CPVRClient::GetStreamReadChunkSize(int& iChunkSize)
 {
-  return DoAddonCall(__FUNCTION__, [&iChunkSize](const AddonInstance* addon) {
-    return addon->toAddon->GetStreamReadChunkSize(addon, &iChunkSize);
-  }, m_clientCapabilities.SupportsRecordings() || m_clientCapabilities.HandlesInputStream());
+  return DoAddonCall(
+      __func__,
+      [&iChunkSize](const AddonInstance* addon) {
+        return addon->toAddon->GetStreamReadChunkSize(addon, &iChunkSize);
+      },
+      m_clientCapabilities.SupportsRecordings() || m_clientCapabilities.HandlesInputStream());
 }
 
 PVR_ERROR CPVRClient::ReadLiveStream(void* lpBuf, int64_t uiBufSize, int& iRead)
 {
   iRead = -1;
-  return DoAddonCall(__FUNCTION__, [&lpBuf, uiBufSize, &iRead](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&lpBuf, uiBufSize, &iRead](const AddonInstance* addon) {
     iRead = addon->toAddon->ReadLiveStream(addon, static_cast<unsigned char*>(lpBuf),
                                            static_cast<int>(uiBufSize));
     return (iRead == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
@@ -1013,7 +1156,7 @@ PVR_ERROR CPVRClient::ReadLiveStream(void* lpBuf, int64_t uiBufSize, int& iRead)
 PVR_ERROR CPVRClient::ReadRecordedStream(void* lpBuf, int64_t uiBufSize, int& iRead)
 {
   iRead = -1;
-  return DoAddonCall(__FUNCTION__, [&lpBuf, uiBufSize, &iRead](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&lpBuf, uiBufSize, &iRead](const AddonInstance* addon) {
     iRead = addon->toAddon->ReadRecordedStream(addon, static_cast<unsigned char*>(lpBuf),
                                                static_cast<int>(uiBufSize));
     return (iRead == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
@@ -1023,7 +1166,7 @@ PVR_ERROR CPVRClient::ReadRecordedStream(void* lpBuf, int64_t uiBufSize, int& iR
 PVR_ERROR CPVRClient::SeekLiveStream(int64_t iFilePosition, int iWhence, int64_t& iPosition)
 {
   iPosition = -1;
-  return DoAddonCall(__FUNCTION__, [iFilePosition, iWhence, &iPosition](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [iFilePosition, iWhence, &iPosition](const AddonInstance* addon) {
     iPosition = addon->toAddon->SeekLiveStream(addon, iFilePosition, iWhence);
     return (iPosition == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
@@ -1032,7 +1175,7 @@ PVR_ERROR CPVRClient::SeekLiveStream(int64_t iFilePosition, int iWhence, int64_t
 PVR_ERROR CPVRClient::SeekRecordedStream(int64_t iFilePosition, int iWhence, int64_t& iPosition)
 {
   iPosition = -1;
-  return DoAddonCall(__FUNCTION__, [iFilePosition, iWhence, &iPosition](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [iFilePosition, iWhence, &iPosition](const AddonInstance* addon) {
     iPosition = addon->toAddon->SeekRecordedStream(addon, iFilePosition, iWhence);
     return (iPosition == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
@@ -1040,7 +1183,7 @@ PVR_ERROR CPVRClient::SeekRecordedStream(int64_t iFilePosition, int iWhence, int
 
 PVR_ERROR CPVRClient::SeekTime(double time, bool backwards, double* startpts)
 {
-  return DoAddonCall(__FUNCTION__, [time, backwards, &startpts](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [time, backwards, &startpts](const AddonInstance* addon) {
     return addon->toAddon->SeekTime(addon, time, backwards, startpts) ? PVR_ERROR_NO_ERROR
                                                                       : PVR_ERROR_NOT_IMPLEMENTED;
   });
@@ -1049,7 +1192,7 @@ PVR_ERROR CPVRClient::SeekTime(double time, bool backwards, double* startpts)
 PVR_ERROR CPVRClient::GetLiveStreamLength(int64_t& iLength)
 {
   iLength = -1;
-  return DoAddonCall(__FUNCTION__, [&iLength](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&iLength](const AddonInstance* addon) {
     iLength = addon->toAddon->LengthLiveStream(addon);
     return (iLength == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
@@ -1058,7 +1201,7 @@ PVR_ERROR CPVRClient::GetLiveStreamLength(int64_t& iLength)
 PVR_ERROR CPVRClient::GetRecordedStreamLength(int64_t& iLength)
 {
   iLength = -1;
-  return DoAddonCall(__FUNCTION__, [&iLength](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&iLength](const AddonInstance* addon) {
     iLength = addon->toAddon->LengthRecordedStream(addon);
     return (iLength == -1) ? PVR_ERROR_NOT_IMPLEMENTED : PVR_ERROR_NO_ERROR;
   });
@@ -1066,21 +1209,25 @@ PVR_ERROR CPVRClient::GetRecordedStreamLength(int64_t& iLength)
 
 PVR_ERROR CPVRClient::SignalQuality(int channelUid, PVR_SIGNAL_STATUS& qualityinfo)
 {
-  return DoAddonCall(__FUNCTION__, [channelUid, &qualityinfo](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [channelUid, &qualityinfo](const AddonInstance* addon) {
     return addon->toAddon->GetSignalStatus(addon, channelUid, &qualityinfo);
   });
 }
 
 PVR_ERROR CPVRClient::GetDescrambleInfo(int channelUid, PVR_DESCRAMBLE_INFO& descrambleinfo) const
 {
-  return DoAddonCall(__FUNCTION__, [channelUid, &descrambleinfo](const AddonInstance* addon) {
-    return addon->toAddon->GetDescrambleInfo(addon, channelUid, &descrambleinfo);
-  }, m_clientCapabilities.SupportsDescrambleInfo());
+  return DoAddonCall(
+      __func__,
+      [channelUid, &descrambleinfo](const AddonInstance* addon) {
+        return addon->toAddon->GetDescrambleInfo(addon, channelUid, &descrambleinfo);
+      },
+      m_clientCapabilities.SupportsDescrambleInfo());
 }
 
-PVR_ERROR CPVRClient::GetChannelStreamProperties(const std::shared_ptr<CPVRChannel>& channel, CPVRStreamProperties& props)
+PVR_ERROR CPVRClient::GetChannelStreamProperties(const std::shared_ptr<CPVRChannel>& channel,
+                                                 CPVRStreamProperties& props)
 {
-  return DoAddonCall(__FUNCTION__, [this, &channel, &props](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [this, &channel, &props](const AddonInstance* addon) {
     if (!CanPlayChannel(channel))
       return PVR_ERROR_NO_ERROR; // no error, but no need to obtain the values from the addon
 
@@ -1100,9 +1247,10 @@ PVR_ERROR CPVRClient::GetChannelStreamProperties(const std::shared_ptr<CPVRChann
   });
 }
 
-PVR_ERROR CPVRClient::GetRecordingStreamProperties(const std::shared_ptr<CPVRRecording>& recording, CPVRStreamProperties& props)
+PVR_ERROR CPVRClient::GetRecordingStreamProperties(const std::shared_ptr<CPVRRecording>& recording,
+                                                   CPVRStreamProperties& props)
 {
-  return DoAddonCall(__FUNCTION__, [this, &recording, &props](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [this, &recording, &props](const AddonInstance* addon) {
     if (!m_clientCapabilities.SupportsRecordings())
       return PVR_ERROR_NO_ERROR; // no error, but no need to obtain the values from the addon
 
@@ -1113,8 +1261,8 @@ PVR_ERROR CPVRClient::GetRecordingStreamProperties(const std::shared_ptr<CPVRRec
     std::unique_ptr<PVR_NAMED_VALUE[]> properties(new PVR_NAMED_VALUE[iPropertyCount]);
     memset(properties.get(), 0, iPropertyCount * sizeof(PVR_NAMED_VALUE));
 
-    PVR_ERROR error =
-        addon->toAddon->GetRecordingStreamProperties(addon, &tag, properties.get(), &iPropertyCount);
+    PVR_ERROR error = addon->toAddon->GetRecordingStreamProperties(addon, &tag, properties.get(),
+                                                                   &iPropertyCount);
     if (error == PVR_ERROR_NO_ERROR)
       WriteStreamProperties(properties.get(), iPropertyCount, props);
 
@@ -1124,72 +1272,87 @@ PVR_ERROR CPVRClient::GetRecordingStreamProperties(const std::shared_ptr<CPVRRec
 
 PVR_ERROR CPVRClient::GetStreamProperties(PVR_STREAM_PROPERTIES* props)
 {
-  return DoAddonCall(__FUNCTION__, [&props](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&props](const AddonInstance* addon) {
     return addon->toAddon->GetStreamProperties(addon, props);
   });
 }
 
 PVR_ERROR CPVRClient::DemuxReset()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->DemuxReset(addon);
-    return PVR_ERROR_NO_ERROR;
-  }, m_clientCapabilities.HandlesDemuxing());
+  return DoAddonCall(
+      __func__,
+      [](const AddonInstance* addon) {
+        addon->toAddon->DemuxReset(addon);
+        return PVR_ERROR_NO_ERROR;
+      },
+      m_clientCapabilities.HandlesDemuxing());
 }
 
 PVR_ERROR CPVRClient::DemuxAbort()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->DemuxAbort(addon);
-    return PVR_ERROR_NO_ERROR;
-  }, m_clientCapabilities.HandlesDemuxing());
+  return DoAddonCall(
+      __func__,
+      [](const AddonInstance* addon) {
+        addon->toAddon->DemuxAbort(addon);
+        return PVR_ERROR_NO_ERROR;
+      },
+      m_clientCapabilities.HandlesDemuxing());
 }
 
 PVR_ERROR CPVRClient::DemuxFlush()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    addon->toAddon->DemuxFlush(addon);
-    return PVR_ERROR_NO_ERROR;
-  }, m_clientCapabilities.HandlesDemuxing());
+  return DoAddonCall(
+      __func__,
+      [](const AddonInstance* addon) {
+        addon->toAddon->DemuxFlush(addon);
+        return PVR_ERROR_NO_ERROR;
+      },
+      m_clientCapabilities.HandlesDemuxing());
 }
 
-PVR_ERROR CPVRClient::DemuxRead(DemuxPacket* &packet)
+PVR_ERROR CPVRClient::DemuxRead(DemuxPacket*& packet)
 {
-  return DoAddonCall(__FUNCTION__, [&packet](const AddonInstance* addon) {
-    packet = addon->toAddon->DemuxRead(addon);
-    return packet ? PVR_ERROR_NO_ERROR : PVR_ERROR_NOT_IMPLEMENTED;
-  }, m_clientCapabilities.HandlesDemuxing());
+  return DoAddonCall(
+      __func__,
+      [&packet](const AddonInstance* addon) {
+        packet = addon->toAddon->DemuxRead(addon);
+        return packet ? PVR_ERROR_NO_ERROR : PVR_ERROR_NOT_IMPLEMENTED;
+      },
+      m_clientCapabilities.HandlesDemuxing());
 }
 
 const char* CPVRClient::ToString(const PVR_ERROR error)
 {
   switch (error)
   {
-  case PVR_ERROR_NO_ERROR:
-    return "no error";
-  case PVR_ERROR_NOT_IMPLEMENTED:
-    return "not implemented";
-  case PVR_ERROR_SERVER_ERROR:
-    return "server error";
-  case PVR_ERROR_SERVER_TIMEOUT:
-    return "server timeout";
-  case PVR_ERROR_RECORDING_RUNNING:
-    return "recording already running";
-  case PVR_ERROR_ALREADY_PRESENT:
-    return "already present";
-  case PVR_ERROR_REJECTED:
-    return "rejected by the backend";
-  case PVR_ERROR_INVALID_PARAMETERS:
-    return "invalid parameters for this method";
-  case PVR_ERROR_FAILED:
-    return "the command failed";
-  case PVR_ERROR_UNKNOWN:
-  default:
-    return "unknown error";
+    case PVR_ERROR_NO_ERROR:
+      return "no error";
+    case PVR_ERROR_NOT_IMPLEMENTED:
+      return "not implemented";
+    case PVR_ERROR_SERVER_ERROR:
+      return "server error";
+    case PVR_ERROR_SERVER_TIMEOUT:
+      return "server timeout";
+    case PVR_ERROR_RECORDING_RUNNING:
+      return "recording already running";
+    case PVR_ERROR_ALREADY_PRESENT:
+      return "already present";
+    case PVR_ERROR_REJECTED:
+      return "rejected by the backend";
+    case PVR_ERROR_INVALID_PARAMETERS:
+      return "invalid parameters for this method";
+    case PVR_ERROR_FAILED:
+      return "the command failed";
+    case PVR_ERROR_UNKNOWN:
+    default:
+      return "unknown error";
   }
 }
 
-PVR_ERROR CPVRClient::DoAddonCall(const char* strFunctionName, std::function<PVR_ERROR(const AddonInstance*)> function, bool bIsImplemented /* = true */, bool bCheckReadyToUse /* = true */) const
+PVR_ERROR CPVRClient::DoAddonCall(const char* strFunctionName,
+                                  std::function<PVR_ERROR(const AddonInstance*)> function,
+                                  bool bIsImplemented /* = true */,
+                                  bool bCheckReadyToUse /* = true */) const
 {
   // Check preconditions.
   if (!bIsImplemented)
@@ -1206,16 +1369,16 @@ PVR_ERROR CPVRClient::DoAddonCall(const char* strFunctionName, std::function<PVR
 
   // Log error, if any.
   if (error != PVR_ERROR_NO_ERROR && error != PVR_ERROR_NOT_IMPLEMENTED)
-    CLog::LogFunction(LOGERROR, strFunctionName, "Add-on '%s' returned an error: %s", GetFriendlyName().c_str(), ToString(error));
+    CLog::LogFunction(LOGERROR, strFunctionName, "Add-on '%s' returned an error: %s",
+                      GetFriendlyName().c_str(), ToString(error));
 
   return error;
 }
 
 bool CPVRClient::CanPlayChannel(const std::shared_ptr<CPVRChannel>& channel) const
 {
-  return (m_bReadyToUse &&
-           ((m_clientCapabilities.SupportsTV() && !channel->IsRadio()) ||
-            (m_clientCapabilities.SupportsRadio() && channel->IsRadio())));
+  return (m_bReadyToUse && ((m_clientCapabilities.SupportsTV() && !channel->IsRadio()) ||
+                            (m_clientCapabilities.SupportsRadio() && channel->IsRadio())));
 }
 
 PVR_ERROR CPVRClient::OpenLiveStream(const std::shared_ptr<CPVRChannel>& channel)
@@ -1223,17 +1386,19 @@ PVR_ERROR CPVRClient::OpenLiveStream(const std::shared_ptr<CPVRChannel>& channel
   if (!channel)
     return PVR_ERROR_INVALID_PARAMETERS;
 
-  return DoAddonCall(__FUNCTION__, [this, channel](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [this, channel](const AddonInstance* addon) {
     CloseLiveStream();
 
     if (!CanPlayChannel(channel))
     {
-      CLog::LogFC(LOGDEBUG, LOGPVR, "Add-on '%s' can not play channel '%s'", GetFriendlyName().c_str(), channel->ChannelName().c_str());
+      CLog::LogFC(LOGDEBUG, LOGPVR, "Add-on '%s' can not play channel '%s'",
+                  GetFriendlyName().c_str(), channel->ChannelName().c_str());
       return PVR_ERROR_SERVER_ERROR;
     }
     else
     {
-      CLog::LogFC(LOGDEBUG, LOGPVR, "Opening live stream for channel '%s'", channel->ChannelName().c_str());
+      CLog::LogFC(LOGDEBUG, LOGPVR, "Opening live stream for channel '%s'",
+                  channel->ChannelName().c_str());
       PVR_CHANNEL tag;
       WriteClientChannelInfo(channel, tag);
       return addon->toAddon->OpenLiveStream(addon, &tag) ? PVR_ERROR_NO_ERROR
@@ -1247,20 +1412,24 @@ PVR_ERROR CPVRClient::OpenRecordedStream(const std::shared_ptr<CPVRRecording>& r
   if (!recording)
     return PVR_ERROR_INVALID_PARAMETERS;
 
-  return DoAddonCall(__FUNCTION__, [this, recording](const AddonInstance* addon) {
-    CloseRecordedStream();
+  return DoAddonCall(
+      __func__,
+      [this, recording](const AddonInstance* addon) {
+        CloseRecordedStream();
 
-    PVR_RECORDING tag;
-    WriteClientRecordingInfo(*recording, tag);
-    CLog::LogFC(LOGDEBUG, LOGPVR, "Opening stream for recording '%s'", recording->m_strTitle.c_str());
-    return addon->toAddon->OpenRecordedStream(addon, &tag) ? PVR_ERROR_NO_ERROR
-                                                           : PVR_ERROR_NOT_IMPLEMENTED;
-  }, m_clientCapabilities.SupportsRecordings());
+        PVR_RECORDING tag;
+        WriteClientRecordingInfo(*recording, tag);
+        CLog::LogFC(LOGDEBUG, LOGPVR, "Opening stream for recording '%s'",
+                    recording->m_strTitle.c_str());
+        return addon->toAddon->OpenRecordedStream(addon, &tag) ? PVR_ERROR_NO_ERROR
+                                                               : PVR_ERROR_NOT_IMPLEMENTED;
+      },
+      m_clientCapabilities.SupportsRecordings());
 }
 
 PVR_ERROR CPVRClient::CloseLiveStream()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [](const AddonInstance* addon) {
     addon->toAddon->CloseLiveStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
@@ -1268,7 +1437,7 @@ PVR_ERROR CPVRClient::CloseLiveStream()
 
 PVR_ERROR CPVRClient::CloseRecordedStream()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [](const AddonInstance* addon) {
     addon->toAddon->CloseRecordedStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
@@ -1276,7 +1445,7 @@ PVR_ERROR CPVRClient::CloseRecordedStream()
 
 PVR_ERROR CPVRClient::PauseStream(bool bPaused)
 {
-  return DoAddonCall(__FUNCTION__, [bPaused](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [bPaused](const AddonInstance* addon) {
     addon->toAddon->PauseStream(addon, bPaused);
     return PVR_ERROR_NO_ERROR;
   });
@@ -1284,7 +1453,7 @@ PVR_ERROR CPVRClient::PauseStream(bool bPaused)
 
 PVR_ERROR CPVRClient::SetSpeed(int speed)
 {
-  return DoAddonCall(__FUNCTION__, [speed](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [speed](const AddonInstance* addon) {
     addon->toAddon->SetSpeed(addon, speed);
     return PVR_ERROR_NO_ERROR;
   });
@@ -1292,7 +1461,7 @@ PVR_ERROR CPVRClient::SetSpeed(int speed)
 
 PVR_ERROR CPVRClient::FillBuffer(bool mode)
 {
-  return DoAddonCall(__FUNCTION__, [mode](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [mode](const AddonInstance* addon) {
     addon->toAddon->FillBuffer(addon, mode);
     return PVR_ERROR_NO_ERROR;
   });
@@ -1301,7 +1470,7 @@ PVR_ERROR CPVRClient::FillBuffer(bool mode)
 PVR_ERROR CPVRClient::CanPauseStream(bool& bCanPause) const
 {
   bCanPause = false;
-  return DoAddonCall(__FUNCTION__, [&bCanPause](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&bCanPause](const AddonInstance* addon) {
     bCanPause = addon->toAddon->CanPauseStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
@@ -1310,7 +1479,7 @@ PVR_ERROR CPVRClient::CanPauseStream(bool& bCanPause) const
 PVR_ERROR CPVRClient::CanSeekStream(bool& bCanSeek) const
 {
   bCanSeek = false;
-  return DoAddonCall(__FUNCTION__, [&bCanSeek](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&bCanSeek](const AddonInstance* addon) {
     bCanSeek = addon->toAddon->CanSeekStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
@@ -1318,7 +1487,7 @@ PVR_ERROR CPVRClient::CanSeekStream(bool& bCanSeek) const
 
 PVR_ERROR CPVRClient::GetStreamTimes(PVR_STREAM_TIMES* times)
 {
-  return DoAddonCall(__FUNCTION__, [&times](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&times](const AddonInstance* addon) {
     return addon->toAddon->GetStreamTimes(addon, times);
   });
 }
@@ -1326,7 +1495,7 @@ PVR_ERROR CPVRClient::GetStreamTimes(PVR_STREAM_TIMES* times)
 PVR_ERROR CPVRClient::IsRealTimeStream(bool& bRealTime) const
 {
   bRealTime = false;
-  return DoAddonCall(__FUNCTION__, [&bRealTime](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&bRealTime](const AddonInstance* addon) {
     bRealTime = addon->toAddon->IsRealTimeStream(addon);
     return PVR_ERROR_NO_ERROR;
   });
@@ -1334,28 +1503,26 @@ PVR_ERROR CPVRClient::IsRealTimeStream(bool& bRealTime) const
 
 PVR_ERROR CPVRClient::OnSystemSleep()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    return addon->toAddon->OnSystemSleep(addon);
-  });
+  return DoAddonCall(
+      __func__, [](const AddonInstance* addon) { return addon->toAddon->OnSystemSleep(addon); });
 }
 
 PVR_ERROR CPVRClient::OnSystemWake()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
-    return addon->toAddon->OnSystemWake(addon);
-  });
+  return DoAddonCall(
+      __func__, [](const AddonInstance* addon) { return addon->toAddon->OnSystemWake(addon); });
 }
 
 PVR_ERROR CPVRClient::OnPowerSavingActivated()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [](const AddonInstance* addon) {
     return addon->toAddon->OnPowerSavingActivated(addon);
   });
 }
 
 PVR_ERROR CPVRClient::OnPowerSavingDeactivated()
 {
-  return DoAddonCall(__FUNCTION__, [](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [](const AddonInstance* addon) {
     return addon->toAddon->OnPowerSavingDeactivated(addon);
   });
 }
@@ -1368,9 +1535,10 @@ std::shared_ptr<CPVRClientMenuHooks> CPVRClient::GetMenuHooks()
   return m_menuhooks;
 }
 
-PVR_ERROR CPVRClient::CallEpgTagMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVREpgInfoTag>& tag)
+PVR_ERROR CPVRClient::CallEpgTagMenuHook(const CPVRClientMenuHook& hook,
+                                         const std::shared_ptr<CPVREpgInfoTag>& tag)
 {
-  return DoAddonCall(__FUNCTION__, [&hook, &tag](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&hook, &tag](const AddonInstance* addon) {
     CAddonEpgTag addonTag(tag);
 
     PVR_MENUHOOK menuHook;
@@ -1382,9 +1550,10 @@ PVR_ERROR CPVRClient::CallEpgTagMenuHook(const CPVRClientMenuHook& hook, const s
   });
 }
 
-PVR_ERROR CPVRClient::CallChannelMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRChannel>& channel)
+PVR_ERROR CPVRClient::CallChannelMenuHook(const CPVRClientMenuHook& hook,
+                                          const std::shared_ptr<CPVRChannel>& channel)
 {
-  return DoAddonCall(__FUNCTION__, [&hook, &channel](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&hook, &channel](const AddonInstance* addon) {
     PVR_CHANNEL tag;
     WriteClientChannelInfo(channel, tag);
 
@@ -1397,9 +1566,11 @@ PVR_ERROR CPVRClient::CallChannelMenuHook(const CPVRClientMenuHook& hook, const
   });
 }
 
-PVR_ERROR CPVRClient::CallRecordingMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRRecording>& recording, bool bDeleted)
+PVR_ERROR CPVRClient::CallRecordingMenuHook(const CPVRClientMenuHook& hook,
+                                            const std::shared_ptr<CPVRRecording>& recording,
+                                            bool bDeleted)
 {
-  return DoAddonCall(__FUNCTION__, [&hook, &recording, &bDeleted](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&hook, &recording, &bDeleted](const AddonInstance* addon) {
     PVR_RECORDING tag;
     WriteClientRecordingInfo(*recording, tag);
 
@@ -1412,9 +1583,10 @@ PVR_ERROR CPVRClient::CallRecordingMenuHook(const CPVRClientMenuHook& hook, cons
   });
 }
 
-PVR_ERROR CPVRClient::CallTimerMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRTimerInfoTag>& timer)
+PVR_ERROR CPVRClient::CallTimerMenuHook(const CPVRClientMenuHook& hook,
+                                        const std::shared_ptr<CPVRTimerInfoTag>& timer)
 {
-  return DoAddonCall(__FUNCTION__, [&hook, &timer](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&hook, &timer](const AddonInstance* addon) {
     PVR_TIMER tag;
     WriteClientTimerInfo(*timer, tag);
 
@@ -1429,7 +1601,7 @@ PVR_ERROR CPVRClient::CallTimerMenuHook(const CPVRClientMenuHook& hook, const st
 
 PVR_ERROR CPVRClient::CallSettingsMenuHook(const CPVRClientMenuHook& hook)
 {
-  return DoAddonCall(__FUNCTION__, [&hook](const AddonInstance* addon) {
+  return DoAddonCall(__func__, [&hook](const AddonInstance* addon) {
     PVR_MENUHOOK menuHook;
     menuHook.category = PVR_MENUHOOK_SETTING;
     menuHook.iHookId = hook.GetId();
@@ -1464,7 +1636,9 @@ int CPVRClient::GetPriority() const
   return m_iPriority;
 }
 
-void CPVRClient::cb_transfer_channel_group(void* kodiInstance, const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP* group)
+void CPVRClient::cb_transfer_channel_group(void* kodiInstance,
+                                           const ADDON_HANDLE handle,
+                                           const PVR_CHANNEL_GROUP* group)
 {
   if (!handle)
   {
@@ -1472,7 +1646,7 @@ void CPVRClient::cb_transfer_channel_group(void* kodiInstance, const ADDON_HANDL
     return;
   }
 
-  CPVRChannelGroups* kodiGroups = static_cast<CPVRChannelGroups *>(handle->dataAddress);
+  CPVRChannelGroups* kodiGroups = static_cast<CPVRChannelGroups*>(handle->dataAddress);
   if (!group || !kodiGroups)
   {
     CLog::LogF(LOGERROR, "Invalid handler data");
@@ -1490,7 +1664,9 @@ void CPVRClient::cb_transfer_channel_group(void* kodiInstance, const ADDON_HANDL
   kodiGroups->UpdateFromClient(transferGroup);
 }
 
-void CPVRClient::cb_transfer_channel_group_member(void* kodiInstance, const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP_MEMBER* member)
+void CPVRClient::cb_transfer_channel_group_member(void* kodiInstance,
+                                                  const ADDON_HANDLE handle,
+                                                  const PVR_CHANNEL_GROUP_MEMBER* member)
 {
   if (!handle)
   {
@@ -1506,19 +1682,25 @@ void CPVRClient::cb_transfer_channel_group_member(void* kodiInstance, const ADDO
     return;
   }
 
-  std::shared_ptr<CPVRChannel> channel = CServiceBroker::GetPVRManager().ChannelGroups()->GetByUniqueID(member->iChannelUniqueId, client->GetID());
+  std::shared_ptr<CPVRChannel> channel =
+      CServiceBroker::GetPVRManager().ChannelGroups()->GetByUniqueID(member->iChannelUniqueId,
+                                                                     client->GetID());
   if (!channel)
   {
-    CLog::LogF(LOGERROR, "Cannot find group '%s' or channel '%d'", member->strGroupName, member->iChannelUniqueId);
+    CLog::LogF(LOGERROR, "Cannot find group '%s' or channel '%d'", member->strGroupName,
+               member->iChannelUniqueId);
   }
   else if (group->IsRadio() == channel->IsRadio())
   {
     /* transfer this entry to the group */
-    group->AddToGroup(channel, CPVRChannelNumber(), member->iOrder, true, CPVRChannelNumber(member->iChannelNumber, member->iSubChannelNumber));
+    group->AddToGroup(channel, CPVRChannelNumber(), member->iOrder, true,
+                      CPVRChannelNumber(member->iChannelNumber, member->iSubChannelNumber));
   }
 }
 
-void CPVRClient::cb_transfer_epg_entry(void* kodiInstance, const ADDON_HANDLE handle, const EPG_TAG* epgentry)
+void CPVRClient::cb_transfer_epg_entry(void* kodiInstance,
+                                       const ADDON_HANDLE handle,
+                                       const EPG_TAG* epgentry)
 {
   if (!handle)
   {
@@ -1538,7 +1720,9 @@ void CPVRClient::cb_transfer_epg_entry(void* kodiInstance, const ADDON_HANDLE ha
   kodiEpg->UpdateEntry(epgentry, client->GetID());
 }
 
-void CPVRClient::cb_transfer_channel_entry(void* kodiInstance, const ADDON_HANDLE handle, const PVR_CHANNEL* channel)
+void CPVRClient::cb_transfer_channel_entry(void* kodiInstance,
+                                           const ADDON_HANDLE handle,
+                                           const PVR_CHANNEL* channel)
 {
   if (!handle)
   {
@@ -1547,7 +1731,8 @@ void CPVRClient::cb_transfer_channel_entry(void* kodiInstance, const ADDON_HANDL
   }
 
   CPVRClient* client = static_cast<CPVRClient*>(kodiInstance);
-  CPVRChannelGroupInternal* kodiChannels = static_cast<CPVRChannelGroupInternal*>(handle->dataAddress);
+  CPVRChannelGroupInternal* kodiChannels =
+      static_cast<CPVRChannelGroupInternal*>(handle->dataAddress);
   if (!channel || !client || !kodiChannels)
   {
     CLog::LogF(LOGERROR, "Invalid handler data");
@@ -1556,10 +1741,13 @@ void CPVRClient::cb_transfer_channel_entry(void* kodiInstance, const ADDON_HANDL
 
   /* transfer this entry to the internal channels group */
   std::shared_ptr<CPVRChannel> transferChannel(new CPVRChannel(*channel, client->GetID()));
-  kodiChannels->UpdateFromClient(transferChannel, CPVRChannelNumber(), channel->iOrder, transferChannel->ClientChannelNumber());
+  kodiChannels->UpdateFromClient(transferChannel, CPVRChannelNumber(), channel->iOrder,
+                                 transferChannel->ClientChannelNumber());
 }
 
-void CPVRClient::cb_transfer_recording_entry(void* kodiInstance, const ADDON_HANDLE handle, const PVR_RECORDING* recording)
+void CPVRClient::cb_transfer_recording_entry(void* kodiInstance,
+                                             const ADDON_HANDLE handle,
+                                             const PVR_RECORDING* recording)
 {
   if (!handle)
   {
@@ -1580,7 +1768,9 @@ void CPVRClient::cb_transfer_recording_entry(void* kodiInstance, const ADDON_HAN
   kodiRecordings->UpdateFromClient(transferRecording);
 }
 
-void CPVRClient::cb_transfer_timer_entry(void* kodiInstance, const ADDON_HANDLE handle, const PVR_TIMER* timer)
+void CPVRClient::cb_transfer_timer_entry(void* kodiInstance,
+                                         const ADDON_HANDLE handle,
+                                         const PVR_TIMER* timer)
 {
   if (!handle)
   {
@@ -1597,10 +1787,13 @@ void CPVRClient::cb_transfer_timer_entry(void* kodiInstance, const ADDON_HANDLE
   }
 
   /* Note: channel can be NULL here, for instance for epg-based timer rules ("record on any channel" condition). */
-  std::shared_ptr<CPVRChannel> channel = CServiceBroker::GetPVRManager().ChannelGroups()->GetByUniqueID(timer->iClientChannelUid, client->GetID());
+  std::shared_ptr<CPVRChannel> channel =
+      CServiceBroker::GetPVRManager().ChannelGroups()->GetByUniqueID(timer->iClientChannelUid,
+                                                                     client->GetID());
 
   /* transfer this entry to the timers container */
-  std::shared_ptr<CPVRTimerInfoTag> transferTimer(new CPVRTimerInfoTag(*timer, channel, client->GetID()));
+  std::shared_ptr<CPVRTimerInfoTag> transferTimer(
+      new CPVRTimerInfoTag(*timer, channel, client->GetID()));
   kodiTimers->UpdateFromClient(transferTimer);
 }
 
@@ -1628,7 +1821,8 @@ void CPVRClient::cb_recording_notification(void* kodiInstance,
     return;
   }
 
-  std::string strLine1 = StringUtils::Format(g_localizeStrings.Get(bOnOff ? 19197 : 19198).c_str(), client->Name().c_str());
+  std::string strLine1 = StringUtils::Format(g_localizeStrings.Get(bOnOff ? 19197 : 19198).c_str(),
+                                             client->Name().c_str());
   std::string strLine2;
   if (strName)
     strLine2 = strName;
@@ -1637,7 +1831,8 @@ void CPVRClient::cb_recording_notification(void* kodiInstance,
 
   /* display a notification for 5 seconds */
   CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, strLine1, strLine2, 5000, false);
-  CServiceBroker::GetEventLog().Add(EventPtr(new CNotificationEvent(client->Name(), strLine1, client->Icon(), strLine2)));
+  CServiceBroker::GetEventLog().Add(
+      EventPtr(new CNotificationEvent(client->Name(), strLine1, client->Icon(), strLine2)));
 
   CLog::LogFC(LOGDEBUG, LOGPVR, "Recording %s on client '%s'. name='%s' filename='%s'",
               bOnOff ? "started" : "finished", client->Name().c_str(), strName, strFileName);
@@ -1689,7 +1884,10 @@ DemuxPacket* CPVRClient::cb_allocate_demux_packet(void* kodiInstance, int iDataS
   return CDVDDemuxUtils::AllocateDemuxPacket(iDataSize);
 }
 
-void CPVRClient::cb_connection_state_change(void* kodiInstance, const char* strConnectionString, PVR_CONNECTION_STATE newState, const char* strMessage)
+void CPVRClient::cb_connection_state_change(void* kodiInstance,
+                                            const char* strConnectionString,
+                                            PVR_CONNECTION_STATE newState,
+                                            const char* strMessage)
 {
   CPVRClient* client = static_cast<CPVRClient*>(kodiInstance);
   if (!client || !strConnectionString)
@@ -1702,7 +1900,9 @@ void CPVRClient::cb_connection_state_change(void* kodiInstance, const char* strC
   if (prevState == newState)
     return;
 
-  CLog::LogFC(LOGDEBUG, LOGPVR, "State for connection '%s' on client '%s' changed from '%d' to '%d'", strConnectionString, client->Name().c_str(), prevState, newState);
+  CLog::LogFC(LOGDEBUG, LOGPVR,
+              "State for connection '%s' on client '%s' changed from '%d' to '%d'",
+              strConnectionString, client->Name().c_str(), prevState, newState);
 
   client->SetConnectionState(newState);
 
@@ -1710,10 +1910,13 @@ void CPVRClient::cb_connection_state_change(void* kodiInstance, const char* strC
   if (strMessage != nullptr)
     msg = strMessage;
 
-  CServiceBroker::GetPVRManager().ConnectionStateChange(client, std::string(strConnectionString), newState, msg);
+  CServiceBroker::GetPVRManager().ConnectionStateChange(client, std::string(strConnectionString),
+                                                        newState, msg);
 }
 
-void CPVRClient::cb_epg_event_state_change(void* kodiInstance, EPG_TAG* tag, EPG_EVENT_STATE newState)
+void CPVRClient::cb_epg_event_state_change(void* kodiInstance,
+                                           EPG_TAG* tag,
+                                           EPG_EVENT_STATE newState)
 {
   CPVRClient* client = static_cast<CPVRClient*>(kodiInstance);
   if (!client || !tag)
@@ -1723,7 +1926,8 @@ void CPVRClient::cb_epg_event_state_change(void* kodiInstance, EPG_TAG* tag, EPG
   }
 
   // Note: channel data and epg id may not yet be available. Tag will be fully initialized later.
-  const std::shared_ptr<CPVREpgInfoTag> epgTag = std::make_shared<CPVREpgInfoTag>(*tag, client->GetID(), nullptr, -1);
+  const std::shared_ptr<CPVREpgInfoTag> epgTag =
+      std::make_shared<CPVREpgInfoTag>(*tag, client->GetID(), nullptr, -1);
   CServiceBroker::GetPVRManager().EpgContainer().UpdateFromClient(epgTag, newState);
 }
 
@@ -1801,7 +2005,7 @@ CPVRClientCapabilities::CPVRClientCapabilities(const CPVRClientCapabilities& oth
   InitRecordingsLifetimeValues();
 }
 
-const CPVRClientCapabilities& CPVRClientCapabilities::operator =(const CPVRClientCapabilities& other)
+const CPVRClientCapabilities& CPVRClientCapabilities::operator=(const CPVRClientCapabilities& other)
 {
   if (other.m_addonCapabilities)
     m_addonCapabilities.reset(new PVR_ADDON_CAPABILITIES(*other.m_addonCapabilities));
@@ -1809,7 +2013,8 @@ const CPVRClientCapabilities& CPVRClientCapabilities::operator =(const CPVRClien
   return *this;
 }
 
-const CPVRClientCapabilities& CPVRClientCapabilities::operator =(const PVR_ADDON_CAPABILITIES& addonCapabilities)
+const CPVRClientCapabilities& CPVRClientCapabilities::operator=(
+    const PVR_ADDON_CAPABILITIES& addonCapabilities)
 {
   m_addonCapabilities.reset(new PVR_ADDON_CAPABILITIES(addonCapabilities));
   InitRecordingsLifetimeValues();
@@ -1844,8 +2049,9 @@ void CPVRClientCapabilities::InitRecordingsLifetimeValues()
     // No values given by addon, but lifetime supported. Use default values 1..365
     for (int i = 1; i < 366; ++i)
     {
-      m_recordingsLifetimeValues.emplace_back(StringUtils::Format(g_localizeStrings.Get(17999).c_str(), i),
-                                              i); // "%s days"
+      m_recordingsLifetimeValues.emplace_back(
+          StringUtils::Format(g_localizeStrings.Get(17999).c_str(), i),
+          i); // "%s days"
     }
   }
   else
@@ -1854,10 +2060,11 @@ void CPVRClientCapabilities::InitRecordingsLifetimeValues()
   }
 }
 
-void CPVRClientCapabilities::GetRecordingsLifetimeValues(std::vector<std::pair<std::string, int>>& list) const
+void CPVRClientCapabilities::GetRecordingsLifetimeValues(
+    std::vector<std::pair<std::string, int>>& list) const
 {
   for (const auto& lifetime : m_recordingsLifetimeValues)
     list.push_back(lifetime);
 }
 
-}
+} // namespace PVR
diff --git a/xbmc/pvr/addons/PVRClient.h b/xbmc/pvr/addons/PVRClient.h
index 8f69092c0797..34ba567cdab6 100644
--- a/xbmc/pvr/addons/PVRClient.h
+++ b/xbmc/pvr/addons/PVRClient.h
@@ -20,1134 +20,1231 @@
 
 namespace PVR
 {
-  class CPVRChannel;
-  class CPVRChannelGroup;
-  class CPVRChannelGroups;
-  class CPVRClientMenuHook;
-  class CPVRClientMenuHooks;
-  class CPVREpg;
-  class CPVREpgInfoTag;
-  class CPVRRecording;
-  class CPVRRecordings;
-  class CPVRStreamProperties;
-  class CPVRTimerInfoTag;
-  class CPVRTimerType;
-  class CPVRTimersContainer;
-
-  #define PVR_INVALID_CLIENT_ID (-2)
-
-  class CPVRClientCapabilities
+class CPVRChannel;
+class CPVRChannelGroup;
+class CPVRChannelGroups;
+class CPVRClientMenuHook;
+class CPVRClientMenuHooks;
+class CPVREpg;
+class CPVREpgInfoTag;
+class CPVRRecording;
+class CPVRRecordings;
+class CPVRStreamProperties;
+class CPVRTimerInfoTag;
+class CPVRTimerType;
+class CPVRTimersContainer;
+
+#define PVR_INVALID_CLIENT_ID (-2)
+
+class CPVRClientCapabilities
+{
+public:
+  CPVRClientCapabilities() = default;
+  virtual ~CPVRClientCapabilities() = default;
+
+  CPVRClientCapabilities(const CPVRClientCapabilities& other);
+  const CPVRClientCapabilities& operator=(const CPVRClientCapabilities& other);
+
+  const CPVRClientCapabilities& operator=(const PVR_ADDON_CAPABILITIES& addonCapabilities);
+
+  void clear();
+
+  /////////////////////////////////////////////////////////////////////////////////
+  //
+  // Channels
+  //
+  /////////////////////////////////////////////////////////////////////////////////
+
+  /*!
+   * @brief Check whether this add-on supports TV channels.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsTV() const { return m_addonCapabilities && m_addonCapabilities->bSupportsTV; }
+
+  /*!
+   * @brief Check whether this add-on supports radio channels.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsRadio() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRadio; }
+
+  /*!
+   * @brief Check whether this add-on supports channel groups.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsChannelGroups() const
   {
-  public:
-    CPVRClientCapabilities() = default;
-    virtual ~CPVRClientCapabilities() = default;
-
-    CPVRClientCapabilities(const CPVRClientCapabilities& other);
-    const CPVRClientCapabilities& operator =(const CPVRClientCapabilities& other);
-
-    const CPVRClientCapabilities& operator =(const PVR_ADDON_CAPABILITIES& addonCapabilities);
-
-    void clear();
-
-    /////////////////////////////////////////////////////////////////////////////////
-    //
-    // Channels
-    //
-    /////////////////////////////////////////////////////////////////////////////////
-
-    /*!
-     * @brief Check whether this add-on supports TV channels.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsTV() const { return m_addonCapabilities && m_addonCapabilities->bSupportsTV; }
-
-    /*!
-     * @brief Check whether this add-on supports radio channels.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRadio() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRadio; }
-
-    /*!
-     * @brief Check whether this add-on supports channel groups.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsChannelGroups() const { return m_addonCapabilities && m_addonCapabilities->bSupportsChannelGroups; }
-
-    /*!
-     * @brief Check whether this add-on supports scanning for new channels on the backend.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsChannelScan() const { return m_addonCapabilities && m_addonCapabilities->bSupportsChannelScan; }
-
-    /*!
-     * @brief Check whether this add-on supports the following functions: DeleteChannel, RenameChannel, DialogChannelSettings and DialogAddChannel.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsChannelSettings() const { return m_addonCapabilities && m_addonCapabilities->bSupportsChannelSettings; }
-
-    /*!
-     * @brief Check whether this add-on supports descramble information for playing channels.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsDescrambleInfo() const { return m_addonCapabilities && m_addonCapabilities->bSupportsDescrambleInfo; }
-
-    /////////////////////////////////////////////////////////////////////////////////
-    //
-    // EPG
-    //
-    /////////////////////////////////////////////////////////////////////////////////
-
-    /*!
-     * @brief Check whether this add-on provides EPG information.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsEPG() const { return m_addonCapabilities && m_addonCapabilities->bSupportsEPG; }
-
-    /*!
-     * @brief Check whether this add-on supports asynchronous transfer of epg events.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsAsyncEPGTransfer() const { return m_addonCapabilities && m_addonCapabilities->bSupportsAsyncEPGTransfer; }
-
-    /////////////////////////////////////////////////////////////////////////////////
-    //
-    // Timers
-    //
-    /////////////////////////////////////////////////////////////////////////////////
-
-    /*!
-     * @brief Check whether this add-on supports the creation and editing of timers.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsTimers() const { return m_addonCapabilities && m_addonCapabilities->bSupportsTimers; }
-
-    /////////////////////////////////////////////////////////////////////////////////
-    //
-    // Recordings
-    //
-    /////////////////////////////////////////////////////////////////////////////////
-
-    /*!
-     * @brief Check whether this add-on supports recordings.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRecordings() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings; }
-
-    /*!
-     * @brief Check whether this add-on supports undelete of deleted recordings.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRecordingsUndelete() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings && m_addonCapabilities->bSupportsRecordingsUndelete; }
-
-    /*!
-     * @brief Check whether this add-on supports play count for recordings.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRecordingsPlayCount() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings && m_addonCapabilities->bSupportsRecordingPlayCount; }
-
-    /*!
-     * @brief Check whether this add-on supports store/retrieve of last played position for recordings..
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRecordingsLastPlayedPosition() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings && m_addonCapabilities->bSupportsLastPlayedPosition; }
-
-    /*!
-     * @brief Check whether this add-on supports retrieving an edit decision list for recordings.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRecordingsEdl() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings && m_addonCapabilities->bSupportsRecordingEdl; }
-
-    /*!
-     * @brief Check whether this add-on supports retrieving an edit decision list for epg tags.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsEpgTagEdl() const { return m_addonCapabilities && m_addonCapabilities->bSupportsEPG && m_addonCapabilities->bSupportsEPGEdl; }
-
-    /*!
-     * @brief Check whether this add-on supports renaming recordings..
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRecordingsRename() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings && m_addonCapabilities->bSupportsRecordingsRename; }
-
-    /*!
-     * @brief Check whether this add-on supports changing lifetime of recording.
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRecordingsLifetimeChange() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings && m_addonCapabilities->bSupportsRecordingsLifetimeChange; }
-
-    /*!
-     * @brief Obtain a list with all possible values for recordings lifetime.
-     * @param list out, the list with the values or an empty list, if lifetime is not supported.
-     */
-    void GetRecordingsLifetimeValues(std::vector<std::pair<std::string, int>>& list) const;
-
-    /*!
-     * @brief Check whether this add-on supports retrieving the size recordings..
-     * @return True if supported, false otherwise.
-     */
-    bool SupportsRecordingsSize() const
-    {
-      return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings &&
-             m_addonCapabilities->bSupportsRecordingSize;
-    }
-
-    /////////////////////////////////////////////////////////////////////////////////
-    //
-    // Streams
-    //
-    /////////////////////////////////////////////////////////////////////////////////
-
-    /*!
-     * @brief Check whether this add-on provides an input stream. false if Kodi handles the stream.
-     * @return True if supported, false otherwise.
-     */
-    bool HandlesInputStream() const { return m_addonCapabilities && m_addonCapabilities->bHandlesInputStream; }
-
-    /*!
-     * @brief Check whether this add-on demultiplexes packets.
-     * @return True if supported, false otherwise.
-     */
-    bool HandlesDemuxing() const { return m_addonCapabilities && m_addonCapabilities->bHandlesDemuxing; }
-
-  private:
-    void InitRecordingsLifetimeValues();
-
-    std::unique_ptr<PVR_ADDON_CAPABILITIES> m_addonCapabilities;
-    std::vector<std::pair<std::string, int>> m_recordingsLifetimeValues;
-  };
-
-  /*!
-   * Interface from Kodi to a PVR add-on.
+    return m_addonCapabilities && m_addonCapabilities->bSupportsChannelGroups;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports scanning for new channels on the backend.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsChannelScan() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsChannelScan;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports the following functions:
+   * DeleteChannel, RenameChannel, DialogChannelSettings and DialogAddChannel.
    *
-   * Also translates Kodi's C++ structures to the add-on's C structures.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsChannelSettings() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsChannelSettings;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports descramble information for playing channels.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsDescrambleInfo() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsDescrambleInfo;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////////
+  //
+  // EPG
+  //
+  /////////////////////////////////////////////////////////////////////////////////
+
+  /*!
+   * @brief Check whether this add-on provides EPG information.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsEPG() const { return m_addonCapabilities && m_addonCapabilities->bSupportsEPG; }
+
+  /*!
+   * @brief Check whether this add-on supports asynchronous transfer of epg events.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsAsyncEPGTransfer() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsAsyncEPGTransfer;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////////
+  //
+  // Timers
+  //
+  /////////////////////////////////////////////////////////////////////////////////
+
+  /*!
+   * @brief Check whether this add-on supports the creation and editing of timers.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsTimers() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsTimers;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////////
+  //
+  // Recordings
+  //
+  /////////////////////////////////////////////////////////////////////////////////
+
+  /*!
+   * @brief Check whether this add-on supports recordings.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsRecordings() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports undelete of deleted recordings.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsRecordingsUndelete() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings &&
+           m_addonCapabilities->bSupportsRecordingsUndelete;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports play count for recordings.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsRecordingsPlayCount() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings &&
+           m_addonCapabilities->bSupportsRecordingPlayCount;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports store/retrieve of last played position for recordings..
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsRecordingsLastPlayedPosition() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings &&
+           m_addonCapabilities->bSupportsLastPlayedPosition;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports retrieving an edit decision list for recordings.
+   * @return True if supported, false otherwise.
    */
-  class CPVRClient : public ADDON::IAddonInstanceHandler
+  bool SupportsRecordingsEdl() const
   {
-  public:
-    explicit CPVRClient(ADDON::BinaryAddonBasePtr addonBase);
-    ~CPVRClient() override;
-
-    void OnPreInstall() override;
-    void OnPreUnInstall() override;
-
-    /** @name PVR add-on methods */
-    //@{
-
-    /*!
-     * @brief Initialise the instance of this add-on.
-     * @param iClientId The ID of this add-on.
-     */
-    ADDON_STATUS Create(int iClientId);
-
-    /*!
-     * @brief Stop this add-on instance. No more client add-on access after this call.
-     */
-    void Stop();
-
-    /*!
-     * @brief Continue this add-on instance. Client add-on access is okay again after this call.
-     */
-    void Continue();
-
-    /*!
-     * @brief Destroy the instance of this add-on.
-     */
-    void Destroy();
-
-    /*!
-     * @brief Destroy and recreate this add-on.
-     */
-    void ReCreate();
-
-    /*!
-     * @return True if this instance is initialised (ADDON_Create returned true), false otherwise.
-     */
-    bool ReadyToUse() const;
-
-    /*!
-     * @brief Gets the backend connection state.
-     * @return the backend connection state.
-     */
-    PVR_CONNECTION_STATE GetConnectionState() const;
-
-    /*!
-     * @brief Sets the backend connection state.
-     * @param state the new backend connection state.
-     */
-    void SetConnectionState(PVR_CONNECTION_STATE state);
-
-    /*!
-     * @brief Gets the backend's previous connection state.
-     * @return the backend's previous connection state.
-     */
-    PVR_CONNECTION_STATE GetPreviousConnectionState() const;
-
-    /*!
-     * @brief signal to PVRManager this client should be ignored
-     * @return true if this client should be ignored
-     */
-    bool IgnoreClient() const;
-
-    /*!
-     * @return The ID of this instance.
-     */
-    int GetID() const;
-
-    //@}
-    /** @name PVR server methods */
-    //@{
-
-    /*!
-     * @brief Query this add-on's capabilities.
-     * @return The add-on's capabilities.
-     */
-    const CPVRClientCapabilities& GetClientCapabilities() const { return m_clientCapabilities; }
-
-    /*!
-     * @brief Get the stream properties of the stream that's currently being read.
-     * @param pProperties The properties.
-     * @return PVR_ERROR_NO_ERROR if the properties have been fetched successfully.
-     */
-    PVR_ERROR GetStreamProperties(PVR_STREAM_PROPERTIES* pProperties);
-
-    /*!
-     * @return The name reported by the backend.
-     */
-    const std::string& GetBackendName() const;
-
-    /*!
-     * @return The version string reported by the backend.
-     */
-    const std::string& GetBackendVersion() const;
-
-    /*!
-     * @brief the ip address or alias of the pvr backend server
-     */
-    const std::string& GetBackendHostname() const;
-
-    /*!
-     * @return The connection string reported by the backend.
-     */
-    const std::string& GetConnectionString() const;
-
-    /*!
-     * @return A friendly name for this add-on that can be used in log messages.
-     */
-    const std::string& GetFriendlyName() const;
-
-    /*!
-     * @brief Get the disk space reported by the server.
-     * @param iTotal The total disk space.
-     * @param iUsed The used disk space.
-     * @return PVR_ERROR_NO_ERROR if the drive space has been fetched successfully.
-     */
-    PVR_ERROR GetDriveSpace(uint64_t& iTotal, uint64_t& iUsed);
-
-    /*!
-     * @brief Start a channel scan on the server.
-     * @return PVR_ERROR_NO_ERROR if the channel scan has been started successfully.
-     */
-    PVR_ERROR StartChannelScan();
-
-    /*!
-     * @brief Request the client to open dialog about given channel to add
-     * @param channel The channel to add
-     * @return PVR_ERROR_NO_ERROR if the add has been fetched successfully.
-     */
-    PVR_ERROR OpenDialogChannelAdd(const std::shared_ptr<CPVRChannel>& channel);
-
-    /*!
-     * @brief Request the client to open dialog about given channel settings
-     * @param channel The channel to edit
-     * @return PVR_ERROR_NO_ERROR if the edit has been fetched successfully.
-     */
-    PVR_ERROR OpenDialogChannelSettings(const std::shared_ptr<CPVRChannel>& channel);
-
-    /*!
-     * @brief Request the client to delete given channel
-     * @param channel The channel to delete
-     * @return PVR_ERROR_NO_ERROR if the delete has been fetched successfully.
-     */
-    PVR_ERROR DeleteChannel(const std::shared_ptr<CPVRChannel>& channel);
-
-    /*!
-     * @brief Request the client to rename given channel
-     * @param channel The channel to rename
-     * @return PVR_ERROR_NO_ERROR if the rename has been fetched successfully.
-     */
-    PVR_ERROR RenameChannel(const std::shared_ptr<CPVRChannel>& channel);
-
-    /*
-     * @brief Check if an epg tag can be recorded
-     * @param tag The epg tag
-     * @param bIsRecordable Set to true if the tag can be recorded
-     * @return PVR_ERROR_NO_ERROR if bIsRecordable has been set successfully.
-     */
-    PVR_ERROR IsRecordable(const std::shared_ptr<const CPVREpgInfoTag>& tag, bool& bIsRecordable) const;
-
-    /*
-     * @brief Check if an epg tag can be played
-     * @param tag The epg tag
-     * @param bIsPlayable Set to true if the tag can be played
-     * @return PVR_ERROR_NO_ERROR if bIsPlayable has been set successfully.
-     */
-    PVR_ERROR IsPlayable(const std::shared_ptr<const CPVREpgInfoTag>& tag, bool& bIsPlayable) const;
-
-    /*!
-     * @brief Fill the given container with the properties required for playback of the given EPG tag. Values are obtained from the PVR backend.
-     * @param tag The EPG tag.
-     * @param props The container to be filled with the stream properties.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetEpgTagStreamProperties(const std::shared_ptr<CPVREpgInfoTag>& tag, CPVRStreamProperties& props);
-
-    //@}
-    /** @name PVR EPG methods */
-    //@{
-
-    /*!
-     * @brief Request an EPG table for a channel from the client.
-     * @param iChannelUid The UID of the channel to get the EPG table for.
-     * @param epg The table to write the data to.
-     * @param start The start time to use.
-     * @param end The end time to use.
-     * @return PVR_ERROR_NO_ERROR if the table has been fetched successfully.
-     */
-    PVR_ERROR GetEPGForChannel(int iChannelUid, CPVREpg* epg, time_t start, time_t end);
-
-    /*!
-     * Tell the client the time frame to use when notifying epg events back to Kodi. The client might push epg events asynchronously
-     * to Kodi using the callback function EpgEventStateChange. To be able to only push events that are actually of interest for Kodi,
-     * client needs to know about the epg time frame Kodi uses.
-     * @param iDays number of days from "now". EPG_TIMEFRAME_UNLIMITED means that Kodi is interested in all epg events, regardless of event times.
-     * @return PVR_ERROR_NO_ERROR if new value was successfully set.
-     */
-    PVR_ERROR SetEPGTimeFrame(int iDays);
-
-    //@}
-    /** @name PVR channel group methods */
-    //@{
-
-    /*!
-     * @brief Get the total amount of channel groups from the backend.
-     * @param iGroups The total amount of channel groups on the server or -1 on error.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetChannelGroupsAmount(int& iGroups);
-
-    /*!
-     * @brief Request the list of all channel groups from the backend.
-     * @param groups The groups container to get the groups for.
-     * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-     */
-    PVR_ERROR GetChannelGroups(CPVRChannelGroups* groups);
-
-    /*!
-     * @brief Request the list of all group members from the backend.
-     * @param group The group to get the members for.
-     * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-     */
-    PVR_ERROR GetChannelGroupMembers(CPVRChannelGroup* group);
-
-    //@}
-    /** @name PVR channel methods */
-    //@{
-
-    /*!
-     * @brief Get the total amount of channels from the backend.
-     * @param iChannels The total amount of channels on the server or -1 on error.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetChannelsAmount(int& iChannels);
-
-    /*!
-     * @brief Request the list of all channels from the backend.
-     * @param channels The channel group to add the channels to.
-     * @param bRadio True to get the radio channels, false to get the TV channels.
-     * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-     */
-    PVR_ERROR GetChannels(CPVRChannelGroup& channels, bool bRadio);
-
-    //@}
-    /** @name PVR recording methods */
-    //@{
-
-    /*!
-     * @brief Get the total amount of recordings from the backend.
-     * @param deleted True to return deleted recordings.
-     * @param iRecordings The total amount of recordings on the server or -1 on error.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetRecordingsAmount(bool deleted, int& iRecordings);
-
-    /*!
-     * @brief Request the list of all recordings from the backend.
-     * @param results The container to add the recordings to.
-     * @param deleted True to return deleted recordings.
-     * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-     */
-    PVR_ERROR GetRecordings(CPVRRecordings* results, bool deleted);
-
-    /*!
-     * @brief Delete a recording on the backend.
-     * @param recording The recording to delete.
-     * @return PVR_ERROR_NO_ERROR if the recording has been deleted successfully.
-     */
-    PVR_ERROR DeleteRecording(const CPVRRecording& recording);
-
-    /*!
-     * @brief Undelete a recording on the backend.
-     * @param recording The recording to undelete.
-     * @return PVR_ERROR_NO_ERROR if the recording has been undeleted successfully.
-     */
-    PVR_ERROR UndeleteRecording(const CPVRRecording& recording);
-
-    /*!
-     * @brief Delete all recordings permanent which in the deleted folder on the backend.
-     * @return PVR_ERROR_NO_ERROR if the recordings has been deleted successfully.
-     */
-    PVR_ERROR DeleteAllRecordingsFromTrash();
-
-    /*!
-     * @brief Rename a recording on the backend.
-     * @param recording The recording to rename.
-     * @return PVR_ERROR_NO_ERROR if the recording has been renamed successfully.
-     */
-    PVR_ERROR RenameRecording(const CPVRRecording& recording);
-
-    /*!
-     * @brief Set the lifetime of a recording on the backend.
-     * @param recording The recording to set the lifetime for. recording.m_iLifetime contains the new lifetime value.
-     * @return PVR_ERROR_NO_ERROR if the recording's lifetime has been set successfully.
-     */
-    PVR_ERROR SetRecordingLifetime(const CPVRRecording& recording);
-
-    /*!
-     * @brief Set the play count of a recording on the backend.
-     * @param recording The recording to set the play count.
-     * @param count Play count.
-     * @return PVR_ERROR_NO_ERROR if the recording's play count has been set successfully.
-     */
-    PVR_ERROR SetRecordingPlayCount(const CPVRRecording& recording, int count);
-
-    /*!
-    * @brief Set the last watched position of a recording on the backend.
-    * @param recording The recording.
-    * @param lastplayedposition The last watched position in seconds
-    * @return PVR_ERROR_NO_ERROR if the position has been stored successfully.
-    */
-    PVR_ERROR SetRecordingLastPlayedPosition(const CPVRRecording& recording, int lastplayedposition);
-
-    /*!
-    * @brief Retrieve the last watched position of a recording on the backend.
-    * @param recording The recording.
-    * @param iPosition The last watched position in seconds or -1 on error
-    * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-    */
-    PVR_ERROR GetRecordingLastPlayedPosition(const CPVRRecording& recording, int& iPosition);
-
-    /*!
-    * @brief Retrieve the edit decision list (EDL) from the backend.
-    * @param recording The recording.
-    * @param edls The edit decision list (empty on error).
-    * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-    */
-    PVR_ERROR GetRecordingEdl(const CPVRRecording& recording, std::vector<PVR_EDL_ENTRY>& edls);
-
-    /*!
-    * @brief Retrieve the size of a recording on the backend.
-    * @param recording The recording.
-    * @param sizeInBytes The size in bytes
-    * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-    */
-    PVR_ERROR GetRecordingSize(const CPVRRecording& recording, int64_t& sizeInBytes);
-
-    /*!
-    * @brief Retrieve the edit decision list (EDL) from the backend.
-    * @param epgTag The EPG tag.
-    * @param edls The edit decision list (empty on error).
-    * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-    */
-    PVR_ERROR GetEpgTagEdl(const std::shared_ptr<const CPVREpgInfoTag>& epgTag, std::vector<PVR_EDL_ENTRY>& edls);
-
-    //@}
-    /** @name PVR timer methods */
-    //@{
-
-    /*!
-     * @brief Get the total amount of timers from the backend.
-     * @param iTimers The total amount of timers on the backend or -1 on error.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetTimersAmount(int& iTimers);
-
-    /*!
-     * @brief Request the list of all timers from the backend.
-     * @param results The container to store the result in.
-     * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-     */
-    PVR_ERROR GetTimers(CPVRTimersContainer* results);
-
-    /*!
-     * @brief Add a timer on the backend.
-     * @param timer The timer to add.
-     * @return PVR_ERROR_NO_ERROR if the timer has been added successfully.
-     */
-    PVR_ERROR AddTimer(const CPVRTimerInfoTag& timer);
-
-    /*!
-     * @brief Delete a timer on the backend.
-     * @param timer The timer to delete.
-     * @param bForce Set to true to delete a timer that is currently recording a program.
-     * @return PVR_ERROR_NO_ERROR if the timer has been deleted successfully.
-     */
-    PVR_ERROR DeleteTimer(const CPVRTimerInfoTag& timer, bool bForce = false);
-
-    /*!
-     * @brief Update the timer information on the server.
-     * @param timer The timer to update.
-     * @return PVR_ERROR_NO_ERROR if the timer has been updated successfully.
-     */
-    PVR_ERROR UpdateTimer(const CPVRTimerInfoTag& timer);
-
-    /*!
-     * @brief Get all timer types supported by the backend.
-     * @param results The container to store the result in.
-     * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
-     */
-    PVR_ERROR GetTimerTypes(std::vector<std::shared_ptr<CPVRTimerType>>& results) const;
-
-    //@}
-    /** @name PVR live stream methods */
-    //@{
-
-    /*!
-     * @brief Open a live stream on the server.
-     * @param channel The channel to stream.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR OpenLiveStream(const std::shared_ptr<CPVRChannel>& channel);
-
-    /*!
-     * @brief Close an open live stream.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CloseLiveStream();
-
-    /*!
-     * @brief Read from an open live stream.
-     * @param lpBuf The buffer to store the data in.
-     * @param uiBufSize The amount of bytes to read.
-     * @param iRead The amount of bytes that were actually read from the stream.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR ReadLiveStream(void* lpBuf, int64_t uiBufSize, int& iRead);
-
-    /*!
-     * @brief Seek in a live stream on a backend.
-     * @param iFilePosition The position to seek to.
-     * @param iWhence ?
-     * @param iPosition The new position or -1 on error.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR SeekLiveStream(int64_t iFilePosition, int iWhence, int64_t& iPosition);
-
-    /*!
-     * @brief Get the lenght of the currently playing live stream, if any.
-     * @param iLength The total length of the stream that's currently being read or -1 on error.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetLiveStreamLength(int64_t& iLength);
-
-    /*!
-     * @brief (Un)Pause a stream.
-     * @param bPaused True to pause the stream, false to unpause.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR PauseStream(bool bPaused);
-
-    /*!
-     * @brief Get the signal quality of the stream that's currently open.
-     * @param channelUid Channel unique identifier
-     * @param qualityinfo The signal quality.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR SignalQuality(int channelUid, PVR_SIGNAL_STATUS& qualityinfo);
-
-    /*!
-     * @brief Get the descramble information of the stream that's currently open.
-     * @param channelUid Channel unique identifier
-     * @param descrambleinfo The descramble information.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetDescrambleInfo(int channelUid, PVR_DESCRAMBLE_INFO& descrambleinfo) const;
-
-    /*!
-     * @brief Fill the given container with the properties required for playback of the given channel. Values are obtained from the PVR backend.
-     * @param channel The channel.
-     * @param props The container to be filled with the stream properties.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetChannelStreamProperties(const std::shared_ptr<CPVRChannel>& channel, CPVRStreamProperties& props);
-
-    /*!
-     * @brief Check whether PVR backend supports pausing the currently playing stream
-     * @param bCanPause True if the stream can be paused, false otherwise.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CanPauseStream(bool& bCanPause) const;
-
-    /*!
-     * @brief Check whether PVR backend supports seeking for the currently playing stream
-     * @param bCanSeek True if the stream can be seeked, false otherwise.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CanSeekStream(bool& bCanSeek) const;
-
-    /*!
-     * @brief Notify the pvr addon/demuxer that Kodi wishes to seek the stream by time
-     * @param time The absolute time since stream start
-     * @param backwards True to seek to keyframe BEFORE time, else AFTER
-     * @param startpts can be updated to point to where display should start
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     * @remarks Optional, and only used if addon has its own demuxer.
-     */
-    PVR_ERROR SeekTime(double time, bool backwards, double* startpts);
-
-    /*!
-     * @brief Notify the pvr addon/demuxer that Kodi wishes to change playback speed
-     * @param speed The requested playback speed
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     * @remarks Optional, and only used if addon has its own demuxer.
-     */
-    PVR_ERROR SetSpeed(int speed);
-
-    /*!
-     * @brief Notify the pvr addon/demuxer that Kodi wishes to fill demux queue
-     * @param mode for setting on/off
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     * @remarks Optional, and only used if addon has its own demuxer.
-     */
-    PVR_ERROR FillBuffer(bool mode);
-
-    //@}
-    /** @name PVR recording stream methods */
-    //@{
-
-    /*!
-     * @brief Open a recording on the server.
-     * @param recording The recording to open.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR OpenRecordedStream(const std::shared_ptr<CPVRRecording>& recording);
-
-    /*!
-     * @brief Close an open recording stream.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CloseRecordedStream();
-
-    /*!
-     * @brief Read from an open recording stream.
-     * @param lpBuf The buffer to store the data in.
-     * @param uiBufSize The amount of bytes to read.
-     * @param iRead The amount of bytes that were actually read from the stream.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR ReadRecordedStream(void* lpBuf, int64_t uiBufSize, int& iRead);
-
-    /*!
-     * @brief Seek in a recording stream on a backend.
-     * @param iFilePosition The position to seek to.
-     * @param iWhence ?
-     * @param iPosition The new position or -1 on error.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR SeekRecordedStream(int64_t iFilePosition, int iWhence, int64_t& iPosition);
-
-    /*!
-     * @brief Get the lenght of the currently playing recording stream, if any.
-     * @param iLength The total length of the stream that's currently being read or -1 on error.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetRecordedStreamLength(int64_t& iLength);
-
-    /*!
-     * @brief Fill the given container with the properties required for playback of the given recording. Values are obtained from the PVR backend.
-     * @param recording The recording.
-     * @param props The container to be filled with the stream properties.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetRecordingStreamProperties(const std::shared_ptr<CPVRRecording>& recording, CPVRStreamProperties& props);
-
-    //@}
-    /** @name PVR demultiplexer methods */
-    //@{
-
-    /*!
-     * @brief Reset the demultiplexer in the add-on.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR DemuxReset();
-
-    /*!
-     * @brief Abort the demultiplexer thread in the add-on.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR DemuxAbort();
-
-    /*!
-     * @brief Flush all data that's currently in the demultiplexer buffer in the add-on.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR DemuxFlush();
-
-    /*!
-     * @brief Read a packet from the demultiplexer.
-     * @param packet The packet read.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR DemuxRead(DemuxPacket* &packet);
-
-    static const char* ToString(const PVR_ERROR error);
-
-    /*!
-     * @brief Check whether the currently playing stream, if any, is a real-time stream.
-     * @param bRealTime True if real-time, false otherwise.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR IsRealTimeStream(bool& bRealTime) const;
-
-    /*!
-     * @brief Get Stream times for the currently playing stream, if any (will be moved to inputstream).
-     * @param times The stream times.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetStreamTimes(PVR_STREAM_TIMES* times);
-
-    /*!
-     * @brief reads the client's properties.
-     * @return True on success, false otherwise.
-     */
-    bool GetAddonProperties();
-
-    /*!
-     * @brief Get the client's menu hooks.
-     * @return The hooks. Guaranteed never to be nullptr.
-     */
-    std::shared_ptr<CPVRClientMenuHooks> GetMenuHooks();
-
-    /*!
-     * @brief Call one of the EPG tag menu hooks of the client.
-     * @param hook The hook to call.
-     * @param tag The EPG tag associated with the hook to be called.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CallEpgTagMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVREpgInfoTag>& tag);
-
-    /*!
-     * @brief Call one of the channel menu hooks of the client.
-     * @param hook The hook to call.
-     * @param tag The channel associated with the hook to be called.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CallChannelMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRChannel>& channel);
-
-    /*!
-     * @brief Call one of the recording menu hooks of the client.
-     * @param hook The hook to call.
-     * @param tag The recording associated with the hook to be called.
-     * @param bDeleted True, if the recording is deleted (trashed), false otherwise
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CallRecordingMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRRecording>& recording, bool bDeleted);
-
-    /*!
-     * @brief Call one of the timer menu hooks of the client.
-     * @param hook The hook to call.
-     * @param tag The timer associated with the hook to be called.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CallTimerMenuHook(const CPVRClientMenuHook& hook, const std::shared_ptr<CPVRTimerInfoTag>& timer);
-
-    /*!
-     * @brief Call one of the settings menu hooks of the client.
-     * @param hook The hook to call.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR CallSettingsMenuHook(const CPVRClientMenuHook& hook);
-
-    /*!
-     * @brief Propagate power management events to this add-on
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR OnSystemSleep();
-    PVR_ERROR OnSystemWake();
-    PVR_ERROR OnPowerSavingActivated();
-    PVR_ERROR OnPowerSavingDeactivated();
-
-    /*!
-     * @brief Get the priority of this client. Larger value means higher priority.
-     * @return The priority.
-     */
-    int GetPriority() const;
-
-    /*!
-     * @brief Set a new priority for this client.
-     * @param iPriority The new priority.
-     */
-    void SetPriority(int iPriority);
-
-    /*!
-     * @brief Obtain the chunk size to use when reading streams.
-     * @param iChunkSize the chunk size in bytes.
-     * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
-     */
-    PVR_ERROR GetStreamReadChunkSize(int& iChunkSize);
-
-    /*!
-     * @brief Get the interface table used between addon and Kodi.
-     * @todo This function will be removed after old callback library system is removed.
-     */
-    AddonInstance_PVR* GetInstanceInterface() { return &m_struct; }
-
-  private:
-    /*!
-     * @brief Resets all class members to their defaults. Called by the constructors.
-     */
-    void ResetProperties(int iClientId = PVR_INVALID_CLIENT_ID);
-
-    /*!
-     * @brief Copy over group info from xbmcGroup to addonGroup.
-     * @param xbmcGroup The group on XBMC's side.
-     * @param addonGroup The group on the addon's side.
-     */
-    static void WriteClientGroupInfo(const CPVRChannelGroup& xbmcGroup, PVR_CHANNEL_GROUP& addonGroup);
-
-    /*!
-     * @brief Copy over recording info from xbmcRecording to addonRecording.
-     * @param xbmcRecording The recording on XBMC's side.
-     * @param addonRecording The recording on the addon's side.
-     */
-    static void WriteClientRecordingInfo(const CPVRRecording& xbmcRecording, PVR_RECORDING& addonRecording);
-
-    /*!
-     * @brief Copy over timer info from xbmcTimer to addonTimer.
-     * @param xbmcTimer The timer on XBMC's side.
-     * @param addonTimer The timer on the addon's side.
-     */
-    static void WriteClientTimerInfo(const CPVRTimerInfoTag& xbmcTimer, PVR_TIMER& addonTimer);
-
-    /*!
-     * @brief Copy over channel info from xbmcChannel to addonClient.
-     * @param xbmcChannel The channel on XBMC's side.
-     * @param addonChannel The channel on the addon's side.
-     */
-    static void WriteClientChannelInfo(const std::shared_ptr<CPVRChannel>& xbmcChannel, PVR_CHANNEL& addonChannel);
-
-    /*!
-     * @brief Write the given addon properties to the given properties container.
-     * @param properties Pointer to an array of addon properties.
-     * @param iPropertyCount The number of properties contained in the addon properties array.
-     * @param props The container the addon properties shall be written to.
-     */
-    static void WriteStreamProperties(const PVR_NAMED_VALUE* properties, unsigned int iPropertyCount, CPVRStreamProperties& props);
-
-    /*!
-     * @brief Whether a channel can be played by this add-on
-     * @param channel The channel to check.
-     * @return True when it can be played, false otherwise.
-     */
-    bool CanPlayChannel(const std::shared_ptr<CPVRChannel>& channel) const;
-
-    /*!
-     * @brief Stop this instance, if it is currently running.
-     */
-    void StopRunningInstance();
-
-    /*!
-     * @brief Wraps an addon function call in order to do common pre and post function invocation actions.
-     * @param strFunctionName The function name, for logging purposes.
-     * @param function The function to wrap. It has to have return type PVR_ERROR and must take one parameter of type const AddonInstance*.
-     * @param bIsImplemented If false, this method will return PVR_ERROR_NOT_IMPLEMENTED.
-     * @param bCheckReadyToUse If true, this method will check whether this instance is ready for use and return PVR_ERROR_SERVER_ERROR if it is not.
-     * @return PVR_ERROR_NO_ERROR on success, any other PVR_ERROR_* value otherwise.
-     */
-    typedef AddonInstance_PVR AddonInstance;
-    PVR_ERROR DoAddonCall(const char* strFunctionName,
-                          std::function<PVR_ERROR(const AddonInstance*)> function,
-                          bool bIsImplemented = true,
-                          bool bCheckReadyToUse = true) const;
-
-    /*!
-     * @brief Callback functions from addon to kodi
-     */
-    //@{
-
-    /*!
-     * @brief Transfer a channel group from the add-on to Kodi. The group will be created if it doesn't exist.
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param handle The handle parameter that Kodi used when requesting the channel groups list
-     * @param entry The entry to transfer to Kodi
-     */
-    static void cb_transfer_channel_group(void* kodiInstance, const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP* entry);
-
-    /*!
-     * @brief Transfer a channel group member entry from the add-on to Kodi. The channel will be added to the group if the group can be found.
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param handle The handle parameter that Kodi used when requesting the channel group members list
-     * @param entry The entry to transfer to Kodi
-     */
-    static void cb_transfer_channel_group_member(void* kodiInstance, const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP_MEMBER* entry);
-
-    /*!
-     * @brief Transfer an EPG tag from the add-on to Kodi
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param handle The handle parameter that Kodi used when requesting the EPG data
-     * @param entry The entry to transfer to Kodi
-     */
-    static void cb_transfer_epg_entry(void* kodiInstance, const ADDON_HANDLE handle, const EPG_TAG* entry);
-
-    /*!
-     * @brief Transfer a channel entry from the add-on to Kodi
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param handle The handle parameter that Kodi used when requesting the channel list
-     * @param entry The entry to transfer to Kodi
-     */
-    static void cb_transfer_channel_entry(void* kodiInstance, const ADDON_HANDLE handle, const PVR_CHANNEL* entry);
-
-    /*!
-     * @brief Transfer a timer entry from the add-on to Kodi
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param handle The handle parameter that Kodi used when requesting the timers list
-     * @param entry The entry to transfer to Kodi
-     */
-    static void cb_transfer_timer_entry(void* kodiInstance, const ADDON_HANDLE handle, const PVR_TIMER* entry);
-
-    /*!
-     * @brief Transfer a recording entry from the add-on to Kodi
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param handle The handle parameter that Kodi used when requesting the recordings list
-     * @param entry The entry to transfer to Kodi
-     */
-    static void cb_transfer_recording_entry(void* kodiInstance, const ADDON_HANDLE handle, const PVR_RECORDING* entry);
-
-    /*!
-     * @brief Add or replace a menu hook for the context menu for this add-on
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param hook The hook to add.
-     */
-    static void cb_add_menu_hook(void* kodiInstance, PVR_MENUHOOK* hook);
-
-    /*!
-     * @brief Display a notification in Kodi that a recording started or stopped on the server
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param strName The name of the recording to display
-     * @param strFileName The filename of the recording
-     * @param bOnOff True when recording started, false when it stopped
-     */
-    static void cb_recording_notification(void* kodiInstance,
-                                          const char* strName,
-                                          const char* strFileName,
-                                          bool bOnOff);
-
-    /*!
-     * @brief Request Kodi to update it's list of channels
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     */
-    static void cb_trigger_channel_update(void* kodiInstance);
-
-    /*!
-     * @brief Request Kodi to update it's list of timers
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     */
-    static void cb_trigger_timer_update(void* kodiInstance);
-
-    /*!
-     * @brief Request Kodi to update it's list of recordings
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     */
-    static void cb_trigger_recording_update(void* kodiInstance);
-
-    /*!
-     * @brief Request Kodi to update it's list of channel groups
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     */
-    static void cb_trigger_channel_groups_update(void* kodiInstance);
-
-    /*!
-     * @brief Schedule an EPG update for the given channel channel
-     * @param kodiInstance A pointer to the add-on
-     * @param iChannelUid The unique id of the channel for this add-on
-     */
-    static void cb_trigger_epg_update(void* kodiInstance, unsigned int iChannelUid);
-
-    /*!
-     * @brief Free a packet that was allocated with AllocateDemuxPacket
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param pPacket The packet to free.
-     */
-    static void cb_free_demux_packet(void* kodiInstance, DemuxPacket* pPacket);
-
-    /*!
-     * @brief Allocate a demux packet. Free with FreeDemuxPacket
-     * @param kodiInstance Pointer to Kodi's CPVRClient class.
-     * @param iDataSize The size of the data that will go into the packet
-     * @return The allocated packet.
-     */
-    static DemuxPacket* cb_allocate_demux_packet(void* kodiInstance, int iDataSize = 0);
-
-    /*!
-     * @brief Notify a state change for a PVR backend connection
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param strConnectionString The connection string reported by the backend that can be displayed in the UI.
-     * @param newState The new state.
-     * @param strMessage A localized addon-defined string representing the new state, that can be displayed
-     *        in the UI or NULL if the Kodi-defined default string for the new state shall be displayed.
-     */
-    static void cb_connection_state_change(void* kodiInstance, const char* strConnectionString, PVR_CONNECTION_STATE newState, const char* strMessage);
-
-    /*!
-     * @brief Notify a state change for an EPG event
-     * @param kodiInstance Pointer to Kodi's CPVRClient class
-     * @param tag The EPG event.
-     * @param newState The new state.
-     * @param newState The new state. For EPG_EVENT_CREATED and EPG_EVENT_UPDATED, tag must be filled with all available
-     *        event data, not just a delta. For EPG_EVENT_DELETED, it is sufficient to fill EPG_TAG.iUniqueBroadcastId
-     */
-    static void cb_epg_event_state_change(void* kodiInstance, EPG_TAG* tag, EPG_EVENT_STATE newState);
-
-    /*! @todo remove the use complete from them, or add as generl function?!
-     * Returns the ffmpeg codec id from given ffmpeg codec string name
-     */
-    static PVR_CODEC cb_get_codec_by_name(const void* kodiInstance, const char* strCodecName);
-    //@}
-
-    std::atomic<bool> m_bReadyToUse; /*!< true if this add-on is initialised (ADDON_Create returned true), false otherwise */
-    std::atomic<bool> m_bBlockAddonCalls; /*!< true if no add-on API calls are allowed */
-    PVR_CONNECTION_STATE m_connectionState; /*!< the backend connection state */
-    PVR_CONNECTION_STATE m_prevConnectionState; /*!< the previous backend connection state */
-    bool m_ignoreClient; /*!< signals to PVRManager to ignore this client until it has been connected */
-    std::vector<std::shared_ptr<CPVRTimerType>> m_timertypes; /*!< timer types supported by this backend */
-    int m_iClientId; /*!< unique ID of the client */
-    mutable int m_iPriority; /*!< priority of the client */
-    mutable bool m_bPriorityFetched;
-
-    /* cached data */
-    std::string m_strBackendName; /*!< the cached backend version */
-    std::string m_strBackendVersion; /*!< the cached backend version */
-    std::string m_strConnectionString; /*!< the cached connection string */
-    std::string m_strFriendlyName; /*!< the cached friendly name */
-    std::string m_strBackendHostname; /*!< the cached backend hostname */
-    CPVRClientCapabilities m_clientCapabilities; /*!< the cached add-on's capabilities */
-    std::shared_ptr<CPVRClientMenuHooks> m_menuhooks; /*!< the menu hooks for this add-on */
-
-    /* stored strings to make sure const char* members in AddonProperties_PVR stay valid */
-    std::string m_strUserPath; /*!< @brief translated path to the user profile */
-    std::string m_strClientPath; /*!< @brief translated path to this add-on */
-
-    mutable CCriticalSection m_critSection;
-
-    AddonInstance_PVR m_struct;
-  };
-}
+    return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings &&
+           m_addonCapabilities->bSupportsRecordingEdl;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports retrieving an edit decision list for epg tags.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsEpgTagEdl() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsEPG &&
+           m_addonCapabilities->bSupportsEPGEdl;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports renaming recordings..
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsRecordingsRename() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings &&
+           m_addonCapabilities->bSupportsRecordingsRename;
+  }
+
+  /*!
+   * @brief Check whether this add-on supports changing lifetime of recording.
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsRecordingsLifetimeChange() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings &&
+           m_addonCapabilities->bSupportsRecordingsLifetimeChange;
+  }
+
+  /*!
+   * @brief Obtain a list with all possible values for recordings lifetime.
+   * @param list out, the list with the values or an empty list, if lifetime is not supported.
+   */
+  void GetRecordingsLifetimeValues(std::vector<std::pair<std::string, int>>& list) const;
+
+  /*!
+   * @brief Check whether this add-on supports retrieving the size recordings..
+   * @return True if supported, false otherwise.
+   */
+  bool SupportsRecordingsSize() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings &&
+           m_addonCapabilities->bSupportsRecordingSize;
+  }
+
+  /////////////////////////////////////////////////////////////////////////////////
+  //
+  // Streams
+  //
+  /////////////////////////////////////////////////////////////////////////////////
+
+  /*!
+   * @brief Check whether this add-on provides an input stream. false if Kodi handles the stream.
+   * @return True if supported, false otherwise.
+   */
+  bool HandlesInputStream() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bHandlesInputStream;
+  }
+
+  /*!
+   * @brief Check whether this add-on demultiplexes packets.
+   * @return True if supported, false otherwise.
+   */
+  bool HandlesDemuxing() const
+  {
+    return m_addonCapabilities && m_addonCapabilities->bHandlesDemuxing;
+  }
+
+private:
+  void InitRecordingsLifetimeValues();
+
+  std::unique_ptr<PVR_ADDON_CAPABILITIES> m_addonCapabilities;
+  std::vector<std::pair<std::string, int>> m_recordingsLifetimeValues;
+};
+
+/*!
+ * Interface from Kodi to a PVR add-on.
+ *
+ * Also translates Kodi's C++ structures to the add-on's C structures.
+ */
+class CPVRClient : public ADDON::IAddonInstanceHandler
+{
+public:
+  explicit CPVRClient(ADDON::BinaryAddonBasePtr addonBase);
+  ~CPVRClient() override;
+
+  void OnPreInstall() override;
+  void OnPreUnInstall() override;
+
+  /** @name PVR add-on methods */
+  //@{
+
+  /*!
+   * @brief Initialise the instance of this add-on.
+   * @param iClientId The ID of this add-on.
+   */
+  ADDON_STATUS Create(int iClientId);
+
+  /*!
+   * @brief Stop this add-on instance. No more client add-on access after this call.
+   */
+  void Stop();
+
+  /*!
+   * @brief Continue this add-on instance. Client add-on access is okay again after this call.
+   */
+  void Continue();
+
+  /*!
+   * @brief Destroy the instance of this add-on.
+   */
+  void Destroy();
+
+  /*!
+   * @brief Destroy and recreate this add-on.
+   */
+  void ReCreate();
+
+  /*!
+   * @return True if this instance is initialised (ADDON_Create returned true), false otherwise.
+   */
+  bool ReadyToUse() const;
+
+  /*!
+   * @brief Gets the backend connection state.
+   * @return the backend connection state.
+   */
+  PVR_CONNECTION_STATE GetConnectionState() const;
+
+  /*!
+   * @brief Sets the backend connection state.
+   * @param state the new backend connection state.
+   */
+  void SetConnectionState(PVR_CONNECTION_STATE state);
+
+  /*!
+   * @brief Gets the backend's previous connection state.
+   * @return the backend's previous connection state.
+   */
+  PVR_CONNECTION_STATE GetPreviousConnectionState() const;
+
+  /*!
+   * @brief signal to PVRManager this client should be ignored
+   * @return true if this client should be ignored
+   */
+  bool IgnoreClient() const;
+
+  /*!
+   * @return The ID of this instance.
+   */
+  int GetID() const;
+
+  //@}
+  /** @name PVR server methods */
+  //@{
+
+  /*!
+   * @brief Query this add-on's capabilities.
+   * @return The add-on's capabilities.
+   */
+  const CPVRClientCapabilities& GetClientCapabilities() const { return m_clientCapabilities; }
+
+  /*!
+   * @brief Get the stream properties of the stream that's currently being read.
+   * @param pProperties The properties.
+   * @return PVR_ERROR_NO_ERROR if the properties have been fetched successfully.
+   */
+  PVR_ERROR GetStreamProperties(PVR_STREAM_PROPERTIES* pProperties);
+
+  /*!
+   * @return The name reported by the backend.
+   */
+  const std::string& GetBackendName() const;
+
+  /*!
+   * @return The version string reported by the backend.
+   */
+  const std::string& GetBackendVersion() const;
+
+  /*!
+   * @brief the ip address or alias of the pvr backend server
+   */
+  const std::string& GetBackendHostname() const;
+
+  /*!
+   * @return The connection string reported by the backend.
+   */
+  const std::string& GetConnectionString() const;
+
+  /*!
+   * @return A friendly name for this add-on that can be used in log messages.
+   */
+  const std::string& GetFriendlyName() const;
+
+  /*!
+   * @brief Get the disk space reported by the server.
+   * @param iTotal The total disk space.
+   * @param iUsed The used disk space.
+   * @return PVR_ERROR_NO_ERROR if the drive space has been fetched successfully.
+   */
+  PVR_ERROR GetDriveSpace(uint64_t& iTotal, uint64_t& iUsed);
+
+  /*!
+   * @brief Start a channel scan on the server.
+   * @return PVR_ERROR_NO_ERROR if the channel scan has been started successfully.
+   */
+  PVR_ERROR StartChannelScan();
+
+  /*!
+   * @brief Request the client to open dialog about given channel to add
+   * @param channel The channel to add
+   * @return PVR_ERROR_NO_ERROR if the add has been fetched successfully.
+   */
+  PVR_ERROR OpenDialogChannelAdd(const std::shared_ptr<CPVRChannel>& channel);
+
+  /*!
+   * @brief Request the client to open dialog about given channel settings
+   * @param channel The channel to edit
+   * @return PVR_ERROR_NO_ERROR if the edit has been fetched successfully.
+   */
+  PVR_ERROR OpenDialogChannelSettings(const std::shared_ptr<CPVRChannel>& channel);
+
+  /*!
+   * @brief Request the client to delete given channel
+   * @param channel The channel to delete
+   * @return PVR_ERROR_NO_ERROR if the delete has been fetched successfully.
+   */
+  PVR_ERROR DeleteChannel(const std::shared_ptr<CPVRChannel>& channel);
+
+  /*!
+   * @brief Request the client to rename given channel
+   * @param channel The channel to rename
+   * @return PVR_ERROR_NO_ERROR if the rename has been fetched successfully.
+   */
+  PVR_ERROR RenameChannel(const std::shared_ptr<CPVRChannel>& channel);
+
+  /*
+   * @brief Check if an epg tag can be recorded
+   * @param tag The epg tag
+   * @param bIsRecordable Set to true if the tag can be recorded
+   * @return PVR_ERROR_NO_ERROR if bIsRecordable has been set successfully.
+   */
+  PVR_ERROR IsRecordable(const std::shared_ptr<const CPVREpgInfoTag>& tag,
+                         bool& bIsRecordable) const;
+
+  /*
+   * @brief Check if an epg tag can be played
+   * @param tag The epg tag
+   * @param bIsPlayable Set to true if the tag can be played
+   * @return PVR_ERROR_NO_ERROR if bIsPlayable has been set successfully.
+   */
+  PVR_ERROR IsPlayable(const std::shared_ptr<const CPVREpgInfoTag>& tag, bool& bIsPlayable) const;
+
+  /*!
+   * @brief Fill the given container with the properties required for playback
+   * of the given EPG tag. Values are obtained from the PVR backend.
+   *
+   * @param tag The EPG tag.
+   * @param props The container to be filled with the stream properties.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetEpgTagStreamProperties(const std::shared_ptr<CPVREpgInfoTag>& tag,
+                                      CPVRStreamProperties& props);
+
+  //@}
+  /** @name PVR EPG methods */
+  //@{
+
+  /*!
+   * @brief Request an EPG table for a channel from the client.
+   * @param iChannelUid The UID of the channel to get the EPG table for.
+   * @param epg The table to write the data to.
+   * @param start The start time to use.
+   * @param end The end time to use.
+   * @return PVR_ERROR_NO_ERROR if the table has been fetched successfully.
+   */
+  PVR_ERROR GetEPGForChannel(int iChannelUid, CPVREpg* epg, time_t start, time_t end);
+
+  /*!
+   * @brief Tell the client the time frame to use when notifying epg events back
+   * to Kodi.
+   *
+   * The client might push epg events asynchronously to Kodi using the callback
+   * function EpgEventStateChange. To be able to only push events that are
+   * actually of interest for Kodi, client needs to know about the epg time
+   * frame Kodi uses.
+   *
+   * @param iDays number of days from "now". EPG_TIMEFRAME_UNLIMITED means that Kodi is interested in all epg events, regardless of event times.
+   * @return PVR_ERROR_NO_ERROR if new value was successfully set.
+   */
+  PVR_ERROR SetEPGTimeFrame(int iDays);
+
+  //@}
+  /** @name PVR channel group methods */
+  //@{
+
+  /*!
+   * @brief Get the total amount of channel groups from the backend.
+   * @param iGroups The total amount of channel groups on the server or -1 on error.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetChannelGroupsAmount(int& iGroups);
+
+  /*!
+   * @brief Request the list of all channel groups from the backend.
+   * @param groups The groups container to get the groups for.
+   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+   */
+  PVR_ERROR GetChannelGroups(CPVRChannelGroups* groups);
+
+  /*!
+   * @brief Request the list of all group members from the backend.
+   * @param group The group to get the members for.
+   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+   */
+  PVR_ERROR GetChannelGroupMembers(CPVRChannelGroup* group);
+
+  //@}
+  /** @name PVR channel methods */
+  //@{
+
+  /*!
+   * @brief Get the total amount of channels from the backend.
+   * @param iChannels The total amount of channels on the server or -1 on error.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetChannelsAmount(int& iChannels);
+
+  /*!
+   * @brief Request the list of all channels from the backend.
+   * @param channels The channel group to add the channels to.
+   * @param bRadio True to get the radio channels, false to get the TV channels.
+   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+   */
+  PVR_ERROR GetChannels(CPVRChannelGroup& channels, bool bRadio);
+
+  //@}
+  /** @name PVR recording methods */
+  //@{
+
+  /*!
+   * @brief Get the total amount of recordings from the backend.
+   * @param deleted True to return deleted recordings.
+   * @param iRecordings The total amount of recordings on the server or -1 on error.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetRecordingsAmount(bool deleted, int& iRecordings);
+
+  /*!
+   * @brief Request the list of all recordings from the backend.
+   * @param results The container to add the recordings to.
+   * @param deleted True to return deleted recordings.
+   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+   */
+  PVR_ERROR GetRecordings(CPVRRecordings* results, bool deleted);
+
+  /*!
+   * @brief Delete a recording on the backend.
+   * @param recording The recording to delete.
+   * @return PVR_ERROR_NO_ERROR if the recording has been deleted successfully.
+   */
+  PVR_ERROR DeleteRecording(const CPVRRecording& recording);
+
+  /*!
+   * @brief Undelete a recording on the backend.
+   * @param recording The recording to undelete.
+   * @return PVR_ERROR_NO_ERROR if the recording has been undeleted successfully.
+   */
+  PVR_ERROR UndeleteRecording(const CPVRRecording& recording);
+
+  /*!
+   * @brief Delete all recordings permanent which in the deleted folder on the backend.
+   * @return PVR_ERROR_NO_ERROR if the recordings has been deleted successfully.
+   */
+  PVR_ERROR DeleteAllRecordingsFromTrash();
+
+  /*!
+   * @brief Rename a recording on the backend.
+   * @param recording The recording to rename.
+   * @return PVR_ERROR_NO_ERROR if the recording has been renamed successfully.
+   */
+  PVR_ERROR RenameRecording(const CPVRRecording& recording);
+
+  /*!
+   * @brief Set the lifetime of a recording on the backend.
+   * @param recording The recording to set the lifetime for. recording.m_iLifetime contains the new lifetime value.
+   * @return PVR_ERROR_NO_ERROR if the recording's lifetime has been set successfully.
+   */
+  PVR_ERROR SetRecordingLifetime(const CPVRRecording& recording);
+
+  /*!
+   * @brief Set the play count of a recording on the backend.
+   * @param recording The recording to set the play count.
+   * @param count Play count.
+   * @return PVR_ERROR_NO_ERROR if the recording's play count has been set successfully.
+   */
+  PVR_ERROR SetRecordingPlayCount(const CPVRRecording& recording, int count);
+
+  /*!
+   * @brief Set the last watched position of a recording on the backend.
+   * @param recording The recording.
+   * @param lastplayedposition The last watched position in seconds
+   * @return PVR_ERROR_NO_ERROR if the position has been stored successfully.
+   */
+  PVR_ERROR SetRecordingLastPlayedPosition(const CPVRRecording& recording, int lastplayedposition);
+
+  /*!
+   * @brief Retrieve the last watched position of a recording on the backend.
+   * @param recording The recording.
+   * @param iPosition The last watched position in seconds or -1 on error
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetRecordingLastPlayedPosition(const CPVRRecording& recording, int& iPosition);
+
+  /*!
+   * @brief Retrieve the edit decision list (EDL) from the backend.
+   * @param recording The recording.
+   * @param edls The edit decision list (empty on error).
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetRecordingEdl(const CPVRRecording& recording, std::vector<PVR_EDL_ENTRY>& edls);
+
+  /*!
+   * @brief Retrieve the size of a recording on the backend.
+   * @param recording The recording.
+   * @param sizeInBytes The size in bytes
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetRecordingSize(const CPVRRecording& recording, int64_t& sizeInBytes);
+
+  /*!
+   * @brief Retrieve the edit decision list (EDL) from the backend.
+   * @param epgTag The EPG tag.
+   * @param edls The edit decision list (empty on error).
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetEpgTagEdl(const std::shared_ptr<const CPVREpgInfoTag>& epgTag,
+                         std::vector<PVR_EDL_ENTRY>& edls);
+
+  //@}
+  /** @name PVR timer methods */
+  //@{
+
+  /*!
+   * @brief Get the total amount of timers from the backend.
+   * @param iTimers The total amount of timers on the backend or -1 on error.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetTimersAmount(int& iTimers);
+
+  /*!
+   * @brief Request the list of all timers from the backend.
+   * @param results The container to store the result in.
+   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+   */
+  PVR_ERROR GetTimers(CPVRTimersContainer* results);
+
+  /*!
+   * @brief Add a timer on the backend.
+   * @param timer The timer to add.
+   * @return PVR_ERROR_NO_ERROR if the timer has been added successfully.
+   */
+  PVR_ERROR AddTimer(const CPVRTimerInfoTag& timer);
+
+  /*!
+   * @brief Delete a timer on the backend.
+   * @param timer The timer to delete.
+   * @param bForce Set to true to delete a timer that is currently recording a program.
+   * @return PVR_ERROR_NO_ERROR if the timer has been deleted successfully.
+   */
+  PVR_ERROR DeleteTimer(const CPVRTimerInfoTag& timer, bool bForce = false);
+
+  /*!
+   * @brief Update the timer information on the server.
+   * @param timer The timer to update.
+   * @return PVR_ERROR_NO_ERROR if the timer has been updated successfully.
+   */
+  PVR_ERROR UpdateTimer(const CPVRTimerInfoTag& timer);
+
+  /*!
+   * @brief Get all timer types supported by the backend.
+   * @param results The container to store the result in.
+   * @return PVR_ERROR_NO_ERROR if the list has been fetched successfully.
+   */
+  PVR_ERROR GetTimerTypes(std::vector<std::shared_ptr<CPVRTimerType>>& results) const;
+
+  //@}
+  /** @name PVR live stream methods */
+  //@{
+
+  /*!
+   * @brief Open a live stream on the server.
+   * @param channel The channel to stream.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR OpenLiveStream(const std::shared_ptr<CPVRChannel>& channel);
+
+  /*!
+   * @brief Close an open live stream.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CloseLiveStream();
+
+  /*!
+   * @brief Read from an open live stream.
+   * @param lpBuf The buffer to store the data in.
+   * @param uiBufSize The amount of bytes to read.
+   * @param iRead The amount of bytes that were actually read from the stream.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR ReadLiveStream(void* lpBuf, int64_t uiBufSize, int& iRead);
+
+  /*!
+   * @brief Seek in a live stream on a backend.
+   * @param iFilePosition The position to seek to.
+   * @param iWhence ?
+   * @param iPosition The new position or -1 on error.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR SeekLiveStream(int64_t iFilePosition, int iWhence, int64_t& iPosition);
+
+  /*!
+   * @brief Get the lenght of the currently playing live stream, if any.
+   * @param iLength The total length of the stream that's currently being read or -1 on error.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetLiveStreamLength(int64_t& iLength);
+
+  /*!
+   * @brief (Un)Pause a stream.
+   * @param bPaused True to pause the stream, false to unpause.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR PauseStream(bool bPaused);
+
+  /*!
+   * @brief Get the signal quality of the stream that's currently open.
+   * @param channelUid Channel unique identifier
+   * @param qualityinfo The signal quality.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR SignalQuality(int channelUid, PVR_SIGNAL_STATUS& qualityinfo);
+
+  /*!
+   * @brief Get the descramble information of the stream that's currently open.
+   * @param channelUid Channel unique identifier
+   * @param descrambleinfo The descramble information.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetDescrambleInfo(int channelUid, PVR_DESCRAMBLE_INFO& descrambleinfo) const;
+
+  /*!
+   * @brief Fill the given container with the properties required for playback of the given channel. Values are obtained from the PVR backend.
+   * @param channel The channel.
+   * @param props The container to be filled with the stream properties.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetChannelStreamProperties(const std::shared_ptr<CPVRChannel>& channel,
+                                       CPVRStreamProperties& props);
+
+  /*!
+   * @brief Check whether PVR backend supports pausing the currently playing stream
+   * @param bCanPause True if the stream can be paused, false otherwise.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CanPauseStream(bool& bCanPause) const;
+
+  /*!
+   * @brief Check whether PVR backend supports seeking for the currently playing stream
+   * @param bCanSeek True if the stream can be seeked, false otherwise.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CanSeekStream(bool& bCanSeek) const;
+
+  /*!
+   * @brief Notify the pvr addon/demuxer that Kodi wishes to seek the stream by time
+   * @param time The absolute time since stream start
+   * @param backwards True to seek to keyframe BEFORE time, else AFTER
+   * @param startpts can be updated to point to where display should start
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   * @remarks Optional, and only used if addon has its own demuxer.
+   */
+  PVR_ERROR SeekTime(double time, bool backwards, double* startpts);
+
+  /*!
+   * @brief Notify the pvr addon/demuxer that Kodi wishes to change playback speed
+   * @param speed The requested playback speed
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   * @remarks Optional, and only used if addon has its own demuxer.
+   */
+  PVR_ERROR SetSpeed(int speed);
+
+  /*!
+   * @brief Notify the pvr addon/demuxer that Kodi wishes to fill demux queue
+   * @param mode for setting on/off
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   * @remarks Optional, and only used if addon has its own demuxer.
+   */
+  PVR_ERROR FillBuffer(bool mode);
+
+  //@}
+  /** @name PVR recording stream methods */
+  //@{
+
+  /*!
+   * @brief Open a recording on the server.
+   * @param recording The recording to open.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR OpenRecordedStream(const std::shared_ptr<CPVRRecording>& recording);
+
+  /*!
+   * @brief Close an open recording stream.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CloseRecordedStream();
+
+  /*!
+   * @brief Read from an open recording stream.
+   * @param lpBuf The buffer to store the data in.
+   * @param uiBufSize The amount of bytes to read.
+   * @param iRead The amount of bytes that were actually read from the stream.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR ReadRecordedStream(void* lpBuf, int64_t uiBufSize, int& iRead);
+
+  /*!
+   * @brief Seek in a recording stream on a backend.
+   * @param iFilePosition The position to seek to.
+   * @param iWhence ?
+   * @param iPosition The new position or -1 on error.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR SeekRecordedStream(int64_t iFilePosition, int iWhence, int64_t& iPosition);
+
+  /*!
+   * @brief Get the lenght of the currently playing recording stream, if any.
+   * @param iLength The total length of the stream that's currently being read or -1 on error.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetRecordedStreamLength(int64_t& iLength);
+
+  /*!
+   * @brief Fill the given container with the properties required for playback of the given recording. Values are obtained from the PVR backend.
+   * @param recording The recording.
+   * @param props The container to be filled with the stream properties.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetRecordingStreamProperties(const std::shared_ptr<CPVRRecording>& recording,
+                                         CPVRStreamProperties& props);
+
+  //@}
+  /** @name PVR demultiplexer methods */
+  //@{
+
+  /*!
+   * @brief Reset the demultiplexer in the add-on.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR DemuxReset();
+
+  /*!
+   * @brief Abort the demultiplexer thread in the add-on.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR DemuxAbort();
+
+  /*!
+   * @brief Flush all data that's currently in the demultiplexer buffer in the add-on.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR DemuxFlush();
+
+  /*!
+   * @brief Read a packet from the demultiplexer.
+   * @param packet The packet read.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR DemuxRead(DemuxPacket*& packet);
+
+  static const char* ToString(const PVR_ERROR error);
+
+  /*!
+   * @brief Check whether the currently playing stream, if any, is a real-time stream.
+   * @param bRealTime True if real-time, false otherwise.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR IsRealTimeStream(bool& bRealTime) const;
+
+  /*!
+   * @brief Get Stream times for the currently playing stream, if any (will be moved to inputstream).
+   * @param times The stream times.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetStreamTimes(PVR_STREAM_TIMES* times);
+
+  /*!
+   * @brief reads the client's properties.
+   * @return True on success, false otherwise.
+   */
+  bool GetAddonProperties();
+
+  /*!
+   * @brief Get the client's menu hooks.
+   * @return The hooks. Guaranteed never to be nullptr.
+   */
+  std::shared_ptr<CPVRClientMenuHooks> GetMenuHooks();
+
+  /*!
+   * @brief Call one of the EPG tag menu hooks of the client.
+   * @param hook The hook to call.
+   * @param tag The EPG tag associated with the hook to be called.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CallEpgTagMenuHook(const CPVRClientMenuHook& hook,
+                               const std::shared_ptr<CPVREpgInfoTag>& tag);
+
+  /*!
+   * @brief Call one of the channel menu hooks of the client.
+   * @param hook The hook to call.
+   * @param tag The channel associated with the hook to be called.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CallChannelMenuHook(const CPVRClientMenuHook& hook,
+                                const std::shared_ptr<CPVRChannel>& channel);
+
+  /*!
+   * @brief Call one of the recording menu hooks of the client.
+   * @param hook The hook to call.
+   * @param tag The recording associated with the hook to be called.
+   * @param bDeleted True, if the recording is deleted (trashed), false otherwise
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CallRecordingMenuHook(const CPVRClientMenuHook& hook,
+                                  const std::shared_ptr<CPVRRecording>& recording,
+                                  bool bDeleted);
+
+  /*!
+   * @brief Call one of the timer menu hooks of the client.
+   * @param hook The hook to call.
+   * @param tag The timer associated with the hook to be called.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CallTimerMenuHook(const CPVRClientMenuHook& hook,
+                              const std::shared_ptr<CPVRTimerInfoTag>& timer);
+
+  /*!
+   * @brief Call one of the settings menu hooks of the client.
+   * @param hook The hook to call.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR CallSettingsMenuHook(const CPVRClientMenuHook& hook);
+
+  /*!
+   * @brief Propagate power management events to this add-on
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR OnSystemSleep();
+  PVR_ERROR OnSystemWake();
+  PVR_ERROR OnPowerSavingActivated();
+  PVR_ERROR OnPowerSavingDeactivated();
+
+  /*!
+   * @brief Get the priority of this client. Larger value means higher priority.
+   * @return The priority.
+   */
+  int GetPriority() const;
+
+  /*!
+   * @brief Set a new priority for this client.
+   * @param iPriority The new priority.
+   */
+  void SetPriority(int iPriority);
+
+  /*!
+   * @brief Obtain the chunk size to use when reading streams.
+   * @param iChunkSize the chunk size in bytes.
+   * @return PVR_ERROR_NO_ERROR on success, respective error code otherwise.
+   */
+  PVR_ERROR GetStreamReadChunkSize(int& iChunkSize);
+
+  /*!
+   * @brief Get the interface table used between addon and Kodi.
+   * @todo This function will be removed after old callback library system is removed.
+   */
+  AddonInstance_PVR* GetInstanceInterface() { return &m_struct; }
+
+private:
+  /*!
+   * @brief Resets all class members to their defaults. Called by the constructors.
+   */
+  void ResetProperties(int iClientId = PVR_INVALID_CLIENT_ID);
+
+  /*!
+   * @brief Copy over group info from xbmcGroup to addonGroup.
+   * @param xbmcGroup The group on XBMC's side.
+   * @param addonGroup The group on the addon's side.
+   */
+  static void WriteClientGroupInfo(const CPVRChannelGroup& xbmcGroup,
+                                   PVR_CHANNEL_GROUP& addonGroup);
+
+  /*!
+   * @brief Copy over recording info from xbmcRecording to addonRecording.
+   * @param xbmcRecording The recording on XBMC's side.
+   * @param addonRecording The recording on the addon's side.
+   */
+  static void WriteClientRecordingInfo(const CPVRRecording& xbmcRecording,
+                                       PVR_RECORDING& addonRecording);
+
+  /*!
+   * @brief Copy over timer info from xbmcTimer to addonTimer.
+   * @param xbmcTimer The timer on XBMC's side.
+   * @param addonTimer The timer on the addon's side.
+   */
+  static void WriteClientTimerInfo(const CPVRTimerInfoTag& xbmcTimer, PVR_TIMER& addonTimer);
+
+  /*!
+   * @brief Copy over channel info from xbmcChannel to addonClient.
+   * @param xbmcChannel The channel on XBMC's side.
+   * @param addonChannel The channel on the addon's side.
+   */
+  static void WriteClientChannelInfo(const std::shared_ptr<CPVRChannel>& xbmcChannel,
+                                     PVR_CHANNEL& addonChannel);
+
+  /*!
+   * @brief Write the given addon properties to the given properties container.
+   * @param properties Pointer to an array of addon properties.
+   * @param iPropertyCount The number of properties contained in the addon properties array.
+   * @param props The container the addon properties shall be written to.
+   */
+  static void WriteStreamProperties(const PVR_NAMED_VALUE* properties,
+                                    unsigned int iPropertyCount,
+                                    CPVRStreamProperties& props);
+
+  /*!
+   * @brief Whether a channel can be played by this add-on
+   * @param channel The channel to check.
+   * @return True when it can be played, false otherwise.
+   */
+  bool CanPlayChannel(const std::shared_ptr<CPVRChannel>& channel) const;
+
+  /*!
+   * @brief Stop this instance, if it is currently running.
+   */
+  void StopRunningInstance();
+
+  /*!
+   * @brief Wraps an addon function call in order to do common pre and post function invocation actions.
+   * @param strFunctionName The function name, for logging purposes.
+   * @param function The function to wrap. It has to have return type PVR_ERROR and must take one parameter of type const AddonInstance*.
+   * @param bIsImplemented If false, this method will return PVR_ERROR_NOT_IMPLEMENTED.
+   * @param bCheckReadyToUse If true, this method will check whether this instance is ready for use and return PVR_ERROR_SERVER_ERROR if it is not.
+   * @return PVR_ERROR_NO_ERROR on success, any other PVR_ERROR_* value otherwise.
+   */
+  typedef AddonInstance_PVR AddonInstance;
+  PVR_ERROR DoAddonCall(const char* strFunctionName,
+                        std::function<PVR_ERROR(const AddonInstance*)> function,
+                        bool bIsImplemented = true,
+                        bool bCheckReadyToUse = true) const;
+
+  /*!
+   * @brief Callback functions from addon to kodi
+   */
+  //@{
+
+  /*!
+   * @brief Transfer a channel group from the add-on to Kodi. The group will be created if it doesn't exist.
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param handle The handle parameter that Kodi used when requesting the channel groups list
+   * @param entry The entry to transfer to Kodi
+   */
+  static void cb_transfer_channel_group(void* kodiInstance,
+                                        const ADDON_HANDLE handle,
+                                        const PVR_CHANNEL_GROUP* entry);
+
+  /*!
+   * @brief Transfer a channel group member entry from the add-on to Kodi. The channel will be added to the group if the group can be found.
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param handle The handle parameter that Kodi used when requesting the channel group members list
+   * @param entry The entry to transfer to Kodi
+   */
+  static void cb_transfer_channel_group_member(void* kodiInstance,
+                                               const ADDON_HANDLE handle,
+                                               const PVR_CHANNEL_GROUP_MEMBER* entry);
+
+  /*!
+   * @brief Transfer an EPG tag from the add-on to Kodi
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param handle The handle parameter that Kodi used when requesting the EPG data
+   * @param entry The entry to transfer to Kodi
+   */
+  static void cb_transfer_epg_entry(void* kodiInstance,
+                                    const ADDON_HANDLE handle,
+                                    const EPG_TAG* entry);
+
+  /*!
+   * @brief Transfer a channel entry from the add-on to Kodi
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param handle The handle parameter that Kodi used when requesting the channel list
+   * @param entry The entry to transfer to Kodi
+   */
+  static void cb_transfer_channel_entry(void* kodiInstance,
+                                        const ADDON_HANDLE handle,
+                                        const PVR_CHANNEL* entry);
+
+  /*!
+   * @brief Transfer a timer entry from the add-on to Kodi
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param handle The handle parameter that Kodi used when requesting the timers list
+   * @param entry The entry to transfer to Kodi
+   */
+  static void cb_transfer_timer_entry(void* kodiInstance,
+                                      const ADDON_HANDLE handle,
+                                      const PVR_TIMER* entry);
+
+  /*!
+   * @brief Transfer a recording entry from the add-on to Kodi
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param handle The handle parameter that Kodi used when requesting the recordings list
+   * @param entry The entry to transfer to Kodi
+   */
+  static void cb_transfer_recording_entry(void* kodiInstance,
+                                          const ADDON_HANDLE handle,
+                                          const PVR_RECORDING* entry);
+
+  /*!
+   * @brief Add or replace a menu hook for the context menu for this add-on
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param hook The hook to add.
+   */
+  static void cb_add_menu_hook(void* kodiInstance, PVR_MENUHOOK* hook);
+
+  /*!
+   * @brief Display a notification in Kodi that a recording started or stopped on the server
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param strName The name of the recording to display
+   * @param strFileName The filename of the recording
+   * @param bOnOff True when recording started, false when it stopped
+   */
+  static void cb_recording_notification(void* kodiInstance,
+                                        const char* strName,
+                                        const char* strFileName,
+                                        bool bOnOff);
+
+  /*!
+   * @brief Request Kodi to update it's list of channels
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   */
+  static void cb_trigger_channel_update(void* kodiInstance);
+
+  /*!
+   * @brief Request Kodi to update it's list of timers
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   */
+  static void cb_trigger_timer_update(void* kodiInstance);
+
+  /*!
+   * @brief Request Kodi to update it's list of recordings
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   */
+  static void cb_trigger_recording_update(void* kodiInstance);
+
+  /*!
+   * @brief Request Kodi to update it's list of channel groups
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   */
+  static void cb_trigger_channel_groups_update(void* kodiInstance);
+
+  /*!
+   * @brief Schedule an EPG update for the given channel channel
+   * @param kodiInstance A pointer to the add-on
+   * @param iChannelUid The unique id of the channel for this add-on
+   */
+  static void cb_trigger_epg_update(void* kodiInstance, unsigned int iChannelUid);
+
+  /*!
+   * @brief Free a packet that was allocated with AllocateDemuxPacket
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param pPacket The packet to free.
+   */
+  static void cb_free_demux_packet(void* kodiInstance, DemuxPacket* pPacket);
+
+  /*!
+   * @brief Allocate a demux packet. Free with FreeDemuxPacket
+   * @param kodiInstance Pointer to Kodi's CPVRClient class.
+   * @param iDataSize The size of the data that will go into the packet
+   * @return The allocated packet.
+   */
+  static DemuxPacket* cb_allocate_demux_packet(void* kodiInstance, int iDataSize = 0);
+
+  /*!
+   * @brief Notify a state change for a PVR backend connection
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param strConnectionString The connection string reported by the backend that can be displayed in the UI.
+   * @param newState The new state.
+   * @param strMessage A localized addon-defined string representing the new state, that can be displayed
+   *        in the UI or NULL if the Kodi-defined default string for the new state shall be displayed.
+   */
+  static void cb_connection_state_change(void* kodiInstance,
+                                         const char* strConnectionString,
+                                         PVR_CONNECTION_STATE newState,
+                                         const char* strMessage);
+
+  /*!
+   * @brief Notify a state change for an EPG event
+   * @param kodiInstance Pointer to Kodi's CPVRClient class
+   * @param tag The EPG event.
+   * @param newState The new state.
+   * @param newState The new state. For EPG_EVENT_CREATED and EPG_EVENT_UPDATED, tag must be filled with all available
+   *        event data, not just a delta. For EPG_EVENT_DELETED, it is sufficient to fill EPG_TAG.iUniqueBroadcastId
+   */
+  static void cb_epg_event_state_change(void* kodiInstance, EPG_TAG* tag, EPG_EVENT_STATE newState);
+
+  /*! @todo remove the use complete from them, or add as generl function?!
+   * Returns the ffmpeg codec id from given ffmpeg codec string name
+   */
+  static PVR_CODEC cb_get_codec_by_name(const void* kodiInstance, const char* strCodecName);
+  //@}
+
+  std::atomic<bool>
+      m_bReadyToUse; /*!< true if this add-on is initialised (ADDON_Create returned true), false otherwise */
+  std::atomic<bool> m_bBlockAddonCalls; /*!< true if no add-on API calls are allowed */
+  PVR_CONNECTION_STATE m_connectionState; /*!< the backend connection state */
+  PVR_CONNECTION_STATE m_prevConnectionState; /*!< the previous backend connection state */
+  bool
+      m_ignoreClient; /*!< signals to PVRManager to ignore this client until it has been connected */
+  std::vector<std::shared_ptr<CPVRTimerType>>
+      m_timertypes; /*!< timer types supported by this backend */
+  int m_iClientId; /*!< unique ID of the client */
+  mutable int m_iPriority; /*!< priority of the client */
+  mutable bool m_bPriorityFetched;
+
+  /* cached data */
+  std::string m_strBackendName; /*!< the cached backend version */
+  std::string m_strBackendVersion; /*!< the cached backend version */
+  std::string m_strConnectionString; /*!< the cached connection string */
+  std::string m_strFriendlyName; /*!< the cached friendly name */
+  std::string m_strBackendHostname; /*!< the cached backend hostname */
+  CPVRClientCapabilities m_clientCapabilities; /*!< the cached add-on's capabilities */
+  std::shared_ptr<CPVRClientMenuHooks> m_menuhooks; /*!< the menu hooks for this add-on */
+
+  /* stored strings to make sure const char* members in AddonProperties_PVR stay valid */
+  std::string m_strUserPath; /*!< @brief translated path to the user profile */
+  std::string m_strClientPath; /*!< @brief translated path to this add-on */
+
+  mutable CCriticalSection m_critSection;
+
+  AddonInstance_PVR m_struct;
+};
+} // namespace PVR
diff --git a/xbmc/pvr/addons/PVRClients.cpp b/xbmc/pvr/addons/PVRClients.cpp
index 4fe8222bec65..31cf05d859d2 100644
--- a/xbmc/pvr/addons/PVRClients.cpp
+++ b/xbmc/pvr/addons/PVRClients.cpp
@@ -93,7 +93,7 @@ void CPVRClients::UpdateAddons(const std::string& changedAddonId /*= ""*/)
 
   bool bFoundChangedAddon = changedAddonId.empty();
   std::vector<std::pair<BinaryAddonBasePtr, bool>> addonsWithStatus;
-  for (const auto &addon : addons)
+  for (const auto& addon : addons)
   {
     bool bEnabled = CServiceBroker::GetBinaryAddonManager().IsAddonEnabled(addon->ID());
     addonsWithStatus.emplace_back(std::make_pair(addon, bEnabled));
diff --git a/xbmc/pvr/channels/PVRChannel.cpp b/xbmc/pvr/channels/PVRChannel.cpp
index c14a1505b59c..c50a9c2f5478 100644
--- a/xbmc/pvr/channels/PVRChannel.cpp
+++ b/xbmc/pvr/channels/PVRChannel.cpp
@@ -48,18 +48,18 @@ CPVRChannel::CPVRChannel(bool bRadio /* = false */)
 }
 
 CPVRChannel::CPVRChannel(const PVR_CHANNEL& channel, unsigned int iClientId)
-: m_bIsRadio(channel.bIsRadio),
-  m_bIsHidden(channel.bIsHidden),
-  m_strIconPath(channel.strIconPath),
-  m_strChannelName(channel.strChannelName),
-  m_bHasArchive(channel.bHasArchive),
-  m_bEPGEnabled(!channel.bIsHidden),
-  m_iUniqueId(channel.iUniqueId),
-  m_iClientId(iClientId),
-  m_clientChannelNumber(channel.iChannelNumber, channel.iSubChannelNumber),
-  m_strClientChannelName(channel.strChannelName),
-  m_strMimeType(channel.strMimeType),
-  m_iClientEncryptionSystem(channel.iEncryptionSystem)
+  : m_bIsRadio(channel.bIsRadio),
+    m_bIsHidden(channel.bIsHidden),
+    m_strIconPath(channel.strIconPath),
+    m_strChannelName(channel.strChannelName),
+    m_bHasArchive(channel.bHasArchive),
+    m_bEPGEnabled(!channel.bIsHidden),
+    m_iUniqueId(channel.iUniqueId),
+    m_iClientId(iClientId),
+    m_clientChannelNumber(channel.iChannelNumber, channel.iSubChannelNumber),
+    m_strClientChannelName(channel.strChannelName),
+    m_strMimeType(channel.strMimeType),
+    m_iClientEncryptionSystem(channel.iEncryptionSystem)
 {
   if (m_strChannelName.empty())
     m_strChannelName = StringUtils::Format("%s %d", g_localizeStrings.Get(19029).c_str(), m_iUniqueId);
diff --git a/xbmc/pvr/channels/PVRChannel.h b/xbmc/pvr/channels/PVRChannel.h
index 0375a02423fe..272ea4743ea5 100644
--- a/xbmc/pvr/channels/PVRChannel.h
+++ b/xbmc/pvr/channels/PVRChannel.h
@@ -488,7 +488,8 @@ namespace PVR
     int m_iClientId = -1; /*!< the identifier of the client that serves this channel */
     CPVRChannelNumber m_clientChannelNumber; /*!< the channel number on the client for the currently selected channel group */
     std::string m_strClientChannelName; /*!< the name of this channel on the client */
-    std::string m_strMimeType; /*!< the stream input type based mime type, see @ref https://www.iana.org/assignments/media-types/media-types.xhtml#video */
+    std::string
+        m_strMimeType; /*!< the stream input type based mime type, see @ref https://www.iana.org/assignments/media-types/media-types.xhtml#video */
     std::string m_strFileNameAndPath; /*!< the filename to be used by PVRManager to open and read the stream */
     int m_iClientEncryptionSystem = -1; /*!< the encryption system used by this channel. 0 for FreeToAir, -1 for unknown */
     std::string m_strClientEncryptionName; /*!< the name of the encryption system used by this channel */

From c7a558bd1581800168323412cc58e991c16d8e41 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 8 Jun 2020 14:53:44 +0200
Subject: [PATCH 25/27] [addons][pvr] make menu hook transfer to Kodi in
 "const"

Before was it without, but as this need nowhere a change it must be "const"
to prevent wrong changes.
---
 .../addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h | 2 +-
 .../kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h  | 2 +-
 xbmc/pvr/addons/PVRClient.cpp                                   | 2 +-
 xbmc/pvr/addons/PVRClient.h                                     | 2 +-
 4 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index 918bf4afd04e..296bd79ce3f7 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -718,7 +718,7 @@ class CInstancePVRClient : public IAddonInstance
   /// ...
   /// ~~~~~~~~~~~~~
   ///
-  inline void AddMenuHook(kodi::addon::PVRMenuhook& hook)
+  inline void AddMenuHook(const kodi::addon::PVRMenuhook& hook)
   {
     m_instanceData->toKodi->AddMenuHook(m_instanceData->toKodi->kodiInstance, hook);
   }
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
index 9e62916c0d91..2d255adeb149 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/c-api/addon-instance/pvr.h
@@ -77,7 +77,7 @@ extern "C"
 
     //--==----==----==----==----==----==----==----==----==----==----==----==----==
     // General callback functions
-    void (*AddMenuHook)(void* kodiInstance, struct PVR_MENUHOOK* hook);
+    void (*AddMenuHook)(void* kodiInstance, const struct PVR_MENUHOOK* hook);
     void (*RecordingNotification)(void* kodiInstance,
                                   const char* name,
                                   const char* fileName,
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index 934799b66be6..16ee83d2877c 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -1797,7 +1797,7 @@ void CPVRClient::cb_transfer_timer_entry(void* kodiInstance,
   kodiTimers->UpdateFromClient(transferTimer);
 }
 
-void CPVRClient::cb_add_menu_hook(void* kodiInstance, PVR_MENUHOOK* hook)
+void CPVRClient::cb_add_menu_hook(void* kodiInstance, const PVR_MENUHOOK* hook)
 {
   CPVRClient* client = static_cast<CPVRClient*>(kodiInstance);
   if (!hook || !client)
diff --git a/xbmc/pvr/addons/PVRClient.h b/xbmc/pvr/addons/PVRClient.h
index 34ba567cdab6..a7f844b4786e 100644
--- a/xbmc/pvr/addons/PVRClient.h
+++ b/xbmc/pvr/addons/PVRClient.h
@@ -1128,7 +1128,7 @@ class CPVRClient : public ADDON::IAddonInstanceHandler
    * @param kodiInstance Pointer to Kodi's CPVRClient class
    * @param hook The hook to add.
    */
-  static void cb_add_menu_hook(void* kodiInstance, PVR_MENUHOOK* hook);
+  static void cb_add_menu_hook(void* kodiInstance, const PVR_MENUHOOK* hook);
 
   /*!
    * @brief Display a notification in Kodi that a recording started or stopped on the server

From f993d541442240c807827fd741fe4e5e13992609 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Wed, 20 May 2020 16:54:30 +0200
Subject: [PATCH 26/27] [addons][pvr] increase version to 7.0.0

Also are his new header depends addd to there.
---
 .../include/kodi/versions.h                   | 26 ++++++++++++++++---
 1 file changed, 23 insertions(+), 3 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index 85737b70ce0b..a2570898dac3 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -108,10 +108,30 @@
 #define ADDON_INSTANCE_VERSION_PERIPHERAL_DEPENDS     "addon-instance/Peripheral.h" \
                                                       "addon-instance/PeripheralUtils.h"
 
-#define ADDON_INSTANCE_VERSION_PVR                    "6.5.2"
-#define ADDON_INSTANCE_VERSION_PVR_MIN                "6.5.1"
+#define ADDON_INSTANCE_VERSION_PVR                    "7.0.0"
+#define ADDON_INSTANCE_VERSION_PVR_MIN                "7.0.0"
 #define ADDON_INSTANCE_VERSION_PVR_XML_ID             "kodi.binary.instance.pvr"
-#define ADDON_INSTANCE_VERSION_PVR_DEPENDS            "addon-instance/PVR.h"
+#define ADDON_INSTANCE_VERSION_PVR_DEPENDS            "c-api/addon-instance/pvr.h" \
+                                                      "c-api/addon-instance/pvr/pvr_channel_groups.h" \
+                                                      "c-api/addon-instance/pvr/pvr_channels.h" \
+                                                      "c-api/addon-instance/pvr/pvr_defines.h" \
+                                                      "c-api/addon-instance/pvr/pvr_edl.h" \
+                                                      "c-api/addon-instance/pvr/pvr_epg.h" \
+                                                      "c-api/addon-instance/pvr/pvr_general.h" \
+                                                      "c-api/addon-instance/pvr/pvr_menu_hook.h" \
+                                                      "c-api/addon-instance/pvr/pvr_recordings.h" \
+                                                      "c-api/addon-instance/pvr/pvr_stream.h" \
+                                                      "c-api/addon-instance/pvr/pvr_timers.h" \
+                                                      "addon-instance/PVR.h" \
+                                                      "addon-instance/pvr/ChannelGroups.h" \
+                                                      "addon-instance/pvr/Channels.h" \
+                                                      "addon-instance/pvr/EDL.h" \
+                                                      "addon-instance/pvr/EPG.h" \
+                                                      "addon-instance/pvr/General.h" \
+                                                      "addon-instance/pvr/MenuHook.h" \
+                                                      "addon-instance/pvr/Recordings.h" \
+                                                      "addon-instance/pvr/Stream.h" \
+                                                      "addon-instance/pvr/Timers.h"
 
 #define ADDON_INSTANCE_VERSION_SCREENSAVER            "2.0.1"
 #define ADDON_INSTANCE_VERSION_SCREENSAVER_MIN        "2.0.1"

From 7ef55fae6ac77f8d54f0d92dfb70314ae966eb97 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Mon, 8 Jun 2020 19:09:34 +0200
Subject: [PATCH 27/27] [addons] add script to generate function lists for used
 parts in interface group

This thought to generate a easily by user usable list about parts
and allow c&p for new projects.

This scan the headers about and if a `/// @copydetails ...header_addon_auto_check`
or `/// @copydetails ...source_addon_auto_check` is included becomes about related
group the list generated.

This list is added in .gitignore to prevent problems if by API changes not updated.

There must be a system in automatic doxygen build start by doc upload added.
---
 xbmc/addons/kodi-addon-dev-kit/.gitignore     |   2 +
 .../include/kodi/addon-instance/PVR.h         | 121 +++++++++++
 .../doxygen-header-class-list-creator.py      | 190 ++++++++++++++++++
 3 files changed, 313 insertions(+)
 create mode 100755 xbmc/addons/kodi-addon-dev-kit/tools/doxygen-header-class-list-creator.py

diff --git a/xbmc/addons/kodi-addon-dev-kit/.gitignore b/xbmc/addons/kodi-addon-dev-kit/.gitignore
index 039c6a72a8b6..93c8d068bd36 100644
--- a/xbmc/addons/kodi-addon-dev-kit/.gitignore
+++ b/xbmc/addons/kodi-addon-dev-kit/.gitignore
@@ -29,3 +29,5 @@
 
 /docs
 /build
+
+include/groups.dox
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
index 296bd79ce3f7..cc04f738d4b2 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/addon-instance/PVR.h
@@ -394,6 +394,17 @@ class CInstancePVRClient : public IAddonInstance
   ///
   /// The with "Valid implementation required." declared functions are mandatory,
   /// all others are an option.
+  ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Basic parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Base_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_Base_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -803,6 +814,16 @@ class CInstancePVRClient : public IAddonInstance
   /// If a channel changes after the initial import, or if a new one was added,
   /// then the add-on should call @ref TriggerChannelUpdate().
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Channel parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Channels_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_Channels_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -1003,6 +1024,16 @@ class CInstancePVRClient : public IAddonInstance
   /// This is used to divide available addon channels into groups, which can
   /// then be selected by the user.
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Channel group parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_supportsChannelGroups_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_supportsChannelGroups_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -1154,6 +1185,16 @@ class CInstancePVRClient : public IAddonInstance
   /// to true</b>\n
   /// The support of this is a pure option and not mandatory.
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Channel edit parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_supportsChannelEdit_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_supportsChannelEdit_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -1269,6 +1310,16 @@ class CInstancePVRClient : public IAddonInstance
   /// @remarks Only used by Kodi if @ref PVRCapabilities::SetSupportsEPG "supportsEPG"
   /// is set to true.\n\n
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **EPG parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_EPGTag_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_EPGTag_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -1546,6 +1597,16 @@ class CInstancePVRClient : public IAddonInstance
   /// If a recordings changes after the initial import, or if a new one was added,
   /// then the add-on should call @ref TriggerRecordingUpdate().
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Recordings parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Recordings_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_Recordings_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -1884,6 +1945,16 @@ class CInstancePVRClient : public IAddonInstance
   /// If a timer changes after the initial import, or if a new one was added,
   /// then the add-on should call @ref TriggerTimerUpdate().
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Timer parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Timers_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_Timers_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -2052,6 +2123,16 @@ class CInstancePVRClient : public IAddonInstance
   /// @brief **Used to notify the pvr addon for power management events**\n
   /// Used to allow any energy savings.
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Power management events in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_PowerManagement_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_PowerManagement_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -2108,6 +2189,16 @@ class CInstancePVRClient : public IAddonInstance
   /// @brief **PVR TV stream**\n
   /// Stream processing regarding live TV.
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **TV stream parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Streams_TV_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_Streams_TV_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -2193,6 +2284,16 @@ class CInstancePVRClient : public IAddonInstance
   /// This is only on Live TV streams and only if @ref PVRCapabilities::SetHandlesDemuxing()
   /// has been set to "true".
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Stream demuxing parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Streams_TV_Demux_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_Streams_TV_Demux_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -2345,6 +2446,16 @@ class CInstancePVRClient : public IAddonInstance
   ///
   /// @note Demuxing is not possible with the recordings.
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Recording stream parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Streams_Recording_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_Streams_Recording_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
@@ -2423,6 +2534,16 @@ class CInstancePVRClient : public IAddonInstance
   /// These apply to all other groups in inputstream and are therefore declared
   /// as several.
   ///
+  ///
+  ///---------------------------------------------------------------------------
+  ///
+  /// **Various stream parts in interface:**\n
+  /// Copy this to your project and extend with your parts or leave functions
+  /// complete away where not used or supported.
+  ///
+  /// @copydetails cpp_kodi_addon_pvr_Streams_Various_header_addon_auto_check
+  /// @copydetails cpp_kodi_addon_pvr_Streams_Various_source_addon_auto_check
+  ///
   ///@{
 
   //============================================================================
diff --git a/xbmc/addons/kodi-addon-dev-kit/tools/doxygen-header-class-list-creator.py b/xbmc/addons/kodi-addon-dev-kit/tools/doxygen-header-class-list-creator.py
new file mode 100755
index 000000000000..497a4b63d7d5
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/tools/doxygen-header-class-list-creator.py
@@ -0,0 +1,190 @@
+#!/usr/bin/python3
+
+from optparse import OptionParser
+import glob
+import io
+import os
+import re
+import sys
+
+def read_file(name, normalize=True):
+  """ Read a file. """
+  try:
+    with open(name, 'r', encoding='utf-8') as f:
+      # read the data
+      data = f.read()
+      if normalize:
+        # normalize line endings
+        data = data.replace("\r\n", "\n")
+      return data
+  except IOError as e:
+    (errno, strerror) = e.args
+    sys.stderr.write('Failed to read file ' + name + ': ' + strerror)
+    raise
+
+def write_file(name, data):
+  """ Write a file. """
+  try:
+    with open(name, 'w', encoding='utf-8') as f:
+      # write the data
+      if sys.version_info.major == 2:
+        f.write(data.decode('utf-8'))
+      else:
+        f.write(data)
+  except IOError as e:
+    (errno, strerror) = e.args
+    sys.stderr.write('Failed to write file ' + name + ': ' + strerror)
+    raise
+
+def auto_check_header(file):
+  groups_to_check = []
+
+  data = read_file(file)
+  if not 'addon_auto_check' in data:
+    return ''
+
+  for line in io.StringIO(data):
+    line = re.search(r"^.*\/\/\/.*@copydetails *(.*)(_header|_source)_addon_auto_check.*", line, flags=re.UNICODE)
+    if line and line.group(1):
+      group = line.group(1)
+      if group in groups_to_check:
+        continue
+
+      print(' - Found use with %s' % group)
+      groups_to_check.append(line.group(1))
+
+  return groups_to_check
+
+def parse_header(file, group, new_path=''):
+  header_sources = ''
+  header_addon = ''
+  source_addon = ''
+
+  data = read_file(file)
+  group_found = False
+  group_start = False
+  virtual_function_start = False
+  for line in io.StringIO(data):
+    if not group_found and 'defgroup ' + group in line:
+      group_found = True
+      continue
+    elif group_found and not group_start and '///@{' in line:
+      group_start = True
+      continue
+    elif group_start and '///@}' in line:
+      break
+    elif re.match(r'^.*//.*', line) or re.match(r'^.*//.*', line) or line == '\n' or not group_start:
+      continue
+
+    if re.match(r'^.*virtual.*', line):
+      virtual_function_start = True
+
+    if virtual_function_start:
+      header_sources += re.sub(r"^\s+", "", line, flags=re.UNICODE)
+
+    if virtual_function_start and re.match(r'^.*}.*', line):
+      virtual_function_start = False
+
+  if not group_found:
+    return ""
+
+  header_sources = header_sources.replace("\n", "")
+  header_sources = " ".join(re.split("\s+", header_sources, flags=re.UNICODE))
+  header_sources = header_sources.replace("}", "}\n")
+  header_sources = header_sources.replace("= 0;", "= 0;\n")
+  header_sources = header_sources.replace(",", ", ")
+
+  # Generate class header part of list
+  header_addon += '/// @defgroup ' + group + '_header_addon_auto_check Group header include\n'
+  header_addon += '/// @ingroup ' + group + '\n'
+  header_addon += '///@{\n'
+  header_addon += '/// *Header parts:*\n'
+  header_addon += '/// ~~~~~~~~~~~~~{.cpp}\n'
+  header_addon += '///\n'
+  for line in io.StringIO(header_sources):
+    line = re.search(r"^.*virtual.([A-Za-z1-9].*\(.*\))", line, flags=re.UNICODE)
+    if line:
+      header_addon += '/// ' + re.sub(' +', ' ', line.group(1)) + ' override;\n'
+  header_addon += '///\n'
+  header_addon += '/// ~~~~~~~~~~~~~\n'
+  header_addon += '///@}\n\n'
+
+  # Generate class source part of list
+  source_addon += '/// @defgroup ' + group + '_source_addon_auto_check Group source include\n'
+  source_addon += '/// @ingroup ' + group + '\n'
+  source_addon += '///@{\n'
+  source_addon += '/// *Source parts:*\n'
+  source_addon += '/// ~~~~~~~~~~~~~{.cpp}\n'
+  source_addon += '///\n'
+  for line in io.StringIO(header_sources):
+    line = line.replace("{", "\n{\n  ")
+    line = line.replace("}", "\n}")
+    for line in io.StringIO(line + '\n'):
+      func = re.search(r"^.*(virtual *) *(.*) ([a-z|A-Z|0-9].*)(\(.*\))", line, flags=re.UNICODE)
+      if func:
+        source_addon += '/// ' + re.sub(' +', ' ', func.group(2) + ' CMyInstance::' + func.group(3) + func.group(4) + '\n')
+      else:
+        source_addon += '/// ' + line
+      if '= 0' in line:
+        source_addon += '/// {\n'
+        source_addon += '///   // Required in interface to have!\n'
+        source_addon += '///   // ...\n'
+        source_addon += '/// }\n'
+
+  source_addon += '/// ~~~~~~~~~~~~~\n'
+  source_addon += '///@}\n\n'
+
+  return header_addon + source_addon
+
+def print_error(msg):
+  print('Error: %s\nSee --help for usage.' % msg)
+
+# cannot be loaded as a module
+if __name__ != "__main__":
+  sys.stderr.write('This file cannot be loaded as a module!')
+  sys.exit()
+
+# parse command-line options
+disc = """
+This utility generate group list about addon header sources to add inside doxygen.
+"""
+
+parser = OptionParser(description=disc)
+parser.add_option(
+    '--header-file',
+    dest='headerfile',
+    metavar='DIR',
+    help='the to checked header [required]')
+parser.add_option(
+    '--doxygen-group',
+    dest='doxygengroup',
+    help='the to checked doxygen group inside header [required]')
+(options, args) = parser.parse_args()
+
+docs = ''
+groups_to_check = []
+
+# Check about use of helper docs
+if options.doxygengroup is None:
+  print('Scaning about used places...')
+  headers = glob.glob("../include/kodi/**/*.h", recursive=True)
+  for header in headers:
+    group = auto_check_header(header)
+    if group:
+      groups_to_check += group
+else:
+  groups_to_check.append(options.doxygengroup)
+
+# Generate the helper docs
+if options.headerfile is None:
+  headers = glob.glob("../include/kodi/**/*.h", recursive=True)
+  print('Parsing about docs:')
+  for header in headers:
+    print(' - %s' % header)
+    for group in groups_to_check:
+      docs += parse_header(header, group)
+else:
+  for group in groups_to_check:
+    docs += parse_header(options.headerfile, group)
+
+write_file("../include/groups.dox", docs)
