From 6d64f86449a0c984e3d6ca4e67024039ff3cbd30 Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Tue, 26 May 2020 17:40:07 -0700
Subject: [PATCH 1/7] [clang-format] Enable comment reflow

---
 .clang-format | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.clang-format b/.clang-format
index c70b27c2afdf..4a7f704f03ea 100644
--- a/.clang-format
+++ b/.clang-format
@@ -71,7 +71,7 @@ PenaltyBreakString: 1000
 PenaltyExcessCharacter: 1000000
 PenaltyReturnTypeOnItsOwnLine: 60000
 PointerAlignment: Left
-ReflowComments:  false
+ReflowComments:  true
 SortIncludes:    true
 SpaceAfterCStyleCast: false
 SpaceAfterTemplateKeyword: false

From 838cf16f17a7fcf5d49ac0b3d51d9826a9fb7a6e Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Tue, 26 May 2020 17:41:25 -0700
Subject: [PATCH 2/7] RetroPlayer: Clang-format files

---
 xbmc/cores/RetroPlayer/RetroPlayer.cpp        |  98 ++---
 xbmc/cores/RetroPlayer/RetroPlayer.h          | 214 +++++------
 .../cores/RetroPlayer/RetroPlayerAutoSave.cpp |  13 +-
 xbmc/cores/RetroPlayer/RetroPlayerAutoSave.h  |  61 ++-
 xbmc/cores/RetroPlayer/RetroPlayerDefines.h   |   4 +-
 xbmc/cores/RetroPlayer/RetroPlayerInput.cpp   |   4 +-
 xbmc/cores/RetroPlayer/RetroPlayerInput.h     |  48 +--
 xbmc/cores/RetroPlayer/RetroPlayerTypes.h     |  10 +-
 xbmc/cores/RetroPlayer/RetroPlayerUtils.cpp   |   2 +-
 xbmc/cores/RetroPlayer/RetroPlayerUtils.h     |  50 +--
 .../RetroPlayer/audio/AudioTranslator.cpp     |  71 ++--
 .../cores/RetroPlayer/audio/AudioTranslator.h |  36 +-
 .../RetroPlayer/buffers/BaseRenderBuffer.cpp  |   3 +-
 .../RetroPlayer/buffers/BaseRenderBuffer.h    |  36 +-
 .../buffers/BaseRenderBufferPool.cpp          |  23 +-
 .../buffers/BaseRenderBufferPool.h            |  78 ++--
 .../cores/RetroPlayer/buffers/IRenderBuffer.h |  81 ++--
 .../RetroPlayer/buffers/IRenderBufferPool.h   |  79 ++--
 .../RetroPlayer/buffers/RenderBufferDMA.cpp   |   4 +-
 .../RetroPlayer/buffers/RenderBufferDMA.h     |  70 ++--
 .../buffers/RenderBufferManager.cpp           |  30 +-
 .../RetroPlayer/buffers/RenderBufferManager.h |  48 +--
 .../buffers/RenderBufferOpenGL.cpp            |  13 +-
 .../RetroPlayer/buffers/RenderBufferOpenGL.h  |  55 ++-
 .../buffers/RenderBufferOpenGLES.cpp          |  20 +-
 .../buffers/RenderBufferOpenGLES.h            |  66 ++--
 .../RetroPlayer/buffers/RenderBufferPoolDMA.h |  58 +--
 .../buffers/RenderBufferPoolOpenGL.cpp        |  61 ++-
 .../buffers/RenderBufferPoolOpenGL.h          |  52 +--
 .../buffers/RenderBufferPoolOpenGLES.cpp      |  75 ++--
 .../buffers/RenderBufferPoolOpenGLES.h        |  56 +--
 .../buffers/video/RenderBufferGuiTexture.cpp  |  32 +-
 .../buffers/video/RenderBufferGuiTexture.h    |  56 +--
 .../buffers/video/RenderBufferSysMem.cpp      |   6 +-
 .../buffers/video/RenderBufferSysMem.h        |  35 +-
 .../guibridge/GUIGameRenderManager.cpp        |  67 ++--
 .../guibridge/GUIGameRenderManager.h          | 276 +++++++-------
 .../RetroPlayer/guibridge/GUIGameSettings.cpp |  21 +-
 .../RetroPlayer/guibridge/GUIGameSettings.h   |  47 ++-
 .../guibridge/GUIGameSettingsHandle.cpp       |   4 +-
 .../guibridge/GUIGameSettingsHandle.h         |  26 +-
 .../guibridge/GUIGameVideoHandle.cpp          |   4 +-
 .../guibridge/GUIGameVideoHandle.h            |  30 +-
 .../RetroPlayer/guibridge/GUIRenderHandle.cpp |  17 +-
 .../RetroPlayer/guibridge/GUIRenderHandle.h   | 124 +++---
 .../RetroPlayer/guibridge/GUIRenderTarget.cpp |  22 +-
 .../RetroPlayer/guibridge/GUIRenderTarget.h   | 152 ++++----
 .../guibridge/GUIRenderTargetFactory.cpp      |   8 +-
 .../guibridge/GUIRenderTargetFactory.h        |  44 +--
 .../guibridge/IGUIRenderSettings.h            |  78 ++--
 .../RetroPlayer/guibridge/IGameCallback.h     |  26 +-
 .../RetroPlayer/guibridge/IRenderCallback.h   |  18 +-
 .../guicontrols/GUIGameControl.cpp            |  37 +-
 .../RetroPlayer/guicontrols/GUIGameControl.h  |  20 +-
 .../guicontrols/GUIRenderSettings.cpp         |   7 +-
 .../guicontrols/GUIRenderSettings.h           |  72 ++--
 .../guiplayback/GUIPlaybackControl.cpp        | 109 +++---
 .../guiplayback/GUIPlaybackControl.h          |  68 ++--
 .../guiwindows/GameWindowFullScreen.cpp       | 101 ++---
 .../guiwindows/GameWindowFullScreen.h         |  84 ++---
 .../guiwindows/GameWindowFullScreenText.cpp   |  23 +-
 .../guiwindows/GameWindowFullScreenText.h     | 104 ++---
 xbmc/cores/RetroPlayer/playback/GameLoop.cpp  |  20 +-
 xbmc/cores/RetroPlayer/playback/GameLoop.h    |  80 ++--
 xbmc/cores/RetroPlayer/playback/IPlayback.h   |  48 +--
 .../RetroPlayer/playback/IPlaybackControl.h   |  62 +--
 .../RetroPlayer/playback/RealtimePlayback.h   |  42 +--
 .../playback/ReversiblePlayback.cpp           |  53 +--
 .../RetroPlayer/playback/ReversiblePlayback.h | 104 +++--
 .../RetroPlayer/process/RPProcessInfo.cpp     |  58 +--
 .../cores/RetroPlayer/process/RPProcessInfo.h | 329 ++++++++--------
 .../process/X11/RPProcessInfoX11.cpp          |   3 +-
 .../process/X11/RPProcessInfoX11.h            |  18 +-
 .../process/android/RPProcessInfoAndroid.cpp  |   3 +-
 .../process/android/RPProcessInfoAndroid.h    |  18 +-
 .../process/gbm/RPProcessInfoGbm.cpp          |   3 +-
 .../process/gbm/RPProcessInfoGbm.h            |  18 +-
 .../process/ios/RPProcessInfoIOS.cpp          |   3 +-
 .../process/ios/RPProcessInfoIOS.h            |  18 +-
 .../process/osx/RPProcessInfoOSX.cpp          |   3 +-
 .../process/osx/RPProcessInfoOSX.h            |  18 +-
 .../process/rbpi/RPProcessInfoPi.cpp          |   3 +-
 .../process/rbpi/RPProcessInfoPi.h            |  18 +-
 .../process/wayland/RPProcessInfoWayland.cpp  |   3 +-
 .../process/wayland/RPProcessInfoWayland.h    |  18 +-
 .../process/windows/RPProcessInfoWin.cpp      |   3 +-
 .../process/windows/RPProcessInfoWin.h        |  18 +-
 .../RetroPlayer/rendering/IRenderManager.h    |  67 ++--
 .../RetroPlayer/rendering/RPRenderManager.cpp | 158 ++++----
 .../RetroPlayer/rendering/RPRenderManager.h   | 356 ++++++++++--------
 .../RetroPlayer/rendering/RenderContext.cpp   |  82 ++--
 .../RetroPlayer/rendering/RenderContext.h     | 120 +++---
 .../RetroPlayer/rendering/RenderSettings.cpp  |  10 +-
 .../RetroPlayer/rendering/RenderSettings.h    |  28 +-
 .../rendering/RenderTranslator.cpp            |  66 ++--
 .../RetroPlayer/rendering/RenderTranslator.h  |  46 +--
 .../RetroPlayer/rendering/RenderUtils.cpp     | 206 +++++-----
 .../cores/RetroPlayer/rendering/RenderUtils.h |  46 ++-
 .../rendering/RenderVideoSettings.cpp         |  43 ++-
 .../rendering/RenderVideoSettings.h           |  70 ++--
 .../VideoRenderers/RPBaseRenderer.cpp         |  42 +--
 .../rendering/VideoRenderers/RPBaseRenderer.h | 179 ++++-----
 .../VideoRenderers/RPRendererDMA.cpp          |  13 +-
 .../rendering/VideoRenderers/RPRendererDMA.h  |  44 +--
 .../VideoRenderers/RPRendererGuiTexture.cpp   |  57 +--
 .../VideoRenderers/RPRendererGuiTexture.h     |  90 ++---
 .../VideoRenderers/RPRendererOpenGL.cpp       | 141 +++----
 .../VideoRenderers/RPRendererOpenGL.h         | 132 +++----
 .../VideoRenderers/RPRendererOpenGLES.cpp     | 139 +++----
 .../VideoRenderers/RPRendererOpenGLES.h       |  88 ++---
 .../VideoRenderers/RPWinRenderer.cpp          |  86 +++--
 .../rendering/VideoRenderers/RPWinRenderer.h  | 167 ++++----
 .../windows/RPWinOutputShader.cpp             |  48 +--
 .../VideoShaders/windows/RPWinOutputShader.h  |  37 +-
 .../cores/RetroPlayer/savestates/ISavestate.h | 216 +++++------
 .../savestates/SavestateDatabase.cpp          |  20 +-
 .../savestates/SavestateDatabase.h            |  34 +-
 .../savestates/SavestateFlatBuffer.cpp        |  95 ++---
 .../savestates/SavestateFlatBuffer.h          | 134 +++----
 .../RetroPlayer/savestates/SavestateTypes.h   |  28 +-
 .../RetroPlayer/savestates/SavestateUtils.cpp |   4 +-
 .../RetroPlayer/savestates/SavestateUtils.h   |  26 +-
 .../RetroPlayer/streams/IRetroPlayerStream.h  |   4 +-
 .../RetroPlayer/streams/IStreamManager.h      |   4 +-
 .../RetroPlayer/streams/RPStreamManager.cpp   |  39 +-
 .../RetroPlayer/streams/RPStreamManager.h     |  52 +--
 .../RetroPlayer/streams/RetroPlayerAudio.cpp  |  28 +-
 .../RetroPlayer/streams/RetroPlayerAudio.h    |  77 ++--
 .../streams/RetroPlayerStreamTypes.h          |   8 +-
 .../RetroPlayer/streams/RetroPlayerVideo.cpp  |  60 ++-
 .../RetroPlayer/streams/RetroPlayerVideo.h    | 128 ++++---
 .../streams/memory/BasicMemoryStream.h        |  54 +--
 .../streams/memory/DeltaPairMemoryStream.cpp  |   6 +-
 .../streams/memory/DeltaPairMemoryStream.h    |  82 ++--
 .../streams/memory/IMemoryStream.h            | 234 ++++++------
 .../streams/memory/LinearMemoryStream.cpp     |   2 +-
 .../streams/memory/LinearMemoryStream.h       |  84 ++---
 137 files changed, 4161 insertions(+), 4020 deletions(-)

diff --git a/xbmc/cores/RetroPlayer/RetroPlayer.cpp b/xbmc/cores/RetroPlayer/RetroPlayer.cpp
index 5ff265a62d6f..cadbeae545f6 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayer.cpp
+++ b/xbmc/cores/RetroPlayer/RetroPlayer.cpp
@@ -52,9 +52,8 @@ using namespace KODI;
 using namespace GAME;
 using namespace RETRO;
 
-CRetroPlayer::CRetroPlayer(IPlayerCallback& callback) :
-  IPlayer(callback),
-  m_gameServices(CServiceBroker::GetGameServices())
+CRetroPlayer::CRetroPlayer(IPlayerCallback& callback)
+  : IPlayer(callback), m_gameServices(CServiceBroker::GetGameServices())
 {
   ResetPlayback();
   CServiceBroker::GetWinSystem()->RegisterRenderLoop(this);
@@ -74,7 +73,8 @@ bool CRetroPlayer::OpenFile(const CFileItem& file, const CPlayerOptions& options
   // Currently this may prompt the user, the goal is to figure this out silently
   if (!GAME::CGameUtils::FillInGameClient(fileCopy, true))
   {
-    CLog::Log(LOGINFO, "RetroPlayer[PLAYER]: No compatible game client selected, aborting playback");
+    CLog::Log(LOGINFO,
+              "RetroPlayer[PLAYER]: No compatible game client selected, aborting playback");
     return false;
   }
 
@@ -111,7 +111,8 @@ bool CRetroPlayer::OpenFile(const CFileItem& file, const CPlayerOptions& options
   }
   else if (!CServiceBroker::GetAddonMgr().GetAddon(gameClientId, addon, ADDON::ADDON_GAMEDLL))
   {
-    CLog::Log(LOGERROR, "RetroPlayer[PLAYER]: Can't find add-on %s for game file!", gameClientId.c_str());
+    CLog::Log(LOGERROR, "RetroPlayer[PLAYER]: Can't find add-on %s for game file!",
+              gameClientId.c_str());
   }
   else
   {
@@ -137,7 +138,8 @@ bool CRetroPlayer::OpenFile(const CFileItem& file, const CPlayerOptions& options
       if (bSuccess)
         CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Using game client %s", gameClientId.c_str());
       else
-        CLog::Log(LOGERROR, "RetroPlayer[PLAYER]: Failed to open file using %s", gameClientId.c_str());
+        CLog::Log(LOGERROR, "RetroPlayer[PLAYER]: Failed to open file using %s",
+                  gameClientId.c_str());
     }
     else
       CLog::Log(LOGERROR, "RetroPlayer[PLAYER]: Failed to initialize %s", gameClientId.c_str());
@@ -159,7 +161,9 @@ bool CRetroPlayer::OpenFile(const CFileItem& file, const CPlayerOptions& options
           // Warn the user that continuing with a different game client will
           // overwrite the save
           bool dummy;
-          if (!CGUIDialogYesNo::ShowAndGetInput(438, StringUtils::Format(g_localizeStrings.Get(35217), addon->Name()), dummy, 222, 35218, 0))
+          if (!CGUIDialogYesNo::ShowAndGetInput(
+                  438, StringUtils::Format(g_localizeStrings.Get(35217), addon->Name()), dummy, 222,
+                  35218, 0))
             bSuccess = false;
         }
       }
@@ -211,7 +215,8 @@ bool CRetroPlayer::CloseFile(bool reopen /* = false */)
   {
     std::string savePath = m_playback->CreateSavestate();
     if (!savePath.empty())
-      CLog::Log(LOGDEBUG, "RetroPlayer[SAVE]: Saved state to %s", CURL::GetRedacted(savePath).c_str());
+      CLog::Log(LOGDEBUG, "RetroPlayer[SAVE]: Saved state to %s",
+                CURL::GetRedacted(savePath).c_str());
     else
       CLog::Log(LOGDEBUG, "RetroPlayer[SAVE]: Failed to save state at close");
   }
@@ -303,7 +308,7 @@ void CRetroPlayer::SeekPercentage(float fPercent /* = 0 */)
   if (!CanSeek())
     return;
 
-  if (fPercent < 0.0f  )
+  if (fPercent < 0.0f)
     fPercent = 0.0f;
   else if (fPercent > 100.0f)
     fPercent = 100.0f;
@@ -386,40 +391,40 @@ void CRetroPlayer::SetSpeed(float speed)
   }
 }
 
-bool CRetroPlayer::OnAction(const CAction &action)
+bool CRetroPlayer::OnAction(const CAction& action)
 {
   switch (action.GetID())
   {
-  case ACTION_PLAYER_RESET:
-  {
-    if (m_gameClient)
+    case ACTION_PLAYER_RESET:
     {
-      float speed = static_cast<float>(m_playback->GetSpeed());
+      if (m_gameClient)
+      {
+        float speed = static_cast<float>(m_playback->GetSpeed());
 
-      m_playback->SetSpeed(0.0);
+        m_playback->SetSpeed(0.0);
 
-      CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Sending reset command via ACTION_PLAYER_RESET");
-      m_gameClient->Input().HardwareReset();
+        CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Sending reset command via ACTION_PLAYER_RESET");
+        m_gameClient->Input().HardwareReset();
 
-      // If rewinding or paused, begin playback
-      if (speed <= 0.0f)
-        speed = 1.0f;
+        // If rewinding or paused, begin playback
+        if (speed <= 0.0f)
+          speed = 1.0f;
 
-      SetSpeed(speed);
+        SetSpeed(speed);
+      }
+      return true;
     }
-    return true;
-  }
-  case ACTION_SHOW_OSD:
-  {
-    if (m_gameClient)
+    case ACTION_SHOW_OSD:
     {
-      CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Closing OSD via ACTION_SHOW_OSD");
-      CloseOSD();
-      return true;
+      if (m_gameClient)
+      {
+        CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Closing OSD via ACTION_SHOW_OSD");
+        CloseOSD();
+        return true;
+      }
     }
-  }
-  default:
-    break;
+    default:
+      break;
   }
 
   return false;
@@ -492,19 +497,15 @@ void CRetroPlayer::SetPlaybackSpeed(double speed)
     {
       if (speed == 1.0)
       {
-        IPlayerCallback *callback = &m_callback;
-        CJobManager::GetInstance().Submit([callback]()
-          {
-            callback->OnPlayBackResumed();
-          }, CJob::PRIORITY_NORMAL);
+        IPlayerCallback* callback = &m_callback;
+        CJobManager::GetInstance().Submit([callback]() { callback->OnPlayBackResumed(); },
+                                          CJob::PRIORITY_NORMAL);
       }
       else if (speed == 0.0)
       {
-        IPlayerCallback *callback = &m_callback;
-        CJobManager::GetInstance().Submit([callback]()
-          {
-            callback->OnPlayBackPaused();
-          }, CJob::PRIORITY_NORMAL);
+        IPlayerCallback* callback = &m_callback;
+        CJobManager::GetInstance().Submit([callback]() { callback->OnPlayBackPaused(); },
+                                          CJob::PRIORITY_NORMAL);
       }
     }
   }
@@ -551,7 +552,8 @@ void CRetroPlayer::CreatePlayback(bool bRestoreState)
   if (m_gameClient->RequiresGameLoop())
   {
     m_playback->Deinitialize();
-    m_playback.reset(new CReversiblePlayback(m_gameClient.get(), m_gameClient->GetFrameRate(), m_gameClient->GetSerializeSize()));
+    m_playback.reset(new CReversiblePlayback(m_gameClient.get(), m_gameClient->GetFrameRate(),
+                                             m_gameClient->GetSerializeSize()));
   }
   else
     ResetPlayback();
@@ -593,8 +595,7 @@ void CRetroPlayer::CloseOSD()
 void CRetroPlayer::RegisterWindowCallbacks()
 {
   m_gameServices.GameRenderManager().RegisterPlayer(m_renderManager->GetGUIRenderTargetFactory(),
-                                                    m_renderManager.get(),
-                                                    this);
+                                                    m_renderManager.get(), this);
 }
 
 void CRetroPlayer::UnregisterWindowCallbacks()
@@ -602,9 +603,9 @@ void CRetroPlayer::UnregisterWindowCallbacks()
   m_gameServices.GameRenderManager().UnregisterPlayer();
 }
 
-void CRetroPlayer::PrintGameInfo(const CFileItem &file) const
+void CRetroPlayer::PrintGameInfo(const CFileItem& file) const
 {
-  const CGameInfoTag *tag = file.GetGameInfoTag();
+  const CGameInfoTag* tag = file.GetGameInfoTag();
   if (tag)
   {
     CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: ---------------------------------------");
@@ -612,7 +613,8 @@ void CRetroPlayer::PrintGameInfo(const CFileItem &file) const
     CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: URL: %s", tag->GetURL().c_str());
     CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Title: %s", tag->GetTitle().c_str());
     CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Platform: %s", tag->GetPlatform().c_str());
-    CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Genres: %s", StringUtils::Join(tag->GetGenres(), ", ").c_str());
+    CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Genres: %s",
+              StringUtils::Join(tag->GetGenres(), ", ").c_str());
     CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Developer: %s", tag->GetDeveloper().c_str());
     if (tag->GetYear() > 0)
       CLog::Log(LOGDEBUG, "RetroPlayer[PLAYER]: Year: %u", tag->GetYear());
diff --git a/xbmc/cores/RetroPlayer/RetroPlayer.h b/xbmc/cores/RetroPlayer/RetroPlayer.h
index b6e1728d8e66..d1abd81b6b91 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayer.h
+++ b/xbmc/cores/RetroPlayer/RetroPlayer.h
@@ -22,114 +22,114 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameServices;
+class CGameServices;
 }
 
 namespace RETRO
 {
-  class CRetroPlayerInput;
-  class CRPProcessInfo;
-  class CRPRenderManager;
-  class CRPStreamManager;
-  class IPlayback;
-
-  class CRetroPlayer : public IPlayer,
-                       public IRenderLoop,
-                       public IGameCallback,
-                       public IPlaybackCallback,
-                       public IAutoSaveCallback
-  {
-  public:
-    explicit CRetroPlayer(IPlayerCallback& callback);
-    ~CRetroPlayer() override;
-
-    // implementation of IPlayer
-    bool OpenFile(const CFileItem& file, const CPlayerOptions& options) override;
-    bool CloseFile(bool reopen = false) override;
-    bool IsPlaying() const override;
-    bool CanPause() override;
-    void Pause() override;
-    bool HasVideo() const override { return true; }
-    bool HasAudio() const override { return true; }
-    bool HasGame() const override { return true; }
-    bool CanSeek() override;
-    void Seek(bool bPlus = true, bool bLargeStep = false, bool bChapterOverride = false) override;
-    void SeekPercentage(float fPercent = 0) override;
-    float GetCachePercentage() override;
-    void SetMute(bool bOnOff) override;
-    void SeekTime(int64_t iTime = 0) override;
-    bool SeekTimeRelative(int64_t iTime) override;
-    void SetSpeed(float speed) override;
-    bool OnAction(const CAction &action) override;
-    std::string GetPlayerState() override;
-    bool SetPlayerState(const std::string& state) override;
-    void FrameMove() override;
-    void Render(bool clear, uint32_t alpha = 255, bool gui = true) override;
-    bool IsRenderingVideo() override;
-    bool HasGameAgent() override;
-
-    // Implementation of IGameCallback
-    std::string GameClientID() const override;
-
-    // Implementation of IPlaybackCallback
-    void SetPlaybackSpeed(double speed) override;
-    void EnableInput(bool bEnable) override;
-
-    // Implementation of IAutoSaveCallback
-    bool IsAutoSaveEnabled() const override;
-    std::string CreateSavestate() override;
-
-  private:
-    void SetSpeedInternal(double speed);
-
-    /*!
-     * \brief Called when the speed changes
-     * \param newSpeed The new speed, possibly equal to the previous speed
-     */
-    void OnSpeedChange(double newSpeed);
-
-    // Playback functions
-    void CreatePlayback(bool bRestoreState);
-    void ResetPlayback();
-
-    /*!
-     * \brief Opens the OSD
-     */
-    void OpenOSD();
-
-    /*!
-     * \brief Closes the OSD and shows the FullscreenGame window
-     */
-    void CloseOSD();
-
-    void RegisterWindowCallbacks();
-    void UnregisterWindowCallbacks();
-
-    /**
-     * \brief Dump game information (if any) to the debug log.
-     */
-    void PrintGameInfo(const CFileItem &file) const;
-
-    uint64_t GetTime();
-    uint64_t GetTotalTime();
-
-    // Construction parameters
-    GAME::CGameServices &m_gameServices;
-
-    // Subsystems
-    std::unique_ptr<CRPProcessInfo>    m_processInfo;
-    std::unique_ptr<CRPRenderManager>  m_renderManager;
-    std::unique_ptr<CRPStreamManager>  m_streamManager;
-    std::unique_ptr<CRetroPlayerInput> m_input;
-    std::unique_ptr<IPlayback>         m_playback;
-    std::unique_ptr<IPlaybackControl> m_playbackControl;
-    std::unique_ptr<CRetroPlayerAutoSave> m_autoSave;
-
-    // Game parameters
-    GAME::GameClientPtr                m_gameClient;
-
-    // Synchronization parameters
-    CCriticalSection                   m_mutex;
-  };
-}
-}
+class CRetroPlayerInput;
+class CRPProcessInfo;
+class CRPRenderManager;
+class CRPStreamManager;
+class IPlayback;
+
+class CRetroPlayer : public IPlayer,
+                     public IRenderLoop,
+                     public IGameCallback,
+                     public IPlaybackCallback,
+                     public IAutoSaveCallback
+{
+public:
+  explicit CRetroPlayer(IPlayerCallback& callback);
+  ~CRetroPlayer() override;
+
+  // implementation of IPlayer
+  bool OpenFile(const CFileItem& file, const CPlayerOptions& options) override;
+  bool CloseFile(bool reopen = false) override;
+  bool IsPlaying() const override;
+  bool CanPause() override;
+  void Pause() override;
+  bool HasVideo() const override { return true; }
+  bool HasAudio() const override { return true; }
+  bool HasGame() const override { return true; }
+  bool CanSeek() override;
+  void Seek(bool bPlus = true, bool bLargeStep = false, bool bChapterOverride = false) override;
+  void SeekPercentage(float fPercent = 0) override;
+  float GetCachePercentage() override;
+  void SetMute(bool bOnOff) override;
+  void SeekTime(int64_t iTime = 0) override;
+  bool SeekTimeRelative(int64_t iTime) override;
+  void SetSpeed(float speed) override;
+  bool OnAction(const CAction& action) override;
+  std::string GetPlayerState() override;
+  bool SetPlayerState(const std::string& state) override;
+  void FrameMove() override;
+  void Render(bool clear, uint32_t alpha = 255, bool gui = true) override;
+  bool IsRenderingVideo() override;
+  bool HasGameAgent() override;
+
+  // Implementation of IGameCallback
+  std::string GameClientID() const override;
+
+  // Implementation of IPlaybackCallback
+  void SetPlaybackSpeed(double speed) override;
+  void EnableInput(bool bEnable) override;
+
+  // Implementation of IAutoSaveCallback
+  bool IsAutoSaveEnabled() const override;
+  std::string CreateSavestate() override;
+
+private:
+  void SetSpeedInternal(double speed);
+
+  /*!
+   * \brief Called when the speed changes
+   * \param newSpeed The new speed, possibly equal to the previous speed
+   */
+  void OnSpeedChange(double newSpeed);
+
+  // Playback functions
+  void CreatePlayback(bool bRestoreState);
+  void ResetPlayback();
+
+  /*!
+   * \brief Opens the OSD
+   */
+  void OpenOSD();
+
+  /*!
+   * \brief Closes the OSD and shows the FullscreenGame window
+   */
+  void CloseOSD();
+
+  void RegisterWindowCallbacks();
+  void UnregisterWindowCallbacks();
+
+  /**
+   * \brief Dump game information (if any) to the debug log.
+   */
+  void PrintGameInfo(const CFileItem& file) const;
+
+  uint64_t GetTime();
+  uint64_t GetTotalTime();
+
+  // Construction parameters
+  GAME::CGameServices& m_gameServices;
+
+  // Subsystems
+  std::unique_ptr<CRPProcessInfo> m_processInfo;
+  std::unique_ptr<CRPRenderManager> m_renderManager;
+  std::unique_ptr<CRPStreamManager> m_streamManager;
+  std::unique_ptr<CRetroPlayerInput> m_input;
+  std::unique_ptr<IPlayback> m_playback;
+  std::unique_ptr<IPlaybackControl> m_playbackControl;
+  std::unique_ptr<CRetroPlayerAutoSave> m_autoSave;
+
+  // Game parameters
+  GAME::GameClientPtr m_gameClient;
+
+  // Synchronization parameters
+  CCriticalSection m_mutex;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/RetroPlayerAutoSave.cpp b/xbmc/cores/RetroPlayer/RetroPlayerAutoSave.cpp
index 70d202274383..6ba46bb03259 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayerAutoSave.cpp
+++ b/xbmc/cores/RetroPlayer/RetroPlayerAutoSave.cpp
@@ -15,13 +15,11 @@
 using namespace KODI;
 using namespace RETRO;
 
-#define AUTOSAVE_DURATION_SECS    10 // Auto-save every 10 seconds
+#define AUTOSAVE_DURATION_SECS 10 // Auto-save every 10 seconds
 
-CRetroPlayerAutoSave::CRetroPlayerAutoSave(IAutoSaveCallback &callback,
-                                           GAME::CGameSettings &settings) :
-  CThread("CRetroPlayerAutoSave"),
-  m_callback(callback),
-  m_settings(settings)
+CRetroPlayerAutoSave::CRetroPlayerAutoSave(IAutoSaveCallback& callback,
+                                           GAME::CGameSettings& settings)
+  : CThread("CRetroPlayerAutoSave"), m_callback(callback), m_settings(settings)
 {
   CLog::Log(LOGDEBUG, "RetroPlayer[SAVE]: Initializing autosave");
 
@@ -53,7 +51,8 @@ void CRetroPlayerAutoSave::Process()
     {
       std::string savePath = m_callback.CreateSavestate();
       if (!savePath.empty())
-        CLog::Log(LOGDEBUG, "RetroPlayer[SAVE]: Saved state to %s", CURL::GetRedacted(savePath).c_str());
+        CLog::Log(LOGDEBUG, "RetroPlayer[SAVE]: Saved state to %s",
+                  CURL::GetRedacted(savePath).c_str());
     }
   }
 
diff --git a/xbmc/cores/RetroPlayer/RetroPlayerAutoSave.h b/xbmc/cores/RetroPlayer/RetroPlayerAutoSave.h
index 831e85e18837..2a1d91474a2e 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayerAutoSave.h
+++ b/xbmc/cores/RetroPlayer/RetroPlayerAutoSave.h
@@ -16,37 +16,36 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameClient;
-  class CGameSettings;
-}
+class CGameClient;
+class CGameSettings;
+} // namespace GAME
 
 namespace RETRO
 {
-  class IAutoSaveCallback
-  {
-  public:
-    virtual ~IAutoSaveCallback() = default;
-
-    virtual bool IsAutoSaveEnabled() const = 0;
-    virtual std::string CreateSavestate() = 0;
-  };
-
-  class CRetroPlayerAutoSave : protected CThread
-  {
-  public:
-    explicit CRetroPlayerAutoSave(IAutoSaveCallback &callback,
-                                  GAME::CGameSettings &settings);
-
-    ~CRetroPlayerAutoSave() override;
-
-  protected:
-    // implementation of CThread
-    void Process() override;
-
-  private:
-    // Construction parameters
-    IAutoSaveCallback &m_callback;
-    GAME::CGameSettings &m_settings;
-  };
-}
-}
+class IAutoSaveCallback
+{
+public:
+  virtual ~IAutoSaveCallback() = default;
+
+  virtual bool IsAutoSaveEnabled() const = 0;
+  virtual std::string CreateSavestate() = 0;
+};
+
+class CRetroPlayerAutoSave : protected CThread
+{
+public:
+  explicit CRetroPlayerAutoSave(IAutoSaveCallback& callback, GAME::CGameSettings& settings);
+
+  ~CRetroPlayerAutoSave() override;
+
+protected:
+  // implementation of CThread
+  void Process() override;
+
+private:
+  // Construction parameters
+  IAutoSaveCallback& m_callback;
+  GAME::CGameSettings& m_settings;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/RetroPlayerDefines.h b/xbmc/cores/RetroPlayer/RetroPlayerDefines.h
index b23ac3fd518b..4d84641b44ac 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayerDefines.h
+++ b/xbmc/cores/RetroPlayer/RetroPlayerDefines.h
@@ -8,5 +8,5 @@
 
 #pragma once
 
-#define GAME_STREAM_VIDEO_ID  1
-#define GAME_STREAM_AUDIO_ID  2
+#define GAME_STREAM_VIDEO_ID 1
+#define GAME_STREAM_AUDIO_ID 2
diff --git a/xbmc/cores/RetroPlayer/RetroPlayerInput.cpp b/xbmc/cores/RetroPlayer/RetroPlayerInput.cpp
index 6022fffcefa9..742767535827 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayerInput.cpp
+++ b/xbmc/cores/RetroPlayer/RetroPlayerInput.cpp
@@ -15,8 +15,8 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRetroPlayerInput::CRetroPlayerInput(PERIPHERALS::CPeripherals &peripheralManager) :
-  m_peripheralManager(peripheralManager)
+CRetroPlayerInput::CRetroPlayerInput(PERIPHERALS::CPeripherals& peripheralManager)
+  : m_peripheralManager(peripheralManager)
 {
   CLog::Log(LOGDEBUG, "RetroPlayer[INPUT]: Initializing input");
 
diff --git a/xbmc/cores/RetroPlayer/RetroPlayerInput.h b/xbmc/cores/RetroPlayer/RetroPlayerInput.h
index 98066e2220d0..c551af81b3a3 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayerInput.h
+++ b/xbmc/cores/RetroPlayer/RetroPlayerInput.h
@@ -13,33 +13,33 @@
 
 namespace PERIPHERALS
 {
-  class CPeripherals;
+class CPeripherals;
 }
 
 namespace KODI
 {
 namespace RETRO
 {
-  class CRetroPlayerInput : public GAME::IGameInputCallback
-  {
-  public:
-    CRetroPlayerInput(PERIPHERALS::CPeripherals &peripheralManager);
-    ~CRetroPlayerInput() override;
-
-    void SetSpeed(double speed);
-    void EnableInput(bool bEnabled);
-
-    // implementation of IGameInputCallback
-    bool AcceptsInput() const override { return m_bEnabled; }
-    void PollInput() override;
-
-  private:
-    // Construction parameters
-    PERIPHERALS::CPeripherals &m_peripheralManager;
-
-    // Input variables
-    PERIPHERALS::EventPollHandlePtr m_inputPollHandle;
-    bool m_bEnabled = false;
-  };
-}
-}
+class CRetroPlayerInput : public GAME::IGameInputCallback
+{
+public:
+  CRetroPlayerInput(PERIPHERALS::CPeripherals& peripheralManager);
+  ~CRetroPlayerInput() override;
+
+  void SetSpeed(double speed);
+  void EnableInput(bool bEnabled);
+
+  // implementation of IGameInputCallback
+  bool AcceptsInput() const override { return m_bEnabled; }
+  void PollInput() override;
+
+private:
+  // Construction parameters
+  PERIPHERALS::CPeripherals& m_peripheralManager;
+
+  // Input variables
+  PERIPHERALS::EventPollHandlePtr m_inputPollHandle;
+  bool m_bEnabled = false;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/RetroPlayerTypes.h b/xbmc/cores/RetroPlayer/RetroPlayerTypes.h
index e336c13f651a..f571d88b6e7a 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayerTypes.h
+++ b/xbmc/cores/RetroPlayer/RetroPlayerTypes.h
@@ -15,8 +15,8 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IRenderBufferPool;
-  using RenderBufferPoolPtr = std::shared_ptr<IRenderBufferPool>;
-  using RenderBufferPoolVector = std::vector<RenderBufferPoolPtr>;
-}
-}
+class IRenderBufferPool;
+using RenderBufferPoolPtr = std::shared_ptr<IRenderBufferPool>;
+using RenderBufferPoolVector = std::vector<RenderBufferPoolPtr>;
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/RetroPlayerUtils.cpp b/xbmc/cores/RetroPlayer/RetroPlayerUtils.cpp
index ab366903a759..42d6e47db7f4 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayerUtils.cpp
+++ b/xbmc/cores/RetroPlayer/RetroPlayerUtils.cpp
@@ -30,7 +30,7 @@ const char* CRetroPlayerUtils::StretchModeToIdentifier(STRETCHMODE stretchMode)
   return "";
 }
 
-STRETCHMODE CRetroPlayerUtils::IdentifierToStretchMode(const std::string &stretchMode)
+STRETCHMODE CRetroPlayerUtils::IdentifierToStretchMode(const std::string& stretchMode)
 {
   if (stretchMode == STRETCHMODE_NORMAL_ID)
     return STRETCHMODE::Normal;
diff --git a/xbmc/cores/RetroPlayer/RetroPlayerUtils.h b/xbmc/cores/RetroPlayer/RetroPlayerUtils.h
index f8fae72bd006..27fee5a9f2df 100644
--- a/xbmc/cores/RetroPlayer/RetroPlayerUtils.h
+++ b/xbmc/cores/RetroPlayer/RetroPlayerUtils.h
@@ -16,29 +16,29 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRetroPlayerUtils
-  {
-  public:
-    /*!
-     * \brief Convert a stretch mode enum to a short string identifier
-     *
-     * \param stretchMode The stretch mode
-     *
-     * \return A short string identifier specified by GameSettings.h, or an
-     *         empty string if the stretch mode is invalid
-     */
-    static const char* StretchModeToIdentifier(STRETCHMODE stretchMode);
+class CRetroPlayerUtils
+{
+public:
+  /*!
+   * \brief Convert a stretch mode enum to a short string identifier
+   *
+   * \param stretchMode The stretch mode
+   *
+   * \return A short string identifier specified by GameSettings.h, or an
+   *         empty string if the stretch mode is invalid
+   */
+  static const char* StretchModeToIdentifier(STRETCHMODE stretchMode);
 
-    /*!
-     * \brief Convert a stretch mode identifier to an enum
-     *
-     * \param stretchMode The short string identifier, from GameSettings.h,
-     *        representing the stretch mode
-     *
-     * \return The stretch mode enum, or STRETCHMODE::Normal if the identifier
-     *         is invalid
-     */
-    static STRETCHMODE IdentifierToStretchMode(const std::string &stretchMode);
-  };
-}
-}
+  /*!
+   * \brief Convert a stretch mode identifier to an enum
+   *
+   * \param stretchMode The short string identifier, from GameSettings.h,
+   *        representing the stretch mode
+   *
+   * \return The stretch mode enum, or STRETCHMODE::Normal if the identifier
+   *         is invalid
+   */
+  static STRETCHMODE IdentifierToStretchMode(const std::string& stretchMode);
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/audio/AudioTranslator.cpp b/xbmc/cores/RetroPlayer/audio/AudioTranslator.cpp
index 77562a731d6f..91f37ecc413b 100644
--- a/xbmc/cores/RetroPlayer/audio/AudioTranslator.cpp
+++ b/xbmc/cores/RetroPlayer/audio/AudioTranslator.cpp
@@ -15,9 +15,10 @@ AEDataFormat CAudioTranslator::TranslatePCMFormat(PCMFormat format)
 {
   switch (format)
   {
-  case PCMFormat::FMT_S16NE: return AE_FMT_S16NE;
-  default:
-    break;
+    case PCMFormat::FMT_S16NE:
+      return AE_FMT_S16NE;
+    default:
+      break;
   }
   return AE_FMT_INVALID;
 }
@@ -26,28 +27,48 @@ AEChannel CAudioTranslator::TranslateAudioChannel(AudioChannel channel)
 {
   switch (channel)
   {
-  case AudioChannel::CH_FL:   return AE_CH_FL;
-  case AudioChannel::CH_FR:   return AE_CH_FR;
-  case AudioChannel::CH_FC:   return AE_CH_FC;
-  case AudioChannel::CH_LFE:  return AE_CH_LFE;
-  case AudioChannel::CH_BL:   return AE_CH_BL;
-  case AudioChannel::CH_BR:   return AE_CH_BR;
-  case AudioChannel::CH_FLOC: return AE_CH_FLOC;
-  case AudioChannel::CH_FROC: return AE_CH_FROC;
-  case AudioChannel::CH_BC:   return AE_CH_BC;
-  case AudioChannel::CH_SL:   return AE_CH_SL;
-  case AudioChannel::CH_SR:   return AE_CH_SR;
-  case AudioChannel::CH_TFL:  return AE_CH_TFL;
-  case AudioChannel::CH_TFR:  return AE_CH_TFR;
-  case AudioChannel::CH_TFC:  return AE_CH_TFC;
-  case AudioChannel::CH_TC:   return AE_CH_TC;
-  case AudioChannel::CH_TBL:  return AE_CH_TBL;
-  case AudioChannel::CH_TBR:  return AE_CH_TBR;
-  case AudioChannel::CH_TBC:  return AE_CH_TBC;
-  case AudioChannel::CH_BLOC: return AE_CH_BLOC;
-  case AudioChannel::CH_BROC: return AE_CH_BROC;
-  default:
-    break;
+    case AudioChannel::CH_FL:
+      return AE_CH_FL;
+    case AudioChannel::CH_FR:
+      return AE_CH_FR;
+    case AudioChannel::CH_FC:
+      return AE_CH_FC;
+    case AudioChannel::CH_LFE:
+      return AE_CH_LFE;
+    case AudioChannel::CH_BL:
+      return AE_CH_BL;
+    case AudioChannel::CH_BR:
+      return AE_CH_BR;
+    case AudioChannel::CH_FLOC:
+      return AE_CH_FLOC;
+    case AudioChannel::CH_FROC:
+      return AE_CH_FROC;
+    case AudioChannel::CH_BC:
+      return AE_CH_BC;
+    case AudioChannel::CH_SL:
+      return AE_CH_SL;
+    case AudioChannel::CH_SR:
+      return AE_CH_SR;
+    case AudioChannel::CH_TFL:
+      return AE_CH_TFL;
+    case AudioChannel::CH_TFR:
+      return AE_CH_TFR;
+    case AudioChannel::CH_TFC:
+      return AE_CH_TFC;
+    case AudioChannel::CH_TC:
+      return AE_CH_TC;
+    case AudioChannel::CH_TBL:
+      return AE_CH_TBL;
+    case AudioChannel::CH_TBR:
+      return AE_CH_TBR;
+    case AudioChannel::CH_TBC:
+      return AE_CH_TBC;
+    case AudioChannel::CH_BLOC:
+      return AE_CH_BLOC;
+    case AudioChannel::CH_BROC:
+      return AE_CH_BROC;
+    default:
+      break;
   }
   return AE_CH_NULL;
 }
diff --git a/xbmc/cores/RetroPlayer/audio/AudioTranslator.h b/xbmc/cores/RetroPlayer/audio/AudioTranslator.h
index 28cc854246fb..f8935d8acaea 100644
--- a/xbmc/cores/RetroPlayer/audio/AudioTranslator.h
+++ b/xbmc/cores/RetroPlayer/audio/AudioTranslator.h
@@ -15,22 +15,22 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CAudioTranslator
-  {
-  public:
-    /*!
-     * \brief Translate audio PCM format (Game API to AudioEngine).
-     * \param format The audio PCM format to translate.
-     * \return Translated audio PCM format.
-     */
-    static AEDataFormat TranslatePCMFormat(PCMFormat format);
+class CAudioTranslator
+{
+public:
+  /*!
+   * \brief Translate audio PCM format (Game API to AudioEngine).
+   * \param format The audio PCM format to translate.
+   * \return Translated audio PCM format.
+   */
+  static AEDataFormat TranslatePCMFormat(PCMFormat format);
 
-    /*!
-     * \brief Translate audio channels (Game API to AudioEngine).
-     * \param format The audio channels to translate.
-     * \return Translated audio channels.
-     */
-    static AEChannel TranslateAudioChannel(AudioChannel channel);
-  };
-}
-}
+  /*!
+   * \brief Translate audio channels (Game API to AudioEngine).
+   * \param format The audio channels to translate.
+   * \return Translated audio channels.
+   */
+  static AEChannel TranslateAudioChannel(AudioChannel channel);
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/BaseRenderBuffer.cpp b/xbmc/cores/RetroPlayer/buffers/BaseRenderBuffer.cpp
index bdca429b20d9..2aec349eac23 100644
--- a/xbmc/cores/RetroPlayer/buffers/BaseRenderBuffer.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/BaseRenderBuffer.cpp
@@ -13,8 +13,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CBaseRenderBuffer::CBaseRenderBuffer() :
-  m_refCount(0)
+CBaseRenderBuffer::CBaseRenderBuffer() : m_refCount(0)
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/buffers/BaseRenderBuffer.h b/xbmc/cores/RetroPlayer/buffers/BaseRenderBuffer.h
index 61d83fbeef9f..a88cd0ce248b 100644
--- a/xbmc/cores/RetroPlayer/buffers/BaseRenderBuffer.h
+++ b/xbmc/cores/RetroPlayer/buffers/BaseRenderBuffer.h
@@ -17,24 +17,24 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CBaseRenderBuffer : public IRenderBuffer
-  {
-  public:
-    CBaseRenderBuffer();
-    ~CBaseRenderBuffer() override = default;
+class CBaseRenderBuffer : public IRenderBuffer
+{
+public:
+  CBaseRenderBuffer();
+  ~CBaseRenderBuffer() override = default;
 
-    // Partial implementation of IRenderBuffer
-    void Acquire() override;
-    void Acquire(std::shared_ptr<IRenderBufferPool> pool) override;
-    void Release() override;
-    IRenderBufferPool *GetPool() override { return m_pool.get(); }
+  // Partial implementation of IRenderBuffer
+  void Acquire() override;
+  void Acquire(std::shared_ptr<IRenderBufferPool> pool) override;
+  void Release() override;
+  IRenderBufferPool* GetPool() override { return m_pool.get(); }
 
-  protected:
-    // Reference counting
-    std::atomic_int m_refCount;
+protected:
+  // Reference counting
+  std::atomic_int m_refCount;
 
-    // Pool callback
-    std::shared_ptr<IRenderBufferPool> m_pool;
-  };
-}
-}
+  // Pool callback
+  std::shared_ptr<IRenderBufferPool> m_pool;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/BaseRenderBufferPool.cpp b/xbmc/cores/RetroPlayer/buffers/BaseRenderBufferPool.cpp
index 83aa4cee844f..95176bac1fcc 100644
--- a/xbmc/cores/RetroPlayer/buffers/BaseRenderBufferPool.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/BaseRenderBufferPool.cpp
@@ -21,18 +21,19 @@ CBaseRenderBufferPool::~CBaseRenderBufferPool()
   Flush();
 }
 
-void CBaseRenderBufferPool::RegisterRenderer(CRPBaseRenderer *renderer)
+void CBaseRenderBufferPool::RegisterRenderer(CRPBaseRenderer* renderer)
 {
   CSingleLock lock(m_rendererMutex);
 
   m_renderers.push_back(renderer);
 }
 
-void CBaseRenderBufferPool::UnregisterRenderer(CRPBaseRenderer *renderer)
+void CBaseRenderBufferPool::UnregisterRenderer(CRPBaseRenderer* renderer)
 {
   CSingleLock lock(m_rendererMutex);
 
-  m_renderers.erase(std::remove(m_renderers.begin(), m_renderers.end(), renderer), m_renderers.end());
+  m_renderers.erase(std::remove(m_renderers.begin(), m_renderers.end(), renderer),
+                    m_renderers.end());
 }
 
 bool CBaseRenderBufferPool::HasVisibleRenderer() const
@@ -58,14 +59,14 @@ bool CBaseRenderBufferPool::Configure(AVPixelFormat format)
   return m_bConfigured;
 }
 
-IRenderBuffer *CBaseRenderBufferPool::GetBuffer(unsigned int width, unsigned int height)
+IRenderBuffer* CBaseRenderBufferPool::GetBuffer(unsigned int width, unsigned int height)
 {
   if (!m_bConfigured)
     return nullptr;
 
-  IRenderBuffer *renderBuffer = nullptr;
+  IRenderBuffer* renderBuffer = nullptr;
 
-  void *header = nullptr;
+  void* header = nullptr;
 
   if (GetHeaderWithTimeout(header))
   {
@@ -73,7 +74,7 @@ IRenderBuffer *CBaseRenderBufferPool::GetBuffer(unsigned int width, unsigned int
 
     for (auto it = m_free.begin(); it != m_free.end(); ++it)
     {
-      std::unique_ptr<IRenderBuffer> &buffer = *it;
+      std::unique_ptr<IRenderBuffer>& buffer = *it;
 
       // Only return buffers of the same dimensions
       const unsigned int bufferWidth = buffer->GetWidth();
@@ -90,8 +91,8 @@ IRenderBuffer *CBaseRenderBufferPool::GetBuffer(unsigned int width, unsigned int
 
     if (renderBuffer == nullptr)
     {
-      CLog::Log(LOGDEBUG, "RetroPlayer[RENDER]: Creating render buffer of size %ux%u for buffer pool",
-                width,
+      CLog::Log(LOGDEBUG,
+                "RetroPlayer[RENDER]: Creating render buffer of size %ux%u for buffer pool", width,
                 height);
 
       std::unique_ptr<IRenderBuffer> renderBufferPtr(CreateRenderBuffer(header));
@@ -111,7 +112,7 @@ IRenderBuffer *CBaseRenderBufferPool::GetBuffer(unsigned int width, unsigned int
   return renderBuffer;
 }
 
-void CBaseRenderBufferPool::Return(IRenderBuffer *buffer)
+void CBaseRenderBufferPool::Return(IRenderBuffer* buffer)
 {
   CSingleLock lock(m_bufferMutex);
 
@@ -133,7 +134,7 @@ void CBaseRenderBufferPool::Prime(unsigned int width, unsigned int height)
 
   for (unsigned int i = 0; i < bufferCount; i++)
   {
-    IRenderBuffer *buffer = GetBuffer(width, height);
+    IRenderBuffer* buffer = GetBuffer(width, height);
     if (buffer == nullptr)
       break;
 
diff --git a/xbmc/cores/RetroPlayer/buffers/BaseRenderBufferPool.h b/xbmc/cores/RetroPlayer/buffers/BaseRenderBufferPool.h
index 34284d3c77d3..cda1c7c61e2d 100644
--- a/xbmc/cores/RetroPlayer/buffers/BaseRenderBufferPool.h
+++ b/xbmc/cores/RetroPlayer/buffers/BaseRenderBufferPool.h
@@ -19,48 +19,48 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CBaseRenderBufferPool : public IRenderBufferPool
-  {
-  public:
-    CBaseRenderBufferPool() = default;
-    ~CBaseRenderBufferPool() override;
+class CBaseRenderBufferPool : public IRenderBufferPool
+{
+public:
+  CBaseRenderBufferPool() = default;
+  ~CBaseRenderBufferPool() override;
 
-    // Partial implementation of IRenderBufferPool
-    void RegisterRenderer(CRPBaseRenderer *renderer) override;
-    void UnregisterRenderer(CRPBaseRenderer *renderer) override;
-    bool HasVisibleRenderer() const override;
-    bool Configure(AVPixelFormat format) override;
-    bool IsConfigured() const override { return m_bConfigured; }
-    IRenderBuffer *GetBuffer(unsigned int width, unsigned int height) override;
-    void Return(IRenderBuffer *buffer) override;
-    void Prime(unsigned int width, unsigned int height) override;
-    void Flush() override;
+  // Partial implementation of IRenderBufferPool
+  void RegisterRenderer(CRPBaseRenderer* renderer) override;
+  void UnregisterRenderer(CRPBaseRenderer* renderer) override;
+  bool HasVisibleRenderer() const override;
+  bool Configure(AVPixelFormat format) override;
+  bool IsConfigured() const override { return m_bConfigured; }
+  IRenderBuffer* GetBuffer(unsigned int width, unsigned int height) override;
+  void Return(IRenderBuffer* buffer) override;
+  void Prime(unsigned int width, unsigned int height) override;
+  void Flush() override;
 
-    // Buffer properties
-    AVPixelFormat Format() const { return m_format; }
+  // Buffer properties
+  AVPixelFormat Format() const { return m_format; }
 
-  protected:
-    virtual IRenderBuffer *CreateRenderBuffer(void *header = nullptr) = 0;
-    virtual bool ConfigureInternal() { return true; }
-    virtual void *GetHeader(unsigned int timeoutMs = 0) { return nullptr; }
-    virtual bool GetHeaderWithTimeout(void *&header)
-    {
-      header = nullptr;
-      return true;
-    }
-    virtual bool SendBuffer(IRenderBuffer *buffer) { return false; }
+protected:
+  virtual IRenderBuffer* CreateRenderBuffer(void* header = nullptr) = 0;
+  virtual bool ConfigureInternal() { return true; }
+  virtual void* GetHeader(unsigned int timeoutMs = 0) { return nullptr; }
+  virtual bool GetHeaderWithTimeout(void*& header)
+  {
+    header = nullptr;
+    return true;
+  }
+  virtual bool SendBuffer(IRenderBuffer* buffer) { return false; }
 
-    // Configuration parameters
-    bool m_bConfigured = false;
-    AVPixelFormat m_format = AV_PIX_FMT_NONE;
+  // Configuration parameters
+  bool m_bConfigured = false;
+  AVPixelFormat m_format = AV_PIX_FMT_NONE;
 
-  private:
-    // Buffer properties
-    std::deque<std::unique_ptr<IRenderBuffer>> m_free;
+private:
+  // Buffer properties
+  std::deque<std::unique_ptr<IRenderBuffer>> m_free;
 
-    std::vector<CRPBaseRenderer*> m_renderers;
-    mutable CCriticalSection m_rendererMutex;
-    CCriticalSection m_bufferMutex;
-  };
-}
-}
+  std::vector<CRPBaseRenderer*> m_renderers;
+  mutable CCriticalSection m_rendererMutex;
+  CCriticalSection m_bufferMutex;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/IRenderBuffer.h b/xbmc/cores/RetroPlayer/buffers/IRenderBuffer.h
index 90111f96d017..1565f4112c0e 100644
--- a/xbmc/cores/RetroPlayer/buffers/IRenderBuffer.h
+++ b/xbmc/cores/RetroPlayer/buffers/IRenderBuffer.h
@@ -8,7 +8,8 @@
 
 #pragma once
 
-extern "C" {
+extern "C"
+{
 #include <libavutil/pixfmt.h>
 }
 
@@ -19,47 +20,47 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IRenderBufferPool;
+class IRenderBufferPool;
 
-  class IRenderBuffer
-  {
-  public:
-    virtual ~IRenderBuffer() = default;
+class IRenderBuffer
+{
+public:
+  virtual ~IRenderBuffer() = default;
 
-    // Pool functions
-    virtual void Acquire() = 0;
-    virtual void Acquire(std::shared_ptr<IRenderBufferPool> pool) = 0;
-    virtual void Release() = 0;
-    virtual IRenderBufferPool *GetPool() = 0;
+  // Pool functions
+  virtual void Acquire() = 0;
+  virtual void Acquire(std::shared_ptr<IRenderBufferPool> pool) = 0;
+  virtual void Release() = 0;
+  virtual IRenderBufferPool* GetPool() = 0;
 
-    // Buffer functions
-    virtual bool Allocate(AVPixelFormat format, unsigned int width, unsigned int height) = 0;
-    virtual void Update() { } //! @todo Remove me
-    virtual size_t GetFrameSize() const = 0;
-    virtual uint8_t *GetMemory() = 0;
-    virtual void ReleaseMemory() { }
-    virtual bool UploadTexture() = 0;
-    virtual void BindToUnit(unsigned int unit) { }
-    virtual void SetHeader(void *header) { }
+  // Buffer functions
+  virtual bool Allocate(AVPixelFormat format, unsigned int width, unsigned int height) = 0;
+  virtual void Update() {} //! @todo Remove me
+  virtual size_t GetFrameSize() const = 0;
+  virtual uint8_t* GetMemory() = 0;
+  virtual void ReleaseMemory() {}
+  virtual bool UploadTexture() = 0;
+  virtual void BindToUnit(unsigned int unit) {}
+  virtual void SetHeader(void* header) {}
 
-    // Buffer properties
-    AVPixelFormat GetFormat() const { return m_format; }
-    unsigned int GetWidth() const { return m_width; }
-    unsigned int GetHeight() const { return m_height; }
-    bool IsLoaded() const { return m_bLoaded; }
-    void SetLoaded(bool bLoaded) { m_bLoaded = bLoaded; }
-    bool IsRendered() const { return m_bRendered; }
-    void SetRendered(bool bRendered) { m_bRendered = bRendered; }
-    unsigned int GetRotation() const { return m_rotationDegCCW; }
-    void SetRotation(unsigned int rotationDegCCW) { m_rotationDegCCW = rotationDegCCW; }
+  // Buffer properties
+  AVPixelFormat GetFormat() const { return m_format; }
+  unsigned int GetWidth() const { return m_width; }
+  unsigned int GetHeight() const { return m_height; }
+  bool IsLoaded() const { return m_bLoaded; }
+  void SetLoaded(bool bLoaded) { m_bLoaded = bLoaded; }
+  bool IsRendered() const { return m_bRendered; }
+  void SetRendered(bool bRendered) { m_bRendered = bRendered; }
+  unsigned int GetRotation() const { return m_rotationDegCCW; }
+  void SetRotation(unsigned int rotationDegCCW) { m_rotationDegCCW = rotationDegCCW; }
 
-  protected:
-    AVPixelFormat m_format = AV_PIX_FMT_NONE;
-    unsigned int m_width = 0;
-    unsigned int m_height = 0;
-    bool m_bLoaded = false;
-    bool m_bRendered = false;
-    unsigned int m_rotationDegCCW = 0;
-  };
-}
-}
+protected:
+  AVPixelFormat m_format = AV_PIX_FMT_NONE;
+  unsigned int m_width = 0;
+  unsigned int m_height = 0;
+  bool m_bLoaded = false;
+  bool m_bRendered = false;
+  unsigned int m_rotationDegCCW = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/IRenderBufferPool.h b/xbmc/cores/RetroPlayer/buffers/IRenderBufferPool.h
index de0a67c07f47..f02257d7e3f9 100644
--- a/xbmc/cores/RetroPlayer/buffers/IRenderBufferPool.h
+++ b/xbmc/cores/RetroPlayer/buffers/IRenderBufferPool.h
@@ -8,7 +8,8 @@
 
 #pragma once
 
-extern "C" {
+extern "C"
+{
 #include <libavutil/pixfmt.h>
 }
 
@@ -19,51 +20,51 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderBufferManager;
-  class CRenderVideoSettings;
-  class CRPBaseRenderer;
-  class IRenderBuffer;
+class CRenderBufferManager;
+class CRenderVideoSettings;
+class CRPBaseRenderer;
+class IRenderBuffer;
 
-  class IRenderBufferPool : public std::enable_shared_from_this<IRenderBufferPool>
-  {
-  public:
-    virtual ~IRenderBufferPool() = default;
+class IRenderBufferPool : public std::enable_shared_from_this<IRenderBufferPool>
+{
+public:
+  virtual ~IRenderBufferPool() = default;
 
-    virtual void RegisterRenderer(CRPBaseRenderer *renderer) = 0;
-    virtual void UnregisterRenderer(CRPBaseRenderer *renderer) = 0;
-    virtual bool HasVisibleRenderer() const = 0;
+  virtual void RegisterRenderer(CRPBaseRenderer* renderer) = 0;
+  virtual void UnregisterRenderer(CRPBaseRenderer* renderer) = 0;
+  virtual bool HasVisibleRenderer() const = 0;
 
-    virtual bool Configure(AVPixelFormat format) = 0;
+  virtual bool Configure(AVPixelFormat format) = 0;
 
-    virtual bool IsConfigured() const = 0;
+  virtual bool IsConfigured() const = 0;
 
-    virtual bool IsCompatible(const CRenderVideoSettings &renderSettings) const = 0;
+  virtual bool IsCompatible(const CRenderVideoSettings& renderSettings) const = 0;
 
-    /*!
-     * \brief Get a free buffer from the pool, sets ref count to 1
-     *
-     * \param width The horizontal pixel count of the buffer
-     * \param height The vertical pixel could of the buffer
-     *
-     * \return The allocated buffer, or nullptr on failure
-     */
-    virtual IRenderBuffer *GetBuffer(unsigned int width, unsigned int height) = 0;
+  /*!
+   * \brief Get a free buffer from the pool, sets ref count to 1
+   *
+   * \param width The horizontal pixel count of the buffer
+   * \param height The vertical pixel could of the buffer
+   *
+   * \return The allocated buffer, or nullptr on failure
+   */
+  virtual IRenderBuffer* GetBuffer(unsigned int width, unsigned int height) = 0;
 
-    /*!
-     * \brief Called by buffer when ref count goes to zero
-     *
-     * \param buffer A fully dereferenced buffer
-     */
-    virtual void Return(IRenderBuffer *buffer) = 0;
+  /*!
+   * \brief Called by buffer when ref count goes to zero
+   *
+   * \param buffer A fully dereferenced buffer
+   */
+  virtual void Return(IRenderBuffer* buffer) = 0;
 
-    virtual void Prime(unsigned int width, unsigned int height) = 0;
+  virtual void Prime(unsigned int width, unsigned int height) = 0;
 
-    virtual void Flush() = 0;
+  virtual void Flush() = 0;
 
-    /*!
-     * \brief Call in GetBuffer() before returning buffer to caller
-     */
-    virtual std::shared_ptr<IRenderBufferPool> GetPtr() { return shared_from_this(); }
-  };
-}
-}
+  /*!
+   * \brief Call in GetBuffer() before returning buffer to caller
+   */
+  virtual std::shared_ptr<IRenderBufferPool> GetPtr() { return shared_from_this(); }
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferDMA.cpp b/xbmc/cores/RetroPlayer/buffers/RenderBufferDMA.cpp
index bbd627ad3a73..6277d629d834 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferDMA.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferDMA.cpp
@@ -19,9 +19,7 @@ using namespace KODI;
 using namespace RETRO;
 
 CRenderBufferDMA::CRenderBufferDMA(CRenderContext& context, int fourcc)
-  : m_context(context),
-    m_fourcc(fourcc),
-    m_bo(CBufferObject::GetBufferObject(false))
+  : m_context(context), m_fourcc(fourcc), m_bo(CBufferObject::GetBufferObject(false))
 {
   auto winSystemEGL =
       dynamic_cast<KODI::WINDOWING::LINUX::CWinSystemEGL*>(CServiceBroker::GetWinSystem());
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferDMA.h b/xbmc/cores/RetroPlayer/buffers/RenderBufferDMA.h
index fa1684475502..5e9f157d6334 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferDMA.h
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferDMA.h
@@ -21,46 +21,46 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
+class CRenderContext;
 
-  /**
-   * @brief Special IRenderBuffer implementation for use with CBufferObject.
-   *        This buffer type uses Direct Memory Access (DMA) sharing via file
-   *        descriptors (fds). The file descriptor is then used to create an
-   *        EGL image.
-   *
-   */
-  class CRenderBufferDMA : public CBaseRenderBuffer
-  {
-  public:
-    CRenderBufferDMA(CRenderContext& context, int fourcc);
-    ~CRenderBufferDMA() override;
+/**
+ * @brief Special IRenderBuffer implementation for use with CBufferObject.
+ *        This buffer type uses Direct Memory Access (DMA) sharing via file
+ *        descriptors (fds). The file descriptor is then used to create an
+ *        EGL image.
+ *
+ */
+class CRenderBufferDMA : public CBaseRenderBuffer
+{
+public:
+  CRenderBufferDMA(CRenderContext& context, int fourcc);
+  ~CRenderBufferDMA() override;
 
-    // implementation of IRenderBuffer via CRenderBufferSysMem
-    bool Allocate(AVPixelFormat format, unsigned int width, unsigned int height) override;
-    size_t GetFrameSize() const override;
-    uint8_t *GetMemory() override;
-    void ReleaseMemory() override;
+  // implementation of IRenderBuffer via CRenderBufferSysMem
+  bool Allocate(AVPixelFormat format, unsigned int width, unsigned int height) override;
+  size_t GetFrameSize() const override;
+  uint8_t* GetMemory() override;
+  void ReleaseMemory() override;
 
-    // implementation of IRenderBuffer
-    bool UploadTexture() override;
+  // implementation of IRenderBuffer
+  bool UploadTexture() override;
 
-    GLuint TextureID() const { return m_textureId; }
+  GLuint TextureID() const { return m_textureId; }
 
-  protected:
-    // Construction parameters
-    CRenderContext &m_context;
-    const int m_fourcc = 0;
+protected:
+  // Construction parameters
+  CRenderContext& m_context;
+  const int m_fourcc = 0;
 
-    const GLenum m_textureTarget = GL_TEXTURE_2D;
-    GLuint m_textureId = 0;
+  const GLenum m_textureTarget = GL_TEXTURE_2D;
+  GLuint m_textureId = 0;
 
-  private:
-    void CreateTexture();
-    void DeleteTexture();
+private:
+  void CreateTexture();
+  void DeleteTexture();
 
-    std::unique_ptr<CEGLImage> m_egl;
-    std::unique_ptr<IBufferObject> m_bo;
-  };
-}
-}
+  std::unique_ptr<CEGLImage> m_egl;
+  std::unique_ptr<IBufferObject> m_bo;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferManager.cpp b/xbmc/cores/RetroPlayer/buffers/RenderBufferManager.cpp
index 1fe5139d21b9..45479607b88d 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferManager.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferManager.cpp
@@ -23,24 +23,22 @@ CRenderBufferManager::~CRenderBufferManager()
   FlushPools();
 }
 
-void CRenderBufferManager::RegisterPools(IRendererFactory *factory, RenderBufferPoolVector pools)
+void CRenderBufferManager::RegisterPools(IRendererFactory* factory, RenderBufferPoolVector pools)
 {
   CSingleLock lock(m_critSection);
 
   m_pools.emplace_back(RenderBufferPools{factory, std::move(pools)});
 }
 
-RenderBufferPoolVector CRenderBufferManager::GetPools(IRendererFactory *factory)
+RenderBufferPoolVector CRenderBufferManager::GetPools(IRendererFactory* factory)
 {
   RenderBufferPoolVector bufferPools;
 
   CSingleLock lock(m_critSection);
 
-  auto it = std::find_if(m_pools.begin(), m_pools.end(),
-    [factory](const RenderBufferPools &pools)
-    {
-      return pools.factory == factory;
-    });
+  auto it = std::find_if(m_pools.begin(), m_pools.end(), [factory](const RenderBufferPools& pools) {
+    return pools.factory == factory;
+  });
 
   if (it != m_pools.end())
     bufferPools = it->pools;
@@ -54,9 +52,9 @@ std::vector<IRenderBufferPool*> CRenderBufferManager::GetBufferPools()
 
   CSingleLock lock(m_critSection);
 
-  for (const auto &pools : m_pools)
+  for (const auto& pools : m_pools)
   {
-    for (const auto &pool : pools.pools)
+    for (const auto& pool : pools.pools)
       bufferPools.emplace_back(pool.get());
   }
 
@@ -67,20 +65,20 @@ void CRenderBufferManager::FlushPools()
 {
   CSingleLock lock(m_critSection);
 
-  for (const auto &pools : m_pools)
+  for (const auto& pools : m_pools)
   {
-    for (const auto &pool : pools.pools)
+    for (const auto& pool : pools.pools)
       pool->Flush();
   }
 }
 
-std::string CRenderBufferManager::GetRenderSystemName(IRenderBufferPool *renderBufferPool) const
+std::string CRenderBufferManager::GetRenderSystemName(IRenderBufferPool* renderBufferPool) const
 {
   CSingleLock lock(m_critSection);
 
-  for (const auto &pools : m_pools)
+  for (const auto& pools : m_pools)
   {
-    for (const auto &pool : pools.pools)
+    for (const auto& pool : pools.pools)
     {
       if (pool.get() == renderBufferPool)
         return pools.factory->RenderSystemName();
@@ -95,9 +93,9 @@ bool CRenderBufferManager::HasScalingMethod(SCALINGMETHOD scalingMethod) const
   CRenderVideoSettings videoSettings;
   videoSettings.SetScalingMethod(scalingMethod);
 
-  for (const auto &pools : m_pools)
+  for (const auto& pools : m_pools)
   {
-    for (const auto &pool : pools.pools)
+    for (const auto& pool : pools.pools)
       if (pool->IsCompatible(videoSettings))
         return true;
   }
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferManager.h b/xbmc/cores/RetroPlayer/buffers/RenderBufferManager.h
index 97a3b8620fa5..de69cada4d41 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferManager.h
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferManager.h
@@ -19,33 +19,33 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IRendererFactory;
-  class IRenderBufferPools;
+class IRendererFactory;
+class IRenderBufferPools;
 
-  class CRenderBufferManager
-  {
-  public:
-    CRenderBufferManager() = default;
-    ~CRenderBufferManager();
-
-    void RegisterPools(IRendererFactory *factory, RenderBufferPoolVector pools);
-    RenderBufferPoolVector GetPools(IRendererFactory *factory);
-    std::vector<IRenderBufferPool*> GetBufferPools();
-    void FlushPools();
+class CRenderBufferManager
+{
+public:
+  CRenderBufferManager() = default;
+  ~CRenderBufferManager();
 
-    std::string GetRenderSystemName(IRenderBufferPool *renderBufferPool) const;
+  void RegisterPools(IRendererFactory* factory, RenderBufferPoolVector pools);
+  RenderBufferPoolVector GetPools(IRendererFactory* factory);
+  std::vector<IRenderBufferPool*> GetBufferPools();
+  void FlushPools();
 
-    bool HasScalingMethod(SCALINGMETHOD scalingMethod) const;
+  std::string GetRenderSystemName(IRenderBufferPool* renderBufferPool) const;
 
-  protected:
-    struct RenderBufferPools
-    {
-      IRendererFactory* factory;
-      RenderBufferPoolVector pools;
-    };
+  bool HasScalingMethod(SCALINGMETHOD scalingMethod) const;
 
-    std::vector<RenderBufferPools> m_pools;
-    mutable CCriticalSection m_critSection;
+protected:
+  struct RenderBufferPools
+  {
+    IRendererFactory* factory;
+    RenderBufferPoolVector pools;
   };
-}
-}
+
+  std::vector<RenderBufferPools> m_pools;
+  mutable CCriticalSection m_critSection;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGL.cpp b/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGL.cpp
index 2b25c83a38f7..04a46077f57c 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGL.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGL.cpp
@@ -17,11 +17,8 @@ using namespace RETRO;
 CRenderBufferOpenGL::CRenderBufferOpenGL(GLuint pixeltype,
                                          GLuint internalformat,
                                          GLuint pixelformat,
-                                         GLuint bpp) :
-  m_pixeltype(pixeltype),
-  m_internalformat(internalformat),
-  m_pixelformat(pixelformat),
-  m_bpp(bpp)
+                                         GLuint bpp)
+  : m_pixeltype(pixeltype), m_internalformat(internalformat), m_pixelformat(pixelformat), m_bpp(bpp)
 {
 }
 
@@ -36,7 +33,8 @@ void CRenderBufferOpenGL::CreateTexture()
 
   glBindTexture(m_textureTarget, m_textureId);
 
-  glTexImage2D(m_textureTarget, 0, m_internalformat, m_width, m_height, 0, m_pixelformat, m_pixeltype, NULL);
+  glTexImage2D(m_textureTarget, 0, m_internalformat, m_width, m_height, 0, m_pixelformat,
+               m_pixeltype, NULL);
 
   glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
@@ -63,7 +61,8 @@ bool CRenderBufferOpenGL::UploadTexture()
   //! We want to use PBO's instead of glTexSubImage2D!
   //! This code has been borrowed from OpenGL ES in order
   //! to remove GL dependencies on GLES.
-  glTexSubImage2D(m_textureTarget, 0, 0, 0, m_width, m_height, m_pixelformat, m_pixeltype, m_data.data());
+  glTexSubImage2D(m_textureTarget, 0, 0, 0, m_width, m_height, m_pixelformat, m_pixeltype,
+                  m_data.data());
   glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
 
   return true;
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGL.h b/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGL.h
index f87ed835f481..9fcb9e270982 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGL.h
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGL.h
@@ -16,32 +16,29 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
-
-  class CRenderBufferOpenGL : public CRenderBufferSysMem
-  {
-  public:
-    CRenderBufferOpenGL(GLuint pixeltype,
-                        GLuint internalformat,
-                        GLuint pixelformat,
-                        GLuint bpp);
-    ~CRenderBufferOpenGL() override;
-
-    bool UploadTexture() override;
-    GLuint TextureID() const { return m_textureId; }
-
-  private:
-    // Construction parameters
-    const GLuint m_pixeltype;
-    const GLuint m_internalformat;
-    const GLuint m_pixelformat;
-    const GLuint m_bpp;
-
-    const GLenum m_textureTarget = GL_TEXTURE_2D; //! @todo
-    GLuint m_textureId = 0;
-
-    void CreateTexture();
-    void DeleteTexture();
-  };
-}
-}
+class CRenderContext;
+
+class CRenderBufferOpenGL : public CRenderBufferSysMem
+{
+public:
+  CRenderBufferOpenGL(GLuint pixeltype, GLuint internalformat, GLuint pixelformat, GLuint bpp);
+  ~CRenderBufferOpenGL() override;
+
+  bool UploadTexture() override;
+  GLuint TextureID() const { return m_textureId; }
+
+private:
+  // Construction parameters
+  const GLuint m_pixeltype;
+  const GLuint m_internalformat;
+  const GLuint m_pixelformat;
+  const GLuint m_bpp;
+
+  const GLenum m_textureTarget = GL_TEXTURE_2D; //! @todo
+  GLuint m_textureId = 0;
+
+  void CreateTexture();
+  void DeleteTexture();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.cpp b/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.cpp
index 6b1f6cc97198..8ed366ed7089 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.cpp
@@ -13,16 +13,16 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRenderBufferOpenGLES::CRenderBufferOpenGLES(CRenderContext &context,
+CRenderBufferOpenGLES::CRenderBufferOpenGLES(CRenderContext& context,
                                              GLuint pixeltype,
                                              GLuint internalformat,
                                              GLuint pixelformat,
-                                             GLuint bpp) :
-  m_context(context),
-  m_pixeltype(pixeltype),
-  m_internalformat(internalformat),
-  m_pixelformat(pixelformat),
-  m_bpp(bpp)
+                                             GLuint bpp)
+  : m_context(context),
+    m_pixeltype(pixeltype),
+    m_internalformat(internalformat),
+    m_pixelformat(pixelformat),
+    m_bpp(bpp)
 {
 }
 
@@ -37,7 +37,8 @@ void CRenderBufferOpenGLES::CreateTexture()
 
   glBindTexture(m_textureTarget, m_textureId);
 
-  glTexImage2D(m_textureTarget, 0, m_internalformat, m_width, m_height, 0, m_pixelformat, m_pixeltype, NULL);
+  glTexImage2D(m_textureTarget, 0, m_internalformat, m_width, m_height, 0, m_pixelformat,
+               m_pixeltype, NULL);
 
   glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
@@ -74,7 +75,8 @@ bool CRenderBufferOpenGLES::UploadTexture()
   {
 #ifdef GL_UNPACK_ROW_LENGTH_EXT
     glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, stride / m_bpp);
-    glTexSubImage2D(m_textureTarget, 0, 0, 0, m_width, m_height, m_pixelformat, m_pixeltype, m_data.data());
+    glTexSubImage2D(m_textureTarget, 0, 0, 0, m_width, m_height, m_pixelformat, m_pixeltype,
+                    m_data.data());
     glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, 0);
 #endif
   }
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.h b/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.h
index 29d234a7c79f..58e5d47c864c 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.h
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferOpenGLES.h
@@ -16,36 +16,36 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
-
-  class CRenderBufferOpenGLES : public CRenderBufferSysMem
-  {
-  public:
-    CRenderBufferOpenGLES(CRenderContext &context,
-                          GLuint pixeltype,
-                          GLuint internalformat,
-                          GLuint pixelformat,
-                          GLuint bpp);
-    ~CRenderBufferOpenGLES() override;
-
-    // implementation of IRenderBuffer via CRenderBufferSysMem
-    bool UploadTexture() override;
-
-    GLuint TextureID() const { return m_textureId; }
-
-  private:
-    // Construction parameters
-    CRenderContext &m_context;
-    const GLuint m_pixeltype;
-    const GLuint m_internalformat;
-    const GLuint m_pixelformat;
-    const GLuint m_bpp;
-
-    const GLenum m_textureTarget = GL_TEXTURE_2D; //! @todo
-    GLuint m_textureId = 0;
-
-    void CreateTexture();
-    void DeleteTexture();
-  };
-}
-}
+class CRenderContext;
+
+class CRenderBufferOpenGLES : public CRenderBufferSysMem
+{
+public:
+  CRenderBufferOpenGLES(CRenderContext& context,
+                        GLuint pixeltype,
+                        GLuint internalformat,
+                        GLuint pixelformat,
+                        GLuint bpp);
+  ~CRenderBufferOpenGLES() override;
+
+  // implementation of IRenderBuffer via CRenderBufferSysMem
+  bool UploadTexture() override;
+
+  GLuint TextureID() const { return m_textureId; }
+
+private:
+  // Construction parameters
+  CRenderContext& m_context;
+  const GLuint m_pixeltype;
+  const GLuint m_internalformat;
+  const GLuint m_pixelformat;
+  const GLuint m_bpp;
+
+  const GLenum m_textureTarget = GL_TEXTURE_2D; //! @todo
+  GLuint m_textureId = 0;
+
+  void CreateTexture();
+  void DeleteTexture();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolDMA.h b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolDMA.h
index fb4be7bee764..81645bb3b4b8 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolDMA.h
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolDMA.h
@@ -14,32 +14,32 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
-
-  /**
-   * @brief Special IRenderBufferPool implementation that converts
-   *        AVPixelFormat to DRM_FORMAT_* for use with CRenderBufferDMA.
-   *
-   */
-  class CRenderBufferPoolDMA : public CBaseRenderBufferPool
-  {
-  public:
-    CRenderBufferPoolDMA(CRenderContext& context);
-    ~CRenderBufferPoolDMA() override = default;
-
-    // implementation of IRenderBufferPool via CBaseRenderBufferPool
-    bool IsCompatible(const CRenderVideoSettings &renderSettings) const override;
-
-  protected:
-    // implementation of CBaseRenderBufferPool
-    IRenderBuffer *CreateRenderBuffer(void *header = nullptr) override;
-    bool ConfigureInternal() override;
-
-    // Construction parameters
-    CRenderContext &m_context;
-
-    // Configuration parameters
-    int m_fourcc = 0;
-  };
-}
-}
+class CRenderContext;
+
+/**
+ * @brief Special IRenderBufferPool implementation that converts
+ *        AVPixelFormat to DRM_FORMAT_* for use with CRenderBufferDMA.
+ *
+ */
+class CRenderBufferPoolDMA : public CBaseRenderBufferPool
+{
+public:
+  CRenderBufferPoolDMA(CRenderContext& context);
+  ~CRenderBufferPoolDMA() override = default;
+
+  // implementation of IRenderBufferPool via CBaseRenderBufferPool
+  bool IsCompatible(const CRenderVideoSettings& renderSettings) const override;
+
+protected:
+  // implementation of CBaseRenderBufferPool
+  IRenderBuffer* CreateRenderBuffer(void* header = nullptr) override;
+  bool ConfigureInternal() override;
+
+  // Construction parameters
+  CRenderContext& m_context;
+
+  // Configuration parameters
+  int m_fourcc = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGL.cpp b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGL.cpp
index f859bc5a7af9..6d30346559bd 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGL.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGL.cpp
@@ -17,17 +17,14 @@
 using namespace KODI;
 using namespace RETRO;
 
-bool CRenderBufferPoolOpenGL::IsCompatible(const CRenderVideoSettings &renderSettings) const
+bool CRenderBufferPoolOpenGL::IsCompatible(const CRenderVideoSettings& renderSettings) const
 {
   return CRPRendererOpenGL::SupportsScalingMethod(renderSettings.GetScalingMethod());
 }
 
-IRenderBuffer *CRenderBufferPoolOpenGL::CreateRenderBuffer(void *header /* = nullptr */)
+IRenderBuffer* CRenderBufferPoolOpenGL::CreateRenderBuffer(void* header /* = nullptr */)
 {
-  return new CRenderBufferOpenGL(m_pixeltype,
-                                 m_internalformat,
-                                 m_pixelformat,
-                                 m_bpp);
+  return new CRenderBufferOpenGL(m_pixeltype, m_internalformat, m_pixelformat, m_bpp);
 }
 
 bool CRenderBufferPoolOpenGL::ConfigureInternal()
@@ -35,32 +32,32 @@ bool CRenderBufferPoolOpenGL::ConfigureInternal()
   // Configure CRenderBufferPoolOpenGLES
   switch (m_format)
   {
-  case AV_PIX_FMT_0RGB32:
-  {
-    m_pixeltype = GL_UNSIGNED_BYTE;
-    m_internalformat = GL_RGBA;
-    m_pixelformat = GL_BGRA;
-    m_bpp = sizeof(uint32_t);
-    return true;
-  }
-  case AV_PIX_FMT_RGB555:
-  {
-    m_pixeltype = GL_UNSIGNED_SHORT_5_5_5_1;
-    m_internalformat = GL_RGB;
-    m_pixelformat = GL_RGB;
-    m_bpp = sizeof(uint16_t);
-    return true;
-  }
-  case AV_PIX_FMT_RGB565:
-  {
-    m_pixeltype = GL_UNSIGNED_SHORT_5_6_5;
-    m_internalformat = GL_RGB;
-    m_pixelformat = GL_RGB;
-    m_bpp = sizeof(uint16_t);
-    return true;
-  }
-  default:
-    break;
+    case AV_PIX_FMT_0RGB32:
+    {
+      m_pixeltype = GL_UNSIGNED_BYTE;
+      m_internalformat = GL_RGBA;
+      m_pixelformat = GL_BGRA;
+      m_bpp = sizeof(uint32_t);
+      return true;
+    }
+    case AV_PIX_FMT_RGB555:
+    {
+      m_pixeltype = GL_UNSIGNED_SHORT_5_5_5_1;
+      m_internalformat = GL_RGB;
+      m_pixelformat = GL_RGB;
+      m_bpp = sizeof(uint16_t);
+      return true;
+    }
+    case AV_PIX_FMT_RGB565:
+    {
+      m_pixeltype = GL_UNSIGNED_SHORT_5_6_5;
+      m_internalformat = GL_RGB;
+      m_pixelformat = GL_RGB;
+      m_bpp = sizeof(uint16_t);
+      return true;
+    }
+    default:
+      break;
   }
 
   return false;
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGL.h b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGL.h
index 9ddc897d11b9..e8689b94a6e9 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGL.h
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGL.h
@@ -17,29 +17,29 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
-  class CRenderVideoSettings;
-
-  class CRenderBufferPoolOpenGL : public CBaseRenderBufferPool
-  {
-  public:
-    CRenderBufferPoolOpenGL() = default;
-    ~CRenderBufferPoolOpenGL() override = default;
-
-    // implementation of IRenderBufferPool via CBaseRenderBufferPool
-    bool IsCompatible(const CRenderVideoSettings &renderSettings) const override;
-
-  protected:
-    // implementation of CBaseRenderBufferPool
-    IRenderBuffer *CreateRenderBuffer(void *header = nullptr) override;
-    bool ConfigureInternal() override;
-
-  private:
-    // Configuration parameters
-    GLuint m_pixeltype = 0;
-    GLuint m_internalformat = 0;
-    GLuint m_pixelformat = 0;
-    GLuint m_bpp = 0;
-  };
-}
-}
+class CRenderContext;
+class CRenderVideoSettings;
+
+class CRenderBufferPoolOpenGL : public CBaseRenderBufferPool
+{
+public:
+  CRenderBufferPoolOpenGL() = default;
+  ~CRenderBufferPoolOpenGL() override = default;
+
+  // implementation of IRenderBufferPool via CBaseRenderBufferPool
+  bool IsCompatible(const CRenderVideoSettings& renderSettings) const override;
+
+protected:
+  // implementation of CBaseRenderBufferPool
+  IRenderBuffer* CreateRenderBuffer(void* header = nullptr) override;
+  bool ConfigureInternal() override;
+
+private:
+  // Configuration parameters
+  GLuint m_pixeltype = 0;
+  GLuint m_internalformat = 0;
+  GLuint m_pixelformat = 0;
+  GLuint m_bpp = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGLES.cpp b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGLES.cpp
index 4953b9824c4d..c7aa8f67bdeb 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGLES.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGLES.cpp
@@ -17,64 +17,59 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRenderBufferPoolOpenGLES::CRenderBufferPoolOpenGLES(CRenderContext &context)
-  : m_context(context)
+CRenderBufferPoolOpenGLES::CRenderBufferPoolOpenGLES(CRenderContext& context) : m_context(context)
 {
 }
 
-bool CRenderBufferPoolOpenGLES::IsCompatible(const CRenderVideoSettings &renderSettings) const
+bool CRenderBufferPoolOpenGLES::IsCompatible(const CRenderVideoSettings& renderSettings) const
 {
   return CRPRendererOpenGLES::SupportsScalingMethod(renderSettings.GetScalingMethod());
 }
 
-IRenderBuffer *CRenderBufferPoolOpenGLES::CreateRenderBuffer(void *header /* = nullptr */)
+IRenderBuffer* CRenderBufferPoolOpenGLES::CreateRenderBuffer(void* header /* = nullptr */)
 {
-  return new CRenderBufferOpenGLES(m_context,
-                                   m_pixeltype,
-                                   m_internalformat,
-                                   m_pixelformat,
-                                   m_bpp);
+  return new CRenderBufferOpenGLES(m_context, m_pixeltype, m_internalformat, m_pixelformat, m_bpp);
 }
 
 bool CRenderBufferPoolOpenGLES::ConfigureInternal()
 {
   switch (m_format)
   {
-  case AV_PIX_FMT_0RGB32:
-  {
-    m_pixeltype = GL_UNSIGNED_BYTE;
-    if (m_context.IsExtSupported("GL_EXT_texture_format_BGRA8888") ||
-        m_context.IsExtSupported("GL_IMG_texture_format_BGRA8888"))
-    {
-      m_internalformat = GL_BGRA_EXT;
-      m_pixelformat = GL_BGRA_EXT;
-    }
-    else if (m_context.IsExtSupported("GL_APPLE_texture_format_BGRA8888"))
+    case AV_PIX_FMT_0RGB32:
     {
-      // Apple's implementation does not conform to spec. Instead, they require
-      // differing format/internalformat, more like GL.
-      m_internalformat = GL_RGBA;
-      m_pixelformat = GL_BGRA_EXT;
+      m_pixeltype = GL_UNSIGNED_BYTE;
+      if (m_context.IsExtSupported("GL_EXT_texture_format_BGRA8888") ||
+          m_context.IsExtSupported("GL_IMG_texture_format_BGRA8888"))
+      {
+        m_internalformat = GL_BGRA_EXT;
+        m_pixelformat = GL_BGRA_EXT;
+      }
+      else if (m_context.IsExtSupported("GL_APPLE_texture_format_BGRA8888"))
+      {
+        // Apple's implementation does not conform to spec. Instead, they require
+        // differing format/internalformat, more like GL.
+        m_internalformat = GL_RGBA;
+        m_pixelformat = GL_BGRA_EXT;
+      }
+      else
+      {
+        m_internalformat = GL_RGBA;
+        m_pixelformat = GL_RGBA;
+      }
+      m_bpp = sizeof(uint32_t);
+      return true;
     }
-    else
+    case AV_PIX_FMT_RGB555:
+    case AV_PIX_FMT_RGB565:
     {
-      m_internalformat = GL_RGBA;
-      m_pixelformat = GL_RGBA;
+      m_pixeltype = GL_UNSIGNED_SHORT_5_6_5;
+      m_internalformat = GL_RGB;
+      m_pixelformat = GL_RGB;
+      m_bpp = sizeof(uint16_t);
+      return true;
     }
-    m_bpp = sizeof(uint32_t);
-    return true;
-  }
-  case AV_PIX_FMT_RGB555:
-  case AV_PIX_FMT_RGB565:
-  {
-    m_pixeltype = GL_UNSIGNED_SHORT_5_6_5;
-    m_internalformat = GL_RGB;
-    m_pixelformat = GL_RGB;
-    m_bpp = sizeof(uint16_t);
-    return true;
-  }
-  default:
-    break;
+    default:
+      break;
   }
 
   return false;
diff --git a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGLES.h b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGLES.h
index 725191e98322..b511cdbdac26 100644
--- a/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGLES.h
+++ b/xbmc/cores/RetroPlayer/buffers/RenderBufferPoolOpenGLES.h
@@ -17,31 +17,31 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
-  class CRenderVideoSettings;
-
-  class CRenderBufferPoolOpenGLES : public CBaseRenderBufferPool
-  {
-  public:
-    CRenderBufferPoolOpenGLES(CRenderContext &context);
-    ~CRenderBufferPoolOpenGLES() override = default;
-
-    // implementation of IRenderBufferPool via CBaseRenderBufferPool
-    bool IsCompatible(const CRenderVideoSettings &renderSettings) const override;
-
-  private:
-    // implementation of CBaseRenderBufferPool
-    IRenderBuffer *CreateRenderBuffer(void *header = nullptr) override;
-    bool ConfigureInternal() override;
-
-    // Construction parameters
-    CRenderContext &m_context;
-
-    // Configuration parameters
-    GLuint m_pixeltype = 0;
-    GLuint m_internalformat = 0;
-    GLuint m_pixelformat = 0;
-    GLuint m_bpp = 0;
-  };
-}
-}
+class CRenderContext;
+class CRenderVideoSettings;
+
+class CRenderBufferPoolOpenGLES : public CBaseRenderBufferPool
+{
+public:
+  CRenderBufferPoolOpenGLES(CRenderContext& context);
+  ~CRenderBufferPoolOpenGLES() override = default;
+
+  // implementation of IRenderBufferPool via CBaseRenderBufferPool
+  bool IsCompatible(const CRenderVideoSettings& renderSettings) const override;
+
+private:
+  // implementation of CBaseRenderBufferPool
+  IRenderBuffer* CreateRenderBuffer(void* header = nullptr) override;
+  bool ConfigureInternal() override;
+
+  // Construction parameters
+  CRenderContext& m_context;
+
+  // Configuration parameters
+  GLuint m_pixeltype = 0;
+  GLuint m_internalformat = 0;
+  GLuint m_pixelformat = 0;
+  GLuint m_bpp = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.cpp b/xbmc/cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.cpp
index cc612571eb28..b939131cfd85 100644
--- a/xbmc/cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.cpp
@@ -11,13 +11,15 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRenderBufferGuiTexture::CRenderBufferGuiTexture(SCALINGMETHOD scalingMethod) :
-  m_scalingMethod(scalingMethod)
+CRenderBufferGuiTexture::CRenderBufferGuiTexture(SCALINGMETHOD scalingMethod)
+  : m_scalingMethod(scalingMethod)
 {
   m_textureFormat = XB_FMT_A8R8G8B8;
 }
 
-bool CRenderBufferGuiTexture::Allocate(AVPixelFormat format, unsigned int width, unsigned int height)
+bool CRenderBufferGuiTexture::Allocate(AVPixelFormat format,
+                                       unsigned int width,
+                                       unsigned int height)
 {
   // Initialize IRenderBuffer
   m_format = TranslateFormat(m_textureFormat);
@@ -46,7 +48,7 @@ size_t CRenderBufferGuiTexture::GetFrameSize() const
   return 0;
 }
 
-uint8_t *CRenderBufferGuiTexture::GetMemory()
+uint8_t* CRenderBufferGuiTexture::GetMemory()
 {
   if (m_texture)
     return m_texture->GetPixels();
@@ -77,11 +79,11 @@ AVPixelFormat CRenderBufferGuiTexture::TranslateFormat(unsigned int textureForma
 {
   switch (textureFormat)
   {
-  case XB_FMT_RGBA8:
-  case XB_FMT_A8R8G8B8:
-    return AV_PIX_FMT_BGRA;
-  default:
-    break;
+    case XB_FMT_RGBA8:
+    case XB_FMT_A8R8G8B8:
+      return AV_PIX_FMT_BGRA;
+    default:
+      break;
   }
 
   return AV_PIX_FMT_NONE;
@@ -91,12 +93,12 @@ TEXTURE_SCALING CRenderBufferGuiTexture::TranslateScalingMethod(SCALINGMETHOD sc
 {
   switch (scalingMethod)
   {
-  case SCALINGMETHOD::NEAREST:
-    return TEXTURE_SCALING::NEAREST;
-  case SCALINGMETHOD::LINEAR:
-    return TEXTURE_SCALING::LINEAR;
-  default:
-    break;
+    case SCALINGMETHOD::NEAREST:
+      return TEXTURE_SCALING::NEAREST;
+    case SCALINGMETHOD::LINEAR:
+      return TEXTURE_SCALING::LINEAR;
+    default:
+      break;
   }
 
   return TEXTURE_SCALING::NEAREST;
diff --git a/xbmc/cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.h b/xbmc/cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.h
index f50c9484dbae..3dcea5ac4b23 100644
--- a/xbmc/cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.h
+++ b/xbmc/cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.h
@@ -19,31 +19,31 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderBufferGuiTexture : public CBaseRenderBuffer
-  {
-  public:
-    CRenderBufferGuiTexture(SCALINGMETHOD scalingMethod);
-    ~CRenderBufferGuiTexture() override = default;
-
-    // implementation of IRenderBuffer via CBaseRenderBuffer
-    bool Allocate(AVPixelFormat format, unsigned int width, unsigned int height) override;
-    size_t GetFrameSize() const override;
-    uint8_t *GetMemory() override;
-    bool UploadTexture() override;
-    void BindToUnit(unsigned int unit) override;
-
-    // GUI texture interface
-    CTexture *GetTexture() { return m_texture.get(); }
-
-  protected:
-    AVPixelFormat TranslateFormat(unsigned int textureFormat);
-    TEXTURE_SCALING TranslateScalingMethod(SCALINGMETHOD scalingMethod);
-
-    // Texture parameters
-    SCALINGMETHOD m_scalingMethod;
-    unsigned int m_textureFormat = XB_FMT_UNKNOWN;
-    std::unique_ptr<CTexture> m_texture;
-  };
-
-}
-}
+class CRenderBufferGuiTexture : public CBaseRenderBuffer
+{
+public:
+  CRenderBufferGuiTexture(SCALINGMETHOD scalingMethod);
+  ~CRenderBufferGuiTexture() override = default;
+
+  // implementation of IRenderBuffer via CBaseRenderBuffer
+  bool Allocate(AVPixelFormat format, unsigned int width, unsigned int height) override;
+  size_t GetFrameSize() const override;
+  uint8_t* GetMemory() override;
+  bool UploadTexture() override;
+  void BindToUnit(unsigned int unit) override;
+
+  // GUI texture interface
+  CTexture* GetTexture() { return m_texture.get(); }
+
+protected:
+  AVPixelFormat TranslateFormat(unsigned int textureFormat);
+  TEXTURE_SCALING TranslateScalingMethod(SCALINGMETHOD scalingMethod);
+
+  // Texture parameters
+  SCALINGMETHOD m_scalingMethod;
+  unsigned int m_textureFormat = XB_FMT_UNKNOWN;
+  std::unique_ptr<CTexture> m_texture;
+};
+
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/buffers/video/RenderBufferSysMem.cpp b/xbmc/cores/RetroPlayer/buffers/video/RenderBufferSysMem.cpp
index 0fdcd25e4205..8fb426062f21 100644
--- a/xbmc/cores/RetroPlayer/buffers/video/RenderBufferSysMem.cpp
+++ b/xbmc/cores/RetroPlayer/buffers/video/RenderBufferSysMem.cpp
@@ -37,12 +37,14 @@ size_t CRenderBufferSysMem::GetFrameSize() const
   return m_data.size();
 }
 
-uint8_t *CRenderBufferSysMem::GetMemory()
+uint8_t* CRenderBufferSysMem::GetMemory()
 {
   return m_data.data();
 }
 
-size_t CRenderBufferSysMem::GetBufferSize(AVPixelFormat format, unsigned int width, unsigned int height)
+size_t CRenderBufferSysMem::GetBufferSize(AVPixelFormat format,
+                                          unsigned int width,
+                                          unsigned int height)
 {
   const size_t bufferStride = CRenderTranslator::TranslateWidthToBytes(width, format);
   const size_t bufferSize = bufferStride * height;
diff --git a/xbmc/cores/RetroPlayer/buffers/video/RenderBufferSysMem.h b/xbmc/cores/RetroPlayer/buffers/video/RenderBufferSysMem.h
index 12af72468361..1312e46ff18b 100644
--- a/xbmc/cores/RetroPlayer/buffers/video/RenderBufferSysMem.h
+++ b/xbmc/cores/RetroPlayer/buffers/video/RenderBufferSysMem.h
@@ -13,7 +13,8 @@
 #include <stdint.h>
 #include <vector>
 
-extern "C" {
+extern "C"
+{
 #include <libavutil/pixfmt.h>
 }
 
@@ -21,23 +22,23 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderBufferSysMem : public CBaseRenderBuffer
-  {
-  public:
-    CRenderBufferSysMem() = default;
-    ~CRenderBufferSysMem() override = default;
+class CRenderBufferSysMem : public CBaseRenderBuffer
+{
+public:
+  CRenderBufferSysMem() = default;
+  ~CRenderBufferSysMem() override = default;
 
-    // implementation of IRenderBuffer
-    bool Allocate(AVPixelFormat format, unsigned int width, unsigned int height) override;
-    size_t GetFrameSize() const override;
-    uint8_t *GetMemory() override;
+  // implementation of IRenderBuffer
+  bool Allocate(AVPixelFormat format, unsigned int width, unsigned int height) override;
+  size_t GetFrameSize() const override;
+  uint8_t* GetMemory() override;
 
-    // Utility functions
-    static size_t GetBufferSize(AVPixelFormat format, unsigned int width, unsigned int height);
+  // Utility functions
+  static size_t GetBufferSize(AVPixelFormat format, unsigned int width, unsigned int height);
 
-  protected:
-    std::vector<uint8_t> m_data;
-  };
+protected:
+  std::vector<uint8_t> m_data;
+};
 
-}
-}
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIGameRenderManager.cpp b/xbmc/cores/RetroPlayer/guibridge/GUIGameRenderManager.cpp
index 4b91d97cbc2d..872c4179f562 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIGameRenderManager.cpp
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIGameRenderManager.cpp
@@ -22,9 +22,9 @@ using namespace RETRO;
 
 CGUIGameRenderManager::~CGUIGameRenderManager() = default;
 
-void CGUIGameRenderManager::RegisterPlayer(CGUIRenderTargetFactory *factory,
-                                           IRenderCallback *callback,
-                                           IGameCallback *gameCallback)
+void CGUIGameRenderManager::RegisterPlayer(CGUIRenderTargetFactory* factory,
+                                           IRenderCallback* callback,
+                                           IGameCallback* gameCallback)
 {
   // Set factory
   {
@@ -68,7 +68,7 @@ void CGUIGameRenderManager::UnregisterPlayer()
   }
 }
 
-std::shared_ptr<CGUIRenderHandle> CGUIGameRenderManager::RegisterControl(CGUIGameControl &control)
+std::shared_ptr<CGUIRenderHandle> CGUIGameRenderManager::RegisterControl(CGUIGameControl& control)
 {
   CSingleLock lock(m_targetMutex);
 
@@ -84,7 +84,8 @@ std::shared_ptr<CGUIRenderHandle> CGUIGameRenderManager::RegisterControl(CGUIGam
   return renderHandle;
 }
 
-std::shared_ptr<CGUIRenderHandle> CGUIGameRenderManager::RegisterWindow(CGameWindowFullScreen &window)
+std::shared_ptr<CGUIRenderHandle> CGUIGameRenderManager::RegisterWindow(
+    CGameWindowFullScreen& window)
 {
   CSingleLock lock(m_targetMutex);
 
@@ -100,7 +101,8 @@ std::shared_ptr<CGUIRenderHandle> CGUIGameRenderManager::RegisterWindow(CGameWin
   return renderHandle;
 }
 
-std::shared_ptr<CGUIGameVideoHandle> CGUIGameRenderManager::RegisterDialog(GAME::CDialogGameVideoSelect &dialog)
+std::shared_ptr<CGUIGameVideoHandle> CGUIGameRenderManager::RegisterDialog(
+    GAME::CDialogGameVideoSelect& dialog)
 {
   return std::make_shared<CGUIGameVideoHandle>(*this);
 }
@@ -110,60 +112,60 @@ std::shared_ptr<CGUIGameSettingsHandle> CGUIGameRenderManager::RegisterGameSetti
   return std::make_shared<CGUIGameSettingsHandle>(*this);
 }
 
-void CGUIGameRenderManager::UnregisterHandle(CGUIRenderHandle *handle)
+void CGUIGameRenderManager::UnregisterHandle(CGUIRenderHandle* handle)
 {
   CSingleLock lock(m_targetMutex);
 
   m_renderTargets.erase(handle);
 }
 
-void CGUIGameRenderManager::Render(CGUIRenderHandle *handle)
+void CGUIGameRenderManager::Render(CGUIRenderHandle* handle)
 {
   CSingleLock lock(m_targetMutex);
 
   auto it = m_renderTargets.find(handle);
   if (it != m_renderTargets.end())
   {
-    const std::shared_ptr<CGUIRenderTarget> &renderTarget = it->second;
+    const std::shared_ptr<CGUIRenderTarget>& renderTarget = it->second;
     if (renderTarget)
       renderTarget->Render();
   }
 }
 
-void CGUIGameRenderManager::RenderEx(CGUIRenderHandle *handle)
+void CGUIGameRenderManager::RenderEx(CGUIRenderHandle* handle)
 {
   CSingleLock lock(m_targetMutex);
 
   auto it = m_renderTargets.find(handle);
   if (it != m_renderTargets.end())
   {
-    const std::shared_ptr<CGUIRenderTarget> &renderTarget = it->second;
+    const std::shared_ptr<CGUIRenderTarget>& renderTarget = it->second;
     if (renderTarget)
       renderTarget->RenderEx();
   }
 }
 
-void CGUIGameRenderManager::ClearBackground(CGUIRenderHandle *handle)
+void CGUIGameRenderManager::ClearBackground(CGUIRenderHandle* handle)
 {
   CSingleLock lock(m_targetMutex);
 
   auto it = m_renderTargets.find(handle);
   if (it != m_renderTargets.end())
   {
-    const std::shared_ptr<CGUIRenderTarget> &renderTarget = it->second;
+    const std::shared_ptr<CGUIRenderTarget>& renderTarget = it->second;
     if (renderTarget)
       renderTarget->ClearBackground();
   }
 }
 
-bool CGUIGameRenderManager::IsDirty(CGUIRenderHandle *handle)
+bool CGUIGameRenderManager::IsDirty(CGUIRenderHandle* handle)
 {
   CSingleLock lock(m_targetMutex);
 
   auto it = m_renderTargets.find(handle);
   if (it != m_renderTargets.end())
   {
-    const std::shared_ptr<CGUIRenderTarget> &renderTarget = it->second;
+    const std::shared_ptr<CGUIRenderTarget>& renderTarget = it->second;
     if (renderTarget)
       return renderTarget->IsDirty();
   }
@@ -212,10 +214,10 @@ void CGUIGameRenderManager::UpdateRenderTargets()
 {
   if (m_factory != nullptr)
   {
-    for (auto &it: m_renderTargets)
+    for (auto& it : m_renderTargets)
     {
-      CGUIRenderHandle *handle = it.first;
-      std::shared_ptr<CGUIRenderTarget> &renderTarget = it.second;
+      CGUIRenderHandle* handle = it.first;
+      std::shared_ptr<CGUIRenderTarget>& renderTarget = it.second;
 
       if (!renderTarget)
         renderTarget.reset(CreateRenderTarget(handle));
@@ -223,27 +225,28 @@ void CGUIGameRenderManager::UpdateRenderTargets()
   }
   else
   {
-    for (auto &it : m_renderTargets)
+    for (auto& it : m_renderTargets)
       it.second.reset();
   }
 }
 
-CGUIRenderTarget *CGUIGameRenderManager::CreateRenderTarget(CGUIRenderHandle *handle)
+CGUIRenderTarget* CGUIGameRenderManager::CreateRenderTarget(CGUIRenderHandle* handle)
 {
   switch (handle->Type())
   {
-  case RENDER_HANDLE::CONTROL:
-  {
-    CGUIRenderControlHandle *controlHandle = static_cast<CGUIRenderControlHandle*>(handle);
-    return m_factory->CreateRenderControl(controlHandle->GetControl());
-  }
-  case RENDER_HANDLE::WINDOW:
-  {
-    CGUIRenderFullScreenHandle *fullScreenHandle = static_cast<CGUIRenderFullScreenHandle*>(handle);
-    return m_factory->CreateRenderFullScreen(fullScreenHandle->GetWindow());
-  }
-  default:
-    break;
+    case RENDER_HANDLE::CONTROL:
+    {
+      CGUIRenderControlHandle* controlHandle = static_cast<CGUIRenderControlHandle*>(handle);
+      return m_factory->CreateRenderControl(controlHandle->GetControl());
+    }
+    case RENDER_HANDLE::WINDOW:
+    {
+      CGUIRenderFullScreenHandle* fullScreenHandle =
+          static_cast<CGUIRenderFullScreenHandle*>(handle);
+      return m_factory->CreateRenderFullScreen(fullScreenHandle->GetWindow());
+    }
+    default:
+      break;
   }
 
   return nullptr;
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIGameRenderManager.h b/xbmc/cores/RetroPlayer/guibridge/GUIGameRenderManager.h
index d0191542e2fc..f5040bc559f7 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIGameRenderManager.h
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIGameRenderManager.h
@@ -18,156 +18,156 @@ namespace KODI
 {
 namespace GAME
 {
-  class CDialogGameAdvancedSettings;
-  class CDialogGameVideoSelect;
-}
+class CDialogGameAdvancedSettings;
+class CDialogGameVideoSelect;
+} // namespace GAME
 
 namespace RETRO
 {
-  class CGameWindowFullScreen;
-  class CGUIGameControl;
-  class CGUIGameSettingsHandle;
-  class CGUIGameVideoHandle;
-  class CGUIRenderTargetFactory;
-  class CGUIRenderHandle;
-  class CGUIRenderTarget;
-  class IGameCallback;
-  class IRenderCallback;
+class CGameWindowFullScreen;
+class CGUIGameControl;
+class CGUIGameSettingsHandle;
+class CGUIGameVideoHandle;
+class CGUIRenderTargetFactory;
+class CGUIRenderHandle;
+class CGUIRenderTarget;
+class IGameCallback;
+class IRenderCallback;
+
+/*!
+ * \brief Class to safely route commands between the GUI and RetroPlayer
+ *
+ * This class is brought up before the GUI and player core factory. It
+ * provides the GUI with safe access to a registered player.
+ *
+ * Access to the player is done through handles. When a handle is no
+ * longer needed, it should be destroyed.
+ *
+ * Two kinds of handles are provided:
+ *
+ *   - CGUIRenderHandle
+ *         Allows the holder to invoke render events
+ *
+ *   - CGUIGameVideoHandle
+ *         Allows the holder to query video properties, such as the filter
+ *         or view mode.
+ *
+ * Each manager fulfills the following design requirements:
+ *
+ *   1. No assumption of player lifetimes
+ *
+ *   2. No assumption of GUI element lifetimes, as long as handles are
+ *      destroyed before this class is destructed
+ *
+ *   3. No limit on the number of handles
+ */
+class CGUIGameRenderManager
+{
+  friend class CGUIGameSettingsHandle;
+  friend class CGUIGameVideoHandle;
+  friend class CGUIRenderHandle;
+
+public:
+  CGUIGameRenderManager() = default;
+  ~CGUIGameRenderManager();
 
   /*!
-   * \brief Class to safely route commands between the GUI and RetroPlayer
+   * \brief Register a RetroPlayer instance
    *
-   * This class is brought up before the GUI and player core factory. It
-   * provides the GUI with safe access to a registered player.
+   * \param factory The interface for creating render targets exposed to the GUI
+   * \param callback The interface for querying video properties
+   * \param gameCallback The interface for querying game properties
+   */
+  void RegisterPlayer(CGUIRenderTargetFactory* factory,
+                      IRenderCallback* callback,
+                      IGameCallback* gameCallback);
+
+  /*!
+   * \brief Unregister a RetroPlayer instance
+   */
+  void UnregisterPlayer();
+
+  /*!
+   * \brief Register a GUI game control ("gamewindow" skin control)
+   *
+   * \param control The game control
    *
-   * Access to the player is done through handles. When a handle is no
-   * longer needed, it should be destroyed.
+   * \return A handle to invoke render events
+   */
+  std::shared_ptr<CGUIRenderHandle> RegisterControl(CGUIGameControl& control);
+
+  /*!
+   * \brief Register a fullscreen game window ("FullscreenGame" window)
    *
-   * Two kinds of handles are provided:
+   * \param window The game window
    *
-   *   - CGUIRenderHandle
-   *         Allows the holder to invoke render events
+   * \return A handle to invoke render events
+   */
+  std::shared_ptr<CGUIRenderHandle> RegisterWindow(CGameWindowFullScreen& window);
+
+  /*!
+   * \brief Register a video select dialog (for selecting video filters,
+   *        view modes, etc.)
    *
-   *   - CGUIGameVideoHandle
-   *         Allows the holder to query video properties, such as the filter
-   *         or view mode.
+   * \param dialog The video select dialog
    *
-   * Each manager fulfills the following design requirements:
+   * \return A handle to query game and video properties
+   */
+  std::shared_ptr<CGUIGameVideoHandle> RegisterDialog(GAME::CDialogGameVideoSelect& dialog);
+
+  /*!
+   * \brief Register a game settings dialog
    *
-   *   1. No assumption of player lifetimes
+   * \return A handle to query game properties
+   */
+  std::shared_ptr<CGUIGameSettingsHandle> RegisterGameSettingsDialog();
+
+protected:
+  // Functions exposed to friend class CGUIRenderHandle
+  void UnregisterHandle(CGUIRenderHandle* handle);
+  void Render(CGUIRenderHandle* handle);
+  void RenderEx(CGUIRenderHandle* handle);
+  void ClearBackground(CGUIRenderHandle* handle);
+  bool IsDirty(CGUIRenderHandle* handle);
+
+  // Functions exposed to friend class CGUIGameVideoHandle
+  void UnregisterHandle(CGUIGameVideoHandle* handle) {}
+  bool IsPlayingGame();
+  bool SupportsRenderFeature(RENDERFEATURE feature);
+  bool SupportsScalingMethod(SCALINGMETHOD method);
+
+  // Functions exposed to CGUIGameSettingsHandle
+  void UnregisterHandle(CGUIGameSettingsHandle* handle) {}
+  std::string GameClientID();
+
+private:
+  /*!
+   * \brief Helper function to create or destroy render targets when a
+   *        factory is registered/unregistered
+   */
+  void UpdateRenderTargets();
+
+  /*!
+   * \brief Helper function to create a render target
    *
-   *   2. No assumption of GUI element lifetimes, as long as handles are
-   *      destroyed before this class is destructed
+   * \param handle The handle given to the registered GUI element
    *
-   *   3. No limit on the number of handles
+   * \return A target to receive rendering commands
    */
-  class CGUIGameRenderManager
-  {
-    friend class CGUIGameSettingsHandle;
-    friend class CGUIGameVideoHandle;
-    friend class CGUIRenderHandle;
-
-  public:
-    CGUIGameRenderManager() = default;
-    ~CGUIGameRenderManager();
-
-    /*!
-     * \brief Register a RetroPlayer instance
-     *
-     * \param factory The interface for creating render targets exposed to the GUI
-     * \param callback The interface for querying video properties
-     * \param gameCallback The interface for querying game properties
-     */
-    void RegisterPlayer(CGUIRenderTargetFactory *factory,
-                        IRenderCallback *callback,
-                        IGameCallback *gameCallback);
-
-    /*!
-     * \brief Unregister a RetroPlayer instance
-     */
-    void UnregisterPlayer();
-
-    /*!
-     * \brief Register a GUI game control ("gamewindow" skin control)
-     *
-     * \param control The game control
-     *
-     * \return A handle to invoke render events
-     */
-    std::shared_ptr<CGUIRenderHandle> RegisterControl(CGUIGameControl &control);
-
-    /*!
-     * \brief Register a fullscreen game window ("FullscreenGame" window)
-     *
-     * \param window The game window
-     *
-     * \return A handle to invoke render events
-     */
-    std::shared_ptr<CGUIRenderHandle> RegisterWindow(CGameWindowFullScreen &window);
-
-    /*!
-     * \brief Register a video select dialog (for selecting video filters,
-     *        view modes, etc.)
-     *
-     * \param dialog The video select dialog
-     *
-     * \return A handle to query game and video properties
-     */
-    std::shared_ptr<CGUIGameVideoHandle> RegisterDialog(GAME::CDialogGameVideoSelect &dialog);
-
-    /*!
-     * \brief Register a game settings dialog
-     *
-     * \return A handle to query game properties
-     */
-    std::shared_ptr<CGUIGameSettingsHandle> RegisterGameSettingsDialog();
-
-  protected:
-    // Functions exposed to friend class CGUIRenderHandle
-    void UnregisterHandle(CGUIRenderHandle *handle);
-    void Render(CGUIRenderHandle *handle);
-    void RenderEx(CGUIRenderHandle *handle);
-    void ClearBackground(CGUIRenderHandle *handle);
-    bool IsDirty(CGUIRenderHandle *handle);
-
-    // Functions exposed to friend class CGUIGameVideoHandle
-    void UnregisterHandle(CGUIGameVideoHandle *handle) { }
-    bool IsPlayingGame();
-    bool SupportsRenderFeature(RENDERFEATURE feature);
-    bool SupportsScalingMethod(SCALINGMETHOD method);
-
-    // Functions exposed to CGUIGameSettingsHandle
-    void UnregisterHandle(CGUIGameSettingsHandle *handle) { }
-    std::string GameClientID();
-
-  private:
-    /*!
-     * \brief Helper function to create or destroy render targets when a
-     *        factory is registered/unregistered
-     */
-    void UpdateRenderTargets();
-
-    /*!
-     * \brief Helper function to create a render target
-     *
-     * \param handle The handle given to the registered GUI element
-     *
-     * \return A target to receive rendering commands
-     */
-    CGUIRenderTarget *CreateRenderTarget(CGUIRenderHandle *handle);
-
-    // Render events
-    CGUIRenderTargetFactory *m_factory = nullptr;
-    std::map<CGUIRenderHandle*, std::shared_ptr<CGUIRenderTarget>> m_renderTargets;
-    CCriticalSection m_targetMutex;
-
-    // Video properties
-    IRenderCallback *m_callback = nullptr;
-    CCriticalSection m_callbackMutex;
-
-    // Game properties
-    IGameCallback *m_gameCallback = nullptr;
-    CCriticalSection m_gameCallbackMutex;
-  };
-}
-}
+  CGUIRenderTarget* CreateRenderTarget(CGUIRenderHandle* handle);
+
+  // Render events
+  CGUIRenderTargetFactory* m_factory = nullptr;
+  std::map<CGUIRenderHandle*, std::shared_ptr<CGUIRenderTarget>> m_renderTargets;
+  CCriticalSection m_targetMutex;
+
+  // Video properties
+  IRenderCallback* m_callback = nullptr;
+  CCriticalSection m_callbackMutex;
+
+  // Game properties
+  IGameCallback* m_gameCallback = nullptr;
+  CCriticalSection m_gameCallbackMutex;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIGameSettings.cpp b/xbmc/cores/RetroPlayer/guibridge/GUIGameSettings.cpp
index 795ffc078850..d2c48f7f13f2 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIGameSettings.cpp
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIGameSettings.cpp
@@ -16,9 +16,8 @@
 using namespace KODI;
 using namespace RETRO;
 
-CGUIGameSettings::CGUIGameSettings(CRPProcessInfo &processInfo) :
-  m_processInfo(processInfo),
-  m_guiSettings(processInfo.GetRenderContext().GetGameSettings())
+CGUIGameSettings::CGUIGameSettings(CRPProcessInfo& processInfo)
+  : m_processInfo(processInfo), m_guiSettings(processInfo.GetRenderContext().GetGameSettings())
 {
   // Reset game settings
   m_guiSettings = m_processInfo.GetRenderContext().GetDefaultGameSettings();
@@ -40,17 +39,17 @@ CRenderSettings CGUIGameSettings::GetSettings() const
   return m_renderSettings;
 }
 
-void CGUIGameSettings::Notify(const Observable &obs, const ObservableMessage msg)
+void CGUIGameSettings::Notify(const Observable& obs, const ObservableMessage msg)
 {
   switch (msg)
   {
-  case ObservableMessageSettingsChanged:
-  {
-    UpdateSettings();
-    break;
-  }
-  default:
-    break;
+    case ObservableMessageSettingsChanged:
+    {
+      UpdateSettings();
+      break;
+    }
+    default:
+      break;
   }
 }
 
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIGameSettings.h b/xbmc/cores/RetroPlayer/guibridge/GUIGameSettings.h
index a5e750387889..6400b8d3ba01 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIGameSettings.h
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIGameSettings.h
@@ -21,35 +21,34 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfo;
+class CRPProcessInfo;
 
-  class CGUIGameSettings : public IGUIRenderSettings,
-                           public Observer
-  {
-  public:
-    CGUIGameSettings(CRPProcessInfo &processInfo);
-    ~CGUIGameSettings() override;
+class CGUIGameSettings : public IGUIRenderSettings, public Observer
+{
+public:
+  CGUIGameSettings(CRPProcessInfo& processInfo);
+  ~CGUIGameSettings() override;
 
-    // implementation of IGUIRenderSettings
-    CRenderSettings GetSettings() const override;
+  // implementation of IGUIRenderSettings
+  CRenderSettings GetSettings() const override;
 
-    // implementation of Observer
-    void Notify(const Observable &obs, const ObservableMessage msg) override;
+  // implementation of Observer
+  void Notify(const Observable& obs, const ObservableMessage msg) override;
 
-  private:
-    void UpdateSettings();
+private:
+  void UpdateSettings();
 
-    // Construction parameters
-    CRPProcessInfo &m_processInfo;
+  // Construction parameters
+  CRPProcessInfo& m_processInfo;
 
-    // GUI parameters
-    CGameSettings &m_guiSettings;
+  // GUI parameters
+  CGameSettings& m_guiSettings;
 
-    // Render parameters
-    CRenderSettings m_renderSettings;
+  // Render parameters
+  CRenderSettings m_renderSettings;
 
-    // Synchronization parameters
-    mutable CCriticalSection m_mutex;
-  };
-}
-}
+  // Synchronization parameters
+  mutable CCriticalSection m_mutex;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIGameSettingsHandle.cpp b/xbmc/cores/RetroPlayer/guibridge/GUIGameSettingsHandle.cpp
index 65772072ba35..73c589cd0a8b 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIGameSettingsHandle.cpp
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIGameSettingsHandle.cpp
@@ -13,8 +13,8 @@
 using namespace KODI;
 using namespace RETRO;
 
-CGUIGameSettingsHandle::CGUIGameSettingsHandle(CGUIGameRenderManager &renderManager) :
-  m_renderManager(renderManager)
+CGUIGameSettingsHandle::CGUIGameSettingsHandle(CGUIGameRenderManager& renderManager)
+  : m_renderManager(renderManager)
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIGameSettingsHandle.h b/xbmc/cores/RetroPlayer/guibridge/GUIGameSettingsHandle.h
index 2f53e8b3ce45..14c53977c657 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIGameSettingsHandle.h
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIGameSettingsHandle.h
@@ -14,19 +14,19 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGUIGameRenderManager;
+class CGUIGameRenderManager;
 
-  class CGUIGameSettingsHandle
-  {
-  public:
-    CGUIGameSettingsHandle(CGUIGameRenderManager &renderManager);
-    virtual ~CGUIGameSettingsHandle();
+class CGUIGameSettingsHandle
+{
+public:
+  CGUIGameSettingsHandle(CGUIGameRenderManager& renderManager);
+  virtual ~CGUIGameSettingsHandle();
 
-    std::string GameClientID();
+  std::string GameClientID();
 
-  private:
-    // Construction parameters
-    CGUIGameRenderManager &m_renderManager;
-  };
-}
-}
+private:
+  // Construction parameters
+  CGUIGameRenderManager& m_renderManager;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIGameVideoHandle.cpp b/xbmc/cores/RetroPlayer/guibridge/GUIGameVideoHandle.cpp
index 7ad8cde6a594..521cf4bd233c 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIGameVideoHandle.cpp
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIGameVideoHandle.cpp
@@ -13,8 +13,8 @@
 using namespace KODI;
 using namespace RETRO;
 
-CGUIGameVideoHandle::CGUIGameVideoHandle(CGUIGameRenderManager &renderManager) :
-  m_renderManager(renderManager)
+CGUIGameVideoHandle::CGUIGameVideoHandle(CGUIGameRenderManager& renderManager)
+  : m_renderManager(renderManager)
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIGameVideoHandle.h b/xbmc/cores/RetroPlayer/guibridge/GUIGameVideoHandle.h
index fcb948b0d146..4d26fe4a7e99 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIGameVideoHandle.h
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIGameVideoHandle.h
@@ -14,21 +14,21 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGUIGameRenderManager;
+class CGUIGameRenderManager;
 
-  class CGUIGameVideoHandle
-  {
-  public:
-    CGUIGameVideoHandle(CGUIGameRenderManager &renderManager);
-    virtual ~CGUIGameVideoHandle();
+class CGUIGameVideoHandle
+{
+public:
+  CGUIGameVideoHandle(CGUIGameRenderManager& renderManager);
+  virtual ~CGUIGameVideoHandle();
 
-    bool IsPlayingGame();
-    bool SupportsRenderFeature(RENDERFEATURE feature);
-    bool SupportsScalingMethod(SCALINGMETHOD method);
+  bool IsPlayingGame();
+  bool SupportsRenderFeature(RENDERFEATURE feature);
+  bool SupportsScalingMethod(SCALINGMETHOD method);
 
-  private:
-    // Construction parameters
-    CGUIGameRenderManager &m_renderManager;
-  };
-}
-}
+private:
+  // Construction parameters
+  CGUIGameRenderManager& m_renderManager;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIRenderHandle.cpp b/xbmc/cores/RetroPlayer/guibridge/GUIRenderHandle.cpp
index 34b77fd9b81f..a4b64039094e 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIRenderHandle.cpp
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIRenderHandle.cpp
@@ -15,9 +15,8 @@ using namespace RETRO;
 
 // --- CGUIRenderHandle --------------------------------------------------------
 
-CGUIRenderHandle::CGUIRenderHandle(CGUIGameRenderManager &renderManager, RENDER_HANDLE type) :
-  m_renderManager(renderManager),
-  m_type(type)
+CGUIRenderHandle::CGUIRenderHandle(CGUIGameRenderManager& renderManager, RENDER_HANDLE type)
+  : m_renderManager(renderManager), m_type(type)
 {
 }
 
@@ -48,16 +47,16 @@ void CGUIRenderHandle::ClearBackground()
 
 // --- CGUIRenderControlHandle -------------------------------------------------
 
-CGUIRenderControlHandle::CGUIRenderControlHandle(CGUIGameRenderManager &renderManager, CGUIGameControl &control) :
-  CGUIRenderHandle(renderManager, RENDER_HANDLE::CONTROL),
-  m_control(control)
+CGUIRenderControlHandle::CGUIRenderControlHandle(CGUIGameRenderManager& renderManager,
+                                                 CGUIGameControl& control)
+  : CGUIRenderHandle(renderManager, RENDER_HANDLE::CONTROL), m_control(control)
 {
 }
 
 // --- CGUIRenderFullScreenHandle ----------------------------------------------
 
-CGUIRenderFullScreenHandle::CGUIRenderFullScreenHandle(CGUIGameRenderManager &renderManager, CGameWindowFullScreen &window) :
-  CGUIRenderHandle(renderManager, RENDER_HANDLE::WINDOW),
-  m_window(window)
+CGUIRenderFullScreenHandle::CGUIRenderFullScreenHandle(CGUIGameRenderManager& renderManager,
+                                                       CGameWindowFullScreen& window)
+  : CGUIRenderHandle(renderManager, RENDER_HANDLE::WINDOW), m_window(window)
 {
 }
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIRenderHandle.h b/xbmc/cores/RetroPlayer/guibridge/GUIRenderHandle.h
index e92d77f60fae..f5b8d5b9249d 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIRenderHandle.h
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIRenderHandle.h
@@ -12,65 +12,65 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGameWindowFullScreen;
-  class CGUIGameControl;
-  class CGUIGameRenderManager;
-
-  enum class RENDER_HANDLE
-  {
-    CONTROL,
-    WINDOW,
-  };
-
-  // --- CGUIRenderHandle ------------------------------------------------------
-
-  class CGUIRenderHandle
-  {
-  public:
-    CGUIRenderHandle(CGUIGameRenderManager &renderManager, RENDER_HANDLE type);
-    virtual ~CGUIRenderHandle();
-
-    RENDER_HANDLE Type() const { return m_type; }
-
-    void Render();
-    void RenderEx();
-    bool IsDirty();
-    void ClearBackground();
-
-  private:
-    // Construction parameters
-    CGUIGameRenderManager &m_renderManager;
-    const RENDER_HANDLE m_type;
-  };
-
-  // --- CGUIRenderControlHandle -----------------------------------------------
-
-  class CGUIRenderControlHandle : public CGUIRenderHandle
-  {
-  public:
-    CGUIRenderControlHandle(CGUIGameRenderManager &renderManager, CGUIGameControl &control);
-    ~CGUIRenderControlHandle() override = default;
-
-    CGUIGameControl &GetControl() { return m_control; }
-
-  private:
-    // Construction parameters
-    CGUIGameControl &m_control;
-  };
-
-  // --- CGUIRenderFullScreenHandle --------------------------------------------
-
-  class CGUIRenderFullScreenHandle : public CGUIRenderHandle
-  {
-  public:
-    CGUIRenderFullScreenHandle(CGUIGameRenderManager &renderManager, CGameWindowFullScreen &window);
-    ~CGUIRenderFullScreenHandle() override = default;
-
-    CGameWindowFullScreen &GetWindow() { return m_window; }
-
-  private:
-    // Construction parameters
-    CGameWindowFullScreen &m_window;
-  };
-}
-}
+class CGameWindowFullScreen;
+class CGUIGameControl;
+class CGUIGameRenderManager;
+
+enum class RENDER_HANDLE
+{
+  CONTROL,
+  WINDOW,
+};
+
+// --- CGUIRenderHandle ------------------------------------------------------
+
+class CGUIRenderHandle
+{
+public:
+  CGUIRenderHandle(CGUIGameRenderManager& renderManager, RENDER_HANDLE type);
+  virtual ~CGUIRenderHandle();
+
+  RENDER_HANDLE Type() const { return m_type; }
+
+  void Render();
+  void RenderEx();
+  bool IsDirty();
+  void ClearBackground();
+
+private:
+  // Construction parameters
+  CGUIGameRenderManager& m_renderManager;
+  const RENDER_HANDLE m_type;
+};
+
+// --- CGUIRenderControlHandle -----------------------------------------------
+
+class CGUIRenderControlHandle : public CGUIRenderHandle
+{
+public:
+  CGUIRenderControlHandle(CGUIGameRenderManager& renderManager, CGUIGameControl& control);
+  ~CGUIRenderControlHandle() override = default;
+
+  CGUIGameControl& GetControl() { return m_control; }
+
+private:
+  // Construction parameters
+  CGUIGameControl& m_control;
+};
+
+// --- CGUIRenderFullScreenHandle --------------------------------------------
+
+class CGUIRenderFullScreenHandle : public CGUIRenderHandle
+{
+public:
+  CGUIRenderFullScreenHandle(CGUIGameRenderManager& renderManager, CGameWindowFullScreen& window);
+  ~CGUIRenderFullScreenHandle() override = default;
+
+  CGameWindowFullScreen& GetWindow() { return m_window; }
+
+private:
+  // Construction parameters
+  CGameWindowFullScreen& m_window;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIRenderTarget.cpp b/xbmc/cores/RetroPlayer/guibridge/GUIRenderTarget.cpp
index 50ced4315458..15993fcb82b4 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIRenderTarget.cpp
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIRenderTarget.cpp
@@ -17,35 +17,35 @@ using namespace RETRO;
 
 // --- CGUIRenderTarget --------------------------------------------------------
 
-CGUIRenderTarget::CGUIRenderTarget(IRenderManager *renderManager) :
-  m_renderManager(renderManager)
+CGUIRenderTarget::CGUIRenderTarget(IRenderManager* renderManager) : m_renderManager(renderManager)
 {
 }
 
 // --- CGUIRenderControl -------------------------------------------------------
 
-CGUIRenderControl::CGUIRenderControl(IRenderManager *renderManager, CGUIGameControl &gameControl) :
-  CGUIRenderTarget(renderManager),
-  m_gameControl(gameControl)
+CGUIRenderControl::CGUIRenderControl(IRenderManager* renderManager, CGUIGameControl& gameControl)
+  : CGUIRenderTarget(renderManager), m_gameControl(gameControl)
 {
 }
 
 void CGUIRenderControl::Render()
 {
-  m_renderManager->RenderControl(true, true, m_gameControl.GetRenderRegion(), m_gameControl.GetRenderSettings());
+  m_renderManager->RenderControl(true, true, m_gameControl.GetRenderRegion(),
+                                 m_gameControl.GetRenderSettings());
 }
 
 void CGUIRenderControl::RenderEx()
 {
   //! @todo
-  //m_renderManager->RenderControl(false, false, m_gameControl.GetRenderRegion(), m_gameControl.GetRenderSettings());
+  // m_renderManager->RenderControl(false, false, m_gameControl.GetRenderRegion(),
+  // m_gameControl.GetRenderSettings());
 }
 
 // --- CGUIRenderFullScreen ----------------------------------------------------
 
-CGUIRenderFullScreen::CGUIRenderFullScreen(IRenderManager *renderManager, CGameWindowFullScreen &window) :
-  CGUIRenderTarget(renderManager),
-  m_window(window)
+CGUIRenderFullScreen::CGUIRenderFullScreen(IRenderManager* renderManager,
+                                           CGameWindowFullScreen& window)
+  : CGUIRenderTarget(renderManager), m_window(window)
 {
 }
 
@@ -57,7 +57,7 @@ void CGUIRenderFullScreen::Render()
 void CGUIRenderFullScreen::RenderEx()
 {
   //! @todo
-  //m_renderManager->RenderWindow(false, m_window.GetCoordsRes());
+  // m_renderManager->RenderWindow(false, m_window.GetCoordsRes());
 }
 
 void CGUIRenderFullScreen::ClearBackground()
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIRenderTarget.h b/xbmc/cores/RetroPlayer/guibridge/GUIRenderTarget.h
index 0453a7829275..574a13fa1d23 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIRenderTarget.h
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIRenderTarget.h
@@ -12,83 +12,83 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGameWindowFullScreen;
-  class CGUIGameControl;
-  class IRenderManager;
+class CGameWindowFullScreen;
+class CGUIGameControl;
+class IRenderManager;
 
-  // --- CGUIRenderTarget ------------------------------------------------------
+// --- CGUIRenderTarget ------------------------------------------------------
+
+/*!
+ * \brief A target of rendering commands
+ *
+ * This class abstracts the destination of rendering commands. As a result,
+ * controls and windows are given a unified API.
+ */
+class CGUIRenderTarget
+{
+public:
+  CGUIRenderTarget(IRenderManager* renderManager);
+
+  virtual ~CGUIRenderTarget() = default;
+
+  /*!
+   * \brief Draw the frame to the rendering area
+   */
+  virtual void Render() = 0;
+
+  /*!
+   * \brief Draw the frame to the rendering area differently somehow
+   */
+  virtual void RenderEx() = 0;
 
   /*!
-   * \brief A target of rendering commands
-   *
-   * This class abstracts the destination of rendering commands. As a result,
-   * controls and windows are given a unified API.
+   * \brief Clear the background of the rendering area
    */
-  class CGUIRenderTarget
-  {
-  public:
-    CGUIRenderTarget(IRenderManager *renderManager);
-
-    virtual ~CGUIRenderTarget() = default;
-
-    /*!
-     * \brief Draw the frame to the rendering area
-     */
-    virtual void Render() = 0;
-
-    /*!
-     * \brief Draw the frame to the rendering area differently somehow
-     */
-    virtual void RenderEx() = 0;
-
-    /*!
-     * \brief Clear the background of the rendering area
-     */
-    virtual void ClearBackground() { } //! @todo
-
-    /*!
-     * \brief Check of the rendering area is dirty
-     */
-    virtual bool IsDirty() { return true; } //! @todo
-
-  protected:
-    // Construction parameters
-    IRenderManager *const m_renderManager;
-  };
-
-  // --- CGUIRenderControl -----------------------------------------------------
-
-  class CGUIRenderControl : public CGUIRenderTarget
-  {
-  public:
-    CGUIRenderControl(IRenderManager *renderManager, CGUIGameControl &gameControl);
-    ~CGUIRenderControl() override = default;
-
-    // implementation of CGUIRenderTarget
-    void Render() override;
-    void RenderEx() override;
-
-  private:
-    // Construction parameters
-    CGUIGameControl &m_gameControl;
-  };
-
-  // --- CGUIRenderFullScreen --------------------------------------------------
-
-  class CGUIRenderFullScreen : public CGUIRenderTarget
-  {
-  public:
-    CGUIRenderFullScreen(IRenderManager *renderManager, CGameWindowFullScreen &window);
-    ~CGUIRenderFullScreen() override = default;
-
-    // implementation of CGUIRenderTarget
-    void Render() override;
-    void RenderEx() override;
-    void ClearBackground() override;
-
-  private:
-    // Construction parameters
-    CGameWindowFullScreen &m_window;
-  };
-}
-}
+  virtual void ClearBackground() {} //! @todo
+
+  /*!
+   * \brief Check of the rendering area is dirty
+   */
+  virtual bool IsDirty() { return true; } //! @todo
+
+protected:
+  // Construction parameters
+  IRenderManager* const m_renderManager;
+};
+
+// --- CGUIRenderControl -----------------------------------------------------
+
+class CGUIRenderControl : public CGUIRenderTarget
+{
+public:
+  CGUIRenderControl(IRenderManager* renderManager, CGUIGameControl& gameControl);
+  ~CGUIRenderControl() override = default;
+
+  // implementation of CGUIRenderTarget
+  void Render() override;
+  void RenderEx() override;
+
+private:
+  // Construction parameters
+  CGUIGameControl& m_gameControl;
+};
+
+// --- CGUIRenderFullScreen --------------------------------------------------
+
+class CGUIRenderFullScreen : public CGUIRenderTarget
+{
+public:
+  CGUIRenderFullScreen(IRenderManager* renderManager, CGameWindowFullScreen& window);
+  ~CGUIRenderFullScreen() override = default;
+
+  // implementation of CGUIRenderTarget
+  void Render() override;
+  void RenderEx() override;
+  void ClearBackground() override;
+
+private:
+  // Construction parameters
+  CGameWindowFullScreen& m_window;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIRenderTargetFactory.cpp b/xbmc/cores/RetroPlayer/guibridge/GUIRenderTargetFactory.cpp
index a5f6fd2dfcdb..05675c304c70 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIRenderTargetFactory.cpp
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIRenderTargetFactory.cpp
@@ -13,17 +13,17 @@
 using namespace KODI;
 using namespace RETRO;
 
-CGUIRenderTargetFactory::CGUIRenderTargetFactory(IRenderManager *renderManager) :
-  m_renderManager(renderManager)
+CGUIRenderTargetFactory::CGUIRenderTargetFactory(IRenderManager* renderManager)
+  : m_renderManager(renderManager)
 {
 }
 
-CGUIRenderTarget *CGUIRenderTargetFactory::CreateRenderFullScreen(CGameWindowFullScreen &window)
+CGUIRenderTarget* CGUIRenderTargetFactory::CreateRenderFullScreen(CGameWindowFullScreen& window)
 {
   return new CGUIRenderFullScreen(m_renderManager, window);
 }
 
-CGUIRenderTarget *CGUIRenderTargetFactory::CreateRenderControl(CGUIGameControl &gameControl)
+CGUIRenderTarget* CGUIRenderTargetFactory::CreateRenderControl(CGUIGameControl& gameControl)
 {
   return new CGUIRenderControl(m_renderManager, gameControl);
 }
diff --git a/xbmc/cores/RetroPlayer/guibridge/GUIRenderTargetFactory.h b/xbmc/cores/RetroPlayer/guibridge/GUIRenderTargetFactory.h
index 1b0c7455718c..8066854dae88 100644
--- a/xbmc/cores/RetroPlayer/guibridge/GUIRenderTargetFactory.h
+++ b/xbmc/cores/RetroPlayer/guibridge/GUIRenderTargetFactory.h
@@ -12,29 +12,29 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGameWindowFullScreen;
-  class CGUIGameControl;
-  class IRenderManager;
-  class CGUIRenderTarget;
+class CGameWindowFullScreen;
+class CGUIGameControl;
+class IRenderManager;
+class CGUIRenderTarget;
 
-  class CGUIRenderTargetFactory
-  {
-  public:
-    CGUIRenderTargetFactory(IRenderManager *renderManager);
+class CGUIRenderTargetFactory
+{
+public:
+  CGUIRenderTargetFactory(IRenderManager* renderManager);
 
-    /*!
-     * \brief Create a render target for the fullscreen window
-     */
-    CGUIRenderTarget *CreateRenderFullScreen(CGameWindowFullScreen &window);
+  /*!
+   * \brief Create a render target for the fullscreen window
+   */
+  CGUIRenderTarget* CreateRenderFullScreen(CGameWindowFullScreen& window);
 
-    /*!
-     * \brief Create a render target for a game control
-     */
-    CGUIRenderTarget *CreateRenderControl(CGUIGameControl &gameControl);
+  /*!
+   * \brief Create a render target for a game control
+   */
+  CGUIRenderTarget* CreateRenderControl(CGUIGameControl& gameControl);
 
-  private:
-    // Construction parameters
-    IRenderManager *m_renderManager;
-  };
-}
-}
+private:
+  // Construction parameters
+  IRenderManager* m_renderManager;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/IGUIRenderSettings.h b/xbmc/cores/RetroPlayer/guibridge/IGUIRenderSettings.h
index 9db6eb4dbda5..35970618e5fe 100644
--- a/xbmc/cores/RetroPlayer/guibridge/IGUIRenderSettings.h
+++ b/xbmc/cores/RetroPlayer/guibridge/IGUIRenderSettings.h
@@ -15,44 +15,44 @@ namespace KODI
 {
 namespace RETRO
 {
+/*!
+ * \brief Interface to pass render settings from the GUI to the renderer
+ */
+class IGUIRenderSettings
+{
+public:
+  virtual ~IGUIRenderSettings() = default;
+
+  /*!
+   * \brief Returns true if this render target has a video filter set
+   */
+  virtual bool HasVideoFilter() const { return true; }
+
+  /*!
+   * \brief Returns true if this render target has a stretch mode set
+   */
+  virtual bool HasStretchMode() const { return true; }
+
+  /*!
+   * \brief Returns true if this render target has a video rotation set
+   */
+  virtual bool HasRotation() const { return true; }
+
+  /*!
+   * \brief Get the settings used to render this target
+   *
+   * \return The render settings
+   */
+  virtual CRenderSettings GetSettings() const = 0;
+
   /*!
-   * \brief Interface to pass render settings from the GUI to the renderer
+   * \brief Get the dimensions of this target
+   *
+   * Dimensions are ignored for fullscreen windows.
+   *
+   * \return The destination dimensions, or unused for fullscreen window
    */
-  class IGUIRenderSettings
-  {
-  public:
-    virtual ~IGUIRenderSettings() = default;
-
-    /*!
-     * \brief Returns true if this render target has a video filter set
-     */
-    virtual bool HasVideoFilter() const { return true; }
-
-    /*!
-     * \brief Returns true if this render target has a stretch mode set
-     */
-    virtual bool HasStretchMode() const { return true; }
-
-    /*!
-     * \brief Returns true if this render target has a video rotation set
-     */
-    virtual bool HasRotation() const { return true; }
-
-    /*!
-     * \brief Get the settings used to render this target
-     *
-     * \return The render settings
-     */
-    virtual CRenderSettings GetSettings() const = 0;
-
-    /*!
-     * \brief Get the dimensions of this target
-     *
-     * Dimensions are ignored for fullscreen windows.
-     *
-     * \return The destination dimensions, or unused for fullscreen window
-     */
-    virtual CRect GetDimensions() const { return CRect{}; }
-  };
-}
-}
+  virtual CRect GetDimensions() const { return CRect{}; }
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/IGameCallback.h b/xbmc/cores/RetroPlayer/guibridge/IGameCallback.h
index 5f5bc676155d..e3cad64a36a4 100644
--- a/xbmc/cores/RetroPlayer/guibridge/IGameCallback.h
+++ b/xbmc/cores/RetroPlayer/guibridge/IGameCallback.h
@@ -14,17 +14,17 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IGameCallback
-  {
-  public:
-    virtual ~IGameCallback() = default;
+class IGameCallback
+{
+public:
+  virtual ~IGameCallback() = default;
 
-    /*!
-     * \brief Get the game client being used to play the game
-     *
-     * \return The game client's ID, or empty if no game is being played
-     */
-    virtual std::string GameClientID() const = 0;
-  };
-}
-}
+  /*!
+   * \brief Get the game client being used to play the game
+   *
+   * \return The game client's ID, or empty if no game is being played
+   */
+  virtual std::string GameClientID() const = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guibridge/IRenderCallback.h b/xbmc/cores/RetroPlayer/guibridge/IRenderCallback.h
index 74421326740e..948c6cddf606 100644
--- a/xbmc/cores/RetroPlayer/guibridge/IRenderCallback.h
+++ b/xbmc/cores/RetroPlayer/guibridge/IRenderCallback.h
@@ -14,13 +14,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IRenderCallback
-  {
-  public:
-    virtual ~IRenderCallback() = default;
+class IRenderCallback
+{
+public:
+  virtual ~IRenderCallback() = default;
 
-    virtual bool SupportsRenderFeature(RENDERFEATURE feature) const = 0;
-    virtual bool SupportsScalingMethod(SCALINGMETHOD method) const = 0;
-  };
-}
-}
+  virtual bool SupportsRenderFeature(RENDERFEATURE feature) const = 0;
+  virtual bool SupportsScalingMethod(SCALINGMETHOD method) const = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guicontrols/GUIGameControl.cpp b/xbmc/cores/RetroPlayer/guicontrols/GUIGameControl.cpp
index b13fd8f0f13b..0deed3b3fe5b 100644
--- a/xbmc/cores/RetroPlayer/guicontrols/GUIGameControl.cpp
+++ b/xbmc/cores/RetroPlayer/guicontrols/GUIGameControl.cpp
@@ -24,9 +24,10 @@
 using namespace KODI;
 using namespace RETRO;
 
-CGUIGameControl::CGUIGameControl(int parentID, int controlID, float posX, float posY, float width, float height) :
-  CGUIControl(parentID, controlID, posX, posY, width, height),
-  m_renderSettings(new CGUIRenderSettings(*this))
+CGUIGameControl::CGUIGameControl(
+    int parentID, int controlID, float posX, float posY, float width, float height)
+  : CGUIControl(parentID, controlID, posX, posY, width, height),
+    m_renderSettings(new CGUIRenderSettings(*this))
 {
   // Initialize CGUIControl
   ControlType = GUICONTROL_GAME;
@@ -36,15 +37,15 @@ CGUIGameControl::CGUIGameControl(int parentID, int controlID, float posX, float
   RegisterControl();
 }
 
-CGUIGameControl::CGUIGameControl(const CGUIGameControl &other) :
-  CGUIControl(other),
-  m_videoFilterInfo(other.m_videoFilterInfo),
-  m_stretchModeInfo(other.m_stretchModeInfo),
-  m_rotationInfo(other.m_rotationInfo),
-  m_bHasVideoFilter(other.m_bHasVideoFilter),
-  m_bHasStretchMode(other.m_bHasStretchMode),
-  m_bHasRotation(other.m_bHasRotation),
-  m_renderSettings(new CGUIRenderSettings(*this))
+CGUIGameControl::CGUIGameControl(const CGUIGameControl& other)
+  : CGUIControl(other),
+    m_videoFilterInfo(other.m_videoFilterInfo),
+    m_stretchModeInfo(other.m_stretchModeInfo),
+    m_rotationInfo(other.m_rotationInfo),
+    m_bHasVideoFilter(other.m_bHasVideoFilter),
+    m_bHasStretchMode(other.m_bHasStretchMode),
+    m_bHasRotation(other.m_bHasRotation),
+    m_renderSettings(new CGUIRenderSettings(*this))
 {
   m_renderSettings->SetSettings(other.m_renderSettings->GetSettings());
   m_renderSettings->SetDimensions(CRect(CPoint(m_posX, m_posY), CSize(m_width, m_height)));
@@ -57,27 +58,27 @@ CGUIGameControl::~CGUIGameControl()
   UnregisterControl();
 }
 
-void CGUIGameControl::SetVideoFilter(const GUILIB::GUIINFO::CGUIInfoLabel &videoFilter)
+void CGUIGameControl::SetVideoFilter(const GUILIB::GUIINFO::CGUIInfoLabel& videoFilter)
 {
   m_videoFilterInfo = videoFilter;
 }
 
-void CGUIGameControl::SetStretchMode(const GUILIB::GUIINFO::CGUIInfoLabel &stretchMode)
+void CGUIGameControl::SetStretchMode(const GUILIB::GUIINFO::CGUIInfoLabel& stretchMode)
 {
   m_stretchModeInfo = stretchMode;
 }
 
-void CGUIGameControl::SetRotation(const KODI::GUILIB::GUIINFO::CGUIInfoLabel &rotation)
+void CGUIGameControl::SetRotation(const KODI::GUILIB::GUIINFO::CGUIInfoLabel& rotation)
 {
   m_rotationInfo = rotation;
 }
 
-IGUIRenderSettings *CGUIGameControl::GetRenderSettings() const
+IGUIRenderSettings* CGUIGameControl::GetRenderSettings() const
 {
   return m_renderSettings.get();
 }
 
-void CGUIGameControl::Process(unsigned int currentTime, CDirtyRegionList &dirtyregions)
+void CGUIGameControl::Process(unsigned int currentTime, CDirtyRegionList& dirtyregions)
 {
   //! @todo Proper processing which marks when its actually changed
   if (m_renderHandle->IsDirty())
@@ -124,7 +125,7 @@ void CGUIGameControl::SetHeight(float height)
   m_renderSettings->SetDimensions(CRect(CPoint(m_posX, m_posY), CSize(m_width, height)));
 }
 
-void CGUIGameControl::UpdateInfo(const CGUIListItem *item /* = nullptr */)
+void CGUIGameControl::UpdateInfo(const CGUIListItem* item /* = nullptr */)
 {
   Reset();
 
diff --git a/xbmc/cores/RetroPlayer/guicontrols/GUIGameControl.h b/xbmc/cores/RetroPlayer/guicontrols/GUIGameControl.h
index 3044cafc8a13..17a91bf5dfaa 100644
--- a/xbmc/cores/RetroPlayer/guicontrols/GUIGameControl.h
+++ b/xbmc/cores/RetroPlayer/guicontrols/GUIGameControl.h
@@ -25,30 +25,30 @@ class CGUIGameControl : public CGUIControl
 {
 public:
   CGUIGameControl(int parentID, int controlID, float posX, float posY, float width, float height);
-  CGUIGameControl(const CGUIGameControl &other);
+  CGUIGameControl(const CGUIGameControl& other);
   ~CGUIGameControl() override;
 
   // GUI functions
-  void SetVideoFilter(const KODI::GUILIB::GUIINFO::CGUIInfoLabel &videoFilter);
-  void SetStretchMode(const KODI::GUILIB::GUIINFO::CGUIInfoLabel &stretchMode);
-  void SetRotation(const KODI::GUILIB::GUIINFO::CGUIInfoLabel &rotation);
+  void SetVideoFilter(const KODI::GUILIB::GUIINFO::CGUIInfoLabel& videoFilter);
+  void SetStretchMode(const KODI::GUILIB::GUIINFO::CGUIInfoLabel& stretchMode);
+  void SetRotation(const KODI::GUILIB::GUIINFO::CGUIInfoLabel& rotation);
 
   // Rendering functions
   bool HasVideoFilter() const { return m_bHasVideoFilter; }
   bool HasStretchMode() const { return m_bHasStretchMode; }
   bool HasRotation() const { return m_bHasRotation; }
-  IGUIRenderSettings *GetRenderSettings() const;
+  IGUIRenderSettings* GetRenderSettings() const;
 
   // implementation of CGUIControl
-  CGUIGameControl *Clone() const override { return new CGUIGameControl(*this); };
-  void Process(unsigned int currentTime, CDirtyRegionList &dirtyregions) override;
+  CGUIGameControl* Clone() const override { return new CGUIGameControl(*this); };
+  void Process(unsigned int currentTime, CDirtyRegionList& dirtyregions) override;
   void Render() override;
   void RenderEx() override;
   bool CanFocus() const override;
   void SetPosition(float posX, float posY) override;
   void SetWidth(float width) override;
   void SetHeight(float height) override;
-  void UpdateInfo(const CGUIListItem *item = nullptr) override;
+  void UpdateInfo(const CGUIListItem* item = nullptr) override;
 
 private:
   void Reset();
@@ -69,5 +69,5 @@ class CGUIGameControl : public CGUIControl
   std::shared_ptr<CGUIRenderHandle> m_renderHandle;
 };
 
-}
-}
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guicontrols/GUIRenderSettings.cpp b/xbmc/cores/RetroPlayer/guicontrols/GUIRenderSettings.cpp
index c9e2f99c7c7b..478905ffd8e9 100644
--- a/xbmc/cores/RetroPlayer/guicontrols/GUIRenderSettings.cpp
+++ b/xbmc/cores/RetroPlayer/guicontrols/GUIRenderSettings.cpp
@@ -14,8 +14,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CGUIRenderSettings::CGUIRenderSettings(CGUIGameControl &guiControl) :
-  m_guiControl(guiControl)
+CGUIRenderSettings::CGUIRenderSettings(CGUIGameControl& guiControl) : m_guiControl(guiControl)
 {
 }
 
@@ -62,14 +61,14 @@ void CGUIRenderSettings::SetSettings(CRenderSettings settings)
   m_renderSettings = std::move(settings);
 }
 
-void CGUIRenderSettings::SetDimensions(const CRect &dimensions)
+void CGUIRenderSettings::SetDimensions(const CRect& dimensions)
 {
   CSingleLock lock(m_mutex);
 
   m_renderDimensions = dimensions;
 }
 
-void CGUIRenderSettings::SetVideoFilter(const std::string &videoFilter)
+void CGUIRenderSettings::SetVideoFilter(const std::string& videoFilter)
 {
   CSingleLock lock(m_mutex);
 
diff --git a/xbmc/cores/RetroPlayer/guicontrols/GUIRenderSettings.h b/xbmc/cores/RetroPlayer/guicontrols/GUIRenderSettings.h
index 69d9d8259b12..c99d91b07d1f 100644
--- a/xbmc/cores/RetroPlayer/guicontrols/GUIRenderSettings.h
+++ b/xbmc/cores/RetroPlayer/guicontrols/GUIRenderSettings.h
@@ -18,39 +18,39 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGUIGameControl;
-
-  class CGUIRenderSettings : public IGUIRenderSettings
-  {
-  public:
-    CGUIRenderSettings(CGUIGameControl &guiControl);
-    ~CGUIRenderSettings() override = default;
-
-    // implementation of IGUIRenderSettings
-    bool HasVideoFilter() const override;
-    bool HasStretchMode() const override;
-    bool HasRotation() const override;
-    CRenderSettings GetSettings() const override;
-    CRect GetDimensions() const override;
-
-    // Render functions
-    void Reset();
-    void SetSettings(CRenderSettings settings);
-    void SetDimensions(const CRect &dimensions);
-    void SetVideoFilter(const std::string &videoFilter);
-    void SetStretchMode(STRETCHMODE stretchMode);
-    void SetRotationDegCCW(unsigned int rotationDegCCW);
-
-  private:
-    // Construction parameters
-    CGUIGameControl &m_guiControl;
-
-    // Render parameters
-    CRenderSettings m_renderSettings;
-    CRect m_renderDimensions;
-
-    // Synchronization parameters
-    mutable CCriticalSection m_mutex;
-  };
-}
-}
+class CGUIGameControl;
+
+class CGUIRenderSettings : public IGUIRenderSettings
+{
+public:
+  CGUIRenderSettings(CGUIGameControl& guiControl);
+  ~CGUIRenderSettings() override = default;
+
+  // implementation of IGUIRenderSettings
+  bool HasVideoFilter() const override;
+  bool HasStretchMode() const override;
+  bool HasRotation() const override;
+  CRenderSettings GetSettings() const override;
+  CRect GetDimensions() const override;
+
+  // Render functions
+  void Reset();
+  void SetSettings(CRenderSettings settings);
+  void SetDimensions(const CRect& dimensions);
+  void SetVideoFilter(const std::string& videoFilter);
+  void SetStretchMode(STRETCHMODE stretchMode);
+  void SetRotationDegCCW(unsigned int rotationDegCCW);
+
+private:
+  // Construction parameters
+  CGUIGameControl& m_guiControl;
+
+  // Render parameters
+  CRenderSettings m_renderSettings;
+  CRect m_renderDimensions;
+
+  // Synchronization parameters
+  mutable CCriticalSection m_mutex;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guiplayback/GUIPlaybackControl.cpp b/xbmc/cores/RetroPlayer/guiplayback/GUIPlaybackControl.cpp
index 3dfc94cd35b6..054454fee08c 100644
--- a/xbmc/cores/RetroPlayer/guiplayback/GUIPlaybackControl.cpp
+++ b/xbmc/cores/RetroPlayer/guiplayback/GUIPlaybackControl.cpp
@@ -16,8 +16,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CGUIPlaybackControl::CGUIPlaybackControl(IPlaybackCallback &callback) :
-  m_callback(callback)
+CGUIPlaybackControl::CGUIPlaybackControl(IPlaybackCallback& callback) : m_callback(callback)
 {
 }
 
@@ -25,7 +24,7 @@ CGUIPlaybackControl::~CGUIPlaybackControl() = default;
 
 void CGUIPlaybackControl::FrameMove()
 {
-  CGUIComponent *gui = CServiceBroker::GetGUI();
+  CGUIComponent* gui = CServiceBroker::GetGUI();
   if (gui == nullptr)
     return;
 
@@ -57,51 +56,53 @@ void CGUIPlaybackControl::FrameMove()
   }
 }
 
-CGUIPlaybackControl::GuiState CGUIPlaybackControl::NextState(bool bFullscreen, bool bInMenu, bool bInBackground)
+CGUIPlaybackControl::GuiState CGUIPlaybackControl::NextState(bool bFullscreen,
+                                                             bool bInMenu,
+                                                             bool bInBackground)
 {
   GuiState newState = m_state;
 
   switch (m_state)
   {
-  case GuiState::UNKNOWN:
-  {
-    // Wait for game to enter fullscreen
-    if (bFullscreen)
-      newState = GuiState::FULLSCREEN;
-    break;
-  }
-  case GuiState::FULLSCREEN:
-  {
-    if (bInMenu)
+    case GuiState::UNKNOWN:
     {
-      if (bInBackground)
-        newState = GuiState::MENU_PLAYING;
-      else
-        newState = GuiState::MENU_PAUSED;
+      // Wait for game to enter fullscreen
+      if (bFullscreen)
+        newState = GuiState::FULLSCREEN;
+      break;
     }
-    break;
-  }
-  case GuiState::MENU_PAUSED:
-  {
-    if (!bInMenu)
-      newState = GuiState::FULLSCREEN;
-    else if (bInBackground)
-      newState = GuiState::MENU_PLAYING;
-    break;
-  }
-  case GuiState::MENU_PLAYING:
-  {
-    if (!bInBackground)
+    case GuiState::FULLSCREEN:
+    {
+      if (bInMenu)
+      {
+        if (bInBackground)
+          newState = GuiState::MENU_PLAYING;
+        else
+          newState = GuiState::MENU_PAUSED;
+      }
+      break;
+    }
+    case GuiState::MENU_PAUSED:
     {
       if (!bInMenu)
         newState = GuiState::FULLSCREEN;
-      else
-        newState = GuiState::MENU_PAUSED;
+      else if (bInBackground)
+        newState = GuiState::MENU_PLAYING;
+      break;
     }
-    break;
-  }
-  default:
-    break;
+    case GuiState::MENU_PLAYING:
+    {
+      if (!bInBackground)
+      {
+        if (!bInMenu)
+          newState = GuiState::FULLSCREEN;
+        else
+          newState = GuiState::MENU_PAUSED;
+      }
+      break;
+    }
+    default:
+      break;
   }
 
   return newState;
@@ -113,23 +114,23 @@ double CGUIPlaybackControl::GetTargetSpeed(GuiState state)
 
   switch (state)
   {
-  case GuiState::FULLSCREEN:
-  {
-    targetSpeed = 1.0;
-    break;
-  }
-  case GuiState::MENU_PAUSED:
-  {
-    targetSpeed = 0.0;
-    break;
-  }
-  case GuiState::MENU_PLAYING:
-  {
-    targetSpeed = 1.0;
-    break;
-  }
-  default:
-    break;
+    case GuiState::FULLSCREEN:
+    {
+      targetSpeed = 1.0;
+      break;
+    }
+    case GuiState::MENU_PAUSED:
+    {
+      targetSpeed = 0.0;
+      break;
+    }
+    case GuiState::MENU_PLAYING:
+    {
+      targetSpeed = 1.0;
+      break;
+    }
+    default:
+      break;
   }
 
   return targetSpeed;
diff --git a/xbmc/cores/RetroPlayer/guiplayback/GUIPlaybackControl.h b/xbmc/cores/RetroPlayer/guiplayback/GUIPlaybackControl.h
index 496a58ece283..48baced456b3 100644
--- a/xbmc/cores/RetroPlayer/guiplayback/GUIPlaybackControl.h
+++ b/xbmc/cores/RetroPlayer/guiplayback/GUIPlaybackControl.h
@@ -14,39 +14,39 @@ namespace KODI
 {
 namespace RETRO
 {
-  /*!
-   * \brief Class to control playback by monitoring OSD status
-   */
-  class CGUIPlaybackControl : public IPlaybackControl
+/*!
+ * \brief Class to control playback by monitoring OSD status
+ */
+class CGUIPlaybackControl : public IPlaybackControl
+{
+public:
+  CGUIPlaybackControl(IPlaybackCallback& callback);
+
+  ~CGUIPlaybackControl() override;
+
+  // Implementation of IPlaybackControl
+  void FrameMove() override;
+
+private:
+  enum class GuiState
   {
-  public:
-    CGUIPlaybackControl(IPlaybackCallback &callback);
-
-    ~CGUIPlaybackControl() override;
-
-    // Implementation of IPlaybackControl
-    void FrameMove() override;
-
-  private:
-    enum class GuiState
-    {
-      UNKNOWN,
-      FULLSCREEN,
-      MENU_PAUSED,
-      MENU_PLAYING,
-    };
-
-    // Helper functions
-    GuiState NextState(bool bFullscreen, bool bInMenu, bool bInBackground);
-    static double GetTargetSpeed(GuiState state);
-    static bool AcceptsInput(GuiState state);
-
-    // Construction parameters
-    IPlaybackCallback &m_callback;
-
-    // State parameters
-    GuiState m_state = GuiState::UNKNOWN;
-    double m_previousSpeed = 0.0;
+    UNKNOWN,
+    FULLSCREEN,
+    MENU_PAUSED,
+    MENU_PLAYING,
   };
-}
-}
+
+  // Helper functions
+  GuiState NextState(bool bFullscreen, bool bInMenu, bool bInBackground);
+  static double GetTargetSpeed(GuiState state);
+  static bool AcceptsInput(GuiState state);
+
+  // Construction parameters
+  IPlaybackCallback& m_callback;
+
+  // State parameters
+  GuiState m_state = GuiState::UNKNOWN;
+  double m_previousSpeed = 0.0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreen.cpp b/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreen.cpp
index 9edd6a4dfdf1..81a8fa55f330 100644
--- a/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreen.cpp
+++ b/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreen.cpp
@@ -30,9 +30,9 @@ using namespace KODI;
 using namespace KODI::GUILIB;
 using namespace RETRO;
 
-CGameWindowFullScreen::CGameWindowFullScreen(void) :
-  CGUIWindow(WINDOW_FULLSCREEN_GAME, "VideoFullScreen.xml"),
-  m_fullscreenText(new CGameWindowFullScreenText(*this))
+CGameWindowFullScreen::CGameWindowFullScreen(void)
+  : CGUIWindow(WINDOW_FULLSCREEN_GAME, "VideoFullScreen.xml"),
+    m_fullscreenText(new CGameWindowFullScreenText(*this))
 {
   // initialize CGUIControl
   m_controlStats = new GUICONTROLSTATS;
@@ -50,7 +50,7 @@ CGameWindowFullScreen::~CGameWindowFullScreen()
   delete m_controlStats;
 }
 
-void CGameWindowFullScreen::Process(unsigned int currentTime, CDirtyRegionList &dirtyregion)
+void CGameWindowFullScreen::Process(unsigned int currentTime, CDirtyRegionList& dirtyregion)
 {
   if (m_renderHandle->IsDirty())
     MarkDirtyRegion();
@@ -61,7 +61,9 @@ void CGameWindowFullScreen::Process(unsigned int currentTime, CDirtyRegionList &
 
   //! @todo This isn't quite optimal - ideally we'd only be dirtying up the actual video render rect
   //!       which is probably the job of the renderer as it can more easily track resizing etc.
-  m_renderRegion.SetRect(0, 0, static_cast<float>(CServiceBroker::GetWinSystem()->GetGfxContext().GetWidth()), static_cast<float>(CServiceBroker::GetWinSystem()->GetGfxContext().GetHeight()));
+  m_renderRegion.SetRect(
+      0, 0, static_cast<float>(CServiceBroker::GetWinSystem()->GetGfxContext().GetWidth()),
+      static_cast<float>(CServiceBroker::GetWinSystem()->GetGfxContext().GetHeight()));
 }
 
 void CGameWindowFullScreen::Render()
@@ -78,44 +80,44 @@ void CGameWindowFullScreen::RenderEx()
   m_renderHandle->RenderEx();
 }
 
-bool CGameWindowFullScreen::OnAction(const CAction &action)
+bool CGameWindowFullScreen::OnAction(const CAction& action)
 {
   switch (action.GetID())
   {
-  case ACTION_SHOW_OSD:
-  case ACTION_TRIGGER_OSD:
-  {
-    TriggerOSD();
-    return true;
-  }
-  case ACTION_MOUSE_MOVE:
-  {
-    if (action.GetAmount(2) || action.GetAmount(3))
+    case ACTION_SHOW_OSD:
+    case ACTION_TRIGGER_OSD:
     {
       TriggerOSD();
       return true;
     }
-    break;
-  }
-  case ACTION_MOUSE_LEFT_CLICK:
-  {
-    TriggerOSD();
-    return true;
-  }
-  case ACTION_SHOW_GUI:
-  {
-    // Switch back to the menu
-    CServiceBroker::GetGUI()->GetWindowManager().PreviousWindow();
-    return true;
-  }
-  case ACTION_ASPECT_RATIO:
-  {
-    // Toggle the aspect ratio mode (only if the info is onscreen)
-    //g_application.GetAppPlayer().SetRenderViewMode(CViewModeSettings::GetNextQuickCycleViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode));
-    return true;
-  }
-  default:
-    break;
+    case ACTION_MOUSE_MOVE:
+    {
+      if (action.GetAmount(2) || action.GetAmount(3))
+      {
+        TriggerOSD();
+        return true;
+      }
+      break;
+    }
+    case ACTION_MOUSE_LEFT_CLICK:
+    {
+      TriggerOSD();
+      return true;
+    }
+    case ACTION_SHOW_GUI:
+    {
+      // Switch back to the menu
+      CServiceBroker::GetGUI()->GetWindowManager().PreviousWindow();
+      return true;
+    }
+    case ACTION_ASPECT_RATIO:
+    {
+      // Toggle the aspect ratio mode (only if the info is onscreen)
+      // g_application.GetAppPlayer().SetRenderViewMode(CViewModeSettings::GetNextQuickCycleViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode));
+      return true;
+    }
+    default:
+      break;
   }
 
   return CGUIWindow::OnAction(action);
@@ -125,15 +127,15 @@ bool CGameWindowFullScreen::OnMessage(CGUIMessage& message)
 {
   switch (message.GetMessage())
   {
-  case GUI_MSG_SETFOCUS:
-  case GUI_MSG_LOSTFOCUS:
-  {
-    if (message.GetSenderId() != WINDOW_FULLSCREEN_GAME)
-      return true;
-    break;
-  }
-  default:
-    break;
+    case GUI_MSG_SETFOCUS:
+    case GUI_MSG_LOSTFOCUS:
+    {
+      if (message.GetSenderId() != WINDOW_FULLSCREEN_GAME)
+        return true;
+      break;
+    }
+    default:
+      break;
   }
 
   return CGUIWindow::OnMessage(message);
@@ -170,7 +172,8 @@ void CGameWindowFullScreen::OnWindowLoaded()
 
 void CGameWindowFullScreen::OnInitWindow()
 {
-  GUIINFO::CPlayerGUIInfo& guiInfo = CServiceBroker::GetGUI()->GetInfoManager().GetInfoProviders().GetPlayerInfoProvider();
+  GUIINFO::CPlayerGUIInfo& guiInfo =
+      CServiceBroker::GetGUI()->GetInfoManager().GetInfoProviders().GetPlayerInfoProvider();
   guiInfo.SetShowInfo(false);
   guiInfo.SetDisplayAfterSeek(0); // Make sure display after seek is off
 
@@ -180,7 +183,7 @@ void CGameWindowFullScreen::OnInitWindow()
   CGUIWindow::OnInitWindow();
 
   // Show OSD help
-  GAME::CGameSettings &gameSettings = CServiceBroker::GetGameServices().GameSettings();
+  GAME::CGameSettings& gameSettings = CServiceBroker::GetGameServices().GameSettings();
   if (gameSettings.ShowOSDHelp())
     TriggerOSD();
   else
@@ -208,7 +211,7 @@ void CGameWindowFullScreen::OnDeinitWindow(int nextWindowID)
 
 void CGameWindowFullScreen::TriggerOSD()
 {
-  CGUIDialog *pOSD = GetOSD();
+  CGUIDialog* pOSD = GetOSD();
   if (pOSD != nullptr)
   {
     if (!pOSD->IsDialogRunning())
@@ -216,7 +219,7 @@ void CGameWindowFullScreen::TriggerOSD()
   }
 }
 
-CGUIDialog *CGameWindowFullScreen::GetOSD()
+CGUIDialog* CGameWindowFullScreen::GetOSD()
 {
   return CServiceBroker::GetGUI()->GetWindowManager().GetDialog(WINDOW_DIALOG_GAME_OSD);
 }
diff --git a/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreen.h b/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreen.h
index aefaf0fef8c9..a925c8b4413b 100644
--- a/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreen.h
+++ b/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreen.h
@@ -16,45 +16,45 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGameWindowFullScreenText;
-  class CGUIRenderHandle;
-
-  class CGameWindowFullScreen : public CGUIWindow
-  {
-  public:
-    CGameWindowFullScreen();
-    ~CGameWindowFullScreen() override;
-
-    // implementation of CGUIControl via CGUIWindow
-    void Process(unsigned int currentTime, CDirtyRegionList &dirtyregion) override;
-    void Render() override;
-    void RenderEx() override;
-    bool OnAction(const CAction &action) override;
-    bool OnMessage(CGUIMessage& message) override;
-
-    // implementation of CGUIWindow
-    void FrameMove() override;
-    void ClearBackground() override;
-    bool HasVisibleControls() override;
-    void OnWindowLoaded() override;
-    void OnDeinitWindow(int nextWindowID) override;
-
-  protected:
-    // implementation of CGUIWindow
-    void OnInitWindow() override;
-
-  private:
-    void TriggerOSD();
-    CGUIDialog *GetOSD();
-
-    void RegisterWindow();
-    void UnregisterWindow();
-
-    // GUI parameters
-    std::unique_ptr<CGameWindowFullScreenText> m_fullscreenText;
-
-    // Rendering parameters
-    std::shared_ptr<CGUIRenderHandle> m_renderHandle;
-  };
-}
-}
+class CGameWindowFullScreenText;
+class CGUIRenderHandle;
+
+class CGameWindowFullScreen : public CGUIWindow
+{
+public:
+  CGameWindowFullScreen();
+  ~CGameWindowFullScreen() override;
+
+  // implementation of CGUIControl via CGUIWindow
+  void Process(unsigned int currentTime, CDirtyRegionList& dirtyregion) override;
+  void Render() override;
+  void RenderEx() override;
+  bool OnAction(const CAction& action) override;
+  bool OnMessage(CGUIMessage& message) override;
+
+  // implementation of CGUIWindow
+  void FrameMove() override;
+  void ClearBackground() override;
+  bool HasVisibleControls() override;
+  void OnWindowLoaded() override;
+  void OnDeinitWindow(int nextWindowID) override;
+
+protected:
+  // implementation of CGUIWindow
+  void OnInitWindow() override;
+
+private:
+  void TriggerOSD();
+  CGUIDialog* GetOSD();
+
+  void RegisterWindow();
+  void UnregisterWindow();
+
+  // GUI parameters
+  std::unique_ptr<CGameWindowFullScreenText> m_fullscreenText;
+
+  // Rendering parameters
+  std::shared_ptr<CGUIRenderHandle> m_renderHandle;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreenText.cpp b/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreenText.cpp
index 7be4b91742b0..e0f722a317d6 100644
--- a/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreenText.cpp
+++ b/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreenText.cpp
@@ -15,8 +15,8 @@
 using namespace KODI;
 using namespace RETRO;
 
-CGameWindowFullScreenText::CGameWindowFullScreenText(CGUIWindow &fullscreenWindow) :
-  m_fullscreenWindow(fullscreenWindow)
+CGameWindowFullScreenText::CGameWindowFullScreenText(CGUIWindow& fullscreenWindow)
+  : m_fullscreenWindow(fullscreenWindow)
 {
 }
 
@@ -47,7 +47,7 @@ void CGameWindowFullScreenText::FrameMove()
   }
 }
 
-const std::string &CGameWindowFullScreenText::GetText(unsigned int lineIndex) const
+const std::string& CGameWindowFullScreenText::GetText(unsigned int lineIndex) const
 {
   if (lineIndex < m_lines.size())
     return m_lines[lineIndex];
@@ -64,7 +64,7 @@ void CGameWindowFullScreenText::SetText(unsigned int lineIndex, std::string line
   m_lines[lineIndex] = std::move(line);
 }
 
-const std::vector<std::string> &CGameWindowFullScreenText::GetText() const
+const std::vector<std::string>& CGameWindowFullScreenText::GetText() const
 {
   return m_lines;
 }
@@ -105,7 +105,7 @@ int CGameWindowFullScreenText::GetID() const
   return m_fullscreenWindow.GetID();
 }
 
-bool CGameWindowFullScreenText::OnMessage(CGUIMessage &message)
+bool CGameWindowFullScreenText::OnMessage(CGUIMessage& message)
 {
   return m_fullscreenWindow.OnMessage(message);
 }
@@ -114,11 +114,14 @@ int CGameWindowFullScreenText::GetControlID(unsigned int lineIndex)
 {
   switch (lineIndex)
   {
-  case 0: return LABEL_ROW1;
-  case 1: return LABEL_ROW2;
-  case 2: return LABEL_ROW3;
-  default:
-    break;
+    case 0:
+      return LABEL_ROW1;
+    case 1:
+      return LABEL_ROW2;
+    case 2:
+      return LABEL_ROW3;
+    default:
+      break;
   }
 
   return -1;
diff --git a/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreenText.h b/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreenText.h
index 4cfea3fcad5e..a454a03e8c3a 100644
--- a/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreenText.h
+++ b/xbmc/cores/RetroPlayer/guiwindows/GameWindowFullScreenText.h
@@ -19,66 +19,66 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGameWindowFullScreenText
-  {
-  public:
-    CGameWindowFullScreenText(CGUIWindow &fullscreenWindow);
-    ~CGameWindowFullScreenText() = default;
+class CGameWindowFullScreenText
+{
+public:
+  CGameWindowFullScreenText(CGUIWindow& fullscreenWindow);
+  ~CGameWindowFullScreenText() = default;
 
-    // Window functions
-    void OnWindowLoaded();
-    void FrameMove();
+  // Window functions
+  void OnWindowLoaded();
+  void FrameMove();
 
-    /*!
-     * \brief Get a line of text
-     */
-    const std::string &GetText(unsigned int lineIndex) const;
+  /*!
+   * \brief Get a line of text
+   */
+  const std::string& GetText(unsigned int lineIndex) const;
 
-    /*!
-     * \brief Set a line of text
-     */
-    void SetText(unsigned int lineIndex, std::string line);
+  /*!
+   * \brief Set a line of text
+   */
+  void SetText(unsigned int lineIndex, std::string line);
 
-    /*!
-     * \brief Get entire text
-     */
-    const std::vector<std::string> &GetText() const;
+  /*!
+   * \brief Get entire text
+   */
+  const std::vector<std::string>& GetText() const;
 
-    /*!
-    * \brief Set entire text
-    */
-    void SetText(std::vector<std::string> text);
+  /*!
+   * \brief Set entire text
+   */
+  void SetText(std::vector<std::string> text);
 
-  private:
-    // Window functions
-    void UploadText();
-    void Show();
-    void Hide();
+private:
+  // Window functions
+  void UploadText();
+  void Show();
+  void Hide();
 
-    /*!
-     * \brief Translate line index to the control ID in the skin
-     *
-     * \param lineIndex The line in the string vector
-     *
-     * \return The ID of the line's label control in the skin
-     */
-    static int GetControlID(unsigned int lineIndex);
+  /*!
+   * \brief Translate line index to the control ID in the skin
+   *
+   * \param lineIndex The line in the string vector
+   *
+   * \return The ID of the line's label control in the skin
+   */
+  static int GetControlID(unsigned int lineIndex);
 
-    // Window functions required by GUIMessage macros
-    //! @todo Change macros into functions
-    int GetID() const;
-    bool OnMessage(CGUIMessage &message);
+  // Window functions required by GUIMessage macros
+  //! @todo Change macros into functions
+  int GetID() const;
+  bool OnMessage(CGUIMessage& message);
 
-    // Construction parameters
-    CGUIWindow &m_fullscreenWindow;
+  // Construction parameters
+  CGUIWindow& m_fullscreenWindow;
 
-    // Window state
-    bool m_bShowText = false;
-    bool m_bTextChanged = true;
-    bool m_bTextVisibilityChanged = true;
+  // Window state
+  bool m_bShowText = false;
+  bool m_bTextChanged = true;
+  bool m_bTextVisibilityChanged = true;
 
-    // Text
-    std::vector<std::string> m_lines;
-  };
-}
-}
+  // Text
+  std::vector<std::string> m_lines;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/playback/GameLoop.cpp b/xbmc/cores/RetroPlayer/playback/GameLoop.cpp
index a3531446a52d..b60439ec6795 100644
--- a/xbmc/cores/RetroPlayer/playback/GameLoop.cpp
+++ b/xbmc/cores/RetroPlayer/playback/GameLoop.cpp
@@ -15,16 +15,16 @@
 using namespace KODI;
 using namespace RETRO;
 
-#define DEFAULT_FPS  60  // In case fps is 0 (shouldn't happen)
-#define FOREVER_MS   (7 * 24 * 60 * 60 * 1000) // 1 week is large enough
-
-CGameLoop::CGameLoop(IGameLoopCallback* callback, double fps) :
-  CThread("GameLoop"),
-  m_callback(callback),
-  m_fps(fps ? fps : DEFAULT_FPS),
-  m_speedFactor(0.0),
-  m_lastFrameMs(0.0),
-  m_adjustTime(0.0)
+#define DEFAULT_FPS 60 // In case fps is 0 (shouldn't happen)
+#define FOREVER_MS (7 * 24 * 60 * 60 * 1000) // 1 week is large enough
+
+CGameLoop::CGameLoop(IGameLoopCallback* callback, double fps)
+  : CThread("GameLoop"),
+    m_callback(callback),
+    m_fps(fps ? fps : DEFAULT_FPS),
+    m_speedFactor(0.0),
+    m_lastFrameMs(0.0),
+    m_adjustTime(0.0)
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/playback/GameLoop.h b/xbmc/cores/RetroPlayer/playback/GameLoop.h
index c584fc8c96ca..e4fbcff5f969 100644
--- a/xbmc/cores/RetroPlayer/playback/GameLoop.h
+++ b/xbmc/cores/RetroPlayer/playback/GameLoop.h
@@ -17,53 +17,53 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IGameLoopCallback
-  {
-  public:
-    virtual ~IGameLoopCallback() = default;
+class IGameLoopCallback
+{
+public:
+  virtual ~IGameLoopCallback() = default;
 
-    /*!
-     * \brief The next frame is being shown
-     */
-    virtual void FrameEvent() = 0;
+  /*!
+   * \brief The next frame is being shown
+   */
+  virtual void FrameEvent() = 0;
 
-    /*!
-     * \brief The prior frame is being shown
-     */
-    virtual void RewindEvent() = 0;
-  };
+  /*!
+   * \brief The prior frame is being shown
+   */
+  virtual void RewindEvent() = 0;
+};
 
-  class CGameLoop : protected CThread
-  {
-  public:
-    CGameLoop(IGameLoopCallback* callback, double fps);
+class CGameLoop : protected CThread
+{
+public:
+  CGameLoop(IGameLoopCallback* callback, double fps);
 
-    ~CGameLoop() override;
+  ~CGameLoop() override;
 
-    void Start();
-    void Stop();
+  void Start();
+  void Stop();
 
-    double FPS() const { return m_fps; }
+  double FPS() const { return m_fps; }
 
-    double GetSpeed() const { return m_speedFactor; }
-    void SetSpeed(double speedFactor);
-    void PauseAsync();
+  double GetSpeed() const { return m_speedFactor; }
+  void SetSpeed(double speedFactor);
+  void PauseAsync();
 
-  protected:
-    // implementation of CThread
-    void Process() override;
+protected:
+  // implementation of CThread
+  void Process() override;
 
-  private:
-    double FrameTimeMs() const;
-    double SleepTimeMs() const;
-    double NowMs() const;
+private:
+  double FrameTimeMs() const;
+  double SleepTimeMs() const;
+  double NowMs() const;
 
-    IGameLoopCallback* const m_callback;
-    const double             m_fps;
-    std::atomic<double>      m_speedFactor;
-    double                   m_lastFrameMs;
-    mutable double           m_adjustTime;
-    CEvent                   m_sleepEvent;
-  };
-}
-}
+  IGameLoopCallback* const m_callback;
+  const double m_fps;
+  std::atomic<double> m_speedFactor;
+  double m_lastFrameMs;
+  mutable double m_adjustTime;
+  CEvent m_sleepEvent;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/playback/IPlayback.h b/xbmc/cores/RetroPlayer/playback/IPlayback.h
index 1c1181db49f9..d02c2af4d194 100644
--- a/xbmc/cores/RetroPlayer/playback/IPlayback.h
+++ b/xbmc/cores/RetroPlayer/playback/IPlayback.h
@@ -14,31 +14,31 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IPlayback
-  {
-  public:
-    virtual ~IPlayback() = default;
+class IPlayback
+{
+public:
+  virtual ~IPlayback() = default;
 
-    // Lifetime management
-    virtual void Initialize() = 0;
-    virtual void Deinitialize() = 0;
+  // Lifetime management
+  virtual void Initialize() = 0;
+  virtual void Deinitialize() = 0;
 
-    // Playback capabilities
-    virtual bool CanPause() const = 0;
-    virtual bool CanSeek() const = 0;
+  // Playback capabilities
+  virtual bool CanPause() const = 0;
+  virtual bool CanSeek() const = 0;
 
-    // Control playback
-    virtual unsigned int GetTimeMs() const = 0;
-    virtual unsigned int GetTotalTimeMs() const = 0;
-    virtual unsigned int GetCacheTimeMs() const = 0;
-    virtual void SeekTimeMs(unsigned int timeMs) = 0;
-    virtual double GetSpeed() const = 0;
-    virtual void SetSpeed(double speedFactor) = 0;
-    virtual void PauseAsync() = 0; // Pauses after the following frame
+  // Control playback
+  virtual unsigned int GetTimeMs() const = 0;
+  virtual unsigned int GetTotalTimeMs() const = 0;
+  virtual unsigned int GetCacheTimeMs() const = 0;
+  virtual void SeekTimeMs(unsigned int timeMs) = 0;
+  virtual double GetSpeed() const = 0;
+  virtual void SetSpeed(double speedFactor) = 0;
+  virtual void PauseAsync() = 0; // Pauses after the following frame
 
-    // Savestates
-    virtual std::string CreateSavestate() = 0; // Returns the path of savestate on success
-    virtual bool LoadSavestate(const std::string& path) = 0;
-  };
-}
-}
+  // Savestates
+  virtual std::string CreateSavestate() = 0; // Returns the path of savestate on success
+  virtual bool LoadSavestate(const std::string& path) = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/playback/IPlaybackControl.h b/xbmc/cores/RetroPlayer/playback/IPlaybackControl.h
index 598dea9a7937..6637cae04981 100644
--- a/xbmc/cores/RetroPlayer/playback/IPlaybackControl.h
+++ b/xbmc/cores/RetroPlayer/playback/IPlaybackControl.h
@@ -12,41 +12,41 @@ namespace KODI
 {
 namespace RETRO
 {
+/*!
+ * \brief The playback client being controlled
+ */
+class IPlaybackCallback
+{
+public:
+  virtual ~IPlaybackCallback() = default;
+
   /*!
-   * \brief The playback client being controlled
+   * \brief Set the playback speed
+   *
+   * \param speed The new speed
    */
-  class IPlaybackCallback
-  {
-  public:
-    virtual ~IPlaybackCallback() = default;
+  virtual void SetPlaybackSpeed(double speed) = 0;
 
-    /*!
-     * \brief Set the playback speed
-     *
-     * \param speed The new speed
-     */
-    virtual void SetPlaybackSpeed(double speed) = 0;
+  /*!
+   * \brief Enable/disable game input
+   *
+   * \param bEnable True to enable input, false to disable input
+   */
+  virtual void EnableInput(bool bEnable) = 0;
+};
 
-    /*!
-     * \brief Enable/disable game input
-     *
-     * \param bEnable True to enable input, false to disable input
-     */
-    virtual void EnableInput(bool bEnable) = 0;
-  };
+/*!
+ * \brief Class that can control playback and input
+ */
+class IPlaybackControl
+{
+public:
+  virtual ~IPlaybackControl() = default;
 
   /*!
-   * \brief Class that can control playback and input
+   * \brief Called every frame
    */
-  class IPlaybackControl
-  {
-  public:
-    virtual ~IPlaybackControl() = default;
-
-    /*!
-     * \brief Called every frame
-     */
-    virtual void FrameMove() = 0;
-  };
-}
-}
+  virtual void FrameMove() = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/playback/RealtimePlayback.h b/xbmc/cores/RetroPlayer/playback/RealtimePlayback.h
index f7b5fffbc2e8..d9c19d70cfa2 100644
--- a/xbmc/cores/RetroPlayer/playback/RealtimePlayback.h
+++ b/xbmc/cores/RetroPlayer/playback/RealtimePlayback.h
@@ -14,25 +14,25 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRealtimePlayback : public IPlayback
-  {
-  public:
-    ~CRealtimePlayback() override = default;
+class CRealtimePlayback : public IPlayback
+{
+public:
+  ~CRealtimePlayback() override = default;
 
-    // implementation of IPlayback
-    void Initialize() override {}
-    void Deinitialize() override {}
-    bool CanPause() const override { return false; }
-    bool CanSeek() const override { return false; }
-    unsigned int GetTimeMs() const override { return 0; }
-    unsigned int GetTotalTimeMs() const override { return 0; }
-    unsigned int GetCacheTimeMs() const override { return 0; }
-    void SeekTimeMs(unsigned int timeMs) override {}
-    double GetSpeed() const override { return 1.0; }
-    void SetSpeed(double speedFactor) override {}
-    void PauseAsync() override {}
-    std::string CreateSavestate() override { return ""; }
-    bool LoadSavestate(const std::string& path) override { return false; }
-  };
-}
-}
+  // implementation of IPlayback
+  void Initialize() override {}
+  void Deinitialize() override {}
+  bool CanPause() const override { return false; }
+  bool CanSeek() const override { return false; }
+  unsigned int GetTimeMs() const override { return 0; }
+  unsigned int GetTotalTimeMs() const override { return 0; }
+  unsigned int GetCacheTimeMs() const override { return 0; }
+  void SeekTimeMs(unsigned int timeMs) override {}
+  double GetSpeed() const override { return 1.0; }
+  void SetSpeed(double speedFactor) override {}
+  void PauseAsync() override {}
+  std::string CreateSavestate() override { return ""; }
+  bool LoadSavestate(const std::string& path) override { return false; }
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/playback/ReversiblePlayback.cpp b/xbmc/cores/RetroPlayer/playback/ReversiblePlayback.cpp
index ac50961e1bf1..5a3c8748bc22 100644
--- a/xbmc/cores/RetroPlayer/playback/ReversiblePlayback.cpp
+++ b/xbmc/cores/RetroPlayer/playback/ReversiblePlayback.cpp
@@ -24,28 +24,30 @@
 using namespace KODI;
 using namespace RETRO;
 
-#define REWIND_FACTOR  0.25  // Rewind at 25% of gameplay speed
-
-CReversiblePlayback::CReversiblePlayback(GAME::CGameClient* gameClient, double fps, size_t serializeSize) :
-  m_gameClient(gameClient),
-  m_gameLoop(this, fps),
-  m_savestateDatabase(new CSavestateDatabase),
-  m_totalFrameCount(0),
-  m_pastFrameCount(0),
-  m_futureFrameCount(0),
-  m_playTimeMs(0),
-  m_totalTimeMs(0),
-  m_cacheTimeMs(0)
+#define REWIND_FACTOR 0.25 // Rewind at 25% of gameplay speed
+
+CReversiblePlayback::CReversiblePlayback(GAME::CGameClient* gameClient,
+                                         double fps,
+                                         size_t serializeSize)
+  : m_gameClient(gameClient),
+    m_gameLoop(this, fps),
+    m_savestateDatabase(new CSavestateDatabase),
+    m_totalFrameCount(0),
+    m_pastFrameCount(0),
+    m_futureFrameCount(0),
+    m_playTimeMs(0),
+    m_totalTimeMs(0),
+    m_cacheTimeMs(0)
 {
   UpdateMemoryStream();
 
-  GAME::CGameSettings &gameSettings = CServiceBroker::GetGameServices().GameSettings();
+  GAME::CGameSettings& gameSettings = CServiceBroker::GetGameServices().GameSettings();
   gameSettings.RegisterObserver(this);
 }
 
 CReversiblePlayback::~CReversiblePlayback()
 {
-  GAME::CGameSettings &gameSettings = CServiceBroker::GetGameServices().GameSettings();
+  GAME::CGameSettings& gameSettings = CServiceBroker::GetGameServices().GameSettings();
   gameSettings.UnregisterObserver(this);
 
   Deinitialize();
@@ -124,7 +126,9 @@ std::string CReversiblePlayback::CreateSavestate()
   const std::string label = now.GetAsLocalizedDateTime();
   const std::string gameFileName = URIUtils::GetFileName(m_gameClient->GetGamePath());
   const uint64_t timestampFrames = m_totalFrameCount;
-  const double timestampWallClock = (m_totalFrameCount / m_gameClient->GetFrameRate()); //! @todo Accumulate playtime instead of deriving it
+  const double timestampWallClock =
+      (m_totalFrameCount /
+       m_gameClient->GetFrameRate()); //! @todo Accumulate playtime instead of deriving it
   const std::string gameClientId = m_gameClient->ID();
   const std::string gameClientVersion = m_gameClient->Version().asString();
 
@@ -139,7 +143,7 @@ std::string CReversiblePlayback::CreateSavestate()
   savestate->SetGameClientID(gameClientId);
   savestate->SetGameClientVersion(gameClientVersion);
 
-  uint8_t *memoryData = savestate->GetMemoryBuffer(memorySize);
+  uint8_t* memoryData = savestate->GetMemoryBuffer(memorySize);
 
   {
     CSingleLock lock(m_mutex);
@@ -174,7 +178,8 @@ bool CReversiblePlayback::LoadSavestate(const std::string& path)
   bool bSuccess = false;
 
   std::unique_ptr<ISavestate> savestate = m_savestateDatabase->CreateSavestate();
-  if (m_savestateDatabase->GetSavestate(path, *savestate) && savestate->GetMemorySize() == memorySize)
+  if (m_savestateDatabase->GetSavestate(path, *savestate) &&
+      savestate->GetMemorySize() == memorySize)
   {
     {
       CSingleLock lock(m_mutex);
@@ -268,15 +273,15 @@ void CReversiblePlayback::UpdatePlaybackStats()
   m_cacheTimeMs = MathUtils::round_int(1000.0 * cached / m_gameLoop.FPS());
 }
 
-void CReversiblePlayback::Notify(const Observable &obs, const ObservableMessage msg)
+void CReversiblePlayback::Notify(const Observable& obs, const ObservableMessage msg)
 {
   switch (msg)
   {
-  case ObservableMessageSettingsChanged:
-    UpdateMemoryStream();
-    break;
-  default:
-    break;
+    case ObservableMessageSettingsChanged:
+      UpdateMemoryStream();
+      break;
+    default:
+      break;
   }
 }
 
@@ -286,7 +291,7 @@ void CReversiblePlayback::UpdateMemoryStream()
 
   bool bRewindEnabled = false;
 
-  GAME::CGameSettings &gameSettings = CServiceBroker::GetGameServices().GameSettings();
+  GAME::CGameSettings& gameSettings = CServiceBroker::GetGameServices().GameSettings();
 
   if (m_gameClient->SerializeSize() > 0)
     bRewindEnabled = gameSettings.RewindEnabled();
diff --git a/xbmc/cores/RetroPlayer/playback/ReversiblePlayback.h b/xbmc/cores/RetroPlayer/playback/ReversiblePlayback.h
index 0d5ade2aca16..818a73fdf6c5 100644
--- a/xbmc/cores/RetroPlayer/playback/ReversiblePlayback.h
+++ b/xbmc/cores/RetroPlayer/playback/ReversiblePlayback.h
@@ -21,70 +21,68 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameClient;
+class CGameClient;
 }
 
 namespace RETRO
 {
-  class CSavestateDatabase;
-  class IMemoryStream;
+class CSavestateDatabase;
+class IMemoryStream;
 
-  class CReversiblePlayback : public IPlayback,
-                              public IGameLoopCallback,
-                              public Observer
-  {
-  public:
-    CReversiblePlayback(GAME::CGameClient* gameClient, double fps, size_t serializeSize);
+class CReversiblePlayback : public IPlayback, public IGameLoopCallback, public Observer
+{
+public:
+  CReversiblePlayback(GAME::CGameClient* gameClient, double fps, size_t serializeSize);
 
-    ~CReversiblePlayback() override;
+  ~CReversiblePlayback() override;
 
-    // implementation of IPlayback
-    void Initialize() override;
-    void Deinitialize() override;
-    bool CanPause() const override { return true; }
-    bool CanSeek() const override { return true; }
-    unsigned int GetTimeMs() const override { return m_playTimeMs; }
-    unsigned int GetTotalTimeMs() const override { return m_totalTimeMs; }
-    unsigned int GetCacheTimeMs() const override { return m_cacheTimeMs; }
-    void SeekTimeMs(unsigned int timeMs) override;
-    double GetSpeed() const override;
-    void SetSpeed(double speedFactor) override;
-    void PauseAsync() override;
-    std::string CreateSavestate() override;
-    bool LoadSavestate(const std::string& path) override;
+  // implementation of IPlayback
+  void Initialize() override;
+  void Deinitialize() override;
+  bool CanPause() const override { return true; }
+  bool CanSeek() const override { return true; }
+  unsigned int GetTimeMs() const override { return m_playTimeMs; }
+  unsigned int GetTotalTimeMs() const override { return m_totalTimeMs; }
+  unsigned int GetCacheTimeMs() const override { return m_cacheTimeMs; }
+  void SeekTimeMs(unsigned int timeMs) override;
+  double GetSpeed() const override;
+  void SetSpeed(double speedFactor) override;
+  void PauseAsync() override;
+  std::string CreateSavestate() override;
+  bool LoadSavestate(const std::string& path) override;
 
-    // implementation of IGameLoopCallback
-    void FrameEvent() override;
-    void RewindEvent() override;
+  // implementation of IGameLoopCallback
+  void FrameEvent() override;
+  void RewindEvent() override;
 
-    // implementation of Observer
-    void Notify(const Observable& obs, const ObservableMessage msg) override;
+  // implementation of Observer
+  void Notify(const Observable& obs, const ObservableMessage msg) override;
 
-  private:
-    void AddFrame();
-    void RewindFrames(uint64_t frames);
-    void AdvanceFrames(uint64_t frames);
-    void UpdatePlaybackStats();
-    void UpdateMemoryStream();
+private:
+  void AddFrame();
+  void RewindFrames(uint64_t frames);
+  void AdvanceFrames(uint64_t frames);
+  void UpdatePlaybackStats();
+  void UpdateMemoryStream();
 
-    // Construction parameter
-    GAME::CGameClient* const m_gameClient;
+  // Construction parameter
+  GAME::CGameClient* const m_gameClient;
 
-    // Gameplay functionality
-    CGameLoop m_gameLoop;
-    std::unique_ptr<IMemoryStream> m_memoryStream;
-    CCriticalSection m_mutex;
+  // Gameplay functionality
+  CGameLoop m_gameLoop;
+  std::unique_ptr<IMemoryStream> m_memoryStream;
+  CCriticalSection m_mutex;
 
-    // Savestate functionality
-    std::unique_ptr<CSavestateDatabase> m_savestateDatabase;
+  // Savestate functionality
+  std::unique_ptr<CSavestateDatabase> m_savestateDatabase;
 
-    // Playback stats
-    uint64_t m_totalFrameCount;
-    uint64_t m_pastFrameCount;
-    uint64_t m_futureFrameCount;
-    unsigned int m_playTimeMs;
-    unsigned int m_totalTimeMs;
-    unsigned int m_cacheTimeMs;
-  };
-}
-}
+  // Playback stats
+  uint64_t m_totalFrameCount;
+  uint64_t m_pastFrameCount;
+  uint64_t m_futureFrameCount;
+  unsigned int m_playTimeMs;
+  unsigned int m_totalTimeMs;
+  unsigned int m_cacheTimeMs;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/RPProcessInfo.cpp b/xbmc/cores/RetroPlayer/process/RPProcessInfo.cpp
index 3a9159ac1d26..b471fe97de0a 100644
--- a/xbmc/cores/RetroPlayer/process/RPProcessInfo.cpp
+++ b/xbmc/cores/RetroPlayer/process/RPProcessInfo.cpp
@@ -7,18 +7,20 @@
  */
 
 #include "RPProcessInfo.h"
+
 #include "ServiceBroker.h"
+#include "cores/DataCacheCore.h"
 #include "cores/RetroPlayer/buffers/RenderBufferManager.h"
 #include "cores/RetroPlayer/rendering/RenderContext.h"
-#include "cores/DataCacheCore.h"
-#include "windowing/GraphicContext.h"
 #include "settings/DisplaySettings.h"
 #include "settings/MediaSettings.h"
 #include "threads/SingleLock.h"
 #include "utils/log.h"
+#include "windowing/GraphicContext.h"
 #include "windowing/WinSystem.h"
 
-extern "C" {
+extern "C"
+{
 #include <libavutil/pixdesc.h>
 }
 
@@ -31,16 +33,16 @@ CreateRPProcessControl CRPProcessInfo::m_processControl = nullptr;
 std::vector<std::unique_ptr<IRendererFactory>> CRPProcessInfo::m_rendererFactories;
 CCriticalSection CRPProcessInfo::m_createSection;
 
-CRPProcessInfo::CRPProcessInfo(std::string platformName) :
-  m_platformName(std::move(platformName)),
-  m_renderBufferManager(new CRenderBufferManager),
-  m_renderContext(new CRenderContext(CServiceBroker::GetRenderSystem(),
-                                     CServiceBroker::GetWinSystem(),
-                                     CServiceBroker::GetWinSystem()->GetGfxContext(),
-                                     CDisplaySettings::GetInstance(),
-                                     CMediaSettings::GetInstance()))
+CRPProcessInfo::CRPProcessInfo(std::string platformName)
+  : m_platformName(std::move(platformName)),
+    m_renderBufferManager(new CRenderBufferManager),
+    m_renderContext(new CRenderContext(CServiceBroker::GetRenderSystem(),
+                                       CServiceBroker::GetWinSystem(),
+                                       CServiceBroker::GetWinSystem()->GetGfxContext(),
+                                       CDisplaySettings::GetInstance(),
+                                       CMediaSettings::GetInstance()))
 {
-  for (auto &rendererFactory : m_rendererFactories)
+  for (auto& rendererFactory : m_rendererFactories)
   {
     RenderBufferPoolVector bufferPools = rendererFactory->CreateBufferPools(*m_renderContext);
     if (!bufferPools.empty())
@@ -62,7 +64,7 @@ CRPProcessInfo::~CRPProcessInfo() = default;
 
 CRPProcessInfo* CRPProcessInfo::CreateInstance()
 {
-  CRPProcessInfo *processInfo = nullptr;
+  CRPProcessInfo* processInfo = nullptr;
 
   CSingleLock lock(m_createSection);
 
@@ -71,7 +73,8 @@ CRPProcessInfo* CRPProcessInfo::CreateInstance()
     processInfo = m_processControl();
 
     if (processInfo != nullptr)
-      CLog::Log(LOGINFO, "RetroPlayer[PROCESS]: Created process info for %s", processInfo->GetPlatformName().c_str());
+      CLog::Log(LOGINFO, "RetroPlayer[PROCESS]: Created process info for %s",
+                processInfo->GetPlatformName().c_str());
     else
       CLog::Log(LOGERROR, "RetroPlayer[PROCESS]: Failed to create process info");
   }
@@ -102,7 +105,7 @@ void CRPProcessInfo::RegisterProcessControl(CreateRPProcessControl createFunc)
   }
 }
 
-void CRPProcessInfo::RegisterRendererFactory(IRendererFactory *factory)
+void CRPProcessInfo::RegisterRendererFactory(IRendererFactory* factory)
 {
   CSingleLock lock(m_createSection);
 
@@ -112,22 +115,24 @@ void CRPProcessInfo::RegisterRendererFactory(IRendererFactory *factory)
   m_rendererFactories.emplace_back(factory);
 }
 
-std::string CRPProcessInfo::GetRenderSystemName(IRenderBufferPool *renderBufferPool) const
+std::string CRPProcessInfo::GetRenderSystemName(IRenderBufferPool* renderBufferPool) const
 {
   return m_renderBufferManager->GetRenderSystemName(renderBufferPool);
 }
 
-CRPBaseRenderer *CRPProcessInfo::CreateRenderer(IRenderBufferPool *renderBufferPool, const CRenderSettings &renderSettings)
+CRPBaseRenderer* CRPProcessInfo::CreateRenderer(IRenderBufferPool* renderBufferPool,
+                                                const CRenderSettings& renderSettings)
 {
   CSingleLock lock(m_createSection);
 
-  for (auto &rendererFactory : m_rendererFactories)
+  for (auto& rendererFactory : m_rendererFactories)
   {
     RenderBufferPoolVector bufferPools = m_renderBufferManager->GetPools(rendererFactory.get());
-    for (auto &bufferPool : bufferPools)
+    for (auto& bufferPool : bufferPools)
     {
       if (bufferPool.get() == renderBufferPool)
-        return rendererFactory->CreateRenderer(renderSettings, *m_renderContext, std::move(bufferPool));
+        return rendererFactory->CreateRenderer(renderSettings, *m_renderContext,
+                                               std::move(bufferPool));
     }
   }
 
@@ -136,9 +141,10 @@ CRPBaseRenderer *CRPProcessInfo::CreateRenderer(IRenderBufferPool *renderBufferP
   return nullptr;
 }
 
-void CRPProcessInfo::SetDataCache(CDataCacheCore *cache)
+void CRPProcessInfo::SetDataCache(CDataCacheCore* cache)
 {
-  m_dataCache = cache;;
+  m_dataCache = cache;
+  ;
 }
 
 void CRPProcessInfo::ResetInfo()
@@ -172,8 +178,8 @@ bool CRPProcessInfo::HasScalingMethod(SCALINGMETHOD scalingMethod) const
 std::vector<SCALINGMETHOD> CRPProcessInfo::GetScalingMethods()
 {
   return {
-    SCALINGMETHOD::NEAREST,
-    SCALINGMETHOD::LINEAR,
+      SCALINGMETHOD::NEAREST,
+      SCALINGMETHOD::LINEAR,
   };
 }
 
@@ -182,7 +188,7 @@ std::vector<SCALINGMETHOD> CRPProcessInfo::GetScalingMethods()
 //******************************************************************************
 void CRPProcessInfo::SetVideoPixelFormat(AVPixelFormat pixFormat)
 {
-  const char *videoPixelFormat = av_get_pix_fmt_name(pixFormat);
+  const char* videoPixelFormat = av_get_pix_fmt_name(pixFormat);
 
   if (m_dataCache != nullptr)
     m_dataCache->SetVideoPixelFormat(videoPixelFormat != nullptr ? videoPixelFormat : "");
@@ -203,7 +209,7 @@ void CRPProcessInfo::SetVideoFps(float fps)
 //******************************************************************************
 // player audio info
 //******************************************************************************
-void CRPProcessInfo::SetAudioChannels(const std::string &channels)
+void CRPProcessInfo::SetAudioChannels(const std::string& channels)
 {
   if (m_dataCache != nullptr)
     m_dataCache->SetAudioChannels(channels);
diff --git a/xbmc/cores/RetroPlayer/process/RPProcessInfo.h b/xbmc/cores/RetroPlayer/process/RPProcessInfo.h
index e4f483f427ff..bc5a5db9867b 100644
--- a/xbmc/cores/RetroPlayer/process/RPProcessInfo.h
+++ b/xbmc/cores/RetroPlayer/process/RPProcessInfo.h
@@ -24,175 +24,178 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderBufferManager;
-  class CRenderContext;
-  class CRenderSettings;
-  class CRPBaseRenderer;
-  class CRPProcessInfo;
-  class IRenderBufferPool;
+class CRenderBufferManager;
+class CRenderContext;
+class CRenderSettings;
+class CRPBaseRenderer;
+class CRPProcessInfo;
+class IRenderBufferPool;
+
+/*!
+ * \brief Process info factory
+ */
+using CreateRPProcessControl = CRPProcessInfo* (*)();
+
+/*!
+ * \brief Rendering factory
+ */
+class IRendererFactory
+{
+public:
+  virtual ~IRendererFactory() = default;
+
+  /*!
+   * \brief Get a description name of the rendering system
+   */
+  virtual std::string RenderSystemName() const = 0;
+
+  /*!
+   * \brief Create a renderer
+   *
+   * \param settings The renderer's initial settings
+   * \param context The rendering context
+   * \param bufferPool The buffer pool to which buffers are returned
+   */
+  virtual CRPBaseRenderer* CreateRenderer(const CRenderSettings& settings,
+                                          CRenderContext& context,
+                                          std::shared_ptr<IRenderBufferPool> bufferPool) = 0;
+
+  /*!
+   * \brief Create buffer pools to manager buffers
+   *
+   * \param context The rendering context shared with the buffer pools
+   *
+   * \return The buffer pools supported by the rendering system
+   */
+  virtual RenderBufferPoolVector CreateBufferPools(CRenderContext& context) = 0;
+};
+
+/*!
+ * \brief Player process info
+ */
+class CRPProcessInfo
+{
+public:
+  static CRPProcessInfo* CreateInstance();
+  static void RegisterProcessControl(CreateRPProcessControl createFunc);
+  static void RegisterRendererFactory(IRendererFactory* factory);
+
+  virtual ~CRPProcessInfo();
+
+  /*!
+   * \brief Get the descriptive name of the platform
+   *
+   * \return The name of the platform as set by windowing
+   */
+  const std::string& GetPlatformName() const { return m_platformName; }
+
+  /*!
+   * \brief Get the descriptive name of the rendering system
+   *
+   * \param renderBufferPool A pool belonging to the rendering system
+   *
+   * \return The name of the rendering system as set by windowing
+   */
+  std::string GetRenderSystemName(IRenderBufferPool* renderBufferPool) const;
 
   /*!
-   * \brief Process info factory
+   * \brief Create a renderer
+   *
+   * \param renderBufferPool The buffer pool used to return render buffers
+   * \param renderSettings The settings for this renderer
+   *
+   * \return The renderer, or nullptr on failure
    */
-  using CreateRPProcessControl = CRPProcessInfo* (*)();
+  CRPBaseRenderer* CreateRenderer(IRenderBufferPool* renderBufferPool,
+                                  const CRenderSettings& renderSettings);
 
   /*!
-   * \brief Rendering factory
+   * \brief Set data cache
    */
-  class IRendererFactory
-  {
-  public:
-    virtual ~IRendererFactory() = default;
-
-    /*!
-     * \brief Get a description name of the rendering system
-     */
-    virtual std::string RenderSystemName() const = 0;
-
-    /*!
-     * \brief Create a renderer
-     *
-     * \param settings The renderer's initial settings
-     * \param context The rendering context
-     * \param bufferPool The buffer pool to which buffers are returned
-     */
-    virtual CRPBaseRenderer *CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) = 0;
-
-    /*!
-     * \brief Create buffer pools to manager buffers
-     *
-     * \param context The rendering context shared with the buffer pools
-     *
-     * \return The buffer pools supported by the rendering system
-     */
-    virtual RenderBufferPoolVector CreateBufferPools(CRenderContext &context) = 0;
-  };
+  void SetDataCache(CDataCacheCore* cache);
 
   /*!
-   * \brief Player process info
+   * \brief Reset data cache info
    */
-  class CRPProcessInfo
-  {
-  public:
-    static CRPProcessInfo* CreateInstance();
-    static void RegisterProcessControl(CreateRPProcessControl createFunc);
-    static void RegisterRendererFactory(IRendererFactory *factory);
-
-    virtual ~CRPProcessInfo();
-
-    /*!
-     * \brief Get the descriptive name of the platform
-     *
-     * \return The name of the platform as set by windowing
-     */
-    const std::string &GetPlatformName() const { return m_platformName; }
-
-    /*!
-     * \brief Get the descriptive name of the rendering system
-     *
-     * \param renderBufferPool A pool belonging to the rendering system
-     *
-     * \return The name of the rendering system as set by windowing
-     */
-    std::string GetRenderSystemName(IRenderBufferPool *renderBufferPool) const;
-
-    /*!
-     * \brief Create a renderer
-     *
-     * \param renderBufferPool The buffer pool used to return render buffers
-     * \param renderSettings The settings for this renderer
-     *
-     * \return The renderer, or nullptr on failure
-     */
-    CRPBaseRenderer *CreateRenderer(IRenderBufferPool *renderBufferPool, const CRenderSettings &renderSettings);
-
-    /*!
-     * \brief Set data cache
-     */
-    void SetDataCache(CDataCacheCore *cache);
-
-    /*!
-     * \brief Reset data cache info
-     */
-    void ResetInfo();
-
-    /// @name Rendering functions
-    ///{
-
-    /*!
-     * \brief Get the context shared by the rendering system
-     */
-    CRenderContext &GetRenderContext() { return *m_renderContext; }
-
-    /*!
-     * \brief Get the buffer manager that owns the buffer pools
-     */
-    CRenderBufferManager &GetBufferManager() { return *m_renderBufferManager; }
-
-    /*!
-     * \brief Check if a buffer pool supports the given scaling method
-     */
-    bool HasScalingMethod(SCALINGMETHOD scalingMethod) const;
-
-    /*!
-     * \brief Get the default scaling method for this rendering system
-     */
-    SCALINGMETHOD GetDefaultScalingMethod() const { return m_defaultScalingMethod; }
-
-    ///}
-
-    /// @name Player video info
-    ///{
-    void SetVideoPixelFormat(AVPixelFormat pixFormat);
-    void SetVideoDimensions(int width, int height);
-    void SetVideoFps(float fps);
-    ///}
-
-    /// @name Player audio info
-    ///{
-    void SetAudioChannels(const std::string &channels);
-    void SetAudioSampleRate(int sampleRate);
-    void SetAudioBitsPerSample(int bitsPerSample);
-    ///}
-
-    /// @name Player states
-    ///{
-    void SetSpeed(float speed);
-    void SetPlayTimes(time_t start, int64_t current, int64_t min, int64_t max);
-    ///}
-
-  protected:
-    /*!
-     * \brief Constructor
-     *
-     * \param platformName A descriptive name of the platform
-     */
-    CRPProcessInfo(std::string platformName);
-
-    /*!
-     * \brief Get all scaling methods available to the rendering system
-     */
-    static std::vector<SCALINGMETHOD> GetScalingMethods();
-
-    // Static factories
-    static CreateRPProcessControl m_processControl;
-    static std::vector<std::unique_ptr<IRendererFactory>> m_rendererFactories;
-    static CCriticalSection m_createSection;
-
-    // Construction parameters
-    const std::string m_platformName;
-
-    // Info parameters
-    CDataCacheCore *m_dataCache = nullptr;
-
-    // Rendering parameters
-    std::unique_ptr<CRenderBufferManager> m_renderBufferManager;
-
-  private:
-    // Rendering parameters
-    std::unique_ptr<CRenderContext> m_renderContext;
-    SCALINGMETHOD m_defaultScalingMethod = SCALINGMETHOD::AUTO;
-  };
-
-}
-}
+  void ResetInfo();
+
+  /// @name Rendering functions
+  ///{
+
+  /*!
+   * \brief Get the context shared by the rendering system
+   */
+  CRenderContext& GetRenderContext() { return *m_renderContext; }
+
+  /*!
+   * \brief Get the buffer manager that owns the buffer pools
+   */
+  CRenderBufferManager& GetBufferManager() { return *m_renderBufferManager; }
+
+  /*!
+   * \brief Check if a buffer pool supports the given scaling method
+   */
+  bool HasScalingMethod(SCALINGMETHOD scalingMethod) const;
+
+  /*!
+   * \brief Get the default scaling method for this rendering system
+   */
+  SCALINGMETHOD GetDefaultScalingMethod() const { return m_defaultScalingMethod; }
+
+  ///}
+
+  /// @name Player video info
+  ///{
+  void SetVideoPixelFormat(AVPixelFormat pixFormat);
+  void SetVideoDimensions(int width, int height);
+  void SetVideoFps(float fps);
+  ///}
+
+  /// @name Player audio info
+  ///{
+  void SetAudioChannels(const std::string& channels);
+  void SetAudioSampleRate(int sampleRate);
+  void SetAudioBitsPerSample(int bitsPerSample);
+  ///}
+
+  /// @name Player states
+  ///{
+  void SetSpeed(float speed);
+  void SetPlayTimes(time_t start, int64_t current, int64_t min, int64_t max);
+  ///}
+
+protected:
+  /*!
+   * \brief Constructor
+   *
+   * \param platformName A descriptive name of the platform
+   */
+  CRPProcessInfo(std::string platformName);
+
+  /*!
+   * \brief Get all scaling methods available to the rendering system
+   */
+  static std::vector<SCALINGMETHOD> GetScalingMethods();
+
+  // Static factories
+  static CreateRPProcessControl m_processControl;
+  static std::vector<std::unique_ptr<IRendererFactory>> m_rendererFactories;
+  static CCriticalSection m_createSection;
+
+  // Construction parameters
+  const std::string m_platformName;
+
+  // Info parameters
+  CDataCacheCore* m_dataCache = nullptr;
+
+  // Rendering parameters
+  std::unique_ptr<CRenderBufferManager> m_renderBufferManager;
+
+private:
+  // Rendering parameters
+  std::unique_ptr<CRenderContext> m_renderContext;
+  SCALINGMETHOD m_defaultScalingMethod = SCALINGMETHOD::AUTO;
+};
+
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/X11/RPProcessInfoX11.cpp b/xbmc/cores/RetroPlayer/process/X11/RPProcessInfoX11.cpp
index 2d87274c3033..05cc8192b1a2 100644
--- a/xbmc/cores/RetroPlayer/process/X11/RPProcessInfoX11.cpp
+++ b/xbmc/cores/RetroPlayer/process/X11/RPProcessInfoX11.cpp
@@ -11,8 +11,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPProcessInfoX11::CRPProcessInfoX11() :
-  CRPProcessInfo("X11")
+CRPProcessInfoX11::CRPProcessInfoX11() : CRPProcessInfo("X11")
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/process/X11/RPProcessInfoX11.h b/xbmc/cores/RetroPlayer/process/X11/RPProcessInfoX11.h
index 578227e70a6f..9236e6f8985c 100644
--- a/xbmc/cores/RetroPlayer/process/X11/RPProcessInfoX11.h
+++ b/xbmc/cores/RetroPlayer/process/X11/RPProcessInfoX11.h
@@ -14,13 +14,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfoX11 : public CRPProcessInfo
-  {
-  public:
-    CRPProcessInfoX11();
+class CRPProcessInfoX11 : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoX11();
 
-    static CRPProcessInfo* Create();
-    static void Register();
-  };
-}
-}
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/android/RPProcessInfoAndroid.cpp b/xbmc/cores/RetroPlayer/process/android/RPProcessInfoAndroid.cpp
index 7561af91f224..52498defa7a7 100644
--- a/xbmc/cores/RetroPlayer/process/android/RPProcessInfoAndroid.cpp
+++ b/xbmc/cores/RetroPlayer/process/android/RPProcessInfoAndroid.cpp
@@ -11,8 +11,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPProcessInfoAndroid::CRPProcessInfoAndroid() :
-  CRPProcessInfo("Android")
+CRPProcessInfoAndroid::CRPProcessInfoAndroid() : CRPProcessInfo("Android")
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/process/android/RPProcessInfoAndroid.h b/xbmc/cores/RetroPlayer/process/android/RPProcessInfoAndroid.h
index e5930f42ede6..ef00acf9be28 100644
--- a/xbmc/cores/RetroPlayer/process/android/RPProcessInfoAndroid.h
+++ b/xbmc/cores/RetroPlayer/process/android/RPProcessInfoAndroid.h
@@ -14,13 +14,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfoAndroid : public CRPProcessInfo
-  {
-  public:
-    CRPProcessInfoAndroid();
+class CRPProcessInfoAndroid : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoAndroid();
 
-    static CRPProcessInfo* Create();
-    static void Register();
-  };
-}
-}
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/gbm/RPProcessInfoGbm.cpp b/xbmc/cores/RetroPlayer/process/gbm/RPProcessInfoGbm.cpp
index a1176b923ed5..f17ad3e971e9 100644
--- a/xbmc/cores/RetroPlayer/process/gbm/RPProcessInfoGbm.cpp
+++ b/xbmc/cores/RetroPlayer/process/gbm/RPProcessInfoGbm.cpp
@@ -11,8 +11,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPProcessInfoGbm::CRPProcessInfoGbm() :
-  CRPProcessInfo("GBM")
+CRPProcessInfoGbm::CRPProcessInfoGbm() : CRPProcessInfo("GBM")
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/process/gbm/RPProcessInfoGbm.h b/xbmc/cores/RetroPlayer/process/gbm/RPProcessInfoGbm.h
index f81bf35dfdaf..c1453d7c0b1f 100644
--- a/xbmc/cores/RetroPlayer/process/gbm/RPProcessInfoGbm.h
+++ b/xbmc/cores/RetroPlayer/process/gbm/RPProcessInfoGbm.h
@@ -14,13 +14,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfoGbm : public CRPProcessInfo
-  {
-  public:
-    CRPProcessInfoGbm();
+class CRPProcessInfoGbm : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoGbm();
 
-    static CRPProcessInfo* Create();
-    static void Register();
-  };
-}
-}
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/ios/RPProcessInfoIOS.cpp b/xbmc/cores/RetroPlayer/process/ios/RPProcessInfoIOS.cpp
index 214be524942b..c849e76b2722 100644
--- a/xbmc/cores/RetroPlayer/process/ios/RPProcessInfoIOS.cpp
+++ b/xbmc/cores/RetroPlayer/process/ios/RPProcessInfoIOS.cpp
@@ -11,8 +11,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPProcessInfoIOS::CRPProcessInfoIOS() :
-  CRPProcessInfo("iOS")
+CRPProcessInfoIOS::CRPProcessInfoIOS() : CRPProcessInfo("iOS")
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/process/ios/RPProcessInfoIOS.h b/xbmc/cores/RetroPlayer/process/ios/RPProcessInfoIOS.h
index 02547391e774..8caa5b1885ea 100644
--- a/xbmc/cores/RetroPlayer/process/ios/RPProcessInfoIOS.h
+++ b/xbmc/cores/RetroPlayer/process/ios/RPProcessInfoIOS.h
@@ -16,13 +16,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfoIOS : public CRPProcessInfo
-  {
-  public:
-    CRPProcessInfoIOS();
+class CRPProcessInfoIOS : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoIOS();
 
-    static CRPProcessInfo* Create();
-    static void Register();
-  };
-}
-}
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/osx/RPProcessInfoOSX.cpp b/xbmc/cores/RetroPlayer/process/osx/RPProcessInfoOSX.cpp
index 9ed186403b99..c9192b909f1d 100644
--- a/xbmc/cores/RetroPlayer/process/osx/RPProcessInfoOSX.cpp
+++ b/xbmc/cores/RetroPlayer/process/osx/RPProcessInfoOSX.cpp
@@ -11,8 +11,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPProcessInfoOSX::CRPProcessInfoOSX() :
-  CRPProcessInfo("macOS")
+CRPProcessInfoOSX::CRPProcessInfoOSX() : CRPProcessInfo("macOS")
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/process/osx/RPProcessInfoOSX.h b/xbmc/cores/RetroPlayer/process/osx/RPProcessInfoOSX.h
index fa4e5726d2d2..646f3fae409f 100644
--- a/xbmc/cores/RetroPlayer/process/osx/RPProcessInfoOSX.h
+++ b/xbmc/cores/RetroPlayer/process/osx/RPProcessInfoOSX.h
@@ -14,13 +14,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfoOSX : public CRPProcessInfo
-  {
-  public:
-    CRPProcessInfoOSX();
+class CRPProcessInfoOSX : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoOSX();
 
-    static CRPProcessInfo* Create();
-    static void Register();
-  };
-}
-}
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/rbpi/RPProcessInfoPi.cpp b/xbmc/cores/RetroPlayer/process/rbpi/RPProcessInfoPi.cpp
index 4d3aa2544f0b..135172979a0c 100644
--- a/xbmc/cores/RetroPlayer/process/rbpi/RPProcessInfoPi.cpp
+++ b/xbmc/cores/RetroPlayer/process/rbpi/RPProcessInfoPi.cpp
@@ -11,8 +11,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPProcessInfoPi::CRPProcessInfoPi() :
-  CRPProcessInfo("RPi")
+CRPProcessInfoPi::CRPProcessInfoPi() : CRPProcessInfo("RPi")
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/process/rbpi/RPProcessInfoPi.h b/xbmc/cores/RetroPlayer/process/rbpi/RPProcessInfoPi.h
index 1d7c10598941..a800f72bbbb0 100644
--- a/xbmc/cores/RetroPlayer/process/rbpi/RPProcessInfoPi.h
+++ b/xbmc/cores/RetroPlayer/process/rbpi/RPProcessInfoPi.h
@@ -14,13 +14,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfoPi : public CRPProcessInfo
-  {
-  public:
-    CRPProcessInfoPi();
+class CRPProcessInfoPi : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoPi();
 
-    static CRPProcessInfo* Create();
-    static void Register();
-  };
-}
-}
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/wayland/RPProcessInfoWayland.cpp b/xbmc/cores/RetroPlayer/process/wayland/RPProcessInfoWayland.cpp
index fb64d5edd5f7..2de0fa90fe5e 100644
--- a/xbmc/cores/RetroPlayer/process/wayland/RPProcessInfoWayland.cpp
+++ b/xbmc/cores/RetroPlayer/process/wayland/RPProcessInfoWayland.cpp
@@ -11,8 +11,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPProcessInfoWayland::CRPProcessInfoWayland() :
-  CRPProcessInfo("Wayland")
+CRPProcessInfoWayland::CRPProcessInfoWayland() : CRPProcessInfo("Wayland")
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/process/wayland/RPProcessInfoWayland.h b/xbmc/cores/RetroPlayer/process/wayland/RPProcessInfoWayland.h
index 98a974dd0179..244ee2084049 100644
--- a/xbmc/cores/RetroPlayer/process/wayland/RPProcessInfoWayland.h
+++ b/xbmc/cores/RetroPlayer/process/wayland/RPProcessInfoWayland.h
@@ -14,13 +14,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfoWayland : public CRPProcessInfo
-  {
-  public:
-    CRPProcessInfoWayland();
+class CRPProcessInfoWayland : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoWayland();
 
-    static CRPProcessInfo* Create();
-    static void Register();
-  };
-}
-}
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/process/windows/RPProcessInfoWin.cpp b/xbmc/cores/RetroPlayer/process/windows/RPProcessInfoWin.cpp
index da104abd43ba..3601551f3af0 100644
--- a/xbmc/cores/RetroPlayer/process/windows/RPProcessInfoWin.cpp
+++ b/xbmc/cores/RetroPlayer/process/windows/RPProcessInfoWin.cpp
@@ -13,8 +13,7 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPProcessInfoWin::CRPProcessInfoWin() :
-  CRPProcessInfo("Windows")
+CRPProcessInfoWin::CRPProcessInfoWin() : CRPProcessInfo("Windows")
 {
 }
 
diff --git a/xbmc/cores/RetroPlayer/process/windows/RPProcessInfoWin.h b/xbmc/cores/RetroPlayer/process/windows/RPProcessInfoWin.h
index 429ae289460c..8596446ae819 100644
--- a/xbmc/cores/RetroPlayer/process/windows/RPProcessInfoWin.h
+++ b/xbmc/cores/RetroPlayer/process/windows/RPProcessInfoWin.h
@@ -14,13 +14,13 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfoWin : public CRPProcessInfo
-  {
-  public:
-    CRPProcessInfoWin();
+class CRPProcessInfoWin : public CRPProcessInfo
+{
+public:
+  CRPProcessInfoWin();
 
-    static CRPProcessInfo* Create();
-    static void Register();
-  };
-}
-}
+  static CRPProcessInfo* Create();
+  static void Register();
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/IRenderManager.h b/xbmc/cores/RetroPlayer/rendering/IRenderManager.h
index 04dd8e030f8d..32bb08cafde4 100644
--- a/xbmc/cores/RetroPlayer/rendering/IRenderManager.h
+++ b/xbmc/cores/RetroPlayer/rendering/IRenderManager.h
@@ -16,38 +16,41 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IGUIRenderSettings;
+class IGUIRenderSettings;
+
+/*!
+ * \brief Interface to expose rendering functions to GUI components
+ */
+class IRenderManager
+{
+public:
+  virtual ~IRenderManager() = default;
+
+  /*!
+   * \brief Render a fullscreen window
+   *
+   * \param bClear Whether the render area should be cleared
+   * \param coordsRes Resolution that the window coordinates are in
+   */
+  virtual void RenderWindow(bool bClear, const RESOLUTION_INFO& coordsRes) = 0;
+
+  /*!
+   * \brief Render a game control
+   *
+   * \param bClear Whether the render area should be cleared
+   * \param bUseAlpha Whether the graphics context's alpha should be used
+   * \param renderRegion The region of the control being rendered
+   * \param renderSettings The settings used to render the control
+   */
+  virtual void RenderControl(bool bClear,
+                             bool bUseAlpha,
+                             const CRect& renderRegion,
+                             const IGUIRenderSettings* renderSettings) = 0;
 
   /*!
-   * \brief Interface to expose rendering functions to GUI components
+   * \brief Clear the background of a fullscreen window
    */
-  class IRenderManager
-  {
-  public:
-    virtual ~IRenderManager() = default;
-
-    /*!
-     * \brief Render a fullscreen window
-     *
-     * \param bClear Whether the render area should be cleared
-     * \param coordsRes Resolution that the window coordinates are in
-     */
-    virtual void RenderWindow(bool bClear, const RESOLUTION_INFO &coordsRes) = 0;
-
-    /*!
-     * \brief Render a game control
-     *
-     * \param bClear Whether the render area should be cleared
-     * \param bUseAlpha Whether the graphics context's alpha should be used
-     * \param renderRegion The region of the control being rendered
-     * \param renderSettings The settings used to render the control
-     */
-    virtual void RenderControl(bool bClear, bool bUseAlpha, const CRect &renderRegion, const IGUIRenderSettings *renderSettings) = 0;
-
-    /*!
-     * \brief Clear the background of a fullscreen window
-     */
-    virtual void ClearBackground() = 0;
-  };
-}
-}
+  virtual void ClearBackground() = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/RPRenderManager.cpp b/xbmc/cores/RetroPlayer/rendering/RPRenderManager.cpp
index 46a39b9bf03c..408d6a3f6d95 100644
--- a/xbmc/cores/RetroPlayer/rendering/RPRenderManager.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/RPRenderManager.cpp
@@ -7,6 +7,7 @@
  */
 
 #include "RPRenderManager.h"
+
 #include "RenderContext.h"
 #include "RenderSettings.h"
 #include "RenderTranslator.h"
@@ -18,12 +19,13 @@
 #include "cores/RetroPlayer/guibridge/IGUIRenderSettings.h"
 #include "cores/RetroPlayer/process/RPProcessInfo.h"
 #include "cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.h"
-#include "utils/TransformMatrix.h"
 #include "threads/SingleLock.h"
 #include "utils/Color.h"
+#include "utils/TransformMatrix.h"
 #include "utils/log.h"
 
-extern "C" {
+extern "C"
+{
 #include <libswscale/swscale.h>
 }
 
@@ -33,11 +35,11 @@ extern "C" {
 using namespace KODI;
 using namespace RETRO;
 
-CRPRenderManager::CRPRenderManager(CRPProcessInfo &processInfo) :
-  m_processInfo(processInfo),
-  m_renderContext(processInfo.GetRenderContext()),
-  m_renderSettings(new CGUIGameSettings(processInfo)),
-  m_renderControlFactory(new CGUIRenderTargetFactory(this))
+CRPRenderManager::CRPRenderManager(CRPProcessInfo& processInfo)
+  : m_processInfo(processInfo),
+    m_renderContext(processInfo.GetRenderContext()),
+    m_renderSettings(new CGUIGameSettings(processInfo)),
+    m_renderControlFactory(new CGUIRenderTargetFactory(this))
 {
 }
 
@@ -50,7 +52,7 @@ void CRPRenderManager::Deinitialize()
 {
   CLog::Log(LOGDEBUG, "RetroPlayer[RENDER]: Deinitializing render manager");
 
-  for (auto &pixelScaler : m_scalers)
+  for (auto& pixelScaler : m_scalers)
   {
     if (pixelScaler.second != nullptr)
       sws_freeContext(pixelScaler.second);
@@ -70,13 +72,14 @@ void CRPRenderManager::Deinitialize()
   m_state = RENDER_STATE::UNCONFIGURED;
 }
 
-bool CRPRenderManager::Configure(AVPixelFormat format, unsigned int nominalWidth, unsigned int nominalHeight, unsigned int maxWidth, unsigned int maxHeight)
+bool CRPRenderManager::Configure(AVPixelFormat format,
+                                 unsigned int nominalWidth,
+                                 unsigned int nominalHeight,
+                                 unsigned int maxWidth,
+                                 unsigned int maxHeight)
 {
   CLog::Log(LOGINFO, "RetroPlayer[RENDER]: Configuring format %s, nominal %ux%u, max %ux%u",
-            CRenderTranslator::TranslatePixelFormat(format),
-            nominalWidth,
-            nominalHeight,
-            maxWidth,
+            CRenderTranslator::TranslatePixelFormat(format), nominalWidth, nominalHeight, maxWidth,
             maxHeight);
 
   // Immutable parameters
@@ -91,9 +94,10 @@ bool CRPRenderManager::Configure(AVPixelFormat format, unsigned int nominalWidth
   return true;
 }
 
-bool CRPRenderManager::GetVideoBuffer(unsigned int width, unsigned int height, AVPixelFormat &format, uint8_t *&data, size_t &size)
+bool CRPRenderManager::GetVideoBuffer(
+    unsigned int width, unsigned int height, AVPixelFormat& format, uint8_t*& data, size_t& size)
 {
-  for (IRenderBuffer *buffer : m_pendingBuffers)
+  for (IRenderBuffer* buffer : m_pendingBuffers)
     buffer->Release();
   m_pendingBuffers.clear();
 
@@ -101,12 +105,12 @@ bool CRPRenderManager::GetVideoBuffer(unsigned int width, unsigned int height, A
     return false;
 
   // Get buffers from visible renderers
-  for (IRenderBufferPool *bufferPool : m_processInfo.GetBufferManager().GetBufferPools())
+  for (IRenderBufferPool* bufferPool : m_processInfo.GetBufferManager().GetBufferPools())
   {
     if (!bufferPool->HasVisibleRenderer())
       continue;
 
-    IRenderBuffer *renderBuffer = bufferPool->GetBuffer(width, height);
+    IRenderBuffer* renderBuffer = bufferPool->GetBuffer(width, height);
     if (renderBuffer != nullptr)
       m_pendingBuffers.emplace_back(renderBuffer);
     else
@@ -117,7 +121,7 @@ bool CRPRenderManager::GetVideoBuffer(unsigned int width, unsigned int height, A
     return false;
 
   //! @todo Handle multiple buffers
-  IRenderBuffer *renderBuffer = m_pendingBuffers.at(0);
+  IRenderBuffer* renderBuffer = m_pendingBuffers.at(0);
 
   format = renderBuffer->GetFormat();
   data = renderBuffer->GetMemory();
@@ -126,7 +130,11 @@ bool CRPRenderManager::GetVideoBuffer(unsigned int width, unsigned int height, A
   return true;
 }
 
-void CRPRenderManager::AddFrame(const uint8_t* data, size_t size, unsigned int width, unsigned int height, unsigned int orientationDegCCW)
+void CRPRenderManager::AddFrame(const uint8_t* data,
+                                size_t size,
+                                unsigned int width,
+                                unsigned int height,
+                                unsigned int orientationDegCCW)
 {
   if (m_bFlush || m_state != RENDER_STATE::CONFIGURED)
     return;
@@ -139,7 +147,7 @@ void CRPRenderManager::AddFrame(const uint8_t* data, size_t size, unsigned int w
   std::vector<IRenderBuffer*> renderBuffers;
 
   // Check pending buffers
-  for (IRenderBuffer *buffer : m_pendingBuffers)
+  for (IRenderBuffer* buffer : m_pendingBuffers)
   {
     if (buffer->GetMemory() == data)
     {
@@ -152,12 +160,12 @@ void CRPRenderManager::AddFrame(const uint8_t* data, size_t size, unsigned int w
   if (renderBuffers.empty())
   {
     // Copy frame to buffers with visible renderers
-    for (IRenderBufferPool *bufferPool : m_processInfo.GetBufferManager().GetBufferPools())
+    for (IRenderBufferPool* bufferPool : m_processInfo.GetBufferManager().GetBufferPools())
     {
       if (!bufferPool->HasVisibleRenderer())
         continue;
 
-      IRenderBuffer *renderBuffer = bufferPool->GetBuffer(width, height);
+      IRenderBuffer* renderBuffer = bufferPool->GetBuffer(width, height);
       if (renderBuffer != nullptr)
       {
         CopyFrame(renderBuffer, m_format, data, size, width, height);
@@ -237,7 +245,7 @@ void CRPRenderManager::FrameMove()
 
   if (bIsConfigured)
   {
-    for (auto &renderer : m_renderers)
+    for (auto& renderer : m_renderers)
       renderer->FrameMove();
   }
 }
@@ -259,7 +267,7 @@ void CRPRenderManager::CheckFlush()
       m_bHasCachedFrame = false;
     }
 
-    for (const auto &renderer : m_renderers)
+    for (const auto& renderer : m_renderers)
       renderer->Flush();
 
     m_processInfo.GetBufferManager().FlushPools();
@@ -274,7 +282,7 @@ void CRPRenderManager::Flush()
   m_bFlush = true;
 }
 
-void CRPRenderManager::RenderWindow(bool bClear, const RESOLUTION_INFO &coordsRes)
+void CRPRenderManager::RenderWindow(bool bClear, const RESOLUTION_INFO& coordsRes)
 {
   std::shared_ptr<CRPBaseRenderer> renderer = GetRenderer(nullptr);
   if (!renderer)
@@ -287,7 +295,10 @@ void CRPRenderManager::RenderWindow(bool bClear, const RESOLUTION_INFO &coordsRe
   m_renderContext.SetRenderingResolution(coordsRes, false);
 }
 
-void CRPRenderManager::RenderControl(bool bClear, bool bUseAlpha, const CRect &renderRegion, const IGUIRenderSettings *renderSettings)
+void CRPRenderManager::RenderControl(bool bClear,
+                                     bool bUseAlpha,
+                                     const CRect& renderRegion,
+                                     const IGUIRenderSettings* renderSettings)
 {
   std::shared_ptr<CRPBaseRenderer> renderer = GetRenderer(renderSettings);
   if (!renderer)
@@ -338,7 +349,7 @@ void CRPRenderManager::ClearBackground()
 bool CRPRenderManager::SupportsRenderFeature(RENDERFEATURE feature) const
 {
   //! @todo Move to ProcessInfo
-  for (const auto &renderer : m_renderers)
+  for (const auto& renderer : m_renderers)
   {
     if (renderer->Supports(feature))
       return true;
@@ -350,7 +361,7 @@ bool CRPRenderManager::SupportsRenderFeature(RENDERFEATURE feature) const
 bool CRPRenderManager::SupportsScalingMethod(SCALINGMETHOD method) const
 {
   //! @todo Move to ProcessInfo
-  for (IRenderBufferPool *bufferPool : m_processInfo.GetBufferManager().GetBufferPools())
+  for (IRenderBufferPool* bufferPool : m_processInfo.GetBufferManager().GetBufferPools())
   {
     CRenderVideoSettings renderSettings;
     renderSettings.SetScalingMethod(method);
@@ -361,13 +372,15 @@ bool CRPRenderManager::SupportsScalingMethod(SCALINGMETHOD method) const
   return false;
 }
 
-void CRPRenderManager::RenderInternal(const std::shared_ptr<CRPBaseRenderer> &renderer, bool bClear, uint32_t alpha)
+void CRPRenderManager::RenderInternal(const std::shared_ptr<CRPBaseRenderer>& renderer,
+                                      bool bClear,
+                                      uint32_t alpha)
 {
   renderer->PreRender(bClear);
 
   CSingleExit exitLock(m_renderContext.GraphicsMutex());
 
-  IRenderBuffer *renderBuffer = GetRenderBuffer(renderer->GetBufferPool());
+  IRenderBuffer* renderBuffer = GetRenderBuffer(renderer->GetBufferPool());
 
   // If our renderer has no buffer, try to create one from paused frame now
   if (renderBuffer == nullptr)
@@ -395,7 +408,8 @@ void CRPRenderManager::RenderInternal(const std::shared_ptr<CRPBaseRenderer> &re
   renderer->RenderFrame(bClear, alpha);
 }
 
-std::shared_ptr<CRPBaseRenderer> CRPRenderManager::GetRenderer(const IGUIRenderSettings *renderSettings)
+std::shared_ptr<CRPBaseRenderer> CRPRenderManager::GetRenderer(
+    const IGUIRenderSettings* renderSettings)
 {
   std::shared_ptr<CRPBaseRenderer> renderer;
 
@@ -409,7 +423,7 @@ std::shared_ptr<CRPBaseRenderer> CRPRenderManager::GetRenderer(const IGUIRenderS
   effectiveRenderSettings.VideoSettings() = GetEffectiveSettings(renderSettings);
 
   // Check renderers in order of buffer pools
-  for (IRenderBufferPool *bufferPool : m_processInfo.GetBufferManager().GetBufferPools())
+  for (IRenderBufferPool* bufferPool : m_processInfo.GetBufferManager().GetBufferPools())
   {
     renderer = GetRenderer(bufferPool, effectiveRenderSettings);
     if (renderer)
@@ -426,7 +440,8 @@ std::shared_ptr<CRPBaseRenderer> CRPRenderManager::GetRenderer(const IGUIRenderS
   return renderer;
 }
 
-std::shared_ptr<CRPBaseRenderer> CRPRenderManager::GetRenderer(IRenderBufferPool *bufferPool, const CRenderSettings &renderSettings)
+std::shared_ptr<CRPBaseRenderer> CRPRenderManager::GetRenderer(
+    IRenderBufferPool* bufferPool, const CRenderSettings& renderSettings)
 {
   std::shared_ptr<CRPBaseRenderer> renderer;
 
@@ -437,7 +452,7 @@ std::shared_ptr<CRPBaseRenderer> CRPRenderManager::GetRenderer(IRenderBufferPool
   }
 
   // Get compatible renderer for this buffer pool
-  for (const auto &it : m_renderers)
+  for (const auto& it : m_renderers)
   {
     if (it->GetBufferPool() != bufferPool)
       continue;
@@ -470,17 +485,15 @@ std::shared_ptr<CRPBaseRenderer> CRPRenderManager::GetRenderer(IRenderBufferPool
   return renderer;
 }
 
-bool CRPRenderManager::HasRenderBuffer(IRenderBufferPool *bufferPool)
+bool CRPRenderManager::HasRenderBuffer(IRenderBufferPool* bufferPool)
 {
   bool bHasRenderBuffer = false;
 
   CSingleLock lock(m_bufferMutex);
 
-  auto it = std::find_if(m_renderBuffers.begin(), m_renderBuffers.end(),
-    [bufferPool](IRenderBuffer *renderBuffer)
-    {
-      return renderBuffer->GetPool() == bufferPool;
-    });
+  auto it = std::find_if(
+      m_renderBuffers.begin(), m_renderBuffers.end(),
+      [bufferPool](IRenderBuffer* renderBuffer) { return renderBuffer->GetPool() == bufferPool; });
 
   if (it != m_renderBuffers.end())
     bHasRenderBuffer = true;
@@ -488,20 +501,18 @@ bool CRPRenderManager::HasRenderBuffer(IRenderBufferPool *bufferPool)
   return bHasRenderBuffer;
 }
 
-IRenderBuffer *CRPRenderManager::GetRenderBuffer(IRenderBufferPool *bufferPool)
+IRenderBuffer* CRPRenderManager::GetRenderBuffer(IRenderBufferPool* bufferPool)
 {
   if (m_bFlush || m_state != RENDER_STATE::CONFIGURED)
     return nullptr;
 
-  IRenderBuffer *renderBuffer = nullptr;
+  IRenderBuffer* renderBuffer = nullptr;
 
   CSingleLock lock(m_bufferMutex);
 
-  auto it = std::find_if(m_renderBuffers.begin(), m_renderBuffers.end(),
-    [bufferPool](IRenderBuffer *renderBuffer)
-    {
-      return renderBuffer->GetPool() == bufferPool;
-    });
+  auto it = std::find_if(
+      m_renderBuffers.begin(), m_renderBuffers.end(),
+      [bufferPool](IRenderBuffer* renderBuffer) { return renderBuffer->GetPool() == bufferPool; });
 
   if (it != m_renderBuffers.end())
   {
@@ -512,7 +523,7 @@ IRenderBuffer *CRPRenderManager::GetRenderBuffer(IRenderBufferPool *bufferPool)
   return renderBuffer;
 }
 
-void CRPRenderManager::CreateRenderBuffer(IRenderBufferPool *bufferPool)
+void CRPRenderManager::CreateRenderBuffer(IRenderBufferPool* bufferPool)
 {
   if (m_bFlush || m_state != RENDER_STATE::CONFIGURED)
     return;
@@ -521,13 +532,18 @@ void CRPRenderManager::CreateRenderBuffer(IRenderBufferPool *bufferPool)
 
   if (!HasRenderBuffer(bufferPool) && m_bHasCachedFrame)
   {
-    IRenderBuffer *renderBuffer = CreateFromCache(m_cachedFrame, m_cachedWidth, m_cachedHeight, bufferPool, m_bufferMutex);
+    IRenderBuffer* renderBuffer =
+        CreateFromCache(m_cachedFrame, m_cachedWidth, m_cachedHeight, bufferPool, m_bufferMutex);
     if (renderBuffer != nullptr)
       m_renderBuffers.emplace_back(renderBuffer);
   }
 }
 
-IRenderBuffer *CRPRenderManager::CreateFromCache(std::vector<uint8_t> &cachedFrame, unsigned int width, unsigned int height, IRenderBufferPool *bufferPool, CCriticalSection &mutex)
+IRenderBuffer* CRPRenderManager::CreateFromCache(std::vector<uint8_t>& cachedFrame,
+                                                 unsigned int width,
+                                                 unsigned int height,
+                                                 IRenderBufferPool* bufferPool,
+                                                 CCriticalSection& mutex)
 {
   // Take ownership of cached frame
   std::vector<uint8_t> ownedFrame = std::move(cachedFrame);
@@ -536,7 +552,7 @@ IRenderBuffer *CRPRenderManager::CreateFromCache(std::vector<uint8_t> &cachedFra
   {
     CLog::Log(LOGERROR, "RetroPlayer[RENDER]: Creating render buffer for renderer");
 
-    IRenderBuffer *renderBuffer = bufferPool->GetBuffer(width, height);
+    IRenderBuffer* renderBuffer = bufferPool->GetBuffer(width, height);
     if (renderBuffer != nullptr)
     {
       CSingleExit exit(mutex);
@@ -556,15 +572,21 @@ IRenderBuffer *CRPRenderManager::CreateFromCache(std::vector<uint8_t> &cachedFra
   return nullptr;
 }
 
-void CRPRenderManager::CopyFrame(IRenderBuffer *renderBuffer, AVPixelFormat format, const uint8_t *data, size_t size, unsigned int width, unsigned int height)
+void CRPRenderManager::CopyFrame(IRenderBuffer* renderBuffer,
+                                 AVPixelFormat format,
+                                 const uint8_t* data,
+                                 size_t size,
+                                 unsigned int width,
+                                 unsigned int height)
 {
-  const uint8_t *source = data;
-  uint8_t *target = renderBuffer->GetMemory();
+  const uint8_t* source = data;
+  uint8_t* target = renderBuffer->GetMemory();
 
   if (target != nullptr)
   {
     const unsigned int sourceStride = static_cast<unsigned int>(size / height);
-    const unsigned int targetStride = static_cast<unsigned int>(renderBuffer->GetFrameSize() / renderBuffer->GetHeight());
+    const unsigned int targetStride =
+        static_cast<unsigned int>(renderBuffer->GetFrameSize() / renderBuffer->GetHeight());
 
     if (m_format == renderBuffer->GetFormat())
     {
@@ -582,18 +604,17 @@ void CRPRenderManager::CopyFrame(IRenderBuffer *renderBuffer, AVPixelFormat form
     }
     else
     {
-      SwsContext *&scalerContext = m_scalers[renderBuffer->GetFormat()];
-      scalerContext = sws_getCachedContext(scalerContext,
-                                           width, height, format,
-                                           renderBuffer->GetWidth(), renderBuffer->GetHeight(), renderBuffer->GetFormat(),
-                                           SWS_FAST_BILINEAR, nullptr, nullptr, nullptr);
+      SwsContext*& scalerContext = m_scalers[renderBuffer->GetFormat()];
+      scalerContext = sws_getCachedContext(
+          scalerContext, width, height, format, renderBuffer->GetWidth(), renderBuffer->GetHeight(),
+          renderBuffer->GetFormat(), SWS_FAST_BILINEAR, nullptr, nullptr, nullptr);
 
       if (scalerContext != nullptr)
       {
-        uint8_t* src[] =       { const_cast<uint8_t*>(source),    nullptr,   nullptr,   nullptr };
-        int      srcStride[] = { static_cast<int>(sourceStride),  0,         0,         0       };
-        uint8_t *dst[] =       { target,                          nullptr,   nullptr,   nullptr };
-        int      dstStride[] = { static_cast<int>(targetStride),  0,         0,         0       };
+        uint8_t* src[] = {const_cast<uint8_t*>(source), nullptr, nullptr, nullptr};
+        int srcStride[] = {static_cast<int>(sourceStride), 0, 0, 0};
+        uint8_t* dst[] = {target, nullptr, nullptr, nullptr};
+        int dstStride[] = {static_cast<int>(targetStride), 0, 0, 0};
 
         sws_scale(scalerContext, src, srcStride, 0, height, dst, dstStride);
       }
@@ -603,7 +624,8 @@ void CRPRenderManager::CopyFrame(IRenderBuffer *renderBuffer, AVPixelFormat form
   renderBuffer->ReleaseMemory();
 }
 
-CRenderVideoSettings CRPRenderManager::GetEffectiveSettings(const IGUIRenderSettings *settings) const
+CRenderVideoSettings CRPRenderManager::GetEffectiveSettings(
+    const IGUIRenderSettings* settings) const
 {
   CRenderVideoSettings effectiveSettings = m_renderSettings->GetSettings().VideoSettings();
 
@@ -612,9 +634,11 @@ CRenderVideoSettings CRPRenderManager::GetEffectiveSettings(const IGUIRenderSett
     if (settings->HasVideoFilter())
       effectiveSettings.SetVideoFilter(settings->GetSettings().VideoSettings().GetVideoFilter());
     if (settings->HasStretchMode())
-      effectiveSettings.SetRenderStretchMode(settings->GetSettings().VideoSettings().GetRenderStretchMode());
+      effectiveSettings.SetRenderStretchMode(
+          settings->GetSettings().VideoSettings().GetRenderStretchMode());
     if (settings->HasRotation())
-      effectiveSettings.SetRenderRotation(settings->GetSettings().VideoSettings().GetRenderRotation());
+      effectiveSettings.SetRenderRotation(
+          settings->GetSettings().VideoSettings().GetRenderRotation());
   }
 
   // Sanitize settings
diff --git a/xbmc/cores/RetroPlayer/rendering/RPRenderManager.h b/xbmc/cores/RetroPlayer/rendering/RPRenderManager.h
index c20beb3eac28..4677d0e556e8 100644
--- a/xbmc/cores/RetroPlayer/rendering/RPRenderManager.h
+++ b/xbmc/cores/RetroPlayer/rendering/RPRenderManager.h
@@ -13,7 +13,8 @@
 #include "cores/RetroPlayer/guibridge/IRenderCallback.h"
 #include "threads/CriticalSection.h"
 
-extern "C" {
+extern "C"
+{
 #include <libavutil/pixfmt.h>
 }
 
@@ -29,177 +30,200 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGUIRenderTargetFactory;
-  class CRenderContext;
-  class CRenderSettings;
-  class CRPBaseRenderer;
-  class CRPProcessInfo;
-  class IGUIRenderSettings;
-  class IRenderBuffer;
-  class IRenderBufferPool;
+class CGUIRenderTargetFactory;
+class CRenderContext;
+class CRenderSettings;
+class CRPBaseRenderer;
+class CRPProcessInfo;
+class IGUIRenderSettings;
+class IRenderBuffer;
+class IRenderBufferPool;
+
+/*!
+ * \brief Renders video frames provided by the game loop
+ *
+ * Generally, buffer pools are registered by the windowing subsystem. A buffer
+ * pool provides a software or hardware buffer to store the added frame. When
+ * RenderManager is created, it instantiates all registered buffer pools.
+ *
+ * When a frame arrives, it is copied into a buffer from each buffer pool with
+ * a visible renderer. For example, if a GLES and MMAL renderer are both
+ * visible in the GUI, then the frame will be copied into two buffers.
+ *
+ * When it is time to render the frame, the GUI control or window calls into
+ * this class through the IRenderManager interface. RenderManager selects an
+ * appropriate renderer to use to render the frame. The renderer is then
+ * given the buffer that came from its buffer pool.
+ *
+ * Special behavior is needed when the game is paused. As no new frames are
+ * delivered, a newly created renderer will stay black. For this scenario,
+ * when we detect a pause event, the frame is preemptively cached so that a
+ * newly created renderer will have something to display.
+ */
+class CRPRenderManager : public IRenderManager, public IRenderCallback
+{
+public:
+  CRPRenderManager(CRPProcessInfo& processInfo);
+  ~CRPRenderManager() override = default;
+
+  void Initialize();
+  void Deinitialize();
+
+  /*!
+   * \brief Access the factory for creating GUI render targets
+   */
+  CGUIRenderTargetFactory* GetGUIRenderTargetFactory() { return m_renderControlFactory.get(); }
+
+  // Functions called from game loop
+  bool Configure(AVPixelFormat format,
+                 unsigned int nominalWidth,
+                 unsigned int nominalHeight,
+                 unsigned int maxWidth,
+                 unsigned int maxHeight);
+  bool GetVideoBuffer(
+      unsigned int width, unsigned int height, AVPixelFormat& format, uint8_t*& data, size_t& size);
+  void AddFrame(const uint8_t* data,
+                size_t size,
+                unsigned int width,
+                unsigned int height,
+                unsigned int orientationDegCW);
+  void Flush();
+
+  // Functions called from the player
+  void SetSpeed(double speed);
+
+  // Functions called from render thread
+  void FrameMove();
+
+  // Implementation of IRenderManager
+  void RenderWindow(bool bClear, const RESOLUTION_INFO& coordsRes) override;
+  void RenderControl(bool bClear,
+                     bool bUseAlpha,
+                     const CRect& renderRegion,
+                     const IGUIRenderSettings* renderSettings) override;
+  void ClearBackground() override;
+
+  // Implementation of IRenderCallback
+  bool SupportsRenderFeature(RENDERFEATURE feature) const override;
+  bool SupportsScalingMethod(SCALINGMETHOD method) const override;
+
+private:
+  /*!
+   * \brief Get or create a renderer compatible with the given render settings
+   */
+  std::shared_ptr<CRPBaseRenderer> GetRenderer(const IGUIRenderSettings* renderSettings);
+
+  /*!
+   * \brief Get or create a renderer for the given buffer pool and render settings
+   */
+  std::shared_ptr<CRPBaseRenderer> GetRenderer(IRenderBufferPool* bufferPool,
+                                               const CRenderSettings& renderSettings);
+
+  /*!
+   * \brief Render a frame using the given renderer
+   */
+  void RenderInternal(const std::shared_ptr<CRPBaseRenderer>& renderer,
+                      bool bClear,
+                      uint32_t alpha);
+
+  /*!
+   * \brief Return true if we have a render buffer belonging to the specified pool
+   */
+  bool HasRenderBuffer(IRenderBufferPool* bufferPool);
 
   /*!
-   * \brief Renders video frames provided by the game loop
+   * \brief Get a render buffer belonging to the specified pool
+   */
+  IRenderBuffer* GetRenderBuffer(IRenderBufferPool* bufferPool);
+
+  /*!
+   * \brief Create a render buffer for the specified pool from a cached frame
+   */
+  void CreateRenderBuffer(IRenderBufferPool* bufferPool);
+
+  /*!
+   * \brief Create a render buffer and copy the cached data into it
    *
-   * Generally, buffer pools are registered by the windowing subsystem. A buffer
-   * pool provides a software or hardware buffer to store the added frame. When
-   * RenderManager is created, it instantiates all registered buffer pools.
+   * The cached frame is accessed by both the game and rendering threads,
+   * and therefore requires synchronization.
    *
-   * When a frame arrives, it is copied into a buffer from each buffer pool with
-   * a visible renderer. For example, if a GLES and MMAL renderer are both
-   * visible in the GUI, then the frame will be copied into two buffers.
+   * However, assuming the memory copy is expensive, we must avoid holding
+   * the mutex during the copy.
    *
-   * When it is time to render the frame, the GUI control or window calls into
-   * this class through the IRenderManager interface. RenderManager selects an
-   * appropriate renderer to use to render the frame. The renderer is then
-   * given the buffer that came from its buffer pool.
+   * To allow for this, the function is permitted to invalidate its
+   * cachedFrame parameter, as long as it is restored upon exit. While the
+   * mutex is exited inside this function, cachedFrame is guaranteed to be
+   * empty.
    *
-   * Special behavior is needed when the game is paused. As no new frames are
-   * delivered, a newly created renderer will stay black. For this scenario,
-   * when we detect a pause event, the frame is preemptively cached so that a
-   * newly created renderer will have something to display.
+   * \param cachedFrame The cached frame
+   * \param width The width of the cached frame
+   * \param height The height of the cached frame
+   * \param bufferPool The buffer pool used to create the render buffer
+   * \param mutex The locked mutex, to be unlocked during memory copy
+   *
+   * \return The render buffer if one was created from the cached frame,
+   *         otherwise nullptr
+   */
+  IRenderBuffer* CreateFromCache(std::vector<uint8_t>& cachedFrame,
+                                 unsigned int width,
+                                 unsigned int height,
+                                 IRenderBufferPool* bufferPool,
+                                 CCriticalSection& mutex);
+
+  /*!
+   * \brief Utility function to copy a frame and rescale pixels if necessary
    */
-  class CRPRenderManager : public IRenderManager,
-                           public IRenderCallback
+  void CopyFrame(IRenderBuffer* renderBuffer,
+                 AVPixelFormat format,
+                 const uint8_t* data,
+                 size_t size,
+                 unsigned int width,
+                 unsigned int height);
+
+  CRenderVideoSettings GetEffectiveSettings(const IGUIRenderSettings* settings) const;
+
+  void CheckFlush();
+
+  // Construction parameters
+  CRPProcessInfo& m_processInfo;
+  CRenderContext& m_renderContext;
+
+  // Subsystems
+  std::shared_ptr<IGUIRenderSettings> m_renderSettings;
+  std::shared_ptr<CGUIRenderTargetFactory> m_renderControlFactory;
+
+  // Stream properties
+  AVPixelFormat m_format = AV_PIX_FMT_NONE;
+  unsigned int m_maxWidth = 0;
+  unsigned int m_maxHeight = 0;
+
+  // Render resources
+  std::set<std::shared_ptr<CRPBaseRenderer>> m_renderers;
+  std::vector<IRenderBuffer*> m_pendingBuffers; // Only access from game thread
+  std::vector<IRenderBuffer*> m_renderBuffers;
+  std::map<AVPixelFormat, SwsContext*> m_scalers;
+  std::vector<uint8_t> m_cachedFrame;
+  unsigned int m_cachedWidth = 0;
+  unsigned int m_cachedHeight = 0;
+
+  // State parameters
+  enum class RENDER_STATE
   {
-  public:
-    CRPRenderManager(CRPProcessInfo &processInfo);
-    ~CRPRenderManager() override = default;
-
-    void Initialize();
-    void Deinitialize();
-
-    /*!
-     * \brief Access the factory for creating GUI render targets
-     */
-    CGUIRenderTargetFactory *GetGUIRenderTargetFactory() { return m_renderControlFactory.get(); }
-
-    // Functions called from game loop
-    bool Configure(AVPixelFormat format, unsigned int nominalWidth, unsigned int nominalHeight, unsigned int maxWidth, unsigned int maxHeight);
-    bool GetVideoBuffer(unsigned int width, unsigned int height, AVPixelFormat &format, uint8_t *&data, size_t &size);
-    void AddFrame(const uint8_t* data, size_t size, unsigned int width, unsigned int height, unsigned int orientationDegCW);
-    void Flush();
-
-    // Functions called from the player
-    void SetSpeed(double speed);
-
-    // Functions called from render thread
-    void FrameMove();
-
-    // Implementation of IRenderManager
-    void RenderWindow(bool bClear, const RESOLUTION_INFO &coordsRes) override;
-    void RenderControl(bool bClear, bool bUseAlpha, const CRect &renderRegion, const IGUIRenderSettings *renderSettings) override;
-    void ClearBackground() override;
-
-    // Implementation of IRenderCallback
-    bool SupportsRenderFeature(RENDERFEATURE feature) const override;
-    bool SupportsScalingMethod(SCALINGMETHOD method) const override;
-
-  private:
-    /*!
-     * \brief Get or create a renderer compatible with the given render settings
-     */
-    std::shared_ptr<CRPBaseRenderer> GetRenderer(const IGUIRenderSettings *renderSettings);
-
-    /*!
-     * \brief Get or create a renderer for the given buffer pool and render settings
-     */
-    std::shared_ptr<CRPBaseRenderer> GetRenderer(IRenderBufferPool *bufferPool, const CRenderSettings &renderSettings);
-
-    /*!
-     * \brief Render a frame using the given renderer
-     */
-    void RenderInternal(const std::shared_ptr<CRPBaseRenderer> &renderer, bool bClear, uint32_t alpha);
-
-    /*!
-     * \brief Return true if we have a render buffer belonging to the specified pool
-     */
-    bool HasRenderBuffer(IRenderBufferPool *bufferPool);
-
-    /*!
-     * \brief Get a render buffer belonging to the specified pool
-     */
-    IRenderBuffer *GetRenderBuffer(IRenderBufferPool *bufferPool);
-
-    /*!
-     * \brief Create a render buffer for the specified pool from a cached frame
-     */
-    void CreateRenderBuffer(IRenderBufferPool *bufferPool);
-
-    /*!
-     * \brief Create a render buffer and copy the cached data into it
-     *
-     * The cached frame is accessed by both the game and rendering threads,
-     * and therefore requires synchronization.
-     *
-     * However, assuming the memory copy is expensive, we must avoid holding
-     * the mutex during the copy.
-     *
-     * To allow for this, the function is permitted to invalidate its
-     * cachedFrame parameter, as long as it is restored upon exit. While the
-     * mutex is exited inside this function, cachedFrame is guaranteed to be
-     * empty.
-     *
-     * \param cachedFrame The cached frame
-     * \param width The width of the cached frame
-     * \param height The height of the cached frame
-     * \param bufferPool The buffer pool used to create the render buffer
-     * \param mutex The locked mutex, to be unlocked during memory copy
-     *
-     * \return The render buffer if one was created from the cached frame,
-     *         otherwise nullptr
-     */
-    IRenderBuffer *CreateFromCache(std::vector<uint8_t> &cachedFrame, unsigned int width, unsigned int height, IRenderBufferPool *bufferPool, CCriticalSection &mutex);
-
-    /*!
-     * \brief Utility function to copy a frame and rescale pixels if necessary
-     */
-    void CopyFrame(IRenderBuffer *renderBuffer, AVPixelFormat format, const uint8_t *data, size_t size, unsigned int width, unsigned int height);
-
-    CRenderVideoSettings GetEffectiveSettings(const IGUIRenderSettings *settings) const;
-
-    void CheckFlush();
-
-    // Construction parameters
-    CRPProcessInfo &m_processInfo;
-    CRenderContext &m_renderContext;
-
-    // Subsystems
-    std::shared_ptr<IGUIRenderSettings> m_renderSettings;
-    std::shared_ptr<CGUIRenderTargetFactory> m_renderControlFactory;
-
-    // Stream properties
-    AVPixelFormat m_format = AV_PIX_FMT_NONE;
-    unsigned int m_maxWidth = 0;
-    unsigned int m_maxHeight = 0;
-
-    // Render resources
-    std::set<std::shared_ptr<CRPBaseRenderer>> m_renderers;
-    std::vector<IRenderBuffer*> m_pendingBuffers; // Only access from game thread
-    std::vector<IRenderBuffer*> m_renderBuffers;
-    std::map<AVPixelFormat, SwsContext*> m_scalers;
-    std::vector<uint8_t> m_cachedFrame;
-    unsigned int m_cachedWidth = 0;
-    unsigned int m_cachedHeight = 0;
-
-    // State parameters
-    enum class RENDER_STATE
-    {
-      UNCONFIGURED,
-      CONFIGURING,
-      CONFIGURED,
-    };
-    RENDER_STATE m_state = RENDER_STATE::UNCONFIGURED;
-    bool m_bHasCachedFrame = false; // Invariant: m_cachedFrame is empty if false
-    std::set<std::string> m_failedShaderPresets;
-    std::atomic<bool> m_bFlush = {false};
-
-    // Playback parameters
-    std::atomic<double> m_speed = {1.0};
-
-    // Synchronization parameters
-    CCriticalSection m_stateMutex;
-    CCriticalSection m_bufferMutex;
+    UNCONFIGURED,
+    CONFIGURING,
+    CONFIGURED,
   };
-}
-}
+  RENDER_STATE m_state = RENDER_STATE::UNCONFIGURED;
+  bool m_bHasCachedFrame = false; // Invariant: m_cachedFrame is empty if false
+  std::set<std::string> m_failedShaderPresets;
+  std::atomic<bool> m_bFlush = {false};
+
+  // Playback parameters
+  std::atomic<double> m_speed = {1.0};
+
+  // Synchronization parameters
+  CCriticalSection m_stateMutex;
+  CCriticalSection m_bufferMutex;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderContext.cpp b/xbmc/cores/RetroPlayer/rendering/RenderContext.cpp
index 36078c8ba306..88bcb8af950c 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderContext.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/RenderContext.cpp
@@ -7,11 +7,13 @@
  */
 
 #include "RenderContext.h"
-#include "windowing/GraphicContext.h"
+
 #include "rendering/RenderSystem.h"
 #include "settings/DisplaySettings.h"
 #include "settings/MediaSettings.h"
+#include "windowing/GraphicContext.h"
 #include "windowing/WinSystem.h"
+
 #include "system_gl.h"
 
 #if defined(HAS_GL)
@@ -25,16 +27,16 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRenderContext::CRenderContext(CRenderSystemBase *rendering,
-                               CWinSystemBase *windowing,
-                               CGraphicContext &graphicsContext,
-                               CDisplaySettings &displaySettings,
-                               CMediaSettings &mediaSettings) :
-  m_rendering(rendering),
-  m_windowing(windowing),
-  m_graphicsContext(graphicsContext),
-  m_displaySettings(displaySettings),
-  m_mediaSettings(mediaSettings)
+CRenderContext::CRenderContext(CRenderSystemBase* rendering,
+                               CWinSystemBase* windowing,
+                               CGraphicContext& graphicsContext,
+                               CDisplaySettings& displaySettings,
+                               CMediaSettings& mediaSettings)
+  : m_rendering(rendering),
+    m_windowing(windowing),
+    m_graphicsContext(graphicsContext),
+    m_displaySettings(displaySettings),
+    m_mediaSettings(mediaSettings)
 {
 }
 
@@ -43,12 +45,12 @@ void CRenderContext::SetViewPort(const CRect& viewPort)
   m_rendering->SetViewPort(viewPort);
 }
 
-void CRenderContext::GetViewPort(CRect &viewPort)
+void CRenderContext::GetViewPort(CRect& viewPort)
 {
   m_rendering->GetViewPort(viewPort);
 }
 
-void CRenderContext::SetScissors(const CRect &rect)
+void CRenderContext::SetScissors(const CRect& rect)
 {
   m_rendering->SetScissors(rect);
 }
@@ -70,29 +72,31 @@ static ESHADERMETHOD TranslateShaderMethod(GL_SHADER_METHOD method)
 {
   switch (method)
   {
-  case GL_SHADER_METHOD::DEFAULT: return SM_DEFAULT;
-  case GL_SHADER_METHOD::TEXTURE: return SM_TEXTURE;
+    case GL_SHADER_METHOD::DEFAULT:
+      return SM_DEFAULT;
+    case GL_SHADER_METHOD::TEXTURE:
+      return SM_TEXTURE;
 #if defined(HAS_GLES)
-  case GL_SHADER_METHOD::TEXTURE_NOALPHA:
-    return SM_TEXTURE_NOALPHA;
+    case GL_SHADER_METHOD::TEXTURE_NOALPHA:
+      return SM_TEXTURE_NOALPHA;
 #endif
-  default:
-    break;
+    default:
+      break;
   }
 
   return SM_DEFAULT;
 }
-}
+} // namespace
 #endif
 
 void CRenderContext::EnableGUIShader(GL_SHADER_METHOD method)
 {
 #if defined(HAS_GL)
-  CRenderSystemGL *rendering = dynamic_cast<CRenderSystemGL*>(m_rendering);
+  CRenderSystemGL* rendering = dynamic_cast<CRenderSystemGL*>(m_rendering);
   if (rendering != nullptr)
     rendering->EnableShader(TranslateShaderMethod(method));
 #elif HAS_GLES >= 2
-  CRenderSystemGLES *renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
+  CRenderSystemGLES* renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
   if (renderingGLES != nullptr)
     renderingGLES->EnableGUIShader(TranslateShaderMethod(method));
 #endif
@@ -101,11 +105,11 @@ void CRenderContext::EnableGUIShader(GL_SHADER_METHOD method)
 void CRenderContext::DisableGUIShader()
 {
 #if defined(HAS_GL)
-  CRenderSystemGL *renderingGL = dynamic_cast<CRenderSystemGL*>(m_rendering);
+  CRenderSystemGL* renderingGL = dynamic_cast<CRenderSystemGL*>(m_rendering);
   if (renderingGL != nullptr)
     renderingGL->DisableShader();
 #elif HAS_GLES >= 2
-  CRenderSystemGLES *renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
+  CRenderSystemGLES* renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
   if (renderingGLES != nullptr)
     renderingGLES->DisableGUIShader();
 #endif
@@ -114,11 +118,11 @@ void CRenderContext::DisableGUIShader()
 int CRenderContext::GUIShaderGetPos()
 {
 #if defined(HAS_GL)
-  CRenderSystemGL *renderingGL = dynamic_cast<CRenderSystemGL*>(m_rendering);
+  CRenderSystemGL* renderingGL = dynamic_cast<CRenderSystemGL*>(m_rendering);
   if (renderingGL != nullptr)
     return static_cast<int>(renderingGL->ShaderGetPos());
 #elif HAS_GLES >= 2
-  CRenderSystemGLES *renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
+  CRenderSystemGLES* renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
   if (renderingGLES != nullptr)
     return static_cast<int>(renderingGLES->GUIShaderGetPos());
 #endif
@@ -129,11 +133,11 @@ int CRenderContext::GUIShaderGetPos()
 int CRenderContext::GUIShaderGetCoord0()
 {
 #if defined(HAS_GL)
-  CRenderSystemGL *renderingGL = dynamic_cast<CRenderSystemGL*>(m_rendering);
+  CRenderSystemGL* renderingGL = dynamic_cast<CRenderSystemGL*>(m_rendering);
   if (renderingGL != nullptr)
     return static_cast<int>(renderingGL->ShaderGetCoord0());
 #elif HAS_GLES >= 2
-  CRenderSystemGLES *renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
+  CRenderSystemGLES* renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
   if (renderingGLES != nullptr)
     return static_cast<int>(renderingGLES->GUIShaderGetCoord0());
 #endif
@@ -144,11 +148,11 @@ int CRenderContext::GUIShaderGetCoord0()
 int CRenderContext::GUIShaderGetUniCol()
 {
 #if defined(HAS_GL)
-  CRenderSystemGL *renderingGL = dynamic_cast<CRenderSystemGL*>(m_rendering);
+  CRenderSystemGL* renderingGL = dynamic_cast<CRenderSystemGL*>(m_rendering);
   if (renderingGL != nullptr)
     return static_cast<int>(renderingGL->ShaderGetUniCol());
 #elif HAS_GLES >= 2
-  CRenderSystemGLES *renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
+  CRenderSystemGLES* renderingGLES = dynamic_cast<CRenderSystemGLES*>(m_rendering);
   if (renderingGLES != nullptr)
     return static_cast<int>(renderingGLES->GUIShaderGetUniCol());
 #endif
@@ -159,7 +163,7 @@ int CRenderContext::GUIShaderGetUniCol()
 CGUIShaderDX* CRenderContext::GetGUIShader()
 {
 #if defined(HAS_DX)
-  CRenderSystemDX *renderingDX = dynamic_cast<CRenderSystemDX*>(m_rendering);
+  CRenderSystemDX* renderingDX = dynamic_cast<CRenderSystemDX*>(m_rendering);
   if (renderingDX != nullptr)
     return renderingDX->GetGUIShader();
 #endif
@@ -182,7 +186,7 @@ int CRenderContext::GetScreenHeight()
   return m_graphicsContext.GetHeight();
 }
 
-const CRect &CRenderContext::GetScissors()
+const CRect& CRenderContext::GetScissors()
 {
   return m_graphicsContext.GetScissors();
 }
@@ -227,7 +231,7 @@ RESOLUTION_INFO CRenderContext::GetResInfo()
   return m_graphicsContext.GetResInfo();
 }
 
-void CRenderContext::SetRenderingResolution(const RESOLUTION_INFO &res, bool needsScaling)
+void CRenderContext::SetRenderingResolution(const RESOLUTION_INFO& res, bool needsScaling)
 {
   m_graphicsContext.SetRenderingResolution(res, needsScaling);
 }
@@ -237,7 +241,7 @@ UTILS::Color CRenderContext::MergeAlpha(UTILS::Color color)
   return m_graphicsContext.MergeAlpha(color);
 }
 
-void CRenderContext::SetTransform(const TransformMatrix &matrix, float scaleX, float scaleY)
+void CRenderContext::SetTransform(const TransformMatrix& matrix, float scaleX, float scaleY)
 {
   m_graphicsContext.SetTransform(matrix, scaleX, scaleY);
 }
@@ -247,27 +251,27 @@ void CRenderContext::RemoveTransform()
   m_graphicsContext.RemoveTransform();
 }
 
-CRect CRenderContext::StereoCorrection(const CRect &rect)
+CRect CRenderContext::StereoCorrection(const CRect& rect)
 {
   return m_graphicsContext.StereoCorrection(rect);
 }
 
-CCriticalSection &CRenderContext::GraphicsMutex()
+CCriticalSection& CRenderContext::GraphicsMutex()
 {
   return m_graphicsContext;
 }
 
-RESOLUTION_INFO &CRenderContext::GetResolutionInfo(RESOLUTION resolution)
+RESOLUTION_INFO& CRenderContext::GetResolutionInfo(RESOLUTION resolution)
 {
   return m_displaySettings.GetResolutionInfo(resolution);
 }
 
-CGameSettings &CRenderContext::GetGameSettings()
+CGameSettings& CRenderContext::GetGameSettings()
 {
   return m_mediaSettings.GetCurrentGameSettings();
 }
 
-CGameSettings &CRenderContext::GetDefaultGameSettings()
+CGameSettings& CRenderContext::GetDefaultGameSettings()
 {
   return m_mediaSettings.GetDefaultGameSettings();
 }
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderContext.h b/xbmc/cores/RetroPlayer/rendering/RenderContext.h
index 4deac3fd296a..74cba02a1cba 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderContext.h
+++ b/xbmc/cores/RetroPlayer/rendering/RenderContext.h
@@ -33,72 +33,72 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext
-  {
-  public:
-    CRenderContext(CRenderSystemBase *rendering,
-                  CWinSystemBase *windowing,
-                  CGraphicContext &graphicsContext,
-                  CDisplaySettings &displaySettings,
-                  CMediaSettings &mediaSettings);
+class CRenderContext
+{
+public:
+  CRenderContext(CRenderSystemBase* rendering,
+                 CWinSystemBase* windowing,
+                 CGraphicContext& graphicsContext,
+                 CDisplaySettings& displaySettings,
+                 CMediaSettings& mediaSettings);
 
-    CRenderSystemBase *Rendering() { return m_rendering; }
-    CWinSystemBase *Windowing() { return m_windowing; }
-    CGraphicContext &GraphicsContext() { return m_graphicsContext; }
+  CRenderSystemBase* Rendering() { return m_rendering; }
+  CWinSystemBase* Windowing() { return m_windowing; }
+  CGraphicContext& GraphicsContext() { return m_graphicsContext; }
 
-    // Rendering functions
-    void SetViewPort(const CRect& viewPort);
-    void GetViewPort(CRect &viewPort);
-    void SetScissors(const CRect &rect);
-    void ApplyStateBlock();
-    bool IsExtSupported(const char* extension);
+  // Rendering functions
+  void SetViewPort(const CRect& viewPort);
+  void GetViewPort(CRect& viewPort);
+  void SetScissors(const CRect& rect);
+  void ApplyStateBlock();
+  bool IsExtSupported(const char* extension);
 
-    // OpenGL(ES) rendering functions
-    void EnableGUIShader(GL_SHADER_METHOD method);
-    void DisableGUIShader();
-    int GUIShaderGetPos();
-    int GUIShaderGetCoord0();
-    int GUIShaderGetUniCol();
+  // OpenGL(ES) rendering functions
+  void EnableGUIShader(GL_SHADER_METHOD method);
+  void DisableGUIShader();
+  int GUIShaderGetPos();
+  int GUIShaderGetCoord0();
+  int GUIShaderGetUniCol();
 
-    // DirectX rendering functions
-    CGUIShaderDX* GetGUIShader();
+  // DirectX rendering functions
+  CGUIShaderDX* GetGUIShader();
 
-    // Windowing functions
-    bool UseLimitedColor();
+  // Windowing functions
+  bool UseLimitedColor();
 
-    // Graphics functions
-    int GetScreenWidth();
-    int GetScreenHeight();
-    const CRect &GetScissors();
-    CRect GetViewWindow();
-    void SetViewWindow(float left, float top, float right, float bottom);
-    void SetFullScreenVideo(bool bOnOff);
-    bool IsFullScreenVideo();
-    bool IsCalibrating();
-    RESOLUTION GetVideoResolution();
-    void Clear(UTILS::Color color = 0);
-    RESOLUTION_INFO GetResInfo();
-    void SetRenderingResolution(const RESOLUTION_INFO &res, bool needsScaling);
-    UTILS::Color MergeAlpha(UTILS::Color color);
-    void SetTransform(const TransformMatrix &matrix, float scaleX, float scaleY);
-    void RemoveTransform();
-    CRect StereoCorrection(const CRect &rect);
-    CCriticalSection &GraphicsMutex();
+  // Graphics functions
+  int GetScreenWidth();
+  int GetScreenHeight();
+  const CRect& GetScissors();
+  CRect GetViewWindow();
+  void SetViewWindow(float left, float top, float right, float bottom);
+  void SetFullScreenVideo(bool bOnOff);
+  bool IsFullScreenVideo();
+  bool IsCalibrating();
+  RESOLUTION GetVideoResolution();
+  void Clear(UTILS::Color color = 0);
+  RESOLUTION_INFO GetResInfo();
+  void SetRenderingResolution(const RESOLUTION_INFO& res, bool needsScaling);
+  UTILS::Color MergeAlpha(UTILS::Color color);
+  void SetTransform(const TransformMatrix& matrix, float scaleX, float scaleY);
+  void RemoveTransform();
+  CRect StereoCorrection(const CRect& rect);
+  CCriticalSection& GraphicsMutex();
 
-    // Display settings
-    RESOLUTION_INFO& GetResolutionInfo(RESOLUTION resolution);
+  // Display settings
+  RESOLUTION_INFO& GetResolutionInfo(RESOLUTION resolution);
 
-    // Media settings
-    CGameSettings &GetGameSettings();
-    CGameSettings &GetDefaultGameSettings();
+  // Media settings
+  CGameSettings& GetGameSettings();
+  CGameSettings& GetDefaultGameSettings();
 
-  private:
-    // Construction parameters
-    CRenderSystemBase *const m_rendering;
-    CWinSystemBase *const m_windowing;
-    CGraphicContext &m_graphicsContext;
-    CDisplaySettings &m_displaySettings;
-    CMediaSettings &m_mediaSettings;
-  };
-}
-}
+private:
+  // Construction parameters
+  CRenderSystemBase* const m_rendering;
+  CWinSystemBase* const m_windowing;
+  CGraphicContext& m_graphicsContext;
+  CDisplaySettings& m_displaySettings;
+  CMediaSettings& m_mediaSettings;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderSettings.cpp b/xbmc/cores/RetroPlayer/rendering/RenderSettings.cpp
index f2e346c82b17..3db43d2a0ba3 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderSettings.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/RenderSettings.cpp
@@ -16,15 +16,17 @@ void CRenderSettings::Reset()
   m_videoSettings.Reset();
 }
 
-bool CRenderSettings::operator==(const CRenderSettings &rhs) const
+bool CRenderSettings::operator==(const CRenderSettings& rhs) const
 {
   return m_videoSettings == rhs.m_videoSettings;
 }
 
-bool CRenderSettings::operator<(const CRenderSettings &rhs) const
+bool CRenderSettings::operator<(const CRenderSettings& rhs) const
 {
-  if (m_videoSettings < rhs.m_videoSettings) return true;
-  if (m_videoSettings > rhs.m_videoSettings) return false;
+  if (m_videoSettings < rhs.m_videoSettings)
+    return true;
+  if (m_videoSettings > rhs.m_videoSettings)
+    return false;
 
   return false;
 }
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderSettings.h b/xbmc/cores/RetroPlayer/rendering/RenderSettings.h
index 390664d9a148..d40cb4230c23 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderSettings.h
+++ b/xbmc/cores/RetroPlayer/rendering/RenderSettings.h
@@ -14,21 +14,21 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderSettings
-  {
-  public:
-    CRenderSettings() { Reset(); }
+class CRenderSettings
+{
+public:
+  CRenderSettings() { Reset(); }
 
-    void Reset();
+  void Reset();
 
-    bool operator==(const CRenderSettings &rhs) const;
-    bool operator<(const CRenderSettings &rhs) const;
+  bool operator==(const CRenderSettings& rhs) const;
+  bool operator<(const CRenderSettings& rhs) const;
 
-    CRenderVideoSettings &VideoSettings() { return m_videoSettings; }
-    const CRenderVideoSettings &VideoSettings() const { return m_videoSettings; }
+  CRenderVideoSettings& VideoSettings() { return m_videoSettings; }
+  const CRenderVideoSettings& VideoSettings() const { return m_videoSettings; }
 
-  private:
-    CRenderVideoSettings m_videoSettings;
-  };
-}
-}
+private:
+  CRenderVideoSettings m_videoSettings;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderTranslator.cpp b/xbmc/cores/RetroPlayer/rendering/RenderTranslator.cpp
index 2295baf9c30c..96620064e287 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderTranslator.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/RenderTranslator.cpp
@@ -13,33 +13,33 @@
 using namespace KODI;
 using namespace RETRO;
 
-const char *CRenderTranslator::TranslatePixelFormat(AVPixelFormat format)
+const char* CRenderTranslator::TranslatePixelFormat(AVPixelFormat format)
 {
   switch (format)
   {
-  case AV_PIX_FMT_0RGB32:
-    return "0RGB32";
-  case AV_PIX_FMT_RGB565:
-    return "RGB565";
-  case AV_PIX_FMT_RGB555:
-    return "RGB555";
-  default:
-    break;
+    case AV_PIX_FMT_0RGB32:
+      return "0RGB32";
+    case AV_PIX_FMT_RGB565:
+      return "RGB565";
+    case AV_PIX_FMT_RGB555:
+      return "RGB555";
+    default:
+      break;
   }
 
   return "unknown";
 }
 
-const char *CRenderTranslator::TranslateScalingMethod(SCALINGMETHOD scalingMethod)
+const char* CRenderTranslator::TranslateScalingMethod(SCALINGMETHOD scalingMethod)
 {
   switch (scalingMethod)
   {
-  case SCALINGMETHOD::NEAREST:
-    return "nearest";
-  case SCALINGMETHOD::LINEAR:
-    return "linear";
-  default:
-    break;
+    case SCALINGMETHOD::NEAREST:
+      return "nearest";
+    case SCALINGMETHOD::LINEAR:
+      return "linear";
+    default:
+      break;
   }
 
   return "";
@@ -51,23 +51,23 @@ unsigned int CRenderTranslator::TranslateWidthToBytes(unsigned int width, AVPixe
 
   switch (format)
   {
-  case AV_PIX_FMT_0RGB32:
-  {
-    bpp = sizeof(uint32_t);
-    break;
-  }
-  case AV_PIX_FMT_RGB555:
-  {
-    bpp = sizeof(uint16_t);
-    break;
-  }
-  case AV_PIX_FMT_RGB565:
-  {
-    bpp = sizeof(uint16_t);
-    break;
-  }
-  default:
-    break;
+    case AV_PIX_FMT_0RGB32:
+    {
+      bpp = sizeof(uint32_t);
+      break;
+    }
+    case AV_PIX_FMT_RGB555:
+    {
+      bpp = sizeof(uint16_t);
+      break;
+    }
+    case AV_PIX_FMT_RGB565:
+    {
+      bpp = sizeof(uint16_t);
+      break;
+    }
+    default:
+      break;
   }
 
   return width * bpp;
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderTranslator.h b/xbmc/cores/RetroPlayer/rendering/RenderTranslator.h
index cced2d13f77c..575ad814fc12 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderTranslator.h
+++ b/xbmc/cores/RetroPlayer/rendering/RenderTranslator.h
@@ -16,28 +16,28 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderTranslator
-  {
-  public:
-    /*!
-     * \brief Translate a pixel format to a string suitable for logging
-     */
-    static const char *TranslatePixelFormat(AVPixelFormat format);
+class CRenderTranslator
+{
+public:
+  /*!
+   * \brief Translate a pixel format to a string suitable for logging
+   */
+  static const char* TranslatePixelFormat(AVPixelFormat format);
 
-    /*!
-     * \brief Translate a scaling method to a string suitable for logging
-     */
-    static const char *TranslateScalingMethod(SCALINGMETHOD scalingMethod);
+  /*!
+   * \brief Translate a scaling method to a string suitable for logging
+   */
+  static const char* TranslateScalingMethod(SCALINGMETHOD scalingMethod);
 
-    /*!
-     * \brief Translate a width in pixels to a width in bytes
-     *
-     * \param width The width in pixels
-     * \param format The pixel format
-     *
-     * \return The width in bytes, or 0 if unknown
-     */
-    static unsigned int TranslateWidthToBytes(unsigned int width, AVPixelFormat format);
-  };
-}
-}
+  /*!
+   * \brief Translate a width in pixels to a width in bytes
+   *
+   * \param width The width in pixels
+   * \param format The pixel format
+   *
+   * \return The width in bytes, or 0 if unknown
+   */
+  static unsigned int TranslateWidthToBytes(unsigned int width, AVPixelFormat format);
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderUtils.cpp b/xbmc/cores/RetroPlayer/rendering/RenderUtils.cpp
index a9e94faf9b88..658b402405d0 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderUtils.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/RenderUtils.cpp
@@ -21,97 +21,97 @@ void CRenderUtils::CalculateStretchMode(STRETCHMODE stretchMode,
                                         unsigned int sourceHeight,
                                         float screenWidth,
                                         float screenHeight,
-                                        float &pixelRatio,
-                                        float &zoomAmount)
+                                        float& pixelRatio,
+                                        float& zoomAmount)
 {
   const float sourceFrameRatio = static_cast<float>(sourceWidth) / static_cast<float>(sourceHeight);
 
   switch (stretchMode)
   {
-  case STRETCHMODE::Normal:
-  {
-    switch (rotationDegCCW)
+    case STRETCHMODE::Normal:
     {
-      case 90:
-      case 270:
+      switch (rotationDegCCW)
       {
-        pixelRatio = 1.0f / (sourceFrameRatio * sourceFrameRatio);
-        break;
+        case 90:
+        case 270:
+        {
+          pixelRatio = 1.0f / (sourceFrameRatio * sourceFrameRatio);
+          break;
+        }
+        default:
+          pixelRatio = 1.0f;
+          break;
       }
-      default:
-        pixelRatio = 1.0f;
-        break;
-    }
-    zoomAmount = 1.0f;
+      zoomAmount = 1.0f;
 
-    break;
-  }
-  case STRETCHMODE::Stretch4x3:
-  {
-    // Stretch to 4:3 ratio
-    pixelRatio = (4.0f / 3.0f) / sourceFrameRatio;
-    zoomAmount = 1.0f;
+      break;
+    }
+    case STRETCHMODE::Stretch4x3:
+    {
+      // Stretch to 4:3 ratio
+      pixelRatio = (4.0f / 3.0f) / sourceFrameRatio;
+      zoomAmount = 1.0f;
 
-    break;
-  }
-  case STRETCHMODE::Fullscreen:
-  {
-    // Stretch to the limits of the screen
-    pixelRatio = (screenWidth / screenHeight) / sourceFrameRatio;
-    zoomAmount = 1.0f;
+      break;
+    }
+    case STRETCHMODE::Fullscreen:
+    {
+      // Stretch to the limits of the screen
+      pixelRatio = (screenWidth / screenHeight) / sourceFrameRatio;
+      zoomAmount = 1.0f;
 
-    break;
-  }
-  case STRETCHMODE::Original:
-  {
-    switch (rotationDegCCW)
+      break;
+    }
+    case STRETCHMODE::Original:
     {
-      case 90:
-      case 270:
+      switch (rotationDegCCW)
       {
-        pixelRatio = 1.0f / (sourceFrameRatio * sourceFrameRatio);
-        break;
+        case 90:
+        case 270:
+        {
+          pixelRatio = 1.0f / (sourceFrameRatio * sourceFrameRatio);
+          break;
+        }
+        default:
+          pixelRatio = 1.0f;
+          break;
       }
-      default:
-        pixelRatio = 1.0f;
-        break;
-    }
 
-    // Calculate the correct zoom amount
-    // First zoom to full width
-    float newHeight = screenWidth / pixelRatio;
-    if (newHeight > screenHeight)
-    {
-      // Zoom to full height
-      newHeight = screenHeight;
-    }
+      // Calculate the correct zoom amount
+      // First zoom to full width
+      float newHeight = screenWidth / pixelRatio;
+      if (newHeight > screenHeight)
+      {
+        // Zoom to full height
+        newHeight = screenHeight;
+      }
 
-    // Now work out the zoom amount so that no zoom is done
-    zoomAmount = sourceHeight / newHeight;
+      // Now work out the zoom amount so that no zoom is done
+      zoomAmount = sourceHeight / newHeight;
 
-    switch (rotationDegCCW)
-    {
-      case 90:
-      case 270:
+      switch (rotationDegCCW)
       {
-        zoomAmount *= sourceFrameRatio;
-        break;
+        case 90:
+        case 270:
+        {
+          zoomAmount *= sourceFrameRatio;
+          break;
+        }
+        default:
+          break;
       }
-      default:
-        break;
-    }
 
-    break;
-  }
-  default:
-    break;
+      break;
+    }
+    default:
+      break;
   }
 }
 
-void CRenderUtils::CalcNormalRenderRect(const CRect &viewRect,
+void CRenderUtils::CalcNormalRenderRect(const CRect& viewRect,
                                         float outputFrameRatio,
                                         float zoomAmount,
-                                        CRect &destRect)
+                                        CRect& destRect)
 {
   const float offsetX = viewRect.x1;
   const float offsetY = viewRect.y1;
@@ -155,9 +155,7 @@ void CRenderUtils::CalcNormalRenderRect(const CRect &viewRect,
   destRect.y2 = destRect.y1 + MathUtils::round_int(newHeight);
 }
 
-void CRenderUtils::ClipRect(const CRect &viewRect,
-                            CRect &sourceRect,
-                            CRect &destRect)
+void CRenderUtils::ClipRect(const CRect& viewRect, CRect& sourceRect, CRect& destRect)
 {
   const float offsetX = viewRect.x1;
   const float offsetY = viewRect.y1;
@@ -177,47 +175,47 @@ void CRenderUtils::ClipRect(const CRect &viewRect,
   }
 }
 
-std::array<CPoint, 4> CRenderUtils::ReorderDrawPoints(const CRect &destRect,
+std::array<CPoint, 4> CRenderUtils::ReorderDrawPoints(const CRect& destRect,
                                                       unsigned int orientationDegCCW)
 {
   std::array<CPoint, 4> rotatedDestCoords{};
 
   switch (orientationDegCCW)
   {
-  case 0:
-  {
-    rotatedDestCoords[0] = CPoint{ destRect.x1, destRect.y1 }; // Top left
-    rotatedDestCoords[1] = CPoint{ destRect.x2, destRect.y1 }; // Top right
-    rotatedDestCoords[2] = CPoint{ destRect.x2, destRect.y2 }; // Bottom right
-    rotatedDestCoords[3] = CPoint{ destRect.x1, destRect.y2 }; // Bottom left
-    break;
-  }
-  case 90:
-  {
-    rotatedDestCoords[0] = CPoint{ destRect.x1, destRect.y2 }; // Bottom left
-    rotatedDestCoords[1] = CPoint{ destRect.x1, destRect.y1 }; // Top left
-    rotatedDestCoords[2] = CPoint{ destRect.x2, destRect.y1 }; // Top right
-    rotatedDestCoords[3] = CPoint{ destRect.x2, destRect.y2 }; // Bottom right
-    break;
-  }
-  case 180:
-  {
-    rotatedDestCoords[0] = CPoint{ destRect.x2, destRect.y2 }; // Bottom right
-    rotatedDestCoords[1] = CPoint{ destRect.x1, destRect.y2 }; // Bottom left
-    rotatedDestCoords[2] = CPoint{ destRect.x1, destRect.y1 }; // Top left
-    rotatedDestCoords[3] = CPoint{ destRect.x2, destRect.y1 }; // Top right
-    break;
-  }
-  case 270:
-  {
-    rotatedDestCoords[0] = CPoint{ destRect.x2, destRect.y1 }; // Top right
-    rotatedDestCoords[1] = CPoint{ destRect.x2, destRect.y2 }; // Bottom right
-    rotatedDestCoords[2] = CPoint{ destRect.x1, destRect.y2 }; // Bottom left
-    rotatedDestCoords[3] = CPoint{ destRect.x1, destRect.y1 }; // Top left
-    break;
-  }
-  default:
-    break;
+    case 0:
+    {
+      rotatedDestCoords[0] = CPoint{destRect.x1, destRect.y1}; // Top left
+      rotatedDestCoords[1] = CPoint{destRect.x2, destRect.y1}; // Top right
+      rotatedDestCoords[2] = CPoint{destRect.x2, destRect.y2}; // Bottom right
+      rotatedDestCoords[3] = CPoint{destRect.x1, destRect.y2}; // Bottom left
+      break;
+    }
+    case 90:
+    {
+      rotatedDestCoords[0] = CPoint{destRect.x1, destRect.y2}; // Bottom left
+      rotatedDestCoords[1] = CPoint{destRect.x1, destRect.y1}; // Top left
+      rotatedDestCoords[2] = CPoint{destRect.x2, destRect.y1}; // Top right
+      rotatedDestCoords[3] = CPoint{destRect.x2, destRect.y2}; // Bottom right
+      break;
+    }
+    case 180:
+    {
+      rotatedDestCoords[0] = CPoint{destRect.x2, destRect.y2}; // Bottom right
+      rotatedDestCoords[1] = CPoint{destRect.x1, destRect.y2}; // Bottom left
+      rotatedDestCoords[2] = CPoint{destRect.x1, destRect.y1}; // Top left
+      rotatedDestCoords[3] = CPoint{destRect.x2, destRect.y1}; // Top right
+      break;
+    }
+    case 270:
+    {
+      rotatedDestCoords[0] = CPoint{destRect.x2, destRect.y1}; // Top right
+      rotatedDestCoords[1] = CPoint{destRect.x2, destRect.y2}; // Bottom right
+      rotatedDestCoords[2] = CPoint{destRect.x1, destRect.y2}; // Bottom left
+      rotatedDestCoords[3] = CPoint{destRect.x1, destRect.y1}; // Top left
+      break;
+    }
+    default:
+      break;
   }
 
   return rotatedDestCoords;
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderUtils.h b/xbmc/cores/RetroPlayer/rendering/RenderUtils.h
index 49aa9c86f8e3..0976c3e9ca48 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderUtils.h
+++ b/xbmc/cores/RetroPlayer/rendering/RenderUtils.h
@@ -17,29 +17,27 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderUtils
-  {
-  public:
-    static void CalculateStretchMode(STRETCHMODE stretchMode,
-                                     unsigned int rotationDegCCW,
-                                     unsigned int sourceWidth,
-                                     unsigned int sourceHeight,
-                                     float screenWidth,
-                                     float screenHeight,
-                                     float &pixelRatio,
-                                     float &zoomAmount);
+class CRenderUtils
+{
+public:
+  static void CalculateStretchMode(STRETCHMODE stretchMode,
+                                   unsigned int rotationDegCCW,
+                                   unsigned int sourceWidth,
+                                   unsigned int sourceHeight,
+                                   float screenWidth,
+                                   float screenHeight,
+                                   float& pixelRatio,
+                                   float& zoomAmount);
+
+  static void CalcNormalRenderRect(const CRect& viewRect,
+                                   float outputFrameRatio,
+                                   float zoomAmount,
+                                   CRect& destRect);
 
-    static void CalcNormalRenderRect(const CRect &viewRect,
-                                     float outputFrameRatio,
-                                     float zoomAmount,
-                                     CRect &destRect);
-    
-    static void ClipRect(const CRect &viewRect,
-                         CRect &sourceRect,
-                         CRect &destRect);
+  static void ClipRect(const CRect& viewRect, CRect& sourceRect, CRect& destRect);
 
-    static std::array<CPoint, 4> ReorderDrawPoints(const CRect &destRect,
-                                                   unsigned int orientationDegCCW);
-  };
-}
-}
+  static std::array<CPoint, 4> ReorderDrawPoints(const CRect& destRect,
+                                                 unsigned int orientationDegCCW);
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderVideoSettings.cpp b/xbmc/cores/RetroPlayer/rendering/RenderVideoSettings.cpp
index 4e7587271b8b..7e9b14e8a87b 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderVideoSettings.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/RenderVideoSettings.cpp
@@ -11,8 +11,8 @@
 using namespace KODI;
 using namespace RETRO;
 
-#define VIDEO_FILTER_NEAREST  "nearest"
-#define VIDEO_FILTER_LINEAR   "linear"
+#define VIDEO_FILTER_NEAREST "nearest"
+#define VIDEO_FILTER_LINEAR "linear"
 
 void CRenderVideoSettings::Reset()
 {
@@ -21,23 +21,28 @@ void CRenderVideoSettings::Reset()
   m_rotationDegCCW = 0;
 }
 
-bool CRenderVideoSettings::operator==(const CRenderVideoSettings &rhs) const
+bool CRenderVideoSettings::operator==(const CRenderVideoSettings& rhs) const
 {
-  return m_scalingMethod == rhs.m_scalingMethod &&
-         m_stretchMode == rhs.m_stretchMode &&
+  return m_scalingMethod == rhs.m_scalingMethod && m_stretchMode == rhs.m_stretchMode &&
          m_rotationDegCCW == rhs.m_rotationDegCCW;
 }
 
-bool CRenderVideoSettings::operator<(const CRenderVideoSettings &rhs) const
+bool CRenderVideoSettings::operator<(const CRenderVideoSettings& rhs) const
 {
-  if (m_scalingMethod < rhs.m_scalingMethod) return true;
-  if (m_scalingMethod > rhs.m_scalingMethod) return false;
+  if (m_scalingMethod < rhs.m_scalingMethod)
+    return true;
+  if (m_scalingMethod > rhs.m_scalingMethod)
+    return false;
 
-  if (m_stretchMode < rhs.m_stretchMode) return true;
-  if (m_stretchMode > rhs.m_stretchMode) return false;
+  if (m_stretchMode < rhs.m_stretchMode)
+    return true;
+  if (m_stretchMode > rhs.m_stretchMode)
+    return false;
 
-  if (m_rotationDegCCW < rhs.m_rotationDegCCW) return true;
-  if (m_rotationDegCCW > rhs.m_rotationDegCCW) return false;
+  if (m_rotationDegCCW < rhs.m_rotationDegCCW)
+    return true;
+  if (m_rotationDegCCW > rhs.m_rotationDegCCW)
+    return false;
 
   return false;
 }
@@ -46,18 +51,18 @@ std::string CRenderVideoSettings::GetVideoFilter() const
 {
   switch (m_scalingMethod)
   {
-  case SCALINGMETHOD::NEAREST:
-    return VIDEO_FILTER_NEAREST;
-  case SCALINGMETHOD::LINEAR:
-    return VIDEO_FILTER_LINEAR;
-  default:
-    break;
+    case SCALINGMETHOD::NEAREST:
+      return VIDEO_FILTER_NEAREST;
+    case SCALINGMETHOD::LINEAR:
+      return VIDEO_FILTER_LINEAR;
+    default:
+      break;
   }
 
   return "";
 }
 
-void CRenderVideoSettings::SetVideoFilter(const std::string &videoFilter)
+void CRenderVideoSettings::SetVideoFilter(const std::string& videoFilter)
 {
   if (videoFilter == VIDEO_FILTER_NEAREST)
   {
diff --git a/xbmc/cores/RetroPlayer/rendering/RenderVideoSettings.h b/xbmc/cores/RetroPlayer/rendering/RenderVideoSettings.h
index 603721fcf6a4..dc757398946a 100644
--- a/xbmc/cores/RetroPlayer/rendering/RenderVideoSettings.h
+++ b/xbmc/cores/RetroPlayer/rendering/RenderVideoSettings.h
@@ -16,40 +16,40 @@ namespace KODI
 {
 namespace RETRO
 {
+/*!
+ * \brief Video settings provided by the rendering system
+ */
+class CRenderVideoSettings
+{
+public:
+  CRenderVideoSettings() { Reset(); }
+
+  void Reset();
+
+  bool operator==(const CRenderVideoSettings& rhs) const;
+  bool operator!=(const CRenderVideoSettings& rhs) const { return !(*this == rhs); }
+  bool operator<(const CRenderVideoSettings& rhs) const;
+  bool operator>(const CRenderVideoSettings& rhs) const { return !(*this == rhs || *this < rhs); }
+
   /*!
-   * \brief Video settings provided by the rendering system
+   * \brief Get a string representation of the video filter parameters
    */
-  class CRenderVideoSettings
-  {
-  public:
-    CRenderVideoSettings() { Reset(); }
-
-    void Reset();
-
-    bool operator==(const CRenderVideoSettings &rhs) const;
-    bool operator!=(const CRenderVideoSettings &rhs) const { return !(*this == rhs); }
-    bool operator<(const CRenderVideoSettings &rhs) const;
-    bool operator>(const CRenderVideoSettings &rhs) const { return !(*this == rhs || *this < rhs); }
-
-    /*!
-     * \brief Get a string representation of the video filter parameters
-     */
-    std::string GetVideoFilter() const;
-    void SetVideoFilter(const std::string &videoFilter);
-
-    SCALINGMETHOD GetScalingMethod() const { return m_scalingMethod; }
-    void SetScalingMethod(SCALINGMETHOD method) { m_scalingMethod = method; }
-
-    STRETCHMODE GetRenderStretchMode() const { return m_stretchMode; }
-    void SetRenderStretchMode(STRETCHMODE mode) { m_stretchMode = mode; }
-
-    unsigned int GetRenderRotation() const { return m_rotationDegCCW; }
-    void SetRenderRotation(unsigned int rotationDegCCW) { m_rotationDegCCW = rotationDegCCW; }
-
-  private:
-    SCALINGMETHOD m_scalingMethod;
-    STRETCHMODE m_stretchMode;
-    unsigned int m_rotationDegCCW;
-  };
-}
-}
+  std::string GetVideoFilter() const;
+  void SetVideoFilter(const std::string& videoFilter);
+
+  SCALINGMETHOD GetScalingMethod() const { return m_scalingMethod; }
+  void SetScalingMethod(SCALINGMETHOD method) { m_scalingMethod = method; }
+
+  STRETCHMODE GetRenderStretchMode() const { return m_stretchMode; }
+  void SetRenderStretchMode(STRETCHMODE mode) { m_stretchMode = mode; }
+
+  unsigned int GetRenderRotation() const { return m_rotationDegCCW; }
+  void SetRenderRotation(unsigned int rotationDegCCW) { m_rotationDegCCW = rotationDegCCW; }
+
+private:
+  SCALINGMETHOD m_scalingMethod;
+  STRETCHMODE m_stretchMode;
+  unsigned int m_rotationDegCCW;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.cpp b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.cpp
index 80390de0e90e..02b4ea396218 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.cpp
@@ -18,12 +18,12 @@ using namespace KODI;
 using namespace RETRO;
 
 // Consider renderer visible until this many frames have passed without rendering
-#define VISIBLE_DURATION_FRAME_COUNT  1
+#define VISIBLE_DURATION_FRAME_COUNT 1
 
-CRPBaseRenderer::CRPBaseRenderer(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) :
-  m_context(context),
-  m_bufferPool(std::move(bufferPool)),
-  m_renderSettings(renderSettings)
+CRPBaseRenderer::CRPBaseRenderer(const CRenderSettings& renderSettings,
+                                 CRenderContext& context,
+                                 std::shared_ptr<IRenderBufferPool> bufferPool)
+  : m_context(context), m_bufferPool(std::move(bufferPool)), m_renderSettings(renderSettings)
 {
   m_bufferPool->RegisterRenderer(this);
 }
@@ -35,7 +35,7 @@ CRPBaseRenderer::~CRPBaseRenderer()
   m_bufferPool->UnregisterRenderer(this);
 }
 
-bool CRPBaseRenderer::IsCompatible(const CRenderVideoSettings &settings) const
+bool CRPBaseRenderer::IsCompatible(const CRenderVideoSettings& settings) const
 {
   return m_bufferPool->IsCompatible(settings);
 }
@@ -71,7 +71,7 @@ bool CRPBaseRenderer::IsVisible() const
   return m_renderFrameCount <= m_lastRender + VISIBLE_DURATION_FRAME_COUNT;
 }
 
-void CRPBaseRenderer::SetBuffer(IRenderBuffer *buffer)
+void CRPBaseRenderer::SetBuffer(IRenderBuffer* buffer)
 {
   if (m_renderBuffer != buffer)
   {
@@ -121,16 +121,18 @@ void CRPBaseRenderer::SetRenderRotation(unsigned int rotationDegCCW)
   m_renderSettings.VideoSettings().SetRenderRotation(rotationDegCCW);
 }
 
-void CRPBaseRenderer::ManageRenderArea(const IRenderBuffer &renderBuffer)
+void CRPBaseRenderer::ManageRenderArea(const IRenderBuffer& renderBuffer)
 {
   // Get texture parameters
   const unsigned int sourceWidth = renderBuffer.GetWidth();
   const unsigned int sourceHeight = renderBuffer.GetHeight();
   const unsigned int sourceRotationDegCCW = renderBuffer.GetRotation();
-  const float sourceAspectRatio = static_cast<float>(sourceWidth) / static_cast<float>(sourceHeight);
+  const float sourceAspectRatio =
+      static_cast<float>(sourceWidth) / static_cast<float>(sourceHeight);
 
   const STRETCHMODE stretchMode = m_renderSettings.VideoSettings().GetRenderStretchMode();
-  const unsigned int rotationDegCCW = (sourceRotationDegCCW + m_renderSettings.VideoSettings().GetRenderRotation()) % 360;
+  const unsigned int rotationDegCCW =
+      (sourceRotationDegCCW + m_renderSettings.VideoSettings().GetRenderRotation()) % 360;
 
   // Get screen parameters
   float screenWidth;
@@ -144,20 +146,12 @@ void CRPBaseRenderer::ManageRenderArea(const IRenderBuffer &renderBuffer)
   // Calculate pixel ratio and zoom amount
   float pixelRatio = 1.0f;
   float zoomAmount = 1.0f;
-  CRenderUtils::CalculateStretchMode(stretchMode,
-                                     rotationDegCCW,
-                                     sourceWidth,
-                                     sourceHeight,
-                                     screenWidth,
-                                     screenHeight,
-                                     pixelRatio,
-                                     zoomAmount);
+  CRenderUtils::CalculateStretchMode(stretchMode, rotationDegCCW, sourceWidth, sourceHeight,
+                                     screenWidth, screenHeight, pixelRatio, zoomAmount);
 
   // Calculate destination dimensions
   CRect destRect;
-  CRenderUtils::CalcNormalRenderRect(viewRect,
-                                     sourceAspectRatio * pixelRatio,
-                                     zoomAmount,
+  CRenderUtils::CalcNormalRenderRect(viewRect, sourceAspectRatio * pixelRatio, zoomAmount,
                                      destRect);
 
   m_sourceRect.x1 = 0.0f;
@@ -175,7 +169,7 @@ void CRPBaseRenderer::ManageRenderArea(const IRenderBuffer &renderBuffer)
 
 void CRPBaseRenderer::MarkDirty()
 {
-  //CServiceBroker::GetGUI()->GetWindowManager().MarkDirty(m_dimensions); //! @todo
+  // CServiceBroker::GetGUI()->GetWindowManager().MarkDirty(m_dimensions); //! @todo
 }
 
 void CRPBaseRenderer::PreRender(bool clear)
@@ -193,7 +187,9 @@ void CRPBaseRenderer::PostRender()
   m_context.ApplyStateBlock();
 }
 
-void CRPBaseRenderer::GetScreenDimensions(float &screenWidth, float &screenHeight, float &screenPixelRatio)
+void CRPBaseRenderer::GetScreenDimensions(float& screenWidth,
+                                          float& screenHeight,
+                                          float& screenPixelRatio)
 {
   // Get our calibrated full screen resolution
   RESOLUTION_INFO info = m_context.GetResInfo();
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.h b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.h
index 129f0996dc67..9f41ca790b3c 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.h
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPBaseRenderer.h
@@ -8,11 +8,12 @@
 
 #pragma once
 
-#include "cores/RetroPlayer/rendering/RenderSettings.h"
 #include "cores/GameSettings.h"
+#include "cores/RetroPlayer/rendering/RenderSettings.h"
 #include "utils/Geometry.h"
 
-extern "C" {
+extern "C"
+{
 #include <libavutil/pixfmt.h>
 }
 
@@ -24,89 +25,91 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
-  class IRenderBuffer;
-  class IRenderBufferPool;
-
-  class CRPBaseRenderer
-  {
-  public:
-    CRPBaseRenderer(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool);
-    virtual ~CRPBaseRenderer();
-
-    /*!
-     * \brief Get the buffer pool used by this renderer
-     */
-    IRenderBufferPool *GetBufferPool() { return m_bufferPool.get(); }
-
-    // Player functions
-    bool Configure(AVPixelFormat format);
-    void FrameMove();
-    /*!
-     * \brief Performs whatever necessary before rendering the frame
-     */
-    void PreRender(bool clear);
-    void SetBuffer(IRenderBuffer *buffer);
-    void RenderFrame(bool clear, uint8_t alpha);
-
-    // Feature support
-    virtual bool Supports(RENDERFEATURE feature) const = 0;
-    bool IsCompatible(const CRenderVideoSettings &settings) const;
-    virtual SCALINGMETHOD GetDefaultScalingMethod() const = 0;
-
-    // Public renderer interface
-    virtual void Flush();
-
-    // Get render settings
-    const CRenderSettings &GetRenderSettings() const { return m_renderSettings; }
-
-    // Set render settings
-    void SetScalingMethod(SCALINGMETHOD method);
-    void SetStretchMode(STRETCHMODE stretchMode);
-    void SetRenderRotation(unsigned int rotationDegCCW);
-
-    bool IsVisible() const;
-
-  protected:
-    // Protected renderer interface
-    virtual bool ConfigureInternal() { return true; }
-    virtual void RenderInternal(bool clear, uint8_t alpha) = 0;
-    virtual void FlushInternal() { }
-
-    // Construction parameters
-    CRenderContext &m_context;
-    std::shared_ptr<IRenderBufferPool> m_bufferPool;
-
-    // Stream properties
-    bool m_bConfigured = false;
-    AVPixelFormat m_format = AV_PIX_FMT_NONE;
-
-    // Rendering properties
-    CRenderSettings m_renderSettings;
-    IRenderBuffer *m_renderBuffer = nullptr;
-
-    // Geometry properties
-    CRect m_sourceRect;
-    std::array<CPoint, 4> m_rotatedDestCoords{};
-
-  private:
-    /*!
-     * \brief Calculate driven dimensions
-     */
-    virtual void ManageRenderArea(const IRenderBuffer &renderBuffer);
-
-    /*!
-     * \brief Performs whatever nessesary after a frame has been rendered
-     */
-    void PostRender();
-
-    void MarkDirty();
-
-    // Utility functions
-    void GetScreenDimensions(float &screenWidth, float &screenHeight, float &screenPixelRatio);
-
-    uint64_t m_renderFrameCount = 0;
-    uint64_t m_lastRender = 0;
-  };
-}
-}
+class CRenderContext;
+class IRenderBuffer;
+class IRenderBufferPool;
+
+class CRPBaseRenderer
+{
+public:
+  CRPBaseRenderer(const CRenderSettings& renderSettings,
+                  CRenderContext& context,
+                  std::shared_ptr<IRenderBufferPool> bufferPool);
+  virtual ~CRPBaseRenderer();
+
+  /*!
+   * \brief Get the buffer pool used by this renderer
+   */
+  IRenderBufferPool* GetBufferPool() { return m_bufferPool.get(); }
+
+  // Player functions
+  bool Configure(AVPixelFormat format);
+  void FrameMove();
+  /*!
+   * \brief Performs whatever necessary before rendering the frame
+   */
+  void PreRender(bool clear);
+  void SetBuffer(IRenderBuffer* buffer);
+  void RenderFrame(bool clear, uint8_t alpha);
+
+  // Feature support
+  virtual bool Supports(RENDERFEATURE feature) const = 0;
+  bool IsCompatible(const CRenderVideoSettings& settings) const;
+  virtual SCALINGMETHOD GetDefaultScalingMethod() const = 0;
+
+  // Public renderer interface
+  virtual void Flush();
+
+  // Get render settings
+  const CRenderSettings& GetRenderSettings() const { return m_renderSettings; }
+
+  // Set render settings
+  void SetScalingMethod(SCALINGMETHOD method);
+  void SetStretchMode(STRETCHMODE stretchMode);
+  void SetRenderRotation(unsigned int rotationDegCCW);
+
+  bool IsVisible() const;
+
+protected:
+  // Protected renderer interface
+  virtual bool ConfigureInternal() { return true; }
+  virtual void RenderInternal(bool clear, uint8_t alpha) = 0;
+  virtual void FlushInternal() {}
+
+  // Construction parameters
+  CRenderContext& m_context;
+  std::shared_ptr<IRenderBufferPool> m_bufferPool;
+
+  // Stream properties
+  bool m_bConfigured = false;
+  AVPixelFormat m_format = AV_PIX_FMT_NONE;
+
+  // Rendering properties
+  CRenderSettings m_renderSettings;
+  IRenderBuffer* m_renderBuffer = nullptr;
+
+  // Geometry properties
+  CRect m_sourceRect;
+  std::array<CPoint, 4> m_rotatedDestCoords{};
+
+private:
+  /*!
+   * \brief Calculate driven dimensions
+   */
+  virtual void ManageRenderArea(const IRenderBuffer& renderBuffer);
+
+  /*!
+   * \brief Performs whatever nessesary after a frame has been rendered
+   */
+  void PostRender();
+
+  void MarkDirty();
+
+  // Utility functions
+  void GetScreenDimensions(float& screenWidth, float& screenHeight, float& screenPixelRatio);
+
+  uint64_t m_renderFrameCount = 0;
+  uint64_t m_lastRender = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererDMA.cpp b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererDMA.cpp
index 605f54fbe55f..8c971ffa4f2d 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererDMA.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererDMA.cpp
@@ -107,18 +107,21 @@ void CRPRendererDMA::Render(uint8_t alpha)
   vertex[2].v1 = vertex[3].v1 = rect.y2;
 
   glBindBuffer(GL_ARRAY_BUFFER, m_mainVertexVBO);
-  glBufferData(GL_ARRAY_BUFFER, sizeof(PackedVertex)*4, &vertex[0], GL_STATIC_DRAW);
+  glBufferData(GL_ARRAY_BUFFER, sizeof(PackedVertex) * 4, &vertex[0], GL_STATIC_DRAW);
 
-  glVertexAttribPointer(vertLoc, 3, GL_FLOAT, 0, sizeof(PackedVertex), reinterpret_cast<const GLuint*>(offsetof(PackedVertex, x)));
-  glVertexAttribPointer(loc, 2, GL_FLOAT, 0, sizeof(PackedVertex), reinterpret_cast<const GLuint*>(offsetof(PackedVertex, u1)));
+  glVertexAttribPointer(vertLoc, 3, GL_FLOAT, 0, sizeof(PackedVertex),
+                        reinterpret_cast<const GLuint*>(offsetof(PackedVertex, x)));
+  glVertexAttribPointer(loc, 2, GL_FLOAT, 0, sizeof(PackedVertex),
+                        reinterpret_cast<const GLuint*>(offsetof(PackedVertex, u1)));
 
   glEnableVertexAttribArray(vertLoc);
   glEnableVertexAttribArray(loc);
 
   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_mainIndexVBO);
-  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLubyte)*4, idx, GL_STATIC_DRAW);
+  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLubyte) * 4, idx, GL_STATIC_DRAW);
 
-  glUniform4f(uniColLoc,(colour[0] / 255.0f), (colour[1] / 255.0f), (colour[2] / 255.0f), (colour[3] / 255.0f));
+  glUniform4f(uniColLoc, (colour[0] / 255.0f), (colour[1] / 255.0f), (colour[2] / 255.0f),
+              (colour[3] / 255.0f));
   glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, 0);
 
   glDisableVertexAttribArray(vertLoc);
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererDMA.h b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererDMA.h
index bcdd6995cffa..38d7baeb874d 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererDMA.h
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererDMA.h
@@ -27,27 +27,27 @@ class CRendererFactoryDMA : public IRendererFactory
                                   CRenderContext& context,
                                   std::shared_ptr<IRenderBufferPool> bufferPool) override;
   RenderBufferPoolVector CreateBufferPools(CRenderContext& context) override;
-  };
+};
 
-  /**
-   * @brief Special CRPBaseRenderer implementation to handle Direct Memory
-   *        Access (DMA) buffer types. For specific use with
-   *        CRenderBufferPoolDMA and CRenderBufferDMA. A windowing system
-   *        must register use of this renderer and register at least one
-   *        CBufferObject types.
-   *
-   */
-  class CRPRendererDMA : public CRPRendererOpenGLES
-  {
-  public:
-    CRPRendererDMA(const CRenderSettings& renderSettings,
-                   CRenderContext& context,
-                   std::shared_ptr<IRenderBufferPool> bufferPool);
-    ~CRPRendererDMA() override = default;
+/**
+ * @brief Special CRPBaseRenderer implementation to handle Direct Memory
+ *        Access (DMA) buffer types. For specific use with
+ *        CRenderBufferPoolDMA and CRenderBufferDMA. A windowing system
+ *        must register use of this renderer and register at least one
+ *        CBufferObject types.
+ *
+ */
+class CRPRendererDMA : public CRPRendererOpenGLES
+{
+public:
+  CRPRendererDMA(const CRenderSettings& renderSettings,
+                 CRenderContext& context,
+                 std::shared_ptr<IRenderBufferPool> bufferPool);
+  ~CRPRendererDMA() override = default;
 
-  protected:
-    // implementation of CRPRendererOpenGLES
-    void Render(uint8_t alpha) override;
-  };
-}
-}
+protected:
+  // implementation of CRPRendererOpenGLES
+  void Render(uint8_t alpha) override;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererGuiTexture.cpp b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererGuiTexture.cpp
index 80bf61a468c5..d9aad673f44a 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererGuiTexture.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererGuiTexture.cpp
@@ -7,12 +7,14 @@
  */
 
 #include "RPRendererGuiTexture.h"
+
 #include "cores/RetroPlayer/buffers/video/RenderBufferGuiTexture.h"
 #include "cores/RetroPlayer/rendering/RenderContext.h"
 #include "cores/RetroPlayer/rendering/RenderVideoSettings.h"
 
 #if defined(HAS_DX)
 #include "guilib/GUIShaderDX.h"
+
 #include <DirectXMath.h>
 using namespace DirectX;
 #endif
@@ -31,56 +33,60 @@ std::string CRendererFactoryGuiTexture::RenderSystemName() const
   return "GUITexture";
 }
 
-CRPBaseRenderer *CRendererFactoryGuiTexture::CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool)
+CRPBaseRenderer* CRendererFactoryGuiTexture::CreateRenderer(
+    const CRenderSettings& settings,
+    CRenderContext& context,
+    std::shared_ptr<IRenderBufferPool> bufferPool)
 {
   return new CRPRendererGuiTexture(settings, context, std::move(bufferPool));
 }
 
-RenderBufferPoolVector CRendererFactoryGuiTexture::CreateBufferPools(CRenderContext &context)
+RenderBufferPoolVector CRendererFactoryGuiTexture::CreateBufferPools(CRenderContext& context)
 {
-  return {
+  return
+  {
 #if !defined(HAS_DX)
     std::make_shared<CRenderBufferPoolGuiTexture>(SCALINGMETHOD::NEAREST),
 #endif
-    std::make_shared<CRenderBufferPoolGuiTexture>(SCALINGMETHOD::LINEAR),
+        std::make_shared<CRenderBufferPoolGuiTexture>(SCALINGMETHOD::LINEAR),
   };
 }
 
 // --- CRenderBufferPoolGuiTexture -----------------------------------------------
 
-CRenderBufferPoolGuiTexture::CRenderBufferPoolGuiTexture(SCALINGMETHOD scalingMethod) :
-  m_scalingMethod(scalingMethod)
+CRenderBufferPoolGuiTexture::CRenderBufferPoolGuiTexture(SCALINGMETHOD scalingMethod)
+  : m_scalingMethod(scalingMethod)
 {
 }
 
-bool CRenderBufferPoolGuiTexture::IsCompatible(const CRenderVideoSettings &renderSettings) const
+bool CRenderBufferPoolGuiTexture::IsCompatible(const CRenderVideoSettings& renderSettings) const
 {
   return renderSettings.GetScalingMethod() == m_scalingMethod;
 }
 
-IRenderBuffer *CRenderBufferPoolGuiTexture::CreateRenderBuffer(void *header /* = nullptr */)
+IRenderBuffer* CRenderBufferPoolGuiTexture::CreateRenderBuffer(void* header /* = nullptr */)
 {
   return new CRenderBufferGuiTexture(m_scalingMethod);
 }
 
 // --- CRPRendererGuiTexture -----------------------------------------------------
 
-CRPRendererGuiTexture::CRPRendererGuiTexture(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) :
-  CRPBaseRenderer(renderSettings, context, std::move(bufferPool))
+CRPRendererGuiTexture::CRPRendererGuiTexture(const CRenderSettings& renderSettings,
+                                             CRenderContext& context,
+                                             std::shared_ptr<IRenderBufferPool> bufferPool)
+  : CRPBaseRenderer(renderSettings, context, std::move(bufferPool))
 {
 }
 
 bool CRPRendererGuiTexture::Supports(RENDERFEATURE feature) const
 {
-  return feature == RENDERFEATURE::STRETCH         ||
-         feature == RENDERFEATURE::ZOOM            ||
-         feature == RENDERFEATURE::PIXEL_RATIO     ||
-         feature == RENDERFEATURE::ROTATION;
+  return feature == RENDERFEATURE::STRETCH || feature == RENDERFEATURE::ZOOM ||
+         feature == RENDERFEATURE::PIXEL_RATIO || feature == RENDERFEATURE::ROTATION;
 }
 
 void CRPRendererGuiTexture::RenderInternal(bool clear, uint8_t alpha)
 {
-  CRenderBufferGuiTexture *renderBuffer = static_cast<CRenderBufferGuiTexture*>(m_renderBuffer);
+  CRenderBufferGuiTexture* renderBuffer = static_cast<CRenderBufferGuiTexture*>(m_renderBuffer);
 
   CRect rect = m_sourceRect;
 
@@ -114,14 +120,14 @@ void CRPRendererGuiTexture::RenderInternal(bool clear, uint8_t alpha)
 
   vertex[4] = vertex[0]; // Not used when renderBuffer != nullptr
 
-  CGUIShaderDX *pGUIShader = m_context.GetGUIShader();
+  CGUIShaderDX* pGUIShader = m_context.GetGUIShader();
   if (pGUIShader != nullptr)
   {
     pGUIShader->Begin(SHADER_METHOD_RENDER_TEXTURE_BLEND);
 
     // Set state to render the image
-    CTexture *dxTexture = renderBuffer->GetTexture();
-    ID3D11ShaderResourceView *shaderRes = dxTexture->GetShaderResource();
+    CTexture* dxTexture = renderBuffer->GetTexture();
+    ID3D11ShaderResourceView* shaderRes = dxTexture->GetShaderResource();
     pGUIShader->SetShaderViews(1, &shaderRes);
     pGUIShader->DrawQuad(vertex[0], vertex[1], vertex[2], vertex[3]);
   }
@@ -178,8 +184,10 @@ void CRPRendererGuiTexture::RenderInternal(bool clear, uint8_t alpha)
   glBindBuffer(GL_ARRAY_BUFFER, vertexVBO);
   glBufferData(GL_ARRAY_BUFFER, sizeof(PackedVertex) * 4, &vertex[0], GL_STATIC_DRAW);
 
-  glVertexAttribPointer(posLoc, 3, GL_FLOAT, 0, sizeof(PackedVertex), BUFFER_OFFSET(offsetof(PackedVertex, x)));
-  glVertexAttribPointer(tex0Loc, 2, GL_FLOAT, 0, sizeof(PackedVertex), BUFFER_OFFSET(offsetof(PackedVertex, u1)));
+  glVertexAttribPointer(posLoc, 3, GL_FLOAT, 0, sizeof(PackedVertex),
+                        BUFFER_OFFSET(offsetof(PackedVertex, x)));
+  glVertexAttribPointer(tex0Loc, 2, GL_FLOAT, 0, sizeof(PackedVertex),
+                        BUFFER_OFFSET(offsetof(PackedVertex, u1)));
 
   glEnableVertexAttribArray(posLoc);
   glEnableVertexAttribArray(tex0Loc);
@@ -197,8 +205,8 @@ void CRPRendererGuiTexture::RenderInternal(bool clear, uint8_t alpha)
     colour[2] = (235 - 16) * colour[2] / 255 + 16;
   }
 
-  glUniform4f(uniColLoc, (colour[0] / 255.0f), (colour[1] / 255.0f),
-                         (colour[2] / 255.0f), (colour[3] / 255.0f));
+  glUniform4f(uniColLoc, (colour[0] / 255.0f), (colour[1] / 255.0f), (colour[2] / 255.0f),
+              (colour[3] / 255.0f));
 
   glGenBuffers(1, &indexVBO);
   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexVBO);
@@ -220,7 +228,7 @@ void CRPRendererGuiTexture::RenderInternal(bool clear, uint8_t alpha)
 
   renderBuffer->BindToUnit(0);
 
-  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_BLEND); // Turn blending On
 
   m_context.EnableGUIShader(GL_SHADER_METHOD::TEXTURE);
@@ -260,7 +268,8 @@ void CRPRendererGuiTexture::RenderInternal(bool clear, uint8_t alpha)
   tex[1][0] = tex[2][0] = u2;
   tex[2][1] = tex[3][1] = v2;
 
-  glUniform4f(uniColLoc,(col[0] / 255.0f), (col[1] / 255.0f), (col[2] / 255.0f), (col[3] / 255.0f));
+  glUniform4f(uniColLoc, (col[0] / 255.0f), (col[1] / 255.0f), (col[2] / 255.0f),
+              (col[3] / 255.0f));
   glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
 
   glDisableVertexAttribArray(posLoc);
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererGuiTexture.h b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererGuiTexture.h
index 83cd204730a0..8441a675e683 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererGuiTexture.h
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererGuiTexture.h
@@ -17,46 +17,50 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRendererFactoryGuiTexture : public IRendererFactory
-  {
-  public:
-    ~CRendererFactoryGuiTexture() override = default;
-
-    // implementation of IRendererFactory
-    std::string RenderSystemName() const override;
-    CRPBaseRenderer *CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) override;
-    RenderBufferPoolVector CreateBufferPools(CRenderContext &context) override;
-  };
-
-  class CRenderBufferPoolGuiTexture : public CBaseRenderBufferPool
-  {
-  public:
-    CRenderBufferPoolGuiTexture(SCALINGMETHOD scalingMethod);
-    ~CRenderBufferPoolGuiTexture() override = default;
-
-    // implementation of IRenderBufferPool via CBaseRenderBufferPool
-    bool IsCompatible(const CRenderVideoSettings &renderSettings) const override;
-
-    // implementation of CBaseRenderBufferPool
-    IRenderBuffer *CreateRenderBuffer(void *header = nullptr) override;
-
-  private:
-    SCALINGMETHOD m_scalingMethod;
-  };
-
-  class CRPRendererGuiTexture : public CRPBaseRenderer
-  {
-  public:
-    CRPRendererGuiTexture(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool);
-    ~CRPRendererGuiTexture() override = default;
-
-    // public implementation of CRPBaseRenderer
-    bool Supports(RENDERFEATURE feature) const override;
-    SCALINGMETHOD GetDefaultScalingMethod() const override { return SCALINGMETHOD::NEAREST; }
-
-  protected:
-    // protected implementation of CRPBaseRenderer
-    void RenderInternal(bool clear, uint8_t alpha) override;
-  };
-}
-}
+class CRendererFactoryGuiTexture : public IRendererFactory
+{
+public:
+  ~CRendererFactoryGuiTexture() override = default;
+
+  // implementation of IRendererFactory
+  std::string RenderSystemName() const override;
+  CRPBaseRenderer* CreateRenderer(const CRenderSettings& settings,
+                                  CRenderContext& context,
+                                  std::shared_ptr<IRenderBufferPool> bufferPool) override;
+  RenderBufferPoolVector CreateBufferPools(CRenderContext& context) override;
+};
+
+class CRenderBufferPoolGuiTexture : public CBaseRenderBufferPool
+{
+public:
+  CRenderBufferPoolGuiTexture(SCALINGMETHOD scalingMethod);
+  ~CRenderBufferPoolGuiTexture() override = default;
+
+  // implementation of IRenderBufferPool via CBaseRenderBufferPool
+  bool IsCompatible(const CRenderVideoSettings& renderSettings) const override;
+
+  // implementation of CBaseRenderBufferPool
+  IRenderBuffer* CreateRenderBuffer(void* header = nullptr) override;
+
+private:
+  SCALINGMETHOD m_scalingMethod;
+};
+
+class CRPRendererGuiTexture : public CRPBaseRenderer
+{
+public:
+  CRPRendererGuiTexture(const CRenderSettings& renderSettings,
+                        CRenderContext& context,
+                        std::shared_ptr<IRenderBufferPool> bufferPool);
+  ~CRPRendererGuiTexture() override = default;
+
+  // public implementation of CRPBaseRenderer
+  bool Supports(RENDERFEATURE feature) const override;
+  SCALINGMETHOD GetDefaultScalingMethod() const override { return SCALINGMETHOD::NEAREST; }
+
+protected:
+  // protected implementation of CRPBaseRenderer
+  void RenderInternal(bool clear, uint8_t alpha) override;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.cpp b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.cpp
index 8fc17a1a29ce..c1cd9099330c 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.cpp
@@ -13,7 +13,7 @@
 #include "cores/RetroPlayer/rendering/RenderContext.h"
 #include "utils/log.h"
 
-#define BUFFER_OFFSET(i) (static_cast<char *>(NULL) + (i))
+#define BUFFER_OFFSET(i) (static_cast<char*>(NULL) + (i))
 
 using namespace KODI;
 using namespace RETRO;
@@ -25,20 +25,25 @@ std::string CRendererFactoryOpenGL::RenderSystemName() const
   return "OpenGL";
 }
 
-CRPBaseRenderer *CRendererFactoryOpenGL::CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool)
+CRPBaseRenderer* CRendererFactoryOpenGL::CreateRenderer(
+    const CRenderSettings& settings,
+    CRenderContext& context,
+    std::shared_ptr<IRenderBufferPool> bufferPool)
 {
   return new CRPRendererOpenGL(settings, context, std::move(bufferPool));
 }
 
-RenderBufferPoolVector CRendererFactoryOpenGL::CreateBufferPools(CRenderContext &context)
+RenderBufferPoolVector CRendererFactoryOpenGL::CreateBufferPools(CRenderContext& context)
 {
-  return { std::make_shared<CRenderBufferPoolOpenGL>() };
+  return {std::make_shared<CRenderBufferPoolOpenGL>()};
 }
 
 // --- CRPRendererOpenGL -------------------------------------------------------
 
-CRPRendererOpenGL::CRPRendererOpenGL(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) :
-  CRPBaseRenderer(renderSettings, context, std::move(bufferPool))
+CRPRendererOpenGL::CRPRendererOpenGL(const CRenderSettings& renderSettings,
+                                     CRenderContext& context,
+                                     std::shared_ptr<IRenderBufferPool> bufferPool)
+  : CRPBaseRenderer(renderSettings, context, std::move(bufferPool))
 {
   // Initialize CRPRendererOpenGL
   m_clearColour = m_context.UseLimitedColor() ? (16.0f / 0xff) : 0.0f;
@@ -58,9 +63,11 @@ CRPRendererOpenGL::CRPRendererOpenGL(const CRenderSettings &renderSettings, CRen
   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_mainIndexVBO);
   glBindBuffer(GL_ARRAY_BUFFER, m_mainVertexVBO);
   glEnableVertexAttribArray(vertLoc);
-  glVertexAttribPointer(vertLoc, 3, GL_FLOAT, 0, sizeof(PackedVertex), BUFFER_OFFSET(offsetof(PackedVertex, x)));
+  glVertexAttribPointer(vertLoc, 3, GL_FLOAT, 0, sizeof(PackedVertex),
+                        BUFFER_OFFSET(offsetof(PackedVertex, x)));
   glEnableVertexAttribArray(loc);
-  glVertexAttribPointer(loc, 2, GL_FLOAT, 0, sizeof(PackedVertex), BUFFER_OFFSET(offsetof(PackedVertex, u1)));
+  glVertexAttribPointer(loc, 2, GL_FLOAT, 0, sizeof(PackedVertex),
+                        BUFFER_OFFSET(offsetof(PackedVertex, u1)));
 
   // Set up black bars VAO/VBO
   glGenVertexArrays(1, &m_blackbarsVAO);
@@ -128,16 +135,13 @@ void CRPRendererOpenGL::FlushInternal()
 
 bool CRPRendererOpenGL::Supports(RENDERFEATURE feature) const
 {
-  return feature == RENDERFEATURE::STRETCH         ||
-         feature == RENDERFEATURE::ZOOM            ||
-         feature == RENDERFEATURE::PIXEL_RATIO     ||
-         feature == RENDERFEATURE::ROTATION;
+  return feature == RENDERFEATURE::STRETCH || feature == RENDERFEATURE::ZOOM ||
+         feature == RENDERFEATURE::PIXEL_RATIO || feature == RENDERFEATURE::ROTATION;
 }
 
 bool CRPRendererOpenGL::SupportsScalingMethod(SCALINGMETHOD method)
 {
-  return method == SCALINGMETHOD::NEAREST ||
-         method == SCALINGMETHOD::LINEAR;
+  return method == SCALINGMETHOD::NEAREST || method == SCALINGMETHOD::LINEAR;
 }
 
 void CRPRendererOpenGL::ClearBackBuffer()
@@ -159,94 +163,94 @@ void CRPRendererOpenGL::DrawBlackBars()
 
   glUniform4f(uniCol, m_clearColour / 255.0f, m_clearColour / 255.0f, m_clearColour / 255.0f, 1.0f);
 
-  //top quad
+  // top quad
   if (m_rotatedDestCoords[0].y > 0.0)
   {
     GLubyte quad = count;
     vertices[quad].x = 0.0;
     vertices[quad].y = 0.0;
     vertices[quad].z = 0;
-    vertices[quad+1].x = m_context.GetScreenWidth();
-    vertices[quad+1].y = 0;
-    vertices[quad+1].z = 0;
-    vertices[quad+2].x = m_context.GetScreenWidth();
-    vertices[quad+2].y = m_rotatedDestCoords[0].y;
-    vertices[quad+2].z = 0;
-    vertices[quad+3] = vertices[quad+2];
-    vertices[quad+4].x = 0;
-    vertices[quad+4].y = m_rotatedDestCoords[0].y;
-    vertices[quad+4].z = 0;
-    vertices[quad+5] = vertices[quad];
+    vertices[quad + 1].x = m_context.GetScreenWidth();
+    vertices[quad + 1].y = 0;
+    vertices[quad + 1].z = 0;
+    vertices[quad + 2].x = m_context.GetScreenWidth();
+    vertices[quad + 2].y = m_rotatedDestCoords[0].y;
+    vertices[quad + 2].z = 0;
+    vertices[quad + 3] = vertices[quad + 2];
+    vertices[quad + 4].x = 0;
+    vertices[quad + 4].y = m_rotatedDestCoords[0].y;
+    vertices[quad + 4].z = 0;
+    vertices[quad + 5] = vertices[quad];
     count += 6;
   }
 
-  //bottom quad
+  // bottom quad
   if (m_rotatedDestCoords[2].y < m_context.GetScreenHeight())
   {
     GLubyte quad = count;
     vertices[quad].x = 0.0;
     vertices[quad].y = m_rotatedDestCoords[2].y;
     vertices[quad].z = 0;
-    vertices[quad+1].x = m_context.GetScreenWidth();
-    vertices[quad+1].y = m_rotatedDestCoords[2].y;
-    vertices[quad+1].z = 0;
-    vertices[quad+2].x = m_context.GetScreenWidth();
-    vertices[quad+2].y = m_context.GetScreenHeight();
-    vertices[quad+2].z = 0;
-    vertices[quad+3] = vertices[quad+2];
-    vertices[quad+4].x = 0;
-    vertices[quad+4].y = m_context.GetScreenHeight();
-    vertices[quad+4].z = 0;
-    vertices[quad+5] = vertices[quad];
+    vertices[quad + 1].x = m_context.GetScreenWidth();
+    vertices[quad + 1].y = m_rotatedDestCoords[2].y;
+    vertices[quad + 1].z = 0;
+    vertices[quad + 2].x = m_context.GetScreenWidth();
+    vertices[quad + 2].y = m_context.GetScreenHeight();
+    vertices[quad + 2].z = 0;
+    vertices[quad + 3] = vertices[quad + 2];
+    vertices[quad + 4].x = 0;
+    vertices[quad + 4].y = m_context.GetScreenHeight();
+    vertices[quad + 4].z = 0;
+    vertices[quad + 5] = vertices[quad];
     count += 6;
   }
 
-  //left quad
+  // left quad
   if (m_rotatedDestCoords[0].x > 0.0)
   {
     GLubyte quad = count;
     vertices[quad].x = 0.0;
     vertices[quad].y = m_rotatedDestCoords[0].y;
     vertices[quad].z = 0;
-    vertices[quad+1].x = m_rotatedDestCoords[0].x;
-    vertices[quad+1].y = m_rotatedDestCoords[0].y;
-    vertices[quad+1].z = 0;
-    vertices[quad+2].x = m_rotatedDestCoords[3].x;
-    vertices[quad+2].y = m_rotatedDestCoords[3].y;
-    vertices[quad+2].z = 0;
-    vertices[quad+3] = vertices[quad+2];
-    vertices[quad+4].x = 0;
-    vertices[quad+4].y = m_rotatedDestCoords[3].y;
-    vertices[quad+4].z = 0;
-    vertices[quad+5] = vertices[quad];
+    vertices[quad + 1].x = m_rotatedDestCoords[0].x;
+    vertices[quad + 1].y = m_rotatedDestCoords[0].y;
+    vertices[quad + 1].z = 0;
+    vertices[quad + 2].x = m_rotatedDestCoords[3].x;
+    vertices[quad + 2].y = m_rotatedDestCoords[3].y;
+    vertices[quad + 2].z = 0;
+    vertices[quad + 3] = vertices[quad + 2];
+    vertices[quad + 4].x = 0;
+    vertices[quad + 4].y = m_rotatedDestCoords[3].y;
+    vertices[quad + 4].z = 0;
+    vertices[quad + 5] = vertices[quad];
     count += 6;
   }
 
-  //right quad
+  // right quad
   if (m_rotatedDestCoords[2].x < m_context.GetScreenWidth())
   {
     GLubyte quad = count;
     vertices[quad].x = m_rotatedDestCoords[1].x;
     vertices[quad].y = m_rotatedDestCoords[1].y;
     vertices[quad].z = 0;
-    vertices[quad+1].x = m_context.GetScreenWidth();
-    vertices[quad+1].y = m_rotatedDestCoords[1].y;
-    vertices[quad+1].z = 0;
-    vertices[quad+2].x = m_context.GetScreenWidth();
-    vertices[quad+2].y = m_rotatedDestCoords[2].y;
-    vertices[quad+2].z = 0;
-    vertices[quad+3] = vertices[quad+2];
-    vertices[quad+4].x = m_rotatedDestCoords[1].x;
-    vertices[quad+4].y = m_rotatedDestCoords[2].y;
-    vertices[quad+4].z = 0;
-    vertices[quad+5] = vertices[quad];
+    vertices[quad + 1].x = m_context.GetScreenWidth();
+    vertices[quad + 1].y = m_rotatedDestCoords[1].y;
+    vertices[quad + 1].z = 0;
+    vertices[quad + 2].x = m_context.GetScreenWidth();
+    vertices[quad + 2].y = m_rotatedDestCoords[2].y;
+    vertices[quad + 2].z = 0;
+    vertices[quad + 3] = vertices[quad + 2];
+    vertices[quad + 4].x = m_rotatedDestCoords[1].x;
+    vertices[quad + 4].y = m_rotatedDestCoords[2].y;
+    vertices[quad + 4].z = 0;
+    vertices[quad + 5] = vertices[quad];
     count += 6;
   }
 
   glBindVertexArray(m_blackbarsVAO);
 
   glBindBuffer(GL_ARRAY_BUFFER, m_blackbarsVertexVBO);
-  glBufferData(GL_ARRAY_BUFFER, sizeof(Svertex)*count, &vertices[0], GL_STATIC_DRAW);
+  glBufferData(GL_ARRAY_BUFFER, sizeof(Svertex) * count, &vertices[0], GL_STATIC_DRAW);
 
   glDrawArrays(GL_TRIANGLES, 0, count);
 
@@ -259,7 +263,7 @@ void CRPRendererOpenGL::DrawBlackBars()
 
 void CRPRendererOpenGL::Render(uint8_t alpha)
 {
-  CRenderBufferOpenGL *renderBuffer = static_cast<CRenderBufferOpenGL*>(m_renderBuffer);
+  CRenderBufferOpenGL* renderBuffer = static_cast<CRenderBufferOpenGL*>(m_renderBuffer);
 
   if (renderBuffer == nullptr)
     return;
@@ -312,14 +316,15 @@ void CRPRendererOpenGL::Render(uint8_t alpha)
   vertex[2].v1 = vertex[3].v1 = rect.y2;
 
   glBindVertexArray(m_mainVAO);
-  
+
   glBindBuffer(GL_ARRAY_BUFFER, m_mainVertexVBO);
-  glBufferData(GL_ARRAY_BUFFER, sizeof(PackedVertex)*4, &vertex[0], GL_STATIC_DRAW);
+  glBufferData(GL_ARRAY_BUFFER, sizeof(PackedVertex) * 4, &vertex[0], GL_STATIC_DRAW);
 
   // No need to bind the index VBO, it's part of VAO state
-  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLubyte)*4, idx, GL_STATIC_DRAW);
+  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLubyte) * 4, idx, GL_STATIC_DRAW);
 
-  glUniform4f(uniColLoc,(colour[0] / 255.0f), (colour[1] / 255.0f), (colour[2] / 255.0f), (colour[3] / 255.0f));
+  glUniform4f(uniColLoc, (colour[0] / 255.0f), (colour[1] / 255.0f), (colour[2] / 255.0f),
+              (colour[3] / 255.0f));
 
   glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, 0);
 
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.h b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.h
index f24bf3f18674..be9e4f294fee 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.h
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGL.h
@@ -17,72 +17,76 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
+class CRenderContext;
 
-  class CRendererFactoryOpenGL : public IRendererFactory
-  {
-  public:
-    ~CRendererFactoryOpenGL() override = default;
+class CRendererFactoryOpenGL : public IRendererFactory
+{
+public:
+  ~CRendererFactoryOpenGL() override = default;
 
-    // implementation of IRendererFactory
-    std::string RenderSystemName() const override;
-    CRPBaseRenderer *CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) override;
-    RenderBufferPoolVector CreateBufferPools(CRenderContext &context) override;
-  };
+  // implementation of IRendererFactory
+  std::string RenderSystemName() const override;
+  CRPBaseRenderer* CreateRenderer(const CRenderSettings& settings,
+                                  CRenderContext& context,
+                                  std::shared_ptr<IRenderBufferPool> bufferPool) override;
+  RenderBufferPoolVector CreateBufferPools(CRenderContext& context) override;
+};
+
+class CRPRendererOpenGL : public CRPBaseRenderer
+{
+public:
+  CRPRendererOpenGL(const CRenderSettings& renderSettings,
+                    CRenderContext& context,
+                    std::shared_ptr<IRenderBufferPool> bufferPool);
+  ~CRPRendererOpenGL() override;
+
+  // implementation of CRPBaseRenderer
+  bool Supports(RENDERFEATURE feature) const override;
+  SCALINGMETHOD GetDefaultScalingMethod() const override { return SCALINGMETHOD::NEAREST; }
 
-  class CRPRendererOpenGL : public CRPBaseRenderer
+  static bool SupportsScalingMethod(SCALINGMETHOD method);
+
+protected:
+  struct PackedVertex
+  {
+    float x, y, z;
+    float u1, v1;
+  };
+  struct Svertex
   {
-  public:
-    CRPRendererOpenGL(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool);
-    ~CRPRendererOpenGL() override;
-
-    // implementation of CRPBaseRenderer
-    bool Supports(RENDERFEATURE feature) const override;
-    SCALINGMETHOD GetDefaultScalingMethod() const override { return SCALINGMETHOD::NEAREST; }
-
-    static bool SupportsScalingMethod(SCALINGMETHOD method);
-
-  protected:
-    struct PackedVertex
-    {
-      float x, y, z;
-      float u1, v1;
-    };
-    struct Svertex
-    {
-      float x;
-      float y;
-      float z;
-    };
-    
-    // implementation of CRPBaseRenderer
-    void RenderInternal(bool clear, uint8_t alpha) override;
-    void FlushInternal() override;
-
-    /*!
-     * \brief Set the entire backbuffer to black
-     */
-    void ClearBackBuffer();
-
-    /*!
-     * \brief Draw black bars around the video quad
-     *
-     * This is more efficient than glClear() since it only sets pixels to
-     * black that aren't going to be overwritten by the game.
-     */
-    void DrawBlackBars();
-
-    virtual void Render(uint8_t alpha);
-
-    GLuint m_mainVAO;
-    GLuint m_mainVertexVBO;
-    GLuint m_mainIndexVBO;
-
-    GLuint m_blackbarsVAO;
-    GLuint m_blackbarsVertexVBO;
-    
-    GLenum m_textureTarget = GL_TEXTURE_2D;
-    float m_clearColour = 0.0f;
+    float x;
+    float y;
+    float z;
   };
-}
-}
+
+  // implementation of CRPBaseRenderer
+  void RenderInternal(bool clear, uint8_t alpha) override;
+  void FlushInternal() override;
+
+  /*!
+   * \brief Set the entire backbuffer to black
+   */
+  void ClearBackBuffer();
+
+  /*!
+   * \brief Draw black bars around the video quad
+   *
+   * This is more efficient than glClear() since it only sets pixels to
+   * black that aren't going to be overwritten by the game.
+   */
+  void DrawBlackBars();
+
+  virtual void Render(uint8_t alpha);
+
+  GLuint m_mainVAO;
+  GLuint m_mainVertexVBO;
+  GLuint m_mainIndexVBO;
+
+  GLuint m_blackbarsVAO;
+  GLuint m_blackbarsVertexVBO;
+
+  GLenum m_textureTarget = GL_TEXTURE_2D;
+  float m_clearColour = 0.0f;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp
index b01c89ce8ba9..03427da6bd9f 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.cpp
@@ -18,7 +18,7 @@
 #include <cstring>
 #include <stddef.h>
 
-#define BUFFER_OFFSET(i) ((char *)NULL + (i))
+#define BUFFER_OFFSET(i) ((char*)NULL + (i))
 
 using namespace KODI;
 using namespace RETRO;
@@ -30,20 +30,25 @@ std::string CRendererFactoryOpenGLES::RenderSystemName() const
   return "OpenGLES";
 }
 
-CRPBaseRenderer *CRendererFactoryOpenGLES::CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool)
+CRPBaseRenderer* CRendererFactoryOpenGLES::CreateRenderer(
+    const CRenderSettings& settings,
+    CRenderContext& context,
+    std::shared_ptr<IRenderBufferPool> bufferPool)
 {
   return new CRPRendererOpenGLES(settings, context, std::move(bufferPool));
 }
 
-RenderBufferPoolVector CRendererFactoryOpenGLES::CreateBufferPools(CRenderContext &context)
+RenderBufferPoolVector CRendererFactoryOpenGLES::CreateBufferPools(CRenderContext& context)
 {
-  return { std::make_shared<CRenderBufferPoolOpenGLES>(context) };
+  return {std::make_shared<CRenderBufferPoolOpenGLES>(context)};
 }
 
 // --- CRPRendererOpenGLES -----------------------------------------------------
 
-CRPRendererOpenGLES::CRPRendererOpenGLES(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) :
-  CRPBaseRenderer(renderSettings, context, std::move(bufferPool))
+CRPRendererOpenGLES::CRPRendererOpenGLES(const CRenderSettings& renderSettings,
+                                         CRenderContext& context,
+                                         std::shared_ptr<IRenderBufferPool> bufferPool)
+  : CRPBaseRenderer(renderSettings, context, std::move(bufferPool))
 {
   glGenBuffers(1, &m_mainIndexVBO);
   glGenBuffers(1, &m_mainVertexVBO);
@@ -93,16 +98,13 @@ void CRPRendererOpenGLES::FlushInternal()
 
 bool CRPRendererOpenGLES::Supports(RENDERFEATURE feature) const
 {
-  return feature == RENDERFEATURE::STRETCH         ||
-         feature == RENDERFEATURE::ZOOM            ||
-         feature == RENDERFEATURE::PIXEL_RATIO     ||
-         feature == RENDERFEATURE::ROTATION;
+  return feature == RENDERFEATURE::STRETCH || feature == RENDERFEATURE::ZOOM ||
+         feature == RENDERFEATURE::PIXEL_RATIO || feature == RENDERFEATURE::ROTATION;
 }
 
 bool CRPRendererOpenGLES::SupportsScalingMethod(SCALINGMETHOD method)
 {
-  return method == SCALINGMETHOD::NEAREST ||
-         method == SCALINGMETHOD::LINEAR;
+  return method == SCALINGMETHOD::NEAREST || method == SCALINGMETHOD::LINEAR;
 }
 
 void CRPRendererOpenGLES::ClearBackBuffer()
@@ -131,92 +133,92 @@ void CRPRendererOpenGLES::DrawBlackBars()
 
   glUniform4f(uniCol, m_clearColour / 255.0f, m_clearColour / 255.0f, m_clearColour / 255.0f, 1.0f);
 
-  //top quad
+  // top quad
   if (m_rotatedDestCoords[0].y > 0.0)
   {
     GLubyte quad = count;
     vertices[quad].x = 0.0;
     vertices[quad].y = 0.0;
     vertices[quad].z = 0;
-    vertices[quad+1].x = m_context.GetScreenWidth();
-    vertices[quad+1].y = 0;
-    vertices[quad+1].z = 0;
-    vertices[quad+2].x = m_context.GetScreenWidth();
-    vertices[quad+2].y = m_rotatedDestCoords[0].y;
-    vertices[quad+2].z = 0;
-    vertices[quad+3] = vertices[quad+2];
-    vertices[quad+4].x = 0;
-    vertices[quad+4].y = m_rotatedDestCoords[0].y;
-    vertices[quad+4].z = 0;
-    vertices[quad+5] = vertices[quad];
+    vertices[quad + 1].x = m_context.GetScreenWidth();
+    vertices[quad + 1].y = 0;
+    vertices[quad + 1].z = 0;
+    vertices[quad + 2].x = m_context.GetScreenWidth();
+    vertices[quad + 2].y = m_rotatedDestCoords[0].y;
+    vertices[quad + 2].z = 0;
+    vertices[quad + 3] = vertices[quad + 2];
+    vertices[quad + 4].x = 0;
+    vertices[quad + 4].y = m_rotatedDestCoords[0].y;
+    vertices[quad + 4].z = 0;
+    vertices[quad + 5] = vertices[quad];
     count += 6;
   }
 
-  //bottom quad
+  // bottom quad
   if (m_rotatedDestCoords[2].y < m_context.GetScreenHeight())
   {
     GLubyte quad = count;
     vertices[quad].x = 0.0;
     vertices[quad].y = m_rotatedDestCoords[2].y;
     vertices[quad].z = 0;
-    vertices[quad+1].x = m_context.GetScreenWidth();
-    vertices[quad+1].y = m_rotatedDestCoords[2].y;
-    vertices[quad+1].z = 0;
-    vertices[quad+2].x = m_context.GetScreenWidth();
-    vertices[quad+2].y = m_context.GetScreenHeight();
-    vertices[quad+2].z = 0;
-    vertices[quad+3] = vertices[quad+2];
-    vertices[quad+4].x = 0;
-    vertices[quad+4].y = m_context.GetScreenHeight();
-    vertices[quad+4].z = 0;
-    vertices[quad+5] = vertices[quad];
+    vertices[quad + 1].x = m_context.GetScreenWidth();
+    vertices[quad + 1].y = m_rotatedDestCoords[2].y;
+    vertices[quad + 1].z = 0;
+    vertices[quad + 2].x = m_context.GetScreenWidth();
+    vertices[quad + 2].y = m_context.GetScreenHeight();
+    vertices[quad + 2].z = 0;
+    vertices[quad + 3] = vertices[quad + 2];
+    vertices[quad + 4].x = 0;
+    vertices[quad + 4].y = m_context.GetScreenHeight();
+    vertices[quad + 4].z = 0;
+    vertices[quad + 5] = vertices[quad];
     count += 6;
   }
 
-  //left quad
+  // left quad
   if (m_rotatedDestCoords[0].x > 0.0)
   {
     GLubyte quad = count;
     vertices[quad].x = 0.0;
     vertices[quad].y = m_rotatedDestCoords[0].y;
     vertices[quad].z = 0;
-    vertices[quad+1].x = m_rotatedDestCoords[0].x;
-    vertices[quad+1].y = m_rotatedDestCoords[0].y;
-    vertices[quad+1].z = 0;
-    vertices[quad+2].x = m_rotatedDestCoords[3].x;
-    vertices[quad+2].y = m_rotatedDestCoords[3].y;
-    vertices[quad+2].z = 0;
-    vertices[quad+3] = vertices[quad+2];
-    vertices[quad+4].x = 0;
-    vertices[quad+4].y = m_rotatedDestCoords[3].y;
-    vertices[quad+4].z = 0;
-    vertices[quad+5] = vertices[quad];
+    vertices[quad + 1].x = m_rotatedDestCoords[0].x;
+    vertices[quad + 1].y = m_rotatedDestCoords[0].y;
+    vertices[quad + 1].z = 0;
+    vertices[quad + 2].x = m_rotatedDestCoords[3].x;
+    vertices[quad + 2].y = m_rotatedDestCoords[3].y;
+    vertices[quad + 2].z = 0;
+    vertices[quad + 3] = vertices[quad + 2];
+    vertices[quad + 4].x = 0;
+    vertices[quad + 4].y = m_rotatedDestCoords[3].y;
+    vertices[quad + 4].z = 0;
+    vertices[quad + 5] = vertices[quad];
     count += 6;
   }
 
-  //right quad
+  // right quad
   if (m_rotatedDestCoords[2].x < m_context.GetScreenWidth())
   {
     GLubyte quad = count;
     vertices[quad].x = m_rotatedDestCoords[1].x;
     vertices[quad].y = m_rotatedDestCoords[1].y;
     vertices[quad].z = 0;
-    vertices[quad+1].x = m_context.GetScreenWidth();
-    vertices[quad+1].y = m_rotatedDestCoords[1].y;
-    vertices[quad+1].z = 0;
-    vertices[quad+2].x = m_context.GetScreenWidth();
-    vertices[quad+2].y = m_rotatedDestCoords[2].y;
-    vertices[quad+2].z = 0;
-    vertices[quad+3] = vertices[quad+2];
-    vertices[quad+4].x = m_rotatedDestCoords[1].x;
-    vertices[quad+4].y = m_rotatedDestCoords[2].y;
-    vertices[quad+4].z = 0;
-    vertices[quad+5] = vertices[quad];
+    vertices[quad + 1].x = m_context.GetScreenWidth();
+    vertices[quad + 1].y = m_rotatedDestCoords[1].y;
+    vertices[quad + 1].z = 0;
+    vertices[quad + 2].x = m_context.GetScreenWidth();
+    vertices[quad + 2].y = m_rotatedDestCoords[2].y;
+    vertices[quad + 2].z = 0;
+    vertices[quad + 3] = vertices[quad + 2];
+    vertices[quad + 4].x = m_rotatedDestCoords[1].x;
+    vertices[quad + 4].y = m_rotatedDestCoords[2].y;
+    vertices[quad + 4].z = 0;
+    vertices[quad + 5] = vertices[quad];
     count += 6;
   }
 
   glBindBuffer(GL_ARRAY_BUFFER, m_blackbarsVertexVBO);
-  glBufferData(GL_ARRAY_BUFFER, sizeof(Svertex)*count, &vertices[0], GL_STATIC_DRAW);
+  glBufferData(GL_ARRAY_BUFFER, sizeof(Svertex) * count, &vertices[0], GL_STATIC_DRAW);
 
   glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, sizeof(Svertex), 0);
   glEnableVertexAttribArray(posLoc);
@@ -231,7 +233,7 @@ void CRPRendererOpenGLES::DrawBlackBars()
 
 void CRPRendererOpenGLES::Render(uint8_t alpha)
 {
-  CRenderBufferOpenGLES *renderBuffer = static_cast<CRenderBufferOpenGLES*>(m_renderBuffer);
+  CRenderBufferOpenGLES* renderBuffer = static_cast<CRenderBufferOpenGLES*>(m_renderBuffer);
 
   if (renderBuffer == nullptr)
     return;
@@ -290,18 +292,21 @@ void CRPRendererOpenGLES::Render(uint8_t alpha)
   vertex[2].v1 = vertex[3].v1 = rect.y2;
 
   glBindBuffer(GL_ARRAY_BUFFER, m_mainVertexVBO);
-  glBufferData(GL_ARRAY_BUFFER, sizeof(PackedVertex)*4, &vertex[0], GL_STATIC_DRAW);
+  glBufferData(GL_ARRAY_BUFFER, sizeof(PackedVertex) * 4, &vertex[0], GL_STATIC_DRAW);
 
-  glVertexAttribPointer(vertLoc, 3, GL_FLOAT, 0, sizeof(PackedVertex), BUFFER_OFFSET(offsetof(PackedVertex, x)));
-  glVertexAttribPointer(loc, 2, GL_FLOAT, 0, sizeof(PackedVertex), BUFFER_OFFSET(offsetof(PackedVertex, u1)));
+  glVertexAttribPointer(vertLoc, 3, GL_FLOAT, 0, sizeof(PackedVertex),
+                        BUFFER_OFFSET(offsetof(PackedVertex, x)));
+  glVertexAttribPointer(loc, 2, GL_FLOAT, 0, sizeof(PackedVertex),
+                        BUFFER_OFFSET(offsetof(PackedVertex, u1)));
 
   glEnableVertexAttribArray(vertLoc);
   glEnableVertexAttribArray(loc);
 
   glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_mainIndexVBO);
-  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLubyte)*4, idx, GL_STATIC_DRAW);
+  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLubyte) * 4, idx, GL_STATIC_DRAW);
 
-  glUniform4f(uniColLoc,(colour[0] / 255.0f), (colour[1] / 255.0f), (colour[2] / 255.0f), (colour[3] / 255.0f));
+  glUniform4f(uniColLoc, (colour[0] / 255.0f), (colour[1] / 255.0f), (colour[2] / 255.0f),
+              (colour[3] / 255.0f));
   glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, 0);
 
   glDisableVertexAttribArray(vertLoc);
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.h b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.h
index 7a27bbac3426..ca1f583df6c3 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.h
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.h
@@ -24,54 +24,58 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRendererFactoryOpenGLES : public IRendererFactory
-  {
-  public:
-    ~CRendererFactoryOpenGLES() override = default;
+class CRendererFactoryOpenGLES : public IRendererFactory
+{
+public:
+  ~CRendererFactoryOpenGLES() override = default;
 
-    // implementation of IRendererFactory
-    std::string RenderSystemName() const override;
-    CRPBaseRenderer *CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) override;
-    RenderBufferPoolVector CreateBufferPools(CRenderContext &context) override;
-  };
+  // implementation of IRendererFactory
+  std::string RenderSystemName() const override;
+  CRPBaseRenderer* CreateRenderer(const CRenderSettings& settings,
+                                  CRenderContext& context,
+                                  std::shared_ptr<IRenderBufferPool> bufferPool) override;
+  RenderBufferPoolVector CreateBufferPools(CRenderContext& context) override;
+};
 
-  class CRPRendererOpenGLES : public CRPBaseRenderer
-  {
-  public:
-    CRPRendererOpenGLES(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool);
-    ~CRPRendererOpenGLES() override;
+class CRPRendererOpenGLES : public CRPBaseRenderer
+{
+public:
+  CRPRendererOpenGLES(const CRenderSettings& renderSettings,
+                      CRenderContext& context,
+                      std::shared_ptr<IRenderBufferPool> bufferPool);
+  ~CRPRendererOpenGLES() override;
 
-    // implementation of CRPBaseRenderer
-    bool Supports(RENDERFEATURE feature) const override;
-    SCALINGMETHOD GetDefaultScalingMethod() const override { return SCALINGMETHOD::NEAREST; }
+  // implementation of CRPBaseRenderer
+  bool Supports(RENDERFEATURE feature) const override;
+  SCALINGMETHOD GetDefaultScalingMethod() const override { return SCALINGMETHOD::NEAREST; }
 
-    static bool SupportsScalingMethod(SCALINGMETHOD method);
+  static bool SupportsScalingMethod(SCALINGMETHOD method);
 
-  protected:
-    // implementation of CRPBaseRenderer
-    void RenderInternal(bool clear, uint8_t alpha) override;
-    void FlushInternal() override;
+protected:
+  // implementation of CRPBaseRenderer
+  void RenderInternal(bool clear, uint8_t alpha) override;
+  void FlushInternal() override;
 
-    /*!
-     * \brief Set the entire backbuffer to black
-     */
-    void ClearBackBuffer();
+  /*!
+   * \brief Set the entire backbuffer to black
+   */
+  void ClearBackBuffer();
 
-    /*!
-     * \brief Draw black bars around the video quad
-     *
-     * This is more efficient than glClear() since it only sets pixels to
-     * black that aren't going to be overwritten by the game.
-     */
-    void DrawBlackBars();
+  /*!
+   * \brief Draw black bars around the video quad
+   *
+   * This is more efficient than glClear() since it only sets pixels to
+   * black that aren't going to be overwritten by the game.
+   */
+  void DrawBlackBars();
 
-    virtual void Render(uint8_t alpha);
+  virtual void Render(uint8_t alpha);
 
-    GLuint m_mainIndexVBO;
-    GLuint m_mainVertexVBO;
-    GLuint m_blackbarsVertexVBO;
-    GLenum m_textureTarget = GL_TEXTURE_2D;
-    float m_clearColour = 0.0f;
-  };
-}
-}
+  GLuint m_mainIndexVBO;
+  GLuint m_mainVertexVBO;
+  GLuint m_blackbarsVertexVBO;
+  GLenum m_textureTarget = GL_TEXTURE_2D;
+  float m_clearColour = 0.0f;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPWinRenderer.cpp b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPWinRenderer.cpp
index ea0784cbc6f3..49af98063b20 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPWinRenderer.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPWinRenderer.cpp
@@ -7,6 +7,7 @@
  */
 
 #include "RPWinRenderer.h"
+
 #include "cores/RetroPlayer/rendering/RenderContext.h"
 #include "cores/RetroPlayer/rendering/RenderTranslator.h"
 #include "cores/RetroPlayer/rendering/RenderVideoSettings.h"
@@ -32,22 +33,22 @@ std::string CWinRendererFactory::RenderSystemName() const
   return "DirectX";
 }
 
-CRPBaseRenderer *CWinRendererFactory::CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool)
+CRPBaseRenderer* CWinRendererFactory::CreateRenderer(const CRenderSettings& settings,
+                                                     CRenderContext& context,
+                                                     std::shared_ptr<IRenderBufferPool> bufferPool)
 {
   return new CRPWinRenderer(settings, context, std::move(bufferPool));
 }
 
-RenderBufferPoolVector CWinRendererFactory::CreateBufferPools(CRenderContext &context)
+RenderBufferPoolVector CWinRendererFactory::CreateBufferPools(CRenderContext& context)
 {
-  return { std::make_shared<CWinRenderBufferPool>() };
+  return {std::make_shared<CWinRenderBufferPool>()};
 }
 
 // --- CWinRenderBuffer --------------------------------------------------------
 
-CWinRenderBuffer::CWinRenderBuffer(AVPixelFormat pixFormat, DXGI_FORMAT dxFormat) :
-  m_pixFormat(pixFormat),
-  m_targetDxFormat(dxFormat),
-  m_targetPixFormat(GetPixFormat(dxFormat))
+CWinRenderBuffer::CWinRenderBuffer(AVPixelFormat pixFormat, DXGI_FORMAT dxFormat)
+  : m_pixFormat(pixFormat), m_targetDxFormat(dxFormat), m_targetPixFormat(GetPixFormat(dxFormat))
 {
 }
 
@@ -111,7 +112,7 @@ bool CWinRenderBuffer::UploadTexture()
     }
   }
 
-  uint8_t *destData = nullptr;
+  uint8_t* destData = nullptr;
   unsigned int destStride = 0;
   if (!GetTexture(destData, destStride))
     return false;
@@ -129,8 +130,8 @@ bool CWinRenderBuffer::CreateScalingContext()
 {
   if (m_swsContext == nullptr)
   {
-    m_swsContext = sws_getContext(m_width, m_height, m_pixFormat, m_width, m_height, m_targetPixFormat,
-      SWS_FAST_BILINEAR, NULL, NULL, NULL);
+    m_swsContext = sws_getContext(m_width, m_height, m_pixFormat, m_width, m_height,
+                                  m_targetPixFormat, SWS_FAST_BILINEAR, NULL, NULL, NULL);
 
     if (m_swsContext == nullptr)
     {
@@ -142,12 +143,15 @@ bool CWinRenderBuffer::CreateScalingContext()
   return true;
 }
 
-void CWinRenderBuffer::ScalePixels(uint8_t *source, unsigned int sourceStride, uint8_t *target, unsigned int targetStride)
+void CWinRenderBuffer::ScalePixels(uint8_t* source,
+                                   unsigned int sourceStride,
+                                   uint8_t* target,
+                                   unsigned int targetStride)
 {
-  uint8_t* src[] =       { source,                          nullptr,   nullptr,   nullptr };
-  int      srcStride[] = { static_cast<int>(sourceStride),  0,         0,         0       };
-  uint8_t* dst[] =       { target,                          nullptr,   nullptr,   nullptr };
-  int      dstStride[] = { static_cast<int>(targetStride),  0,         0,         0       };
+  uint8_t* src[] = {source, nullptr, nullptr, nullptr};
+  int srcStride[] = {static_cast<int>(sourceStride), 0, 0, 0};
+  uint8_t* dst[] = {target, nullptr, nullptr, nullptr};
+  int dstStride[] = {static_cast<int>(targetStride), 0, 0, 0};
 
   sws_scale(m_swsContext, src, srcStride, 0, m_height, dst, dstStride);
 }
@@ -164,12 +168,12 @@ CWinRenderBufferPool::CWinRenderBufferPool()
   CompileOutputShaders();
 }
 
-bool CWinRenderBufferPool::IsCompatible(const CRenderVideoSettings &renderSettings) const
+bool CWinRenderBufferPool::IsCompatible(const CRenderVideoSettings& renderSettings) const
 {
   return GetShader(renderSettings.GetScalingMethod()) != nullptr;
 }
 
-IRenderBuffer *CWinRenderBufferPool::CreateRenderBuffer(void *header /* = nullptr */)
+IRenderBuffer* CWinRenderBufferPool::CreateRenderBuffer(void* header /* = nullptr */)
 {
   return new CWinRenderBuffer(m_format, m_targetDxFormat);
 }
@@ -184,7 +188,7 @@ bool CWinRenderBufferPool::ConfigureDX(DXGI_FORMAT dxFormat)
   return true;
 }
 
-CRPWinOutputShader *CWinRenderBufferPool::GetShader(SCALINGMETHOD scalingMethod) const
+CRPWinOutputShader* CWinRenderBufferPool::GetShader(SCALINGMETHOD scalingMethod) const
 {
   auto it = m_outputShaders.find(scalingMethod);
 
@@ -194,11 +198,11 @@ CRPWinOutputShader *CWinRenderBufferPool::GetShader(SCALINGMETHOD scalingMethod)
   return nullptr;
 }
 
-const std::vector<SCALINGMETHOD> &CWinRenderBufferPool::GetScalingMethods()
+const std::vector<SCALINGMETHOD>& CWinRenderBufferPool::GetScalingMethods()
 {
   static std::vector<SCALINGMETHOD> scalingMethods = {
-    SCALINGMETHOD::NEAREST,
-    SCALINGMETHOD::LINEAR,
+      SCALINGMETHOD::NEAREST,
+      SCALINGMETHOD::LINEAR,
   };
 
   return scalingMethods;
@@ -213,20 +217,22 @@ void CWinRenderBufferPool::CompileOutputShaders()
       m_outputShaders[scalingMethod] = std::move(outputShader);
     else
       CLog::Log(LOGERROR, "RPWinRenderer: Unable to create output shader (%s)",
-        CRenderTranslator::TranslateScalingMethod(scalingMethod));
+                CRenderTranslator::TranslateScalingMethod(scalingMethod));
   }
 }
 
 // --- CRPWinRenderer ----------------------------------------------------------
 
-CRPWinRenderer::CRPWinRenderer(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) :
-  CRPBaseRenderer(renderSettings, context, std::move(bufferPool))
+CRPWinRenderer::CRPWinRenderer(const CRenderSettings& renderSettings,
+                               CRenderContext& context,
+                               std::shared_ptr<IRenderBufferPool> bufferPool)
+  : CRPBaseRenderer(renderSettings, context, std::move(bufferPool))
 {
 }
 
 bool CRPWinRenderer::ConfigureInternal()
 {
-  CRenderSystemDX *renderingDx = static_cast<CRenderSystemDX*>(m_context.Rendering());
+  CRenderSystemDX* renderingDx = static_cast<CRenderSystemDX*>(m_context.Rendering());
 
   DXGI_FORMAT targetDxFormat = renderingDx->GetBackBuffer().GetFormat();
 
@@ -237,7 +243,7 @@ bool CRPWinRenderer::ConfigureInternal()
 
 void CRPWinRenderer::RenderInternal(bool clear, uint8_t alpha)
 {
-  CRenderSystemDX *renderingDx = static_cast<CRenderSystemDX*>(m_context.Rendering());
+  CRenderSystemDX* renderingDx = static_cast<CRenderSystemDX*>(m_context.Rendering());
 
   // Set alpha blend state
   renderingDx->SetAlphaBlendEnable(alpha < 0xFF);
@@ -247,10 +253,8 @@ void CRPWinRenderer::RenderInternal(bool clear, uint8_t alpha)
 
 bool CRPWinRenderer::Supports(RENDERFEATURE feature) const
 {
-  if (feature == RENDERFEATURE::STRETCH ||
-      feature == RENDERFEATURE::ZOOM ||
-      feature == RENDERFEATURE::PIXEL_RATIO ||
-      feature == RENDERFEATURE::ROTATION)
+  if (feature == RENDERFEATURE::STRETCH || feature == RENDERFEATURE::ZOOM ||
+      feature == RENDERFEATURE::PIXEL_RATIO || feature == RENDERFEATURE::ROTATION)
     return true;
 
   return false;
@@ -258,8 +262,7 @@ bool CRPWinRenderer::Supports(RENDERFEATURE feature) const
 
 bool CRPWinRenderer::SupportsScalingMethod(SCALINGMETHOD method)
 {
-  if (method == SCALINGMETHOD::LINEAR ||
-      method == SCALINGMETHOD::NEAREST)
+  if (method == SCALINGMETHOD::LINEAR || method == SCALINGMETHOD::NEAREST)
     return true;
 
   return false;
@@ -267,16 +270,12 @@ bool CRPWinRenderer::SupportsScalingMethod(SCALINGMETHOD method)
 
 void CRPWinRenderer::Render(CD3DTexture& target)
 {
-  const CPoint destPoints[4] = {
-    m_rotatedDestCoords[0],
-    m_rotatedDestCoords[1],
-    m_rotatedDestCoords[2],
-    m_rotatedDestCoords[3]
-  };
+  const CPoint destPoints[4] = {m_rotatedDestCoords[0], m_rotatedDestCoords[1],
+                                m_rotatedDestCoords[2], m_rotatedDestCoords[3]};
 
   if (m_renderBuffer != nullptr)
   {
-    CD3DTexture *intermediateTarget = static_cast<CWinRenderBuffer*>(m_renderBuffer)->GetTarget();
+    CD3DTexture* intermediateTarget = static_cast<CWinRenderBuffer*>(m_renderBuffer)->GetTarget();
     if (intermediateTarget != nullptr)
     {
       CRect viewPort;
@@ -285,15 +284,14 @@ void CRPWinRenderer::Render(CD3DTexture& target)
       // Pick appropriate output shader depending on the scaling method of the renderer
       SCALINGMETHOD scalingMethod = m_renderSettings.VideoSettings().GetScalingMethod();
 
-      CWinRenderBufferPool *bufferPool = static_cast<CWinRenderBufferPool*>(m_bufferPool.get());
-      CRPWinOutputShader *outputShader = bufferPool->GetShader(scalingMethod);
+      CWinRenderBufferPool* bufferPool = static_cast<CWinRenderBufferPool*>(m_bufferPool.get());
+      CRPWinOutputShader* outputShader = bufferPool->GetShader(scalingMethod);
 
       // Use the picked output shader to render to the target
       if (outputShader != nullptr)
       {
-        outputShader->Render(*intermediateTarget,
-          m_sourceRect, destPoints, viewPort, &target,
-          m_context.UseLimitedColor() ? 1 : 0);
+        outputShader->Render(*intermediateTarget, m_sourceRect, destPoints, viewPort, &target,
+                             m_context.UseLimitedColor() ? 1 : 0);
       }
     }
   }
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPWinRenderer.h b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPWinRenderer.h
index 6eb92f7e29b0..87615d493871 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPWinRenderer.h
+++ b/xbmc/cores/RetroPlayer/rendering/VideoRenderers/RPWinRenderer.h
@@ -26,100 +26,107 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRenderContext;
-  class CRPWinOutputShader;
+class CRenderContext;
+class CRPWinOutputShader;
 
-  class CWinRendererFactory : public IRendererFactory
-  {
-  public:
-    virtual ~CWinRendererFactory() = default;
-
-    // implementation of IRendererFactory
-    std::string RenderSystemName() const override;
-    CRPBaseRenderer *CreateRenderer(const CRenderSettings &settings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool) override;
-    RenderBufferPoolVector CreateBufferPools(CRenderContext &context) override;
-  };
-
-  class CWinRenderBuffer : public CRenderBufferSysMem
-  {
-  public:
-    CWinRenderBuffer(AVPixelFormat pixFormat, DXGI_FORMAT dxFormat);
-    ~CWinRenderBuffer() override = default;
-
-    // implementation of IRenderBuffer via CRenderBufferSysMem
-    bool UploadTexture() override;
-
-    CD3DTexture *GetTarget() { return m_intermediateTarget.get(); }
-
-  private:
-    bool CreateTexture();
-    bool GetTexture(uint8_t*& data, unsigned int& stride);
-    bool ReleaseTexture();
-
-    bool CreateScalingContext();
-    void ScalePixels(uint8_t *source, unsigned int sourceStride, uint8_t *target, unsigned int targetStride);
-
-    static AVPixelFormat GetPixFormat(DXGI_FORMAT dxFormat);
+class CWinRendererFactory : public IRendererFactory
+{
+public:
+  virtual ~CWinRendererFactory() = default;
+
+  // implementation of IRendererFactory
+  std::string RenderSystemName() const override;
+  CRPBaseRenderer* CreateRenderer(const CRenderSettings& settings,
+                                  CRenderContext& context,
+                                  std::shared_ptr<IRenderBufferPool> bufferPool) override;
+  RenderBufferPoolVector CreateBufferPools(CRenderContext& context) override;
+};
+
+class CWinRenderBuffer : public CRenderBufferSysMem
+{
+public:
+  CWinRenderBuffer(AVPixelFormat pixFormat, DXGI_FORMAT dxFormat);
+  ~CWinRenderBuffer() override = default;
 
-    // Construction parameters
-    const AVPixelFormat m_pixFormat;
-    const DXGI_FORMAT m_targetDxFormat;
+  // implementation of IRenderBuffer via CRenderBufferSysMem
+  bool UploadTexture() override;
 
-    AVPixelFormat m_targetPixFormat;
-    std::unique_ptr<CD3DTexture> m_intermediateTarget;
+  CD3DTexture* GetTarget() { return m_intermediateTarget.get(); }
 
-    SwsContext *m_swsContext = nullptr;
-  };
+private:
+  bool CreateTexture();
+  bool GetTexture(uint8_t*& data, unsigned int& stride);
+  bool ReleaseTexture();
 
-  class CWinRenderBufferPool : public CBaseRenderBufferPool
-  {
-  public:
-    CWinRenderBufferPool();
-    ~CWinRenderBufferPool() override = default;
+  bool CreateScalingContext();
+  void ScalePixels(uint8_t* source,
+                   unsigned int sourceStride,
+                   uint8_t* target,
+                   unsigned int targetStride);
 
-    // implementation of IRenderBufferPool via CRenderBufferPoolSysMem
-    bool IsCompatible(const CRenderVideoSettings &renderSettings) const override;
+  static AVPixelFormat GetPixFormat(DXGI_FORMAT dxFormat);
 
-    // implementation of CBaseRenderBufferPool via CRenderBufferPoolSysMem
-    IRenderBuffer *CreateRenderBuffer(void *header = nullptr) override;
+  // Construction parameters
+  const AVPixelFormat m_pixFormat;
+  const DXGI_FORMAT m_targetDxFormat;
 
-    // DirectX interface
-    bool ConfigureDX(DXGI_FORMAT dxFormat);
-    CRPWinOutputShader *GetShader(SCALINGMETHOD scalingMethod) const;
+  AVPixelFormat m_targetPixFormat;
+  std::unique_ptr<CD3DTexture> m_intermediateTarget;
 
-  private:
-    static const std::vector<SCALINGMETHOD> &GetScalingMethods();
+  SwsContext* m_swsContext = nullptr;
+};
 
-    void CompileOutputShaders();
+class CWinRenderBufferPool : public CBaseRenderBufferPool
+{
+public:
+  CWinRenderBufferPool();
+  ~CWinRenderBufferPool() override = default;
 
-    DXGI_FORMAT m_targetDxFormat = DXGI_FORMAT_UNKNOWN;
-    std::map<SCALINGMETHOD, std::unique_ptr<CRPWinOutputShader>> m_outputShaders;
-  };
+  // implementation of IRenderBufferPool via CRenderBufferPoolSysMem
+  bool IsCompatible(const CRenderVideoSettings& renderSettings) const override;
 
-  class CRPWinRenderer : public CRPBaseRenderer
-  {
-  public:
-    CRPWinRenderer(const CRenderSettings &renderSettings, CRenderContext &context, std::shared_ptr<IRenderBufferPool> bufferPool);
-    ~CRPWinRenderer() override = default;
+  // implementation of CBaseRenderBufferPool via CRenderBufferPoolSysMem
+  IRenderBuffer* CreateRenderBuffer(void* header = nullptr) override;
 
-    // implementation of CRPBaseRenderer
-    bool Supports(RENDERFEATURE feature) const override;
-    SCALINGMETHOD GetDefaultScalingMethod() const override { return DEFAULT_SCALING_METHOD; }
+  // DirectX interface
+  bool ConfigureDX(DXGI_FORMAT dxFormat);
+  CRPWinOutputShader* GetShader(SCALINGMETHOD scalingMethod) const;
 
-    static bool SupportsScalingMethod(SCALINGMETHOD method);
+private:
+  static const std::vector<SCALINGMETHOD>& GetScalingMethods();
 
-    /*!
-     * \brief The default scaling method of the renderer
-     */
-    static const SCALINGMETHOD DEFAULT_SCALING_METHOD = SCALINGMETHOD::NEAREST;
+  void CompileOutputShaders();
 
-  protected:
-    // implementation of CRPBaseRenderer
-    bool ConfigureInternal() override;
-    void RenderInternal(bool clear, uint8_t alpha) override;
+  DXGI_FORMAT m_targetDxFormat = DXGI_FORMAT_UNKNOWN;
+  std::map<SCALINGMETHOD, std::unique_ptr<CRPWinOutputShader>> m_outputShaders;
+};
 
-  private:
-    void Render(CD3DTexture& target);
-  };
-}
-}
+class CRPWinRenderer : public CRPBaseRenderer
+{
+public:
+  CRPWinRenderer(const CRenderSettings& renderSettings,
+                 CRenderContext& context,
+                 std::shared_ptr<IRenderBufferPool> bufferPool);
+  ~CRPWinRenderer() override = default;
+
+  // implementation of CRPBaseRenderer
+  bool Supports(RENDERFEATURE feature) const override;
+  SCALINGMETHOD GetDefaultScalingMethod() const override { return DEFAULT_SCALING_METHOD; }
+
+  static bool SupportsScalingMethod(SCALINGMETHOD method);
+
+  /*!
+   * \brief The default scaling method of the renderer
+   */
+  static const SCALINGMETHOD DEFAULT_SCALING_METHOD = SCALINGMETHOD::NEAREST;
+
+protected:
+  // implementation of CRPBaseRenderer
+  bool ConfigureInternal() override;
+  void RenderInternal(bool clear, uint8_t alpha) override;
+
+private:
+  void Render(CD3DTexture& target);
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoShaders/windows/RPWinOutputShader.cpp b/xbmc/cores/RetroPlayer/rendering/VideoShaders/windows/RPWinOutputShader.cpp
index 86c4f2ea5205..5b479db8002c 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoShaders/windows/RPWinOutputShader.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/VideoShaders/windows/RPWinOutputShader.cpp
@@ -19,12 +19,12 @@ bool CRPWinOutputShader::Create(SCALINGMETHOD scalingMethod)
   DefinesMap defines;
   switch (scalingMethod)
   {
-  case SCALINGMETHOD::NEAREST:
-    defines["SAMP_NEAREST"] = "";
-    break;
-  case SCALINGMETHOD::LINEAR:
-  default:
-    break;
+    case SCALINGMETHOD::NEAREST:
+      defines["SAMP_NEAREST"] = "";
+      break;
+    case SCALINGMETHOD::LINEAR:
+    default:
+      break;
   }
 
   std::string effectPath("special://xbmc/system/shaders/rp_output_d3d.fx");
@@ -36,32 +36,36 @@ bool CRPWinOutputShader::Create(SCALINGMETHOD scalingMethod)
   }
 
   // Create input layout
-  D3D11_INPUT_ELEMENT_DESC layout[] =
-  {
-    { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
-    { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
+  D3D11_INPUT_ELEMENT_DESC layout[] = {
+      {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
+      {"TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0},
   };
   return CWinShader::CreateInputLayout(layout, ARRAYSIZE(layout));
 }
 
-void CRPWinOutputShader::Render(CD3DTexture& sourceTexture, CRect sourceRect, const CPoint points[4]
-  , CRect &viewPort, CD3DTexture *target, unsigned range)
+void CRPWinOutputShader::Render(CD3DTexture& sourceTexture,
+                                CRect sourceRect,
+                                const CPoint points[4],
+                                CRect& viewPort,
+                                CD3DTexture* target,
+                                unsigned range)
 {
   PrepareParameters(sourceTexture.GetWidth(), sourceTexture.GetHeight(), sourceRect, points);
   SetShaderParameters(sourceTexture, range, viewPort);
-  Execute({ target }, 4);
+  Execute({target}, 4);
 }
 
-void CRPWinOutputShader::PrepareParameters(unsigned sourceWidth, unsigned sourceHeight, CRect sourceRect, const CPoint points[4])
+void CRPWinOutputShader::PrepareParameters(unsigned sourceWidth,
+                                           unsigned sourceHeight,
+                                           CRect sourceRect,
+                                           const CPoint points[4])
 {
   bool changed = false;
   for (int i = 0; i < 4 && !changed; ++i)
     changed = points[i] != m_destPoints[i];
 
-  if (m_sourceWidth != sourceWidth ||
-    m_sourceHeight != sourceHeight ||
-    m_sourceRect != sourceRect ||
-    changed)
+  if (m_sourceWidth != sourceWidth || m_sourceHeight != sourceHeight ||
+      m_sourceRect != sourceRect || changed)
   {
     m_sourceWidth = sourceWidth;
     m_sourceHeight = sourceHeight;
@@ -101,14 +105,16 @@ void CRPWinOutputShader::PrepareParameters(unsigned sourceWidth, unsigned source
   }
 }
 
-void CRPWinOutputShader::SetShaderParameters(CD3DTexture& sourceTexture, unsigned range, CRect &viewPort)
+void CRPWinOutputShader::SetShaderParameters(CD3DTexture& sourceTexture,
+                                             unsigned range,
+                                             CRect& viewPort)
 {
   m_effect.SetTechnique("OUTPUT_T");
   m_effect.SetResources("g_Texture", sourceTexture.GetAddressOfSRV(), 1);
 
-  float viewPortArray[2] = { viewPort.Width(), viewPort.Height() };
+  float viewPortArray[2] = {viewPort.Width(), viewPort.Height()};
   m_effect.SetFloatArray("g_viewPort", viewPortArray, 2);
 
-  float params[3] = { static_cast<float>(range) };
+  float params[3] = {static_cast<float>(range)};
   m_effect.SetFloatArray("m_params", params, 1);
 }
diff --git a/xbmc/cores/RetroPlayer/rendering/VideoShaders/windows/RPWinOutputShader.h b/xbmc/cores/RetroPlayer/rendering/VideoShaders/windows/RPWinOutputShader.h
index 45dbb63e073a..ebeb164f7cda 100644
--- a/xbmc/cores/RetroPlayer/rendering/VideoShaders/windows/RPWinOutputShader.h
+++ b/xbmc/cores/RetroPlayer/rendering/VideoShaders/windows/RPWinOutputShader.h
@@ -22,25 +22,32 @@ class CRPWinOutputShader : public CWinShader
   ~CRPWinOutputShader() = default;
 
   bool Create(SCALINGMETHOD scalingMethod);
-  void Render(CD3DTexture &sourceTexture, CRect sourceRect, const CPoint points[4]
-    , CRect &viewPort, CD3DTexture *target, unsigned range = 0);
+  void Render(CD3DTexture& sourceTexture,
+              CRect sourceRect,
+              const CPoint points[4],
+              CRect& viewPort,
+              CD3DTexture* target,
+              unsigned range = 0);
 
 private:
-  void PrepareParameters(unsigned sourceWidth, unsigned sourceHeight, CRect sourceRect, const CPoint points[4]);
-  void SetShaderParameters(CD3DTexture& sourceTexture, unsigned range, CRect &viewPort);
-
-  unsigned m_sourceWidth{ 0 };
-  unsigned m_sourceHeight{ 0 };
-  CRect m_sourceRect{ 0.f, 0.f, 0.f, 0.f };
-  CPoint m_destPoints[4] =
-  {
-    { 0.f, 0.f },
-    { 0.f, 0.f },
-    { 0.f, 0.f },
-    { 0.f, 0.f },
+  void PrepareParameters(unsigned sourceWidth,
+                         unsigned sourceHeight,
+                         CRect sourceRect,
+                         const CPoint points[4]);
+  void SetShaderParameters(CD3DTexture& sourceTexture, unsigned range, CRect& viewPort);
+
+  unsigned m_sourceWidth{0};
+  unsigned m_sourceHeight{0};
+  CRect m_sourceRect{0.f, 0.f, 0.f, 0.f};
+  CPoint m_destPoints[4] = {
+      {0.f, 0.f},
+      {0.f, 0.f},
+      {0.f, 0.f},
+      {0.f, 0.f},
   };
 
-  struct CUSTOMVERTEX {
+  struct CUSTOMVERTEX
+  {
     FLOAT x;
     FLOAT y;
     FLOAT z;
diff --git a/xbmc/cores/RetroPlayer/savestates/ISavestate.h b/xbmc/cores/RetroPlayer/savestates/ISavestate.h
index ede53b1ce151..2330bc5c7107 100644
--- a/xbmc/cores/RetroPlayer/savestates/ISavestate.h
+++ b/xbmc/cores/RetroPlayer/savestates/ISavestate.h
@@ -19,111 +19,111 @@ namespace KODI
 {
 namespace RETRO
 {
-  class ISavestate
-  {
-  public:
-    virtual ~ISavestate() = default;
-
-    /*!
-     * \brief Reset to the initial state
-     */
-    virtual void Reset() = 0;
-
-    /*!
-     * Access the data representation of this savestate
-     */
-    virtual bool Serialize(const uint8_t *&data, size_t &size) const = 0;
-
-    /// @name Savestate properties
-    ///{
-    /*!
-     * \brief The type of save action that created this savestate, either
-     *        manual or automatic
-     */
-    virtual SAVE_TYPE Type() const = 0;
-
-    /*!
-     * \brief The slot this savestate was saved into, or 0 for no slot
-     *
-     * This allows for keyboard access of saved games using the number keys 1-9.
-     */
-    virtual uint8_t Slot() const = 0;
-
-    /*!
-     * \brief The label shown in the GUI for this savestate
-     */
-    virtual std::string Label() const = 0;
-
-    /*!
-     * \brief The timestamp of this savestate's creation
-     */
-    virtual CDateTime Created() const = 0;
-    ///}
-
-    /// @name Game properties
-    ///{
-    /*!
-     * \brief The name of the file beloning to this savestate's game
-     */
-    virtual std::string GameFileName() const = 0;
-    ///}
-
-    /// @name Environment properties
-    ///{
-    /*!
-     * \brief The number of frames in the entire gameplay history
-     */
-    virtual uint64_t TimestampFrames() const = 0;
-
-    /*!
-     * \brief The duration of the entire gameplay history as seen by a wall clock
-     */
-    virtual double TimestampWallClock() const = 0;
-    ///}
-
-    /// @name Game client properties
-    ///{
-    /*!
-     * \brief The game client add-on ID that created this savestate
-     */
-    virtual std::string GameClientID() const = 0;
-
-    /*!
-     * \brief The semantic version of the game client
-     */
-    virtual std::string GameClientVersion() const = 0;
-    ///}
-
-    /// @name Memory properties
-    ///{
-    /*!
-     * \brief A pointer to the internal memory (SRAM) of the frame
-     */
-    virtual const uint8_t *GetMemoryData() const = 0;
-
-    /*!
-     * \brief The size of the memory region returned by GetMemoryData()
-     */
-    virtual size_t GetMemorySize() const = 0;
-    ///}
-
-    // Build flatbuffer by setting individual fields
-    virtual void SetType(SAVE_TYPE type) = 0;
-    virtual void SetSlot(uint8_t slot) = 0;
-    virtual void SetLabel(const std::string &label) = 0;
-    virtual void SetCreated(const CDateTime &created) = 0;
-    virtual void SetGameFileName(const std::string &gameFileName) = 0;
-    virtual void SetTimestampFrames(uint64_t timestampFrames) = 0;
-    virtual void SetTimestampWallClock(double timestampWallClock) = 0;
-    virtual void SetGameClientID(const std::string &gameClient) = 0;
-    virtual void SetGameClientVersion(const std::string &gameClient) = 0;
-    virtual uint8_t *GetMemoryBuffer(size_t size) = 0;
-    virtual void Finalize() = 0;
-
-    /*!
-     * \brief Take ownership and initialize the flatbuffer with the given vector
-     */
-    virtual bool Deserialize(std::vector<uint8_t> data) = 0;
-  };
-}
-}
+class ISavestate
+{
+public:
+  virtual ~ISavestate() = default;
+
+  /*!
+   * \brief Reset to the initial state
+   */
+  virtual void Reset() = 0;
+
+  /*!
+   * Access the data representation of this savestate
+   */
+  virtual bool Serialize(const uint8_t*& data, size_t& size) const = 0;
+
+  /// @name Savestate properties
+  ///{
+  /*!
+   * \brief The type of save action that created this savestate, either
+   *        manual or automatic
+   */
+  virtual SAVE_TYPE Type() const = 0;
+
+  /*!
+   * \brief The slot this savestate was saved into, or 0 for no slot
+   *
+   * This allows for keyboard access of saved games using the number keys 1-9.
+   */
+  virtual uint8_t Slot() const = 0;
+
+  /*!
+   * \brief The label shown in the GUI for this savestate
+   */
+  virtual std::string Label() const = 0;
+
+  /*!
+   * \brief The timestamp of this savestate's creation
+   */
+  virtual CDateTime Created() const = 0;
+  ///}
+
+  /// @name Game properties
+  ///{
+  /*!
+   * \brief The name of the file beloning to this savestate's game
+   */
+  virtual std::string GameFileName() const = 0;
+  ///}
+
+  /// @name Environment properties
+  ///{
+  /*!
+   * \brief The number of frames in the entire gameplay history
+   */
+  virtual uint64_t TimestampFrames() const = 0;
+
+  /*!
+   * \brief The duration of the entire gameplay history as seen by a wall clock
+   */
+  virtual double TimestampWallClock() const = 0;
+  ///}
+
+  /// @name Game client properties
+  ///{
+  /*!
+   * \brief The game client add-on ID that created this savestate
+   */
+  virtual std::string GameClientID() const = 0;
+
+  /*!
+   * \brief The semantic version of the game client
+   */
+  virtual std::string GameClientVersion() const = 0;
+  ///}
+
+  /// @name Memory properties
+  ///{
+  /*!
+   * \brief A pointer to the internal memory (SRAM) of the frame
+   */
+  virtual const uint8_t* GetMemoryData() const = 0;
+
+  /*!
+   * \brief The size of the memory region returned by GetMemoryData()
+   */
+  virtual size_t GetMemorySize() const = 0;
+  ///}
+
+  // Build flatbuffer by setting individual fields
+  virtual void SetType(SAVE_TYPE type) = 0;
+  virtual void SetSlot(uint8_t slot) = 0;
+  virtual void SetLabel(const std::string& label) = 0;
+  virtual void SetCreated(const CDateTime& created) = 0;
+  virtual void SetGameFileName(const std::string& gameFileName) = 0;
+  virtual void SetTimestampFrames(uint64_t timestampFrames) = 0;
+  virtual void SetTimestampWallClock(double timestampWallClock) = 0;
+  virtual void SetGameClientID(const std::string& gameClient) = 0;
+  virtual void SetGameClientVersion(const std::string& gameClient) = 0;
+  virtual uint8_t* GetMemoryBuffer(size_t size) = 0;
+  virtual void Finalize() = 0;
+
+  /*!
+   * \brief Take ownership and initialize the flatbuffer with the given vector
+   */
+  virtual bool Deserialize(std::vector<uint8_t> data) = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/savestates/SavestateDatabase.cpp b/xbmc/cores/RetroPlayer/savestates/SavestateDatabase.cpp
index 3bac022c07af..1f2e1663bce2 100644
--- a/xbmc/cores/RetroPlayer/savestates/SavestateDatabase.cpp
+++ b/xbmc/cores/RetroPlayer/savestates/SavestateDatabase.cpp
@@ -28,7 +28,7 @@ std::unique_ptr<ISavestate> CSavestateDatabase::CreateSavestate()
   return savestate;
 }
 
-bool CSavestateDatabase::AddSavestate(const std::string &gamePath, const ISavestate& save)
+bool CSavestateDatabase::AddSavestate(const std::string& gamePath, const ISavestate& save)
 {
   bool bSuccess = false;
 
@@ -36,7 +36,7 @@ bool CSavestateDatabase::AddSavestate(const std::string &gamePath, const ISavest
 
   CLog::Log(LOGDEBUG, "Saving savestate to %s", CURL::GetRedacted(savestatePath).c_str());
 
-  const uint8_t *data = nullptr;
+  const uint8_t* data = nullptr;
   size_t size = 0;
   if (save.Serialize(data, size))
   {
@@ -79,16 +79,17 @@ bool CSavestateDatabase::GetSavestate(const std::string& gamePath, ISavestate& s
       if (readLength != static_cast<ssize_t>(savestateData.size()))
       {
         CLog::Log(LOGERROR, "Failed to read savestate %s of size %d bytes",
-          CURL::GetRedacted(savestatePath).c_str(),
-          size);
+                  CURL::GetRedacted(savestatePath).c_str(), size);
         savestateData.clear();
       }
     }
     else
-      CLog::Log(LOGERROR, "Failed to get savestate length: %s", CURL::GetRedacted(savestatePath).c_str());
+      CLog::Log(LOGERROR, "Failed to get savestate length: %s",
+                CURL::GetRedacted(savestatePath).c_str());
   }
   else
-    CLog::Log(LOGERROR, "Failed to open savestate file %s", CURL::GetRedacted(savestatePath).c_str());
+    CLog::Log(LOGERROR, "Failed to open savestate file %s",
+              CURL::GetRedacted(savestatePath).c_str());
 
   if (!savestateData.empty())
     bSuccess = save.Deserialize(std::move(savestateData));
@@ -96,7 +97,9 @@ bool CSavestateDatabase::GetSavestate(const std::string& gamePath, ISavestate& s
   return bSuccess;
 }
 
-bool CSavestateDatabase::GetSavestatesNav(CFileItemList& items, const std::string& gamePath, const std::string& gameClient /* = "" */)
+bool CSavestateDatabase::GetSavestatesNav(CFileItemList& items,
+                                          const std::string& gamePath,
+                                          const std::string& gameClient /* = "" */)
 {
   //! @todo
   return false;
@@ -114,7 +117,8 @@ bool CSavestateDatabase::DeleteSavestate(const std::string& path)
   return false;
 }
 
-bool CSavestateDatabase::ClearSavestatesOfGame(const std::string& gamePath, const std::string& gameClient /* = "" */)
+bool CSavestateDatabase::ClearSavestatesOfGame(const std::string& gamePath,
+                                               const std::string& gameClient /* = "" */)
 {
   //! @todo
   return false;
diff --git a/xbmc/cores/RetroPlayer/savestates/SavestateDatabase.h b/xbmc/cores/RetroPlayer/savestates/SavestateDatabase.h
index 473e3cf13257..9d0364724fee 100644
--- a/xbmc/cores/RetroPlayer/savestates/SavestateDatabase.h
+++ b/xbmc/cores/RetroPlayer/savestates/SavestateDatabase.h
@@ -17,27 +17,29 @@ namespace KODI
 {
 namespace RETRO
 {
-  class ISavestate;
+class ISavestate;
 
-  class CSavestateDatabase
-  {
-  public:
-    CSavestateDatabase();
-    virtual ~CSavestateDatabase() = default;
+class CSavestateDatabase
+{
+public:
+  CSavestateDatabase();
+  virtual ~CSavestateDatabase() = default;
 
-    std::unique_ptr<ISavestate> CreateSavestate();
+  std::unique_ptr<ISavestate> CreateSavestate();
 
-    bool AddSavestate(const std::string &gamePath, const ISavestate& save);
+  bool AddSavestate(const std::string& gamePath, const ISavestate& save);
 
-    bool GetSavestate(const std::string& gamePath, ISavestate& save);
+  bool GetSavestate(const std::string& gamePath, ISavestate& save);
 
-    bool GetSavestatesNav(CFileItemList& items, const std::string& gamePath, const std::string& gameClient = "");
+  bool GetSavestatesNav(CFileItemList& items,
+                        const std::string& gamePath,
+                        const std::string& gameClient = "");
 
-    bool RenameSavestate(const std::string& path, const std::string& label);
+  bool RenameSavestate(const std::string& path, const std::string& label);
 
-    bool DeleteSavestate(const std::string& path);
+  bool DeleteSavestate(const std::string& path);
 
-    bool ClearSavestatesOfGame(const std::string& gamePath, const std::string& gameClient = "");
-  };
-}
-}
+  bool ClearSavestatesOfGame(const std::string& gamePath, const std::string& gameClient = "");
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/savestates/SavestateFlatBuffer.cpp b/xbmc/cores/RetroPlayer/savestates/SavestateFlatBuffer.cpp
index e172f5ec7191..cc1c305a1f6e 100644
--- a/xbmc/cores/RetroPlayer/savestates/SavestateFlatBuffer.cpp
+++ b/xbmc/cores/RetroPlayer/savestates/SavestateFlatBuffer.cpp
@@ -16,52 +16,52 @@ using namespace RETRO;
 
 namespace
 {
-  const uint8_t SCHEMA_VERSION = 1;
-
-  /*!
-   * \brief The initial size of the FlatBuffer's memory buffer
-   *
-   * 1024 is the default size in the FlatBuffers header. We might as well use
-   * this until our size requirements are more known.
-   */
-  const size_t INITIAL_FLATBUFFER_SIZE = 1024;
-
-  /*!
-   * \brief Translate the save type (RetroPlayer to FlatBuffers)
-   */
-  SaveType TranslateType(SAVE_TYPE type)
+const uint8_t SCHEMA_VERSION = 1;
+
+/*!
+ * \brief The initial size of the FlatBuffer's memory buffer
+ *
+ * 1024 is the default size in the FlatBuffers header. We might as well use
+ * this until our size requirements are more known.
+ */
+const size_t INITIAL_FLATBUFFER_SIZE = 1024;
+
+/*!
+ * \brief Translate the save type (RetroPlayer to FlatBuffers)
+ */
+SaveType TranslateType(SAVE_TYPE type)
+{
+  switch (type)
   {
-    switch (type)
-    {
     case SAVE_TYPE::AUTO:
       return SaveType_Auto;
     case SAVE_TYPE::MANUAL:
       return SaveType_Manual;
     default:
       break;
-    }
-
-    return SaveType_Unknown;
   }
 
-  /*!
-   * \brief Translate the save type (FlatBuffers to RetroPlayer)
-   */
-  SAVE_TYPE TranslateType(SaveType type)
+  return SaveType_Unknown;
+}
+
+/*!
+ * \brief Translate the save type (FlatBuffers to RetroPlayer)
+ */
+SAVE_TYPE TranslateType(SaveType type)
+{
+  switch (type)
   {
-    switch (type)
-    {
     case SaveType_Auto:
       return SAVE_TYPE::AUTO;
     case SaveType_Manual:
       return SAVE_TYPE::MANUAL;
     default:
       break;
-    }
-
-    return SAVE_TYPE::UNKNOWN;
   }
+
+  return SAVE_TYPE::UNKNOWN;
 }
+} // namespace
 
 CSavestateFlatBuffer::CSavestateFlatBuffer()
 {
@@ -77,7 +77,7 @@ void CSavestateFlatBuffer::Reset()
   m_savestate = nullptr;
 }
 
-bool CSavestateFlatBuffer::Serialize(const uint8_t *&data, size_t &size) const
+bool CSavestateFlatBuffer::Serialize(const uint8_t*& data, size_t& size) const
 {
   // Check if savestate was deserialized from vector or built with FlatBuffers
   if (!m_data.empty())
@@ -130,9 +130,9 @@ std::string CSavestateFlatBuffer::Label() const
   return label;
 }
 
-void CSavestateFlatBuffer::SetLabel(const std::string &label)
+void CSavestateFlatBuffer::SetLabel(const std::string& label)
 {
-  m_labelOffset.reset(new StringOffset{ m_builder->CreateString(label) });
+  m_labelOffset.reset(new StringOffset{m_builder->CreateString(label)});
 }
 
 CDateTime CSavestateFlatBuffer::Created() const
@@ -145,9 +145,9 @@ CDateTime CSavestateFlatBuffer::Created() const
   return created;
 }
 
-void CSavestateFlatBuffer::SetCreated(const CDateTime &created)
+void CSavestateFlatBuffer::SetCreated(const CDateTime& created)
 {
-  m_createdOffset.reset(new StringOffset{ m_builder->CreateString(created.GetAsRFC1123DateTime()) });
+  m_createdOffset.reset(new StringOffset{m_builder->CreateString(created.GetAsRFC1123DateTime())});
 }
 
 std::string CSavestateFlatBuffer::GameFileName() const
@@ -160,9 +160,9 @@ std::string CSavestateFlatBuffer::GameFileName() const
   return gameFileName;
 }
 
-void CSavestateFlatBuffer::SetGameFileName(const std::string &gameFileName)
+void CSavestateFlatBuffer::SetGameFileName(const std::string& gameFileName)
 {
-  m_gameFileNameOffset.reset(new StringOffset{ m_builder->CreateString(gameFileName) });
+  m_gameFileNameOffset.reset(new StringOffset{m_builder->CreateString(gameFileName)});
 }
 
 uint64_t CSavestateFlatBuffer::TimestampFrames() const
@@ -198,9 +198,9 @@ std::string CSavestateFlatBuffer::GameClientID() const
   return gameClientId;
 }
 
-void CSavestateFlatBuffer::SetGameClientID(const std::string &gameClientId)
+void CSavestateFlatBuffer::SetGameClientID(const std::string& gameClientId)
 {
-  m_emulatorAddonIdOffset.reset(new StringOffset{ m_builder->CreateString(gameClientId) });
+  m_emulatorAddonIdOffset.reset(new StringOffset{m_builder->CreateString(gameClientId)});
 }
 
 std::string CSavestateFlatBuffer::GameClientVersion() const
@@ -213,12 +213,12 @@ std::string CSavestateFlatBuffer::GameClientVersion() const
   return gameClientVersion;
 }
 
-void CSavestateFlatBuffer::SetGameClientVersion(const std::string &gameClientVersion)
+void CSavestateFlatBuffer::SetGameClientVersion(const std::string& gameClientVersion)
 {
-  m_emulatorVersionOffset.reset(new StringOffset{ m_builder->CreateString(gameClientVersion) });
+  m_emulatorVersionOffset.reset(new StringOffset{m_builder->CreateString(gameClientVersion)});
 }
 
-const uint8_t *CSavestateFlatBuffer::GetMemoryData() const
+const uint8_t* CSavestateFlatBuffer::GetMemoryData() const
 {
   if (m_savestate != nullptr && m_savestate->memory_data())
     return m_savestate->memory_data()->data();
@@ -234,11 +234,12 @@ size_t CSavestateFlatBuffer::GetMemorySize() const
   return 0;
 }
 
-uint8_t *CSavestateFlatBuffer::GetMemoryBuffer(size_t size)
+uint8_t* CSavestateFlatBuffer::GetMemoryBuffer(size_t size)
 {
-  uint8_t *memoryBuffer = nullptr;
+  uint8_t* memoryBuffer = nullptr;
 
-  m_memoryDataOffset.reset(new VectorOffset{ m_builder->CreateUninitializedVector(size, &memoryBuffer) });
+  m_memoryDataOffset.reset(
+      new VectorOffset{m_builder->CreateUninitializedVector(size, &memoryBuffer)});
 
   return memoryBuffer;
 }
@@ -274,7 +275,8 @@ void CSavestateFlatBuffer::Finalize()
 
   savestateBuilder.add_timestamp_frames(m_timestampFrames);
 
-  const uint64_t wallClockNs = static_cast<uint64_t>(m_timestampWallClock * 1000.0 * 1000.0 * 1000.0);
+  const uint64_t wallClockNs =
+      static_cast<uint64_t>(m_timestampWallClock * 1000.0 * 1000.0 * 1000.0);
   savestateBuilder.add_timestamp_wall_clock_ns(wallClockNs);
 
   if (m_emulatorAddonIdOffset)
@@ -306,13 +308,12 @@ bool CSavestateFlatBuffer::Deserialize(std::vector<uint8_t> data)
   flatbuffers::Verifier verifier(data.data(), data.size());
   if (VerifySavestateBuffer(verifier))
   {
-    const Savestate *savestate = GetSavestate(data.data());
+    const Savestate* savestate = GetSavestate(data.data());
 
     if (savestate->version() != SCHEMA_VERSION)
     {
       CLog::Log(LOGERROR, "RetroPlayer[SAVE): Schema version %u not supported, must be version %u",
-        savestate->version(),
-        SCHEMA_VERSION);
+                savestate->version(), SCHEMA_VERSION);
     }
     else
     {
diff --git a/xbmc/cores/RetroPlayer/savestates/SavestateFlatBuffer.h b/xbmc/cores/RetroPlayer/savestates/SavestateFlatBuffer.h
index 89d8fc4b65f2..012a7c153b82 100644
--- a/xbmc/cores/RetroPlayer/savestates/SavestateFlatBuffer.h
+++ b/xbmc/cores/RetroPlayer/savestates/SavestateFlatBuffer.h
@@ -16,83 +16,83 @@
 
 namespace flatbuffers
 {
-  class FlatBufferBuilder;
+class FlatBufferBuilder;
 }
 
 namespace KODI
 {
 namespace RETRO
 {
-  struct Savestate;
-  struct SavestateBuilder;
+struct Savestate;
+struct SavestateBuilder;
 
-  class CSavestateFlatBuffer : public ISavestate
-  {
-  public:
-    CSavestateFlatBuffer();
-    ~CSavestateFlatBuffer() override;
+class CSavestateFlatBuffer : public ISavestate
+{
+public:
+  CSavestateFlatBuffer();
+  ~CSavestateFlatBuffer() override;
 
-    // Implementation of ISavestate
-    void Reset() override;
-    bool Serialize(const uint8_t *&data, size_t &size) const override;
-    SAVE_TYPE Type() const override;
-    uint8_t Slot() const override;
-    std::string Label() const override;
-    CDateTime Created() const override;
-    std::string GameFileName() const override;
-    uint64_t TimestampFrames() const override;
-    double TimestampWallClock() const override;
-    std::string GameClientID() const override;
-    std::string GameClientVersion() const override;
-    const uint8_t *GetMemoryData() const override;
-    size_t GetMemorySize() const override;
-    void SetType(SAVE_TYPE type) override;
-    void SetSlot(uint8_t slot) override;
-    void SetLabel(const std::string &label) override;
-    void SetCreated(const CDateTime &created) override;
-    void SetGameFileName(const std::string &gameFileName) override;
-    void SetTimestampFrames(uint64_t timestampFrames) override;
-    void SetTimestampWallClock(double timestampWallClock) override;
-    void SetGameClientID(const std::string &gameClient) override;
-    void SetGameClientVersion(const std::string &gameClient) override;
-    uint8_t *GetMemoryBuffer(size_t size) override;
-    void Finalize() override;
-    bool Deserialize(std::vector<uint8_t> data) override;
+  // Implementation of ISavestate
+  void Reset() override;
+  bool Serialize(const uint8_t*& data, size_t& size) const override;
+  SAVE_TYPE Type() const override;
+  uint8_t Slot() const override;
+  std::string Label() const override;
+  CDateTime Created() const override;
+  std::string GameFileName() const override;
+  uint64_t TimestampFrames() const override;
+  double TimestampWallClock() const override;
+  std::string GameClientID() const override;
+  std::string GameClientVersion() const override;
+  const uint8_t* GetMemoryData() const override;
+  size_t GetMemorySize() const override;
+  void SetType(SAVE_TYPE type) override;
+  void SetSlot(uint8_t slot) override;
+  void SetLabel(const std::string& label) override;
+  void SetCreated(const CDateTime& created) override;
+  void SetGameFileName(const std::string& gameFileName) override;
+  void SetTimestampFrames(uint64_t timestampFrames) override;
+  void SetTimestampWallClock(double timestampWallClock) override;
+  void SetGameClientID(const std::string& gameClient) override;
+  void SetGameClientVersion(const std::string& gameClient) override;
+  uint8_t* GetMemoryBuffer(size_t size) override;
+  void Finalize() override;
+  bool Deserialize(std::vector<uint8_t> data) override;
 
-  private:
-    /*!
-     * \brief Helper class to hold data needed in creation of a FlatBuffer
-     *
-     * The builder is used when deserializing from individual fields.
-     */
-    std::unique_ptr<flatbuffers::FlatBufferBuilder> m_builder;
+private:
+  /*!
+   * \brief Helper class to hold data needed in creation of a FlatBuffer
+   *
+   * The builder is used when deserializing from individual fields.
+   */
+  std::unique_ptr<flatbuffers::FlatBufferBuilder> m_builder;
 
-    /*!
-     * \brief System memory storage (for deserializing savestates)
-     *
-     * This memory is used when deserializing from a vector.
-     */
-    std::vector<uint8_t> m_data;
+  /*!
+   * \brief System memory storage (for deserializing savestates)
+   *
+   * This memory is used when deserializing from a vector.
+   */
+  std::vector<uint8_t> m_data;
 
-    /*!
-     * \brief FlatBuffer struct used for accessing data
-     */
-    const Savestate *m_savestate = nullptr;
+  /*!
+   * \brief FlatBuffer struct used for accessing data
+   */
+  const Savestate* m_savestate = nullptr;
 
-    using StringOffset = flatbuffers::Offset<flatbuffers::String>;
-    using VectorOffset = flatbuffers::Offset<flatbuffers::Vector<uint8_t>>;
+  using StringOffset = flatbuffers::Offset<flatbuffers::String>;
+  using VectorOffset = flatbuffers::Offset<flatbuffers::Vector<uint8_t>>;
 
-    // Temporary deserialization variables
-    SAVE_TYPE m_type = SAVE_TYPE::UNKNOWN;
-    uint8_t m_slot = 0;
-    std::unique_ptr<StringOffset> m_labelOffset;
-    std::unique_ptr<StringOffset> m_createdOffset;
-    std::unique_ptr<StringOffset> m_gameFileNameOffset;
-    uint64_t m_timestampFrames = 0;
-    double m_timestampWallClock = 0.0;
-    std::unique_ptr<StringOffset> m_emulatorAddonIdOffset;
-    std::unique_ptr<StringOffset> m_emulatorVersionOffset;
-    std::unique_ptr<VectorOffset> m_memoryDataOffset;
-  };
-}
-}
+  // Temporary deserialization variables
+  SAVE_TYPE m_type = SAVE_TYPE::UNKNOWN;
+  uint8_t m_slot = 0;
+  std::unique_ptr<StringOffset> m_labelOffset;
+  std::unique_ptr<StringOffset> m_createdOffset;
+  std::unique_ptr<StringOffset> m_gameFileNameOffset;
+  uint64_t m_timestampFrames = 0;
+  double m_timestampWallClock = 0.0;
+  std::unique_ptr<StringOffset> m_emulatorAddonIdOffset;
+  std::unique_ptr<StringOffset> m_emulatorVersionOffset;
+  std::unique_ptr<VectorOffset> m_memoryDataOffset;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/savestates/SavestateTypes.h b/xbmc/cores/RetroPlayer/savestates/SavestateTypes.h
index 3fa2dd61475f..e4bbc9bb10ea 100644
--- a/xbmc/cores/RetroPlayer/savestates/SavestateTypes.h
+++ b/xbmc/cores/RetroPlayer/savestates/SavestateTypes.h
@@ -12,17 +12,17 @@ namespace KODI
 {
 namespace RETRO
 {
-  /*!
-   * \brief Type of save action, either:
-   *
-   *   - automatic (saving was not prompted by the user)
-   *   - manual (user manually prompted the save)
-   */
-  enum class SAVE_TYPE
-  {
-    UNKNOWN,
-    AUTO,
-    MANUAL,
-  };
-}
-}
+/*!
+ * \brief Type of save action, either:
+ *
+ *   - automatic (saving was not prompted by the user)
+ *   - manual (user manually prompted the save)
+ */
+enum class SAVE_TYPE
+{
+  UNKNOWN,
+  AUTO,
+  MANUAL,
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/savestates/SavestateUtils.cpp b/xbmc/cores/RetroPlayer/savestates/SavestateUtils.cpp
index 051d26adabb3..1f78fe18cb70 100644
--- a/xbmc/cores/RetroPlayer/savestates/SavestateUtils.cpp
+++ b/xbmc/cores/RetroPlayer/savestates/SavestateUtils.cpp
@@ -10,12 +10,12 @@
 
 #include "utils/URIUtils.h"
 
-#define SAVESTATE_EXTENSION      ".sav"
+#define SAVESTATE_EXTENSION ".sav"
 
 using namespace KODI;
 using namespace RETRO;
 
-std::string CSavestateUtils::MakePath(const std::string &gamePath)
+std::string CSavestateUtils::MakePath(const std::string& gamePath)
 {
   return URIUtils::ReplaceExtension(gamePath, SAVESTATE_EXTENSION);
 }
diff --git a/xbmc/cores/RetroPlayer/savestates/SavestateUtils.h b/xbmc/cores/RetroPlayer/savestates/SavestateUtils.h
index fb6e6b8b9d39..372d56028461 100644
--- a/xbmc/cores/RetroPlayer/savestates/SavestateUtils.h
+++ b/xbmc/cores/RetroPlayer/savestates/SavestateUtils.h
@@ -14,16 +14,16 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CSavestateUtils
-  {
-  public:
-    /*!
-     * \brief Calculate a savestate path for the specified game
-     *
-     * The savestate path is the game path with the extension replaced
-     * by ".sav".
-     */
-    static std::string MakePath(const std::string &gamePath);
-  };
-}
-}
+class CSavestateUtils
+{
+public:
+  /*!
+   * \brief Calculate a savestate path for the specified game
+   *
+   * The savestate path is the game path with the extension replaced
+   * by ".sav".
+   */
+  static std::string MakePath(const std::string& gamePath);
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/IRetroPlayerStream.h b/xbmc/cores/RetroPlayer/streams/IRetroPlayerStream.h
index f5a202d09613..dddf3ff83f9f 100644
--- a/xbmc/cores/RetroPlayer/streams/IRetroPlayerStream.h
+++ b/xbmc/cores/RetroPlayer/streams/IRetroPlayerStream.h
@@ -63,5 +63,5 @@ class IRetroPlayerStream
   virtual void CloseStream() = 0;
 };
 
-}
-}
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/IStreamManager.h b/xbmc/cores/RetroPlayer/streams/IStreamManager.h
index 48549bb3c514..b4906425947b 100644
--- a/xbmc/cores/RetroPlayer/streams/IStreamManager.h
+++ b/xbmc/cores/RetroPlayer/streams/IStreamManager.h
@@ -37,5 +37,5 @@ class IStreamManager
   virtual void CloseStream(StreamPtr stream) = 0;
 };
 
-}
-}
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/RPStreamManager.cpp b/xbmc/cores/RetroPlayer/streams/RPStreamManager.cpp
index 25534c031925..2682d4d01b49 100644
--- a/xbmc/cores/RetroPlayer/streams/RPStreamManager.cpp
+++ b/xbmc/cores/RetroPlayer/streams/RPStreamManager.cpp
@@ -15,9 +15,8 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRPStreamManager::CRPStreamManager(CRPRenderManager& renderManager, CRPProcessInfo& processInfo) :
-  m_renderManager(renderManager),
-  m_processInfo(processInfo)
+CRPStreamManager::CRPStreamManager(CRPRenderManager& renderManager, CRPProcessInfo& processInfo)
+  : m_renderManager(renderManager), m_processInfo(processInfo)
 {
 }
 
@@ -31,24 +30,24 @@ StreamPtr CRPStreamManager::CreateStream(StreamType streamType)
 {
   switch (streamType)
   {
-  case StreamType::AUDIO:
-  {
-    // Save pointer to audio stream
-    m_audioStream = new CRetroPlayerAudio(m_processInfo);
+    case StreamType::AUDIO:
+    {
+      // Save pointer to audio stream
+      m_audioStream = new CRetroPlayerAudio(m_processInfo);
 
-    return StreamPtr(m_audioStream);
-  }
-  case StreamType::VIDEO:
-  case StreamType::SW_BUFFER:
-  {
-    return StreamPtr(new CRetroPlayerVideo(m_renderManager, m_processInfo));
-  }
-  case StreamType::HW_BUFFER:
-  {
-    //return StreamPtr(new CRetroPlayerHardware(m_renderManager, m_processInfo)); //! @todo
-  }
-  default:
-    break;
+      return StreamPtr(m_audioStream);
+    }
+    case StreamType::VIDEO:
+    case StreamType::SW_BUFFER:
+    {
+      return StreamPtr(new CRetroPlayerVideo(m_renderManager, m_processInfo));
+    }
+    case StreamType::HW_BUFFER:
+    {
+      // return StreamPtr(new CRetroPlayerHardware(m_renderManager, m_processInfo)); //! @todo
+    }
+    default:
+      break;
   }
 
   return StreamPtr();
diff --git a/xbmc/cores/RetroPlayer/streams/RPStreamManager.h b/xbmc/cores/RetroPlayer/streams/RPStreamManager.h
index e6f317cbbde9..3615329ebf6e 100644
--- a/xbmc/cores/RetroPlayer/streams/RPStreamManager.h
+++ b/xbmc/cores/RetroPlayer/streams/RPStreamManager.h
@@ -14,29 +14,29 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRetroPlayerAudio;
-  class CRPProcessInfo;
-  class CRPRenderManager;
-
-  class CRPStreamManager : public IStreamManager
-  {
-  public:
-    CRPStreamManager(CRPRenderManager& renderManager, CRPProcessInfo& processInfo);
-    ~CRPStreamManager() override = default;
-
-    void EnableAudio(bool bEnable);
-
-    // Implementation of IStreamManager
-    StreamPtr CreateStream(StreamType streamType) override;
-    void CloseStream(StreamPtr stream) override;
-
-  private:
-    // Construction parameters
-    CRPRenderManager& m_renderManager;
-    CRPProcessInfo& m_processInfo;
-
-    // Stream parameters
-    CRetroPlayerAudio* m_audioStream = nullptr;
-  };
-}
-}
+class CRetroPlayerAudio;
+class CRPProcessInfo;
+class CRPRenderManager;
+
+class CRPStreamManager : public IStreamManager
+{
+public:
+  CRPStreamManager(CRPRenderManager& renderManager, CRPProcessInfo& processInfo);
+  ~CRPStreamManager() override = default;
+
+  void EnableAudio(bool bEnable);
+
+  // Implementation of IStreamManager
+  StreamPtr CreateStream(StreamType streamType) override;
+  void CloseStream(StreamPtr stream) override;
+
+private:
+  // Construction parameters
+  CRPRenderManager& m_renderManager;
+  CRPProcessInfo& m_processInfo;
+
+  // Stream parameters
+  CRetroPlayerAudio* m_audioStream = nullptr;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/RetroPlayerAudio.cpp b/xbmc/cores/RetroPlayer/streams/RetroPlayerAudio.cpp
index 891e6fc7d08f..cca732e7a075 100644
--- a/xbmc/cores/RetroPlayer/streams/RetroPlayerAudio.cpp
+++ b/xbmc/cores/RetroPlayer/streams/RetroPlayerAudio.cpp
@@ -24,10 +24,8 @@ using namespace RETRO;
 
 const double MAX_DELAY = 0.3; // seconds
 
-CRetroPlayerAudio::CRetroPlayerAudio(CRPProcessInfo& processInfo) :
-  m_processInfo(processInfo),
-  m_pAudioStream(nullptr),
-  m_bAudioEnabled(true)
+CRetroPlayerAudio::CRetroPlayerAudio(CRPProcessInfo& processInfo)
+  : m_processInfo(processInfo), m_pAudioStream(nullptr), m_bAudioEnabled(true)
 {
   CLog::Log(LOGDEBUG, "RetroPlayer[AUDIO]: Initializing audio");
 }
@@ -41,12 +39,14 @@ CRetroPlayerAudio::~CRetroPlayerAudio()
 
 bool CRetroPlayerAudio::OpenStream(const StreamProperties& properties)
 {
-  const AudioStreamProperties& audioProperties = static_cast<const AudioStreamProperties&>(properties);
+  const AudioStreamProperties& audioProperties =
+      static_cast<const AudioStreamProperties&>(properties);
 
   const AEDataFormat pcmFormat = CAudioTranslator::TranslatePCMFormat(audioProperties.format);
   if (pcmFormat == AE_FMT_INVALID)
   {
-    CLog::Log(LOGERROR, "RetroPlayer[AUDIO]: Unknown PCM format: %d", static_cast<int>(audioProperties.format));
+    CLog::Log(LOGERROR, "RetroPlayer[AUDIO]: Unknown PCM format: %d",
+              static_cast<int>(audioProperties.format));
     return false;
   }
 
@@ -81,10 +81,10 @@ bool CRetroPlayerAudio::OpenStream(const StreamProperties& properties)
   if (audioEngine == nullptr)
     return false;
 
-  CLog::Log(LOGINFO, "RetroPlayer[AUDIO]: Creating audio stream, format = %s, sample rate = %d, channels = %d",
-             CAEUtil::DataFormatToStr(pcmFormat)
-             , iSampleRate
-             , channelLayout.Count());
+  CLog::Log(
+      LOGINFO,
+      "RetroPlayer[AUDIO]: Creating audio stream, format = %s, sample rate = %d, channels = %d",
+      CAEUtil::DataFormatToStr(pcmFormat), iSampleRate, channelLayout.Count());
 
   AEAudioFormat audioFormat;
   audioFormat.m_dataFormat = pcmFormat;
@@ -105,7 +105,7 @@ bool CRetroPlayerAudio::OpenStream(const StreamProperties& properties)
   return true;
 }
 
-void CRetroPlayerAudio::AddStreamData(const StreamPacket &packet)
+void CRetroPlayerAudio::AddStreamData(const StreamPacket& packet)
 {
   const AudioStreamPacket& audioPacket = static_cast<const AudioStreamPacket&>(packet);
 
@@ -115,14 +115,16 @@ void CRetroPlayerAudio::AddStreamData(const StreamPacket &packet)
     {
       const double delaySecs = m_pAudioStream->GetDelay();
 
-      const size_t frameSize = m_pAudioStream->GetChannelCount() * (CAEUtil::DataFormatToBits(m_pAudioStream->GetDataFormat()) >> 3);
+      const size_t frameSize = m_pAudioStream->GetChannelCount() *
+                               (CAEUtil::DataFormatToBits(m_pAudioStream->GetDataFormat()) >> 3);
 
       const unsigned int frameCount = static_cast<unsigned int>(audioPacket.size / frameSize);
 
       if (delaySecs > MAX_DELAY)
       {
         m_pAudioStream->Flush();
-        CLog::Log(LOGDEBUG, "RetroPlayer[AUDIO]: Audio delay (%0.2f ms) is too high - flushing", delaySecs * 1000);
+        CLog::Log(LOGDEBUG, "RetroPlayer[AUDIO]: Audio delay (%0.2f ms) is too high - flushing",
+                  delaySecs * 1000);
       }
 
       m_pAudioStream->AddData(&audioPacket.data, 0, frameCount, nullptr);
diff --git a/xbmc/cores/RetroPlayer/streams/RetroPlayerAudio.h b/xbmc/cores/RetroPlayer/streams/RetroPlayerAudio.h
index 3b324f73ed1b..587748961720 100644
--- a/xbmc/cores/RetroPlayer/streams/RetroPlayerAudio.h
+++ b/xbmc/cores/RetroPlayer/streams/RetroPlayerAudio.h
@@ -18,52 +18,49 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfo;
+class CRPProcessInfo;
 
-  struct AudioStreamProperties : public StreamProperties
+struct AudioStreamProperties : public StreamProperties
+{
+  AudioStreamProperties(PCMFormat format, double sampleRate, AudioChannelMap channelMap)
+    : format(format), sampleRate(sampleRate), channelMap(channelMap)
   {
-    AudioStreamProperties(PCMFormat format, double sampleRate, AudioChannelMap channelMap) :
-      format(format),
-      sampleRate(sampleRate),
-      channelMap(channelMap)
-    {
-    }
+  }
 
-    PCMFormat format;
-    double sampleRate;
-    AudioChannelMap channelMap;
-  };
+  PCMFormat format;
+  double sampleRate;
+  AudioChannelMap channelMap;
+};
 
-  struct AudioStreamPacket : public StreamPacket
-  {
-    AudioStreamPacket(const uint8_t* data, size_t size) :
-      data(data),
-      size(size)
-    {
-    }
+struct AudioStreamPacket : public StreamPacket
+{
+  AudioStreamPacket(const uint8_t* data, size_t size) : data(data), size(size) {}
 
-    const uint8_t* data;
-    size_t size;
-  };
+  const uint8_t* data;
+  size_t size;
+};
 
-  class CRetroPlayerAudio : public IRetroPlayerStream
-  {
-  public:
-    explicit CRetroPlayerAudio(CRPProcessInfo& processInfo);
-    ~CRetroPlayerAudio() override;
+class CRetroPlayerAudio : public IRetroPlayerStream
+{
+public:
+  explicit CRetroPlayerAudio(CRPProcessInfo& processInfo);
+  ~CRetroPlayerAudio() override;
 
-    void Enable(bool bEnabled) { m_bAudioEnabled = bEnabled; }
+  void Enable(bool bEnabled) { m_bAudioEnabled = bEnabled; }
 
-    // implementation of IRetroPlayerStream
-    bool OpenStream(const StreamProperties& properties) override;
-    bool GetStreamBuffer(unsigned int width, unsigned int height, StreamBuffer& buffer) override { return false; }
-    void AddStreamData(const StreamPacket& packet) override;
-    void CloseStream() override;
+  // implementation of IRetroPlayerStream
+  bool OpenStream(const StreamProperties& properties) override;
+  bool GetStreamBuffer(unsigned int width, unsigned int height, StreamBuffer& buffer) override
+  {
+    return false;
+  }
+  void AddStreamData(const StreamPacket& packet) override;
+  void CloseStream() override;
 
-  private:
-    CRPProcessInfo& m_processInfo;
-    IAEStream* m_pAudioStream;
-    bool m_bAudioEnabled;
-  };
-}
-}
+private:
+  CRPProcessInfo& m_processInfo;
+  IAEStream* m_pAudioStream;
+  bool m_bAudioEnabled;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/RetroPlayerStreamTypes.h b/xbmc/cores/RetroPlayer/streams/RetroPlayerStreamTypes.h
index 6977fb523d34..aa5686adcd2a 100644
--- a/xbmc/cores/RetroPlayer/streams/RetroPlayerStreamTypes.h
+++ b/xbmc/cores/RetroPlayer/streams/RetroPlayerStreamTypes.h
@@ -34,8 +34,8 @@ enum class StreamType
 
 enum class PCMFormat
 {
- FMT_UNKNOWN,
- FMT_S16NE,
+  FMT_UNKNOWN,
+  FMT_S16NE,
 };
 
 enum class AudioChannel
@@ -82,5 +82,5 @@ enum class VideoRotation
   ROTATION_270_CCW,
 };
 
-}
-}
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.cpp b/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.cpp
index ee296101b964..dc2cf1dcd2e3 100644
--- a/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.cpp
+++ b/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.cpp
@@ -16,9 +16,8 @@
 using namespace KODI;
 using namespace RETRO;
 
-CRetroPlayerVideo::CRetroPlayerVideo(CRPRenderManager& renderManager, CRPProcessInfo& processInfo) :
-  m_renderManager(renderManager),
-  m_processInfo(processInfo)
+CRetroPlayerVideo::CRetroPlayerVideo(CRPRenderManager& renderManager, CRPProcessInfo& processInfo)
+  : m_renderManager(renderManager), m_processInfo(processInfo)
 {
   CLog::Log(LOGDEBUG, "RetroPlayer[VIDEO]: Initializing video");
 
@@ -35,7 +34,8 @@ CRetroPlayerVideo::~CRetroPlayerVideo()
 
 bool CRetroPlayerVideo::OpenStream(const StreamProperties& properties)
 {
-  const VideoStreamProperties& videoProperties = static_cast<const VideoStreamProperties&>(properties);
+  const VideoStreamProperties& videoProperties =
+      static_cast<const VideoStreamProperties&>(properties);
 
   if (m_bOpen)
   {
@@ -48,14 +48,12 @@ bool CRetroPlayerVideo::OpenStream(const StreamProperties& properties)
   const unsigned int nominalHeight = videoProperties.nominalHeight;
   const unsigned int maxWidth = videoProperties.maxWidth;
   const unsigned int maxHeight = videoProperties.maxHeight;
-  //const float pixelAspectRatio = videoProperties.pixelAspectRatio; //! @todo
+  // const float pixelAspectRatio = videoProperties.pixelAspectRatio; //! @todo
 
-  CLog::Log(LOGDEBUG, "RetroPlayer[VIDEO]: Creating video stream - format %s, nominal %ux%u, max %ux%u",
-      CRenderTranslator::TranslatePixelFormat(pixfmt),
-      nominalWidth,
-      nominalHeight,
-      maxWidth,
-      maxHeight);
+  CLog::Log(LOGDEBUG,
+            "RetroPlayer[VIDEO]: Creating video stream - format %s, nominal %ux%u, max %ux%u",
+            CRenderTranslator::TranslatePixelFormat(pixfmt), nominalWidth, nominalHeight, maxWidth,
+            maxHeight);
 
   m_processInfo.SetVideoPixelFormat(pixfmt);
   m_processInfo.SetVideoDimensions(nominalWidth, nominalHeight); // Report nominal height for now
@@ -66,23 +64,22 @@ bool CRetroPlayerVideo::OpenStream(const StreamProperties& properties)
   return m_bOpen;
 }
 
-bool CRetroPlayerVideo::GetStreamBuffer(unsigned int width, unsigned int height, StreamBuffer& buffer)
+bool CRetroPlayerVideo::GetStreamBuffer(unsigned int width,
+                                        unsigned int height,
+                                        StreamBuffer& buffer)
 {
   VideoStreamBuffer& videoBuffer = static_cast<VideoStreamBuffer&>(buffer);
 
   if (m_bOpen)
   {
-    return m_renderManager.GetVideoBuffer(width,
-                                          height,
-                                          videoBuffer.pixfmt,
-                                          videoBuffer.data,
+    return m_renderManager.GetVideoBuffer(width, height, videoBuffer.pixfmt, videoBuffer.data,
                                           videoBuffer.size);
   }
 
   return false;
 }
 
-void CRetroPlayerVideo::AddStreamData(const StreamPacket &packet)
+void CRetroPlayerVideo::AddStreamData(const StreamPacket& packet)
 {
   const VideoStreamPacket& videoPacket = static_cast<const VideoStreamPacket&>(packet);
 
@@ -91,24 +88,21 @@ void CRetroPlayerVideo::AddStreamData(const StreamPacket &packet)
     unsigned int orientationDegCCW = 0;
     switch (videoPacket.rotation)
     {
-    case VideoRotation::ROTATION_90_CCW:
-      orientationDegCCW = 90;
-      break;
-    case VideoRotation::ROTATION_180_CCW:
-      orientationDegCCW = 180;
-      break;
-    case VideoRotation::ROTATION_270_CCW:
-      orientationDegCCW = 270;
-      break;
-    default:
-      break;
+      case VideoRotation::ROTATION_90_CCW:
+        orientationDegCCW = 90;
+        break;
+      case VideoRotation::ROTATION_180_CCW:
+        orientationDegCCW = 180;
+        break;
+      case VideoRotation::ROTATION_270_CCW:
+        orientationDegCCW = 270;
+        break;
+      default:
+        break;
     }
 
-    m_renderManager.AddFrame(videoPacket.data,
-                             videoPacket.size,
-                             videoPacket.width,
-                             videoPacket.height,
-                             orientationDegCCW);
+    m_renderManager.AddFrame(videoPacket.data, videoPacket.size, videoPacket.width,
+                             videoPacket.height, orientationDegCCW);
   }
 }
 
diff --git a/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.h b/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.h
index bf76c43acbc6..9bfb8f4789c9 100644
--- a/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.h
+++ b/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.h
@@ -10,7 +10,8 @@
 
 #include "IRetroPlayerStream.h"
 
-extern "C" {
+extern "C"
+{
 #include <libavutil/pixfmt.h>
 }
 
@@ -18,78 +19,83 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CRPProcessInfo;
-  class CRPRenderManager;
+class CRPProcessInfo;
+class CRPRenderManager;
 
-  struct VideoStreamProperties : public StreamProperties
-  {
-    VideoStreamProperties(AVPixelFormat pixfmt, unsigned int nominalWidth, unsigned int nominalHeight, unsigned int maxWidth, unsigned int maxHeight, float pixelAspectRatio) :
-      pixfmt(pixfmt),
+struct VideoStreamProperties : public StreamProperties
+{
+  VideoStreamProperties(AVPixelFormat pixfmt,
+                        unsigned int nominalWidth,
+                        unsigned int nominalHeight,
+                        unsigned int maxWidth,
+                        unsigned int maxHeight,
+                        float pixelAspectRatio)
+    : pixfmt(pixfmt),
       nominalWidth(nominalWidth),
       nominalHeight(nominalHeight),
       maxWidth(maxWidth),
       maxHeight(maxHeight),
       pixelAspectRatio(pixelAspectRatio)
-    {
-    }
+  {
+  }
 
-    AVPixelFormat pixfmt;
-    unsigned int nominalWidth;
-    unsigned int nominalHeight;
-    unsigned int maxWidth;
-    unsigned int maxHeight;
-    float pixelAspectRatio;
-  };
+  AVPixelFormat pixfmt;
+  unsigned int nominalWidth;
+  unsigned int nominalHeight;
+  unsigned int maxWidth;
+  unsigned int maxHeight;
+  float pixelAspectRatio;
+};
 
-  struct VideoStreamBuffer : public StreamBuffer
-  {
-    AVPixelFormat pixfmt;
-    uint8_t *data;
-    size_t size;
-  };
+struct VideoStreamBuffer : public StreamBuffer
+{
+  AVPixelFormat pixfmt;
+  uint8_t* data;
+  size_t size;
+};
 
-  struct VideoStreamPacket: public StreamPacket
+struct VideoStreamPacket : public StreamPacket
+{
+  VideoStreamPacket(unsigned int width,
+                    unsigned int height,
+                    VideoRotation rotation,
+                    const uint8_t* data,
+                    size_t size)
+    : width(width), height(height), rotation(rotation), data(data), size(size)
   {
-    VideoStreamPacket(unsigned int width, unsigned int height, VideoRotation rotation, const uint8_t *data, size_t size) :
-      width(width),
-      height(height),
-      rotation(rotation),
-      data(data),
-      size(size)
-    {
-    }
+  }
 
-    unsigned int width;
-    unsigned int height;
-    VideoRotation rotation;
-    const uint8_t *data;
-    size_t size;
-  };
+  unsigned int width;
+  unsigned int height;
+  VideoRotation rotation;
+  const uint8_t* data;
+  size_t size;
+};
 
-  /*!
-   * \brief Renders video frames provided by the game loop
-   *
-   * \sa CRPRenderManager
-   */
-  class CRetroPlayerVideo : public IRetroPlayerStream
-  {
-  public:
-    CRetroPlayerVideo(CRPRenderManager& m_renderManager, CRPProcessInfo& m_processInfo);
-    ~CRetroPlayerVideo() override;
+/*!
+ * \brief Renders video frames provided by the game loop
+ *
+ * \sa CRPRenderManager
+ */
+class CRetroPlayerVideo : public IRetroPlayerStream
+{
+public:
+  CRetroPlayerVideo(CRPRenderManager& m_renderManager, CRPProcessInfo& m_processInfo);
+  ~CRetroPlayerVideo() override;
 
-    // implementation of IRetroPlayerStream
-    bool OpenStream(const StreamProperties& properties) override;
-    bool GetStreamBuffer(unsigned int width, unsigned int height, StreamBuffer& buffer) override;
-    void AddStreamData(const StreamPacket &packet) override;
-    void CloseStream() override;
+  // implementation of IRetroPlayerStream
+  bool OpenStream(const StreamProperties& properties) override;
+  bool GetStreamBuffer(unsigned int width, unsigned int height, StreamBuffer& buffer) override;
+  void AddStreamData(const StreamPacket& packet) override;
+  void CloseStream() override;
 
-  private:
-    // Construction parameters
-    CRPRenderManager& m_renderManager;
-    CRPProcessInfo& m_processInfo;
+private:
+  // Construction parameters
+  CRPRenderManager& m_renderManager;
+  CRPProcessInfo& m_processInfo;
 
-    // Stream properties
-    bool m_bOpen = false;
-  };
-}
-}
+  // Stream properties
+  bool m_bOpen = false;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/memory/BasicMemoryStream.h b/xbmc/cores/RetroPlayer/streams/memory/BasicMemoryStream.h
index a39e71b44fc9..c3cc71613025 100644
--- a/xbmc/cores/RetroPlayer/streams/memory/BasicMemoryStream.h
+++ b/xbmc/cores/RetroPlayer/streams/memory/BasicMemoryStream.h
@@ -16,33 +16,33 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CBasicMemoryStream : public IMemoryStream
-  {
-  public:
-    CBasicMemoryStream();
+class CBasicMemoryStream : public IMemoryStream
+{
+public:
+  CBasicMemoryStream();
 
-    ~CBasicMemoryStream() override = default;
+  ~CBasicMemoryStream() override = default;
 
-    // implementation of IMemoryStream
-    void Init(size_t frameSize, uint64_t maxFrameCount) override;
-    void Reset() override;
-    size_t FrameSize() const override { return m_frameSize; }
-    uint64_t MaxFrameCount() const override { return 1; }
-    void SetMaxFrameCount(uint64_t maxFrameCount) override {}
-    uint8_t* BeginFrame() override;
-    void SubmitFrame() override;
-    const uint8_t* CurrentFrame() const override;
-    uint64_t FutureFramesAvailable() const override { return 0; }
-    uint64_t AdvanceFrames(uint64_t frameCount) override { return 0; }
-    uint64_t PastFramesAvailable() const override { return 0; }
-    uint64_t RewindFrames(uint64_t frameCount) override { return 0; }
-    uint64_t GetFrameCounter() const override { return 0; }
-    void SetFrameCounter(uint64_t frameCount) override{};
+  // implementation of IMemoryStream
+  void Init(size_t frameSize, uint64_t maxFrameCount) override;
+  void Reset() override;
+  size_t FrameSize() const override { return m_frameSize; }
+  uint64_t MaxFrameCount() const override { return 1; }
+  void SetMaxFrameCount(uint64_t maxFrameCount) override {}
+  uint8_t* BeginFrame() override;
+  void SubmitFrame() override;
+  const uint8_t* CurrentFrame() const override;
+  uint64_t FutureFramesAvailable() const override { return 0; }
+  uint64_t AdvanceFrames(uint64_t frameCount) override { return 0; }
+  uint64_t PastFramesAvailable() const override { return 0; }
+  uint64_t RewindFrames(uint64_t frameCount) override { return 0; }
+  uint64_t GetFrameCounter() const override { return 0; }
+  void SetFrameCounter(uint64_t frameCount) override{};
 
-  private:
-    size_t m_frameSize;
-    std::unique_ptr<uint8_t[]> m_frameBuffer;
-    bool m_bHasFrame;
-  };
-}
-}
+private:
+  size_t m_frameSize;
+  std::unique_ptr<uint8_t[]> m_frameBuffer;
+  bool m_bHasFrame;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/memory/DeltaPairMemoryStream.cpp b/xbmc/cores/RetroPlayer/streams/memory/DeltaPairMemoryStream.cpp
index abef29bb8255..b6a274b565f7 100644
--- a/xbmc/cores/RetroPlayer/streams/memory/DeltaPairMemoryStream.cpp
+++ b/xbmc/cores/RetroPlayer/streams/memory/DeltaPairMemoryStream.cpp
@@ -36,7 +36,7 @@ void CDeltaPairMemoryStream::SubmitFrameInternal()
     uint32_t xor_val = currentFrame[i] ^ nextFrame[i];
     if (xor_val)
     {
-      DeltaPair pair = { i, xor_val };
+      DeltaPair pair = {i, xor_val};
       frame.buffer.push_back(pair);
     }
   }
@@ -89,7 +89,9 @@ void CDeltaPairMemoryStream::CullPastFrames(uint64_t frameCount)
   {
     if (m_rewindBuffer.empty())
     {
-      CLog::Log(LOGDEBUG, "CDeltaPairMemoryStream: Tried to cull %d frames too many. Check your math!", frameCount - removedCount);
+      CLog::Log(LOGDEBUG,
+                "CDeltaPairMemoryStream: Tried to cull %d frames too many. Check your math!",
+                frameCount - removedCount);
       break;
     }
     m_rewindBuffer.pop_front();
diff --git a/xbmc/cores/RetroPlayer/streams/memory/DeltaPairMemoryStream.h b/xbmc/cores/RetroPlayer/streams/memory/DeltaPairMemoryStream.h
index a28abc9837e0..b2a7cc8e4f83 100644
--- a/xbmc/cores/RetroPlayer/streams/memory/DeltaPairMemoryStream.h
+++ b/xbmc/cores/RetroPlayer/streams/memory/DeltaPairMemoryStream.h
@@ -17,51 +17,51 @@ namespace KODI
 {
 namespace RETRO
 {
-  /*!
-   * \brief Implementation of a linear memory stream using XOR deltas
-   */
-  class CDeltaPairMemoryStream : public CLinearMemoryStream
-  {
-  public:
-    CDeltaPairMemoryStream() = default;
-
-    ~CDeltaPairMemoryStream() override = default;
+/*!
+ * \brief Implementation of a linear memory stream using XOR deltas
+ */
+class CDeltaPairMemoryStream : public CLinearMemoryStream
+{
+public:
+  CDeltaPairMemoryStream() = default;
 
-    // implementation of IMemoryStream via CLinearMemoryStream
-    void Reset() override;
-    uint64_t PastFramesAvailable() const override;
-    uint64_t RewindFrames(uint64_t frameCount) override;
+  ~CDeltaPairMemoryStream() override = default;
 
-  protected:
-    // implementation of CLinearMemoryStream
-    void SubmitFrameInternal() override;
-    void CullPastFrames(uint64_t frameCount) override;
+  // implementation of IMemoryStream via CLinearMemoryStream
+  void Reset() override;
+  uint64_t PastFramesAvailable() const override;
+  uint64_t RewindFrames(uint64_t frameCount) override;
 
-    /*!
-     * Rewinding is implemented by applying XOR deltas on the specific parts of
-     * the save state buffer which have changed. In practice, this is very fast
-     * and simple (linear scan) and allows deltas to be compressed down to 1-3%
-     * of original save state size depending on the system. The algorithm runs
-     * on 32 bits at a time for speed.
-     *
-     * Use std::deque here to achieve amortized O(1) on pop/push to front and
-     * back.
-     */
-    struct DeltaPair
-    {
-      size_t pos;
-      uint32_t delta;
-    };
+protected:
+  // implementation of CLinearMemoryStream
+  void SubmitFrameInternal() override;
+  void CullPastFrames(uint64_t frameCount) override;
 
-    using DeltaPairVector = std::vector<DeltaPair>;
+  /*!
+   * Rewinding is implemented by applying XOR deltas on the specific parts of
+   * the save state buffer which have changed. In practice, this is very fast
+   * and simple (linear scan) and allows deltas to be compressed down to 1-3%
+   * of original save state size depending on the system. The algorithm runs
+   * on 32 bits at a time for speed.
+   *
+   * Use std::deque here to achieve amortized O(1) on pop/push to front and
+   * back.
+   */
+  struct DeltaPair
+  {
+    size_t pos;
+    uint32_t delta;
+  };
 
-    struct MemoryFrame
-    {
-      DeltaPairVector buffer;
-      uint64_t frameHistoryCount;
-    };
+  using DeltaPairVector = std::vector<DeltaPair>;
 
-    std::deque<MemoryFrame> m_rewindBuffer;
+  struct MemoryFrame
+  {
+    DeltaPairVector buffer;
+    uint64_t frameHistoryCount;
   };
-}
-}
+
+  std::deque<MemoryFrame> m_rewindBuffer;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/memory/IMemoryStream.h b/xbmc/cores/RetroPlayer/streams/memory/IMemoryStream.h
index 574187e43573..379a6a473133 100644
--- a/xbmc/cores/RetroPlayer/streams/memory/IMemoryStream.h
+++ b/xbmc/cores/RetroPlayer/streams/memory/IMemoryStream.h
@@ -15,130 +15,130 @@ namespace KODI
 {
 namespace RETRO
 {
+/*!
+ * \brief Stream of serialized states from game clients
+ *
+ * A memory stream is composed of "frames" of memory representing serialized
+ * states of the game client. For each video frame run by the game loop, the
+ * game client's state is serialized into a buffer provided by this interface.
+ *
+ * Implementation of three types of memory streams are provided:
+ *
+ *   - Basic memory stream: has only a current frame, and supports neither
+ *         rewind nor forward seeking.
+ *
+ *         \sa CBasicMemoryStream
+ *
+ *   - Linear memory stream: can grow in one direction. It is possible to
+ *         rewind, but not fast-forward.
+ *
+ *         \sa CLinearMemoryStream
+ *
+ *   - Nonlinear memory stream: can have frames both ahead of and behind
+ *         the current frame. If a stream is rewound, it is possible to
+ *         recover these frames by seeking forward again.
+ *
+ *         \sa CNonlinearMemoryStream (TODO)
+ */
+class IMemoryStream
+{
+public:
+  virtual ~IMemoryStream() = default;
+
+  /*!
+   * \brief Initialize memory stream
+   *
+   * \param frameSize The size of the serialized memory state
+   * \param maxFrameCount The maximum number of frames this stream can hold
+   */
+  virtual void Init(size_t frameSize, uint64_t maxFrameCount) = 0;
+
+  /*!
+   * \brief Free any resources used by this stream
+   */
+  virtual void Reset() = 0;
+
+  /*!
+   * \brief Return the frame size passed to Init()
+   */
+  virtual size_t FrameSize() const = 0;
+
+  /*!
+   * \brief Return the current max frame count
+   */
+  virtual uint64_t MaxFrameCount() const = 0;
+
+  /*!
+   * \brief Update the max frame count
+   *
+   * Old frames may be deleted if the max frame count is reduced.
+   */
+  virtual void SetMaxFrameCount(uint64_t maxFrameCount) = 0;
+
   /*!
-   * \brief Stream of serialized states from game clients
+   * \ brief Get a pointer to which FrameSize() bytes can be written
    *
-   * A memory stream is composed of "frames" of memory representing serialized
-   * states of the game client. For each video frame run by the game loop, the
-   * game client's state is serialized into a buffer provided by this interface.
+   * The buffer exposed by this function is passed to the game client, which
+   * fills it with a serialization of its current state.
+   */
+  virtual uint8_t* BeginFrame() = 0;
+
+  /*!
+   * \brief Indicate that a frame of size FrameSize() has been written to the
+   *        location returned from BeginFrame()
+   */
+  virtual void SubmitFrame() = 0;
+
+  /*!
+   * \brief Get a pointer to the current frame
    *
-   * Implementation of three types of memory streams are provided:
+   * This function must have no side effects. The pointer is valid until the
+   * stream is modified.
    *
-   *   - Basic memory stream: has only a current frame, and supports neither
-   *         rewind nor forward seeking.
+   * \return A buffer of size FrameSize(), or nullptr if the stream is empty
+   */
+  virtual const uint8_t* CurrentFrame() const = 0;
+
+  /*!
+   * \brief Return the number of frames ahead of the current frame
    *
-   *         \sa CBasicMemoryStream
+   * If the stream supports forward seeking, frames that are passed over
+   * during a "rewind" operation can be recovered again.
+   */
+  virtual uint64_t FutureFramesAvailable() const = 0;
+
+  /*!
+   * \brief Seek ahead the specified number of frames
    *
-   *   - Linear memory stream: can grow in one direction. It is possible to
-   *         rewind, but not fast-forward.
+   * \return The number of frames advanced
+   */
+  virtual uint64_t AdvanceFrames(uint64_t frameCount) = 0;
+
+  /*!
+   * \brief Return the number of frames behind the current frame
+   */
+  virtual uint64_t PastFramesAvailable() const = 0;
+
+  /*!
+   * \brief Seek backwards the specified number of frames
    *
-   *         \sa CLinearMemoryStream
+   * \return The number of frames rewound
+   */
+  virtual uint64_t RewindFrames(uint64_t frameCount) = 0;
+
+  /*!
+   * \brief Get the total number of frames played until the current frame
    *
-   *   - Nonlinear memory stream: can have frames both ahead of and behind
-   *         the current frame. If a stream is rewound, it is possible to
-   *         recover these frames by seeking forward again.
+   * \return The history of the current frame, or 0 for unknown
+   */
+  virtual uint64_t GetFrameCounter() const = 0;
+
+  /*!
+   * \brief Set the total number of frames played until the current frame
    *
-   *         \sa CNonlinearMemoryStream (TODO)
+   * \param frameCount The history of the current frame
    */
-  class IMemoryStream
-  {
-  public:
-    virtual ~IMemoryStream() = default;
-
-    /*!
-     * \brief Initialize memory stream
-     *
-     * \param frameSize The size of the serialized memory state
-     * \param maxFrameCount The maximum number of frames this stream can hold
-     */
-    virtual void Init(size_t frameSize, uint64_t maxFrameCount) = 0;
-
-    /*!
-     * \brief Free any resources used by this stream
-     */
-    virtual void Reset() = 0;
-
-    /*!
-     * \brief Return the frame size passed to Init()
-     */
-    virtual size_t FrameSize() const = 0;
-
-    /*!
-     * \brief Return the current max frame count
-     */
-    virtual uint64_t MaxFrameCount() const = 0;
-
-    /*!
-     * \brief Update the max frame count
-     *
-     * Old frames may be deleted if the max frame count is reduced.
-     */
-    virtual void SetMaxFrameCount(uint64_t maxFrameCount) = 0;
-
-    /*!
-     * \ brief Get a pointer to which FrameSize() bytes can be written
-     *
-     * The buffer exposed by this function is passed to the game client, which
-     * fills it with a serialization of its current state.
-     */
-    virtual uint8_t* BeginFrame() = 0;
-
-    /*!
-     * \brief Indicate that a frame of size FrameSize() has been written to the
-     *        location returned from BeginFrame()
-     */
-    virtual void SubmitFrame() = 0;
-
-    /*!
-     * \brief Get a pointer to the current frame
-     *
-     * This function must have no side effects. The pointer is valid until the
-     * stream is modified.
-     *
-     * \return A buffer of size FrameSize(), or nullptr if the stream is empty
-     */
-    virtual const uint8_t* CurrentFrame() const = 0;
-
-    /*!
-     * \brief Return the number of frames ahead of the current frame
-     *
-     * If the stream supports forward seeking, frames that are passed over
-     * during a "rewind" operation can be recovered again.
-     */
-    virtual uint64_t FutureFramesAvailable() const = 0;
-
-    /*!
-     * \brief Seek ahead the specified number of frames
-     *
-     * \return The number of frames advanced
-     */
-    virtual uint64_t AdvanceFrames(uint64_t frameCount) = 0;
-
-    /*!
-     * \brief Return the number of frames behind the current frame
-     */
-    virtual uint64_t PastFramesAvailable() const = 0;
-
-    /*!
-     * \brief Seek backwards the specified number of frames
-     *
-     * \return The number of frames rewound
-     */
-    virtual uint64_t RewindFrames(uint64_t frameCount) = 0;
-
-    /*!
-     * \brief Get the total number of frames played until the current frame
-     *
-     * \return The history of the current frame, or 0 for unknown
-     */
-    virtual uint64_t GetFrameCounter() const = 0;
-
-    /*!
-     * \brief Set the total number of frames played until the current frame
-     *
-     * \param frameCount The history of the current frame
-     */
-    virtual void SetFrameCounter(uint64_t frameCount) = 0;
-  };
-}
-}
+  virtual void SetFrameCounter(uint64_t frameCount) = 0;
+};
+} // namespace RETRO
+} // namespace KODI
diff --git a/xbmc/cores/RetroPlayer/streams/memory/LinearMemoryStream.cpp b/xbmc/cores/RetroPlayer/streams/memory/LinearMemoryStream.cpp
index a6612c56b6a6..65a7959ef900 100644
--- a/xbmc/cores/RetroPlayer/streams/memory/LinearMemoryStream.cpp
+++ b/xbmc/cores/RetroPlayer/streams/memory/LinearMemoryStream.cpp
@@ -12,7 +12,7 @@ using namespace KODI;
 using namespace RETRO;
 
 // Pad forward to nearest boundary of bytes
-#define PAD_TO_CEIL(x, bytes)  ((((x) + (bytes) - 1) / (bytes)) * (bytes))
+#define PAD_TO_CEIL(x, bytes) ((((x) + (bytes)-1) / (bytes)) * (bytes))
 
 CLinearMemoryStream::CLinearMemoryStream()
 {
diff --git a/xbmc/cores/RetroPlayer/streams/memory/LinearMemoryStream.h b/xbmc/cores/RetroPlayer/streams/memory/LinearMemoryStream.h
index ebcfd3ab5ad8..f7b94650120f 100644
--- a/xbmc/cores/RetroPlayer/streams/memory/LinearMemoryStream.h
+++ b/xbmc/cores/RetroPlayer/streams/memory/LinearMemoryStream.h
@@ -17,53 +17,53 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CLinearMemoryStream : public IMemoryStream
-  {
-  public:
-    CLinearMemoryStream();
+class CLinearMemoryStream : public IMemoryStream
+{
+public:
+  CLinearMemoryStream();
 
-    ~CLinearMemoryStream() override = default;
+  ~CLinearMemoryStream() override = default;
 
-    // partial implementation of IMemoryStream
-    void Init(size_t frameSize, uint64_t maxFrameCount) override;
-    void Reset() override;
-    size_t FrameSize() const override { return m_frameSize; }
-    uint64_t MaxFrameCount() const override { return m_maxFrames; }
-    void SetMaxFrameCount(uint64_t maxFrameCount) override;
-    uint8_t* BeginFrame() override;
-    void SubmitFrame() override;
-    const uint8_t* CurrentFrame() const override;
-    uint64_t FutureFramesAvailable() const override { return 0; }
-    uint64_t AdvanceFrames(uint64_t frameCount) override { return 0; }
-    uint64_t PastFramesAvailable() const override = 0;
-    uint64_t RewindFrames(uint64_t frameCount) override = 0;
-    uint64_t GetFrameCounter() const override { return m_currentFrameHistory; }
-    void SetFrameCounter(uint64_t frameCount) override { m_currentFrameHistory = frameCount; }
+  // partial implementation of IMemoryStream
+  void Init(size_t frameSize, uint64_t maxFrameCount) override;
+  void Reset() override;
+  size_t FrameSize() const override { return m_frameSize; }
+  uint64_t MaxFrameCount() const override { return m_maxFrames; }
+  void SetMaxFrameCount(uint64_t maxFrameCount) override;
+  uint8_t* BeginFrame() override;
+  void SubmitFrame() override;
+  const uint8_t* CurrentFrame() const override;
+  uint64_t FutureFramesAvailable() const override { return 0; }
+  uint64_t AdvanceFrames(uint64_t frameCount) override { return 0; }
+  uint64_t PastFramesAvailable() const override = 0;
+  uint64_t RewindFrames(uint64_t frameCount) override = 0;
+  uint64_t GetFrameCounter() const override { return m_currentFrameHistory; }
+  void SetFrameCounter(uint64_t frameCount) override { m_currentFrameHistory = frameCount; }
 
-  protected:
-    virtual void SubmitFrameInternal() = 0;
-    virtual void CullPastFrames(uint64_t frameCount) = 0;
+protected:
+  virtual void SubmitFrameInternal() = 0;
+  virtual void CullPastFrames(uint64_t frameCount) = 0;
 
-    // Helper function
-    uint64_t BufferSize() const;
+  // Helper function
+  uint64_t BufferSize() const;
 
-    size_t m_paddedFrameSize;
-    uint64_t m_maxFrames;
+  size_t m_paddedFrameSize;
+  uint64_t m_maxFrames;
 
-    /**
-     * Simple double-buffering. After XORing the two states, the next becomes
-     * the current, and the current becomes a buffer for the next call to
-     * CGameClient::Serialize().
-     */
-    std::unique_ptr<uint32_t[]> m_currentFrame;
-    std::unique_ptr<uint32_t[]> m_nextFrame;
-    bool m_bHasCurrentFrame;
-    bool m_bHasNextFrame;
+  /**
+   * Simple double-buffering. After XORing the two states, the next becomes
+   * the current, and the current becomes a buffer for the next call to
+   * CGameClient::Serialize().
+   */
+  std::unique_ptr<uint32_t[]> m_currentFrame;
+  std::unique_ptr<uint32_t[]> m_nextFrame;
+  bool m_bHasCurrentFrame;
+  bool m_bHasNextFrame;
 
-    uint64_t m_currentFrameHistory;
+  uint64_t m_currentFrameHistory;
 
-  private:
-    size_t m_frameSize;
-  };
-}
-}
+private:
+  size_t m_frameSize;
+};
+} // namespace RETRO
+} // namespace KODI

From d1e6fff19c1cf2a266f0429c8d0ddea3195ddcce Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Tue, 26 May 2020 17:41:46 -0700
Subject: [PATCH 3/7] Games: Clang-format files

---
 xbmc/games/GameServices.cpp                   |   16 +-
 xbmc/games/GameServices.h                     |   60 +-
 xbmc/games/GameSettings.cpp                   |   21 +-
 xbmc/games/GameSettings.h                     |    5 +-
 xbmc/games/GameTypes.h                        |   22 +-
 xbmc/games/GameUtils.cpp                      |   33 +-
 xbmc/games/GameUtils.h                        |   82 +-
 xbmc/games/addons/GameClient.cpp              |  187 +--
 xbmc/games/addons/GameClient.h                |   74 +-
 xbmc/games/addons/GameClientCallbacks.h       |   40 +-
 xbmc/games/addons/GameClientInGameSaves.cpp   |   50 +-
 xbmc/games/addons/GameClientInGameSaves.h     |   75 +-
 xbmc/games/addons/GameClientProperties.cpp    |   34 +-
 xbmc/games/addons/GameClientProperties.h      |    8 +-
 xbmc/games/addons/GameClientSubsystem.cpp     |   22 +-
 xbmc/games/addons/GameClientSubsystem.h       |  100 +-
 xbmc/games/addons/GameClientTranslator.cpp    |  246 ++--
 xbmc/games/addons/GameClientTranslator.h      |  161 +--
 .../addons/input/GameClientController.cpp     |    8 +-
 .../games/addons/input/GameClientController.h |   62 +-
 xbmc/games/addons/input/GameClientDevice.cpp  |   16 +-
 xbmc/games/addons/input/GameClientDevice.h    |   90 +-
 .../games/addons/input/GameClientHardware.cpp |    3 +-
 xbmc/games/addons/input/GameClientHardware.h  |   42 +-
 xbmc/games/addons/input/GameClientInput.cpp   |  174 +--
 xbmc/games/addons/input/GameClientInput.h     |  177 ++-
 .../games/addons/input/GameClientJoystick.cpp |  106 +-
 xbmc/games/addons/input/GameClientJoystick.h  |   99 +-
 .../games/addons/input/GameClientKeyboard.cpp |   54 +-
 xbmc/games/addons/input/GameClientKeyboard.h  |   80 +-
 xbmc/games/addons/input/GameClientMouse.cpp   |   44 +-
 xbmc/games/addons/input/GameClientMouse.h     |   78 +-
 xbmc/games/addons/input/GameClientPort.cpp    |   21 +-
 xbmc/games/addons/input/GameClientPort.h      |  128 +--
 .../games/addons/input/GameClientTopology.cpp |   25 +-
 xbmc/games/addons/input/GameClientTopology.h  |   47 +-
 .../addons/streams/GameClientStreamAudio.cpp  |   34 +-
 .../addons/streams/GameClientStreamAudio.h    |   11 +-
 .../streams/GameClientStreamSwFramebuffer.cpp |    4 +-
 .../streams/GameClientStreamSwFramebuffer.h   |    2 +-
 .../addons/streams/GameClientStreamVideo.cpp  |   28 +-
 .../addons/streams/GameClientStreamVideo.h    |    9 +-
 .../addons/streams/GameClientStreams.cpp      |   50 +-
 xbmc/games/addons/streams/GameClientStreams.h |    6 +-
 xbmc/games/addons/streams/IGameClientStream.h |    9 +-
 xbmc/games/controllers/Controller.cpp         |   36 +-
 xbmc/games/controllers/Controller.h           |   11 +-
 .../games/controllers/ControllerDefinitions.h |   84 +-
 xbmc/games/controllers/ControllerFeature.cpp  |   20 +-
 xbmc/games/controllers/ControllerFeature.h    |    8 +-
 xbmc/games/controllers/ControllerIDs.h        |    8 +-
 xbmc/games/controllers/ControllerLayout.cpp   |   37 +-
 xbmc/games/controllers/ControllerLayout.h     |   16 +-
 xbmc/games/controllers/ControllerManager.h    |   96 +-
 xbmc/games/controllers/ControllerTopology.cpp |   21 +-
 xbmc/games/controllers/ControllerTopology.h   |   12 +-
 .../controllers/ControllerTranslator.cpp      | 1000 +++++++++++------
 xbmc/games/controllers/ControllerTranslator.h |    8 +-
 xbmc/games/controllers/ControllerTypes.h      |   30 +-
 .../dialogs/GUIDialogAxisDetection.cpp        |   19 +-
 .../dialogs/GUIDialogAxisDetection.h          |   68 +-
 .../dialogs/GUIDialogButtonCapture.cpp        |   39 +-
 .../dialogs/GUIDialogButtonCapture.h          |   72 +-
 .../dialogs/GUIDialogIgnoreInput.cpp          |   36 +-
 .../dialogs/GUIDialogIgnoreInput.h            |   54 +-
 .../guicontrols/GUICardinalFeatureButton.cpp  |   24 +-
 .../guicontrols/GUICardinalFeatureButton.h    |   60 +-
 .../controllers/guicontrols/GUIControlTypes.h |   30 +-
 .../guicontrols/GUIControllerButton.cpp       |    6 +-
 .../guicontrols/GUIControllerButton.h         |   18 +-
 .../guicontrols/GUIFeatureButton.cpp          |   11 +-
 .../guicontrols/GUIFeatureButton.h            |   86 +-
 .../guicontrols/GUIFeatureControls.cpp        |   11 +-
 .../guicontrols/GUIFeatureControls.h          |   30 +-
 .../guicontrols/GUIFeatureFactory.cpp         |   28 +-
 .../guicontrols/GUIFeatureFactory.h           |   36 +-
 .../guicontrols/GUIFeatureTranslator.cpp      |   26 +-
 .../guicontrols/GUIFeatureTranslator.h        |   20 +-
 .../guicontrols/GUIGameController.cpp         |    6 +-
 .../guicontrols/GUIGameController.h           |   33 +-
 .../guicontrols/GUIScalarFeatureButton.cpp    |    8 +-
 .../guicontrols/GUIScalarFeatureButton.h      |   44 +-
 .../guicontrols/GUISelectKeyButton.cpp        |   14 +-
 .../guicontrols/GUISelectKeyButton.h          |   64 +-
 .../guicontrols/GUIThrottleButton.cpp         |   14 +-
 .../guicontrols/GUIThrottleButton.h           |   48 +-
 .../guicontrols/GUIWheelButton.cpp            |   14 +-
 .../controllers/guicontrols/GUIWheelButton.h  |   48 +-
 .../controllers/types/ControllerGrid.cpp      |  113 +-
 xbmc/games/controllers/types/ControllerGrid.h |  264 ++---
 .../controllers/types/ControllerTree.cpp      |   75 +-
 xbmc/games/controllers/types/ControllerTree.h |  398 ++++---
 .../windows/ControllerInstaller.cpp           |   37 +-
 .../controllers/windows/ControllerInstaller.h |   22 +-
 .../windows/GUIConfigurationWizard.cpp        |   35 +-
 .../windows/GUIConfigurationWizard.h          |  163 +--
 .../windows/GUIControllerDefines.h            |   52 +-
 .../controllers/windows/GUIControllerList.cpp |   72 +-
 .../controllers/windows/GUIControllerList.h   |   72 +-
 .../windows/GUIControllerWindow.cpp           |   46 +-
 .../controllers/windows/GUIControllerWindow.h |   78 +-
 .../controllers/windows/GUIFeatureList.cpp    |   49 +-
 .../controllers/windows/GUIFeatureList.h      |   88 +-
 .../windows/IConfigurationWindow.h            |  415 +++----
 .../dialogs/GUIDialogSelectGameClient.cpp     |   38 +-
 .../games/dialogs/GUIDialogSelectGameClient.h |  113 +-
 .../osd/DialogGameAdvancedSettings.cpp        |   33 +-
 .../dialogs/osd/DialogGameAdvancedSettings.h  |   22 +-
 xbmc/games/dialogs/osd/DialogGameOSD.cpp      |   11 +-
 xbmc/games/dialogs/osd/DialogGameOSD.h        |   72 +-
 xbmc/games/dialogs/osd/DialogGameOSDHelp.cpp  |   11 +-
 xbmc/games/dialogs/osd/DialogGameOSDHelp.h    |   40 +-
 .../dialogs/osd/DialogGameStretchMode.cpp     |   34 +-
 .../games/dialogs/osd/DialogGameStretchMode.h |   58 +-
 .../dialogs/osd/DialogGameVideoFilter.cpp     |   55 +-
 .../games/dialogs/osd/DialogGameVideoFilter.h |   56 +-
 .../dialogs/osd/DialogGameVideoRotation.cpp   |   32 +-
 .../dialogs/osd/DialogGameVideoRotation.h     |   42 +-
 .../dialogs/osd/DialogGameVideoSelect.cpp     |   30 +-
 .../games/dialogs/osd/DialogGameVideoSelect.h |   74 +-
 xbmc/games/dialogs/osd/DialogGameVolume.cpp   |   17 +-
 xbmc/games/dialogs/osd/DialogGameVolume.h     |   93 +-
 xbmc/games/ports/InputSink.cpp                |   20 +-
 xbmc/games/ports/InputSink.h                  |   55 +-
 xbmc/games/ports/Port.cpp                     |   14 +-
 xbmc/games/ports/Port.h                       |   86 +-
 xbmc/games/tags/GameInfoTag.cpp               |   91 +-
 xbmc/games/tags/GameInfoTag.h                 |  181 +--
 .../games/windows/GUIViewStateWindowGames.cpp |   14 +-
 xbmc/games/windows/GUIViewStateWindowGames.h  |   30 +-
 xbmc/games/windows/GUIWindowGames.cpp         |  116 +-
 xbmc/games/windows/GUIWindowGames.h           |   54 +-
 132 files changed, 4566 insertions(+), 3902 deletions(-)

diff --git a/xbmc/games/GameServices.cpp b/xbmc/games/GameServices.cpp
index 49a20c9aaf88..ecd5f6bf3ebe 100644
--- a/xbmc/games/GameServices.cpp
+++ b/xbmc/games/GameServices.cpp
@@ -16,14 +16,14 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameServices::CGameServices(CControllerManager &controllerManager,
-                             RETRO:: CGUIGameRenderManager &renderManager,
-                             PERIPHERALS::CPeripherals &peripheralManager,
-                             const CProfileManager &profileManager) :
-  m_controllerManager(controllerManager),
-  m_gameRenderManager(renderManager),
-  m_profileManager(profileManager),
-  m_gameSettings(new CGameSettings())
+CGameServices::CGameServices(CControllerManager& controllerManager,
+                             RETRO::CGUIGameRenderManager& renderManager,
+                             PERIPHERALS::CPeripherals& peripheralManager,
+                             const CProfileManager& profileManager)
+  : m_controllerManager(controllerManager),
+    m_gameRenderManager(renderManager),
+    m_profileManager(profileManager),
+    m_gameSettings(new CGameSettings())
 {
 }
 
diff --git a/xbmc/games/GameServices.h b/xbmc/games/GameServices.h
index 48f61b1bb1d6..d489bf8b3906 100644
--- a/xbmc/games/GameServices.h
+++ b/xbmc/games/GameServices.h
@@ -17,50 +17,50 @@ class CProfileManager;
 
 namespace PERIPHERALS
 {
-  class CPeripherals;
+class CPeripherals;
 }
 
 namespace KODI
 {
 namespace RETRO
 {
-  class CGUIGameRenderManager;
+class CGUIGameRenderManager;
 }
 
 namespace GAME
 {
-  class CControllerManager;
-  class CGameSettings;
+class CControllerManager;
+class CGameSettings;
 
-  class CGameServices
-  {
-  public:
-    CGameServices(CControllerManager &controllerManager,
-                  RETRO::CGUIGameRenderManager &renderManager,
-                  PERIPHERALS::CPeripherals &peripheralManager,
-                  const CProfileManager &profileManager);
-    ~CGameServices();
+class CGameServices
+{
+public:
+  CGameServices(CControllerManager& controllerManager,
+                RETRO::CGUIGameRenderManager& renderManager,
+                PERIPHERALS::CPeripherals& peripheralManager,
+                const CProfileManager& profileManager);
+  ~CGameServices();
 
-    ControllerPtr GetController(const std::string& controllerId);
-    ControllerPtr GetDefaultController();
-    ControllerPtr GetDefaultKeyboard();
-    ControllerPtr GetDefaultMouse();
-    ControllerVector GetControllers();
+  ControllerPtr GetController(const std::string& controllerId);
+  ControllerPtr GetDefaultController();
+  ControllerPtr GetDefaultKeyboard();
+  ControllerPtr GetDefaultMouse();
+  ControllerVector GetControllers();
 
-    std::string GetSavestatesFolder() const;
+  std::string GetSavestatesFolder() const;
 
-    CGameSettings& GameSettings() { return *m_gameSettings; }
+  CGameSettings& GameSettings() { return *m_gameSettings; }
 
-    RETRO::CGUIGameRenderManager &GameRenderManager() { return m_gameRenderManager; }
+  RETRO::CGUIGameRenderManager& GameRenderManager() { return m_gameRenderManager; }
 
-  private:
-    // Construction parameters
-    CControllerManager &m_controllerManager;
-    RETRO::CGUIGameRenderManager &m_gameRenderManager;
-    const CProfileManager &m_profileManager;
+private:
+  // Construction parameters
+  CControllerManager& m_controllerManager;
+  RETRO::CGUIGameRenderManager& m_gameRenderManager;
+  const CProfileManager& m_profileManager;
 
-    // Game services
-    std::unique_ptr<CGameSettings> m_gameSettings;
-  };
-}
-}
+  // Game services
+  std::unique_ptr<CGameSettings> m_gameSettings;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/GameSettings.cpp b/xbmc/games/GameSettings.cpp
index a9b0255aebf2..2bbfbf2bf05a 100644
--- a/xbmc/games/GameSettings.cpp
+++ b/xbmc/games/GameSettings.cpp
@@ -20,21 +20,21 @@ using namespace GAME;
 
 namespace
 {
-  const std::string SETTING_GAMES_ENABLE = "gamesgeneral.enable";
-  const std::string SETTING_GAMES_SHOW_OSD_HELP = "gamesgeneral.showosdhelp";
-  const std::string SETTING_GAMES_ENABLEAUTOSAVE = "gamesgeneral.enableautosave";
-  const std::string SETTING_GAMES_ENABLEREWIND = "gamesgeneral.enablerewind";
-  const std::string SETTING_GAMES_REWINDTIME = "gamesgeneral.rewindtime";
-}
+const std::string SETTING_GAMES_ENABLE = "gamesgeneral.enable";
+const std::string SETTING_GAMES_SHOW_OSD_HELP = "gamesgeneral.showosdhelp";
+const std::string SETTING_GAMES_ENABLEAUTOSAVE = "gamesgeneral.enableautosave";
+const std::string SETTING_GAMES_ENABLEREWIND = "gamesgeneral.enablerewind";
+const std::string SETTING_GAMES_REWINDTIME = "gamesgeneral.rewindtime";
+} // namespace
 
 CGameSettings::CGameSettings()
 {
   m_settings = CServiceBroker::GetSettingsComponent()->GetSettings();
 
   m_settings->RegisterCallback(this, {
-    SETTING_GAMES_ENABLEREWIND,
-    SETTING_GAMES_REWINDTIME,
-  });
+                                         SETTING_GAMES_ENABLEREWIND,
+                                         SETTING_GAMES_REWINDTIME,
+                                     });
 }
 
 CGameSettings::~CGameSettings()
@@ -92,8 +92,7 @@ void CGameSettings::OnSettingChanged(std::shared_ptr<const CSetting> setting)
 
   const std::string& settingId = setting->GetId();
 
-  if (settingId == SETTING_GAMES_ENABLEREWIND ||
-      settingId == SETTING_GAMES_REWINDTIME)
+  if (settingId == SETTING_GAMES_ENABLEREWIND || settingId == SETTING_GAMES_REWINDTIME)
   {
     SetChanged();
     NotifyObservers(ObservableMessageSettingsChanged);
diff --git a/xbmc/games/GameSettings.h b/xbmc/games/GameSettings.h
index b08f03abca1c..727ce01cf4a2 100644
--- a/xbmc/games/GameSettings.h
+++ b/xbmc/games/GameSettings.h
@@ -19,8 +19,7 @@ namespace KODI
 namespace GAME
 {
 
-class CGameSettings : public ISettingCallback,
-                      public Observable
+class CGameSettings : public ISettingCallback, public Observable
 {
 public:
   CGameSettings();
@@ -44,4 +43,4 @@ class CGameSettings : public ISettingCallback,
 };
 
 } // namespace GAME
-}
+} // namespace KODI
diff --git a/xbmc/games/GameTypes.h b/xbmc/games/GameTypes.h
index b135508bb50b..3be3195b20a6 100644
--- a/xbmc/games/GameTypes.h
+++ b/xbmc/games/GameTypes.h
@@ -16,17 +16,17 @@ namespace KODI
 namespace GAME
 {
 
-  class CGameClient;
-  using GameClientPtr = std::shared_ptr<CGameClient>;
-  using GameClientVector = std::vector<GameClientPtr>;
+class CGameClient;
+using GameClientPtr = std::shared_ptr<CGameClient>;
+using GameClientVector = std::vector<GameClientPtr>;
 
-  class CGameClientPort;
-  using GameClientPortPtr = std::unique_ptr<CGameClientPort>;
-  using GameClientPortVec = std::vector<GameClientPortPtr>;
+class CGameClientPort;
+using GameClientPortPtr = std::unique_ptr<CGameClientPort>;
+using GameClientPortVec = std::vector<GameClientPortPtr>;
 
-  class CGameClientDevice;
-  using GameClientDevicePtr = std::unique_ptr<CGameClientDevice>;
-  using GameClientDeviceVec = std::vector<GameClientDevicePtr>;
+class CGameClientDevice;
+using GameClientDevicePtr = std::unique_ptr<CGameClientDevice>;
+using GameClientDeviceVec = std::vector<GameClientDevicePtr>;
 
-}
-}
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/GameUtils.cpp b/xbmc/games/GameUtils.cpp
index 256d475c4974..1c0e8849353a 100644
--- a/xbmc/games/GameUtils.cpp
+++ b/xbmc/games/GameUtils.cpp
@@ -27,7 +27,7 @@
 using namespace KODI;
 using namespace GAME;
 
-bool CGameUtils::FillInGameClient(CFileItem &item, bool bPrompt)
+bool CGameUtils::FillInGameClient(CFileItem& item, bool bPrompt)
 {
   using namespace ADDON;
 
@@ -48,12 +48,13 @@ bool CGameUtils::FillInGameClient(CFileItem &item, bool bPrompt)
 
       if (candidates.empty() && installable.empty())
       {
-        int errorTextId = bHasVfsGameClient ?
-            35214 : // "This game can only be played directly from a hard drive or partition. Compressed files must be extracted."
-            35212;  // "This game isn't compatible with any available emulators."
+        int errorTextId =
+            bHasVfsGameClient ? 35214 : // "This game can only be played directly from a hard drive
+                                        // or partition. Compressed files must be extracted."
+                35212; // "This game isn't compatible with any available emulators."
 
         // "Failed to play game"
-        KODI::MESSAGING::HELPERS::ShowOKDialogText(CVariant{ 35210 }, CVariant{ errorTextId });
+        KODI::MESSAGING::HELPERS::ShowOKDialogText(CVariant{35210}, CVariant{errorTextId});
       }
       else if (candidates.size() == 1 && installable.empty())
       {
@@ -62,7 +63,8 @@ bool CGameUtils::FillInGameClient(CFileItem &item, bool bPrompt)
       }
       else
       {
-        std::string gameClient = CGUIDialogSelectGameClient::ShowAndGetGameClient(item.GetPath(), candidates, installable);
+        std::string gameClient = CGUIDialogSelectGameClient::ShowAndGetGameClient(
+            item.GetPath(), candidates, installable);
         if (!gameClient.empty())
           item.GetGameInfoTag()->SetGameClient(gameClient);
       }
@@ -72,7 +74,10 @@ bool CGameUtils::FillInGameClient(CFileItem &item, bool bPrompt)
   return !item.GetGameInfoTag()->GetGameClient().empty();
 }
 
-void CGameUtils::GetGameClients(const CFileItem& file, GameClientVector& candidates, GameClientVector& installable, bool& bHasVfsGameClient)
+void CGameUtils::GetGameClients(const CFileItem& file,
+                                GameClientVector& candidates,
+                                GameClientVector& installable,
+                                bool& bHasVfsGameClient)
 {
   using namespace ADDON;
 
@@ -100,8 +105,7 @@ void CGameUtils::GetGameClients(const CFileItem& file, GameClientVector& candida
 
   // Sort by name
   //! @todo Move to presentation code
-  auto SortByName = [](const GameClientPtr& lhs, const GameClientPtr& rhs)
-  {
+  auto SortByName = [](const GameClientPtr& lhs, const GameClientPtr& rhs) {
     std::string lhsName = lhs->Name();
     std::string rhsName = rhs->Name();
 
@@ -115,14 +119,17 @@ void CGameUtils::GetGameClients(const CFileItem& file, GameClientVector& candida
   std::sort(installable.begin(), installable.end(), SortByName);
 }
 
-void CGameUtils::GetGameClients(const ADDON::VECADDONS& addons, const CURL& translatedUrl, GameClientVector& candidates, bool& bHasVfsGameClient)
+void CGameUtils::GetGameClients(const ADDON::VECADDONS& addons,
+                                const CURL& translatedUrl,
+                                GameClientVector& candidates,
+                                bool& bHasVfsGameClient)
 {
   bHasVfsGameClient = false;
 
   const std::string extension = URIUtils::GetExtension(translatedUrl.Get());
 
-  const bool bIsLocalFile = (translatedUrl.GetProtocol() == "file" ||
-                             translatedUrl.GetProtocol().empty());
+  const bool bIsLocalFile =
+      (translatedUrl.GetProtocol() == "file" || translatedUrl.GetProtocol().empty());
 
   for (auto& addon : addons)
   {
@@ -143,7 +150,7 @@ void CGameUtils::GetGameClients(const ADDON::VECADDONS& addons, const CURL& tran
   }
 }
 
-bool CGameUtils::HasGameExtension(const std::string &path)
+bool CGameUtils::HasGameExtension(const std::string& path)
 {
   using namespace ADDON;
 
diff --git a/xbmc/games/GameUtils.h b/xbmc/games/GameUtils.h
index edd79651c206..d04fcf84ac1d 100644
--- a/xbmc/games/GameUtils.h
+++ b/xbmc/games/GameUtils.h
@@ -22,48 +22,54 @@ namespace KODI
 {
 namespace GAME
 {
+/*!
+ * \ingroup games
+ * \brief Game related utilities.
+ */
+class CGameUtils
+{
+public:
   /*!
-   * \ingroup games
-   * \brief Game related utilities.
+   * \brief Set the game client property, possibly via prompt, for the given item
+   *
+   * \param item The item with or without a game client in its info tag
+   * \param prompt If true and no game client was resolved, prompt the user for one
+   *
+   * \return True if the item has a valid game client ID in its info tag
    */
-  class CGameUtils
-  {
-  public:
-    /*!
-     * \brief Set the game client property, possibly via prompt, for the given item
-     *
-     * \param item The item with or without a game client in its info tag
-     * \param prompt If true and no game client was resolved, prompt the user for one
-     *
-     * \return True if the item has a valid game client ID in its info tag
-     */
-    static bool FillInGameClient(CFileItem &item, bool bPrompt);
+  static bool FillInGameClient(CFileItem& item, bool bPrompt);
 
-    /*!
-     * \brief Check if the file extension is supported by an add-on in
-     *        a local or remote repository
-     *
-     * \param path The path of the game file
-     *
-     * \return true if the path's extension is supported by a known game client
-     */
-    static bool HasGameExtension(const std::string& path);
+  /*!
+   * \brief Check if the file extension is supported by an add-on in
+   *        a local or remote repository
+   *
+   * \param path The path of the game file
+   *
+   * \return true if the path's extension is supported by a known game client
+   */
+  static bool HasGameExtension(const std::string& path);
 
-    /*!
-     * \brief Get all game extensions
-     */
-    static std::set<std::string> GetGameExtensions();
+  /*!
+   * \brief Get all game extensions
+   */
+  static std::set<std::string> GetGameExtensions();
 
-    /*!
-     * \brief Check if game script or game add-on can be launched directly
-     *
-     * \return true if the add-on can be launched, false otherwise
-     */
-    static bool IsStandaloneGame(const ADDON::AddonPtr& addon);
+  /*!
+   * \brief Check if game script or game add-on can be launched directly
+   *
+   * \return true if the add-on can be launched, false otherwise
+   */
+  static bool IsStandaloneGame(const ADDON::AddonPtr& addon);
 
-  private:
-    static void GetGameClients(const CFileItem& file, GameClientVector& candidates, GameClientVector& installable, bool& bHasVfsGameClient);
-    static void GetGameClients(const ADDON::VECADDONS& addons, const CURL& translatedUrl, GameClientVector& candidates, bool& bHasVfsGameClient);
-  };
+private:
+  static void GetGameClients(const CFileItem& file,
+                             GameClientVector& candidates,
+                             GameClientVector& installable,
+                             bool& bHasVfsGameClient);
+  static void GetGameClients(const ADDON::VECADDONS& addons,
+                             const CURL& translatedUrl,
+                             GameClientVector& candidates,
+                             bool& bHasVfsGameClient);
+};
 } // namespace GAME
-}
+} // namespace KODI
diff --git a/xbmc/games/addons/GameClient.cpp b/xbmc/games/addons/GameClient.cpp
index f53715f2712e..6222a8766e88 100644
--- a/xbmc/games/addons/GameClient.cpp
+++ b/xbmc/games/addons/GameClient.cpp
@@ -45,49 +45,50 @@ using namespace KODI;
 using namespace GAME;
 using namespace KODI::MESSAGING;
 
-#define EXTENSION_SEPARATOR          "|"
-#define EXTENSION_WILDCARD           "*"
+#define EXTENSION_SEPARATOR "|"
+#define EXTENSION_WILDCARD "*"
 
-#define GAME_PROPERTY_EXTENSIONS           "extensions"
-#define GAME_PROPERTY_SUPPORTS_VFS         "supports_vfs"
-#define GAME_PROPERTY_SUPPORTS_STANDALONE  "supports_standalone"
+#define GAME_PROPERTY_EXTENSIONS "extensions"
+#define GAME_PROPERTY_SUPPORTS_VFS "supports_vfs"
+#define GAME_PROPERTY_SUPPORTS_STANDALONE "supports_standalone"
 
 // --- NormalizeExtension ------------------------------------------------------
 
 namespace
 {
-  /*
-   * \brief Convert to lower case and canonicalize with a leading "."
-   */
-  std::string NormalizeExtension(const std::string& strExtension)
-  {
-    std::string ext = strExtension;
-
-    if (!ext.empty() && ext != EXTENSION_WILDCARD)
-    {
-      StringUtils::ToLower(ext);
+/*
+ * \brief Convert to lower case and canonicalize with a leading "."
+ */
+std::string NormalizeExtension(const std::string& strExtension)
+{
+  std::string ext = strExtension;
 
-      if (ext[0] != '.')
-        ext.insert(0, ".");
-    }
+  if (!ext.empty() && ext != EXTENSION_WILDCARD)
+  {
+    StringUtils::ToLower(ext);
 
-    return ext;
+    if (ext[0] != '.')
+      ext.insert(0, ".");
   }
+
+  return ext;
 }
+} // namespace
 
 // --- CGameClient -------------------------------------------------------------
 
-CGameClient::CGameClient(const ADDON::AddonInfoPtr& addonInfo) :
-  CAddonDll(addonInfo, ADDON::ADDON_GAMEDLL),
-  m_subsystems(CGameClientSubsystem::CreateSubsystems(*this, m_struct, m_critSection)),
-  m_bSupportsAllExtensions(false),
-  m_bIsPlaying(false),
-  m_serializeSize(0),
-  m_region(GAME_REGION_UNKNOWN)
+CGameClient::CGameClient(const ADDON::AddonInfoPtr& addonInfo)
+  : CAddonDll(addonInfo, ADDON::ADDON_GAMEDLL),
+    m_subsystems(CGameClientSubsystem::CreateSubsystems(*this, m_struct, m_critSection)),
+    m_bSupportsAllExtensions(false),
+    m_bIsPlaying(false),
+    m_serializeSize(0),
+    m_region(GAME_REGION_UNKNOWN)
 {
   using namespace ADDON;
 
-  std::vector<std::string> extensions = StringUtils::Split(Type(ADDON_GAMEDLL)->GetValue(GAME_PROPERTY_EXTENSIONS).asString(), EXTENSION_SEPARATOR);
+  std::vector<std::string> extensions = StringUtils::Split(
+      Type(ADDON_GAMEDLL)->GetValue(GAME_PROPERTY_EXTENSIONS).asString(), EXTENSION_SEPARATOR);
   std::transform(extensions.begin(), extensions.end(),
                  std::inserter(m_extensions, m_extensions.begin()), NormalizeExtension);
 
@@ -99,7 +100,8 @@ CGameClient::CGameClient(const ADDON::AddonInfoPtr& addonInfo) :
   }
 
   m_bSupportsVFS = addonInfo->Type(ADDON_GAMEDLL)->GetValue(GAME_PROPERTY_SUPPORTS_VFS).asBoolean();
-  m_bSupportsStandalone = addonInfo->Type(ADDON_GAMEDLL)->GetValue(GAME_PROPERTY_SUPPORTS_STANDALONE).asBoolean();
+  m_bSupportsStandalone =
+      addonInfo->Type(ADDON_GAMEDLL)->GetValue(GAME_PROPERTY_SUPPORTS_STANDALONE).asBoolean();
 }
 
 CGameClient::~CGameClient(void)
@@ -150,7 +152,7 @@ bool CGameClient::Initialize(void)
     CDirectory::Create(Profile());
 
   // Ensure directory exists for savestates
-  const CGameServices &gameServices = CServiceBroker::GetGameServices();
+  const CGameServices& gameServices = CServiceBroker::GetGameServices();
   std::string savestatesDir = URIUtils::AddFileToFolder(gameServices.GetSavestatesFolder(), ID());
   if (!CDirectory::Exists(savestatesDir))
     CDirectory::Create(savestatesDir);
@@ -185,7 +187,9 @@ void CGameClient::Unload()
   DestroyInstance(this);
 }
 
-bool CGameClient::OpenFile(const CFileItem& file, RETRO::IStreamManager& streamManager, IGameInputCallback *input)
+bool CGameClient::OpenFile(const CFileItem& file,
+                           RETRO::IStreamManager& streamManager,
+                           IGameInputCallback* input)
 {
   // Check if we should open in standalone mode
   if (file.GetPath().empty())
@@ -197,7 +201,7 @@ bool CGameClient::OpenFile(const CFileItem& file, RETRO::IStreamManager& streamM
 
     // Failed to play game
     // The required files can't be found.
-    HELPERS::ShowOKDialogText(CVariant{ 35210 }, CVariant{ g_localizeStrings.Get(35219) });
+    HELPERS::ShowOKDialogText(CVariant{35210}, CVariant{g_localizeStrings.Get(35219)});
     return false;
   }
 
@@ -227,7 +231,10 @@ bool CGameClient::OpenFile(const CFileItem& file, RETRO::IStreamManager& streamM
   {
     LogError(error = m_struct.toAddon.LoadGame(&m_struct, path.c_str()), "LoadGame()");
   }
-  catch (...) { LogException("LoadGame()"); }
+  catch (...)
+  {
+    LogException("LoadGame()");
+  }
 
   if (error != GAME_ERROR_NO_ERROR)
   {
@@ -243,7 +250,7 @@ bool CGameClient::OpenFile(const CFileItem& file, RETRO::IStreamManager& streamM
   return true;
 }
 
-bool CGameClient::OpenStandalone(RETRO::IStreamManager& streamManager, IGameInputCallback *input)
+bool CGameClient::OpenStandalone(RETRO::IStreamManager& streamManager, IGameInputCallback* input)
 {
   CLog::Log(LOGDEBUG, "GameClient: Loading %s in standalone mode", ID().c_str());
 
@@ -260,7 +267,10 @@ bool CGameClient::OpenStandalone(RETRO::IStreamManager& streamManager, IGameInpu
   {
     LogError(error = m_struct.toAddon.LoadStandalone(&m_struct), "LoadStandalone()");
   }
-  catch (...) { LogException("LoadStandalone()"); }
+  catch (...)
+  {
+    LogException("LoadStandalone()");
+  }
 
   if (error != GAME_ERROR_NO_ERROR)
   {
@@ -276,16 +286,18 @@ bool CGameClient::OpenStandalone(RETRO::IStreamManager& streamManager, IGameInpu
   return true;
 }
 
-bool CGameClient::InitializeGameplay(const std::string& gamePath, RETRO::IStreamManager& streamManager, IGameInputCallback *input)
+bool CGameClient::InitializeGameplay(const std::string& gamePath,
+                                     RETRO::IStreamManager& streamManager,
+                                     IGameInputCallback* input)
 {
   if (LoadGameInfo())
   {
     Streams().Initialize(streamManager);
     Input().Start(input);
 
-    m_bIsPlaying      = true;
-    m_gamePath        = gamePath;
-    m_input           = input;
+    m_bIsPlaying = true;
+    m_gamePath = gamePath;
+    m_input = input;
 
     m_inGameSaves.reset(new CGameClientInGameSaves(this, &m_struct));
     m_inGameSaves->Load();
@@ -311,14 +323,17 @@ bool CGameClient::LoadGameInfo()
 
   // Get information about system timings
   // Can be called only after retro_load_game()
-  game_system_timing timingInfo = { };
+  game_system_timing timingInfo = {};
 
   bool bSuccess = false;
   try
   {
     bSuccess = LogError(m_struct.toAddon.GetGameTiming(&m_struct, &timingInfo), "GetGameTiming()");
   }
-  catch (...) { LogException("GetGameTiming()"); }
+  catch (...)
+  {
+    LogException("GetGameTiming()");
+  }
 
   if (!bSuccess)
   {
@@ -331,7 +346,11 @@ bool CGameClient::LoadGameInfo()
   {
     region = m_struct.toAddon.GetRegion(&m_struct);
   }
-  catch (...) { LogException("GetRegion()"); return false; }
+  catch (...)
+  {
+    LogException("GetRegion()");
+    return false;
+  }
 
   size_t serializeSize;
   try
@@ -372,13 +391,17 @@ void CGameClient::NotifyError(GAME_ERROR error)
   {
     // Failed to play game
     // This game requires the following add-on: %s
-    HELPERS::ShowOKDialogText(CVariant{ 35210 }, CVariant{ StringUtils::Format(g_localizeStrings.Get(35211).c_str(), missingResource.c_str()) });
+    HELPERS::ShowOKDialogText(CVariant{35210},
+                              CVariant{StringUtils::Format(g_localizeStrings.Get(35211).c_str(),
+                                                           missingResource.c_str())});
   }
   else
   {
     // Failed to play game
     // The emulator "%s" had an internal error.
-    HELPERS::ShowOKDialogText(CVariant{ 35210 }, CVariant{ StringUtils::Format(g_localizeStrings.Get(35213).c_str(), Name().c_str()) });
+    HELPERS::ShowOKDialogText(
+        CVariant{35210},
+        CVariant{StringUtils::Format(g_localizeStrings.Get(35213).c_str(), Name().c_str())});
   }
 }
 
@@ -417,7 +440,10 @@ void CGameClient::Reset()
     {
       LogError(m_struct.toAddon.Reset(&m_struct), "Reset()");
     }
-    catch (...) { LogException("Reset()"); }
+    catch (...)
+    {
+      LogException("Reset()");
+    }
   }
 }
 
@@ -441,7 +467,10 @@ void CGameClient::CloseFile()
     {
       LogError(m_struct.toAddon.UnloadGame(&m_struct), "UnloadGame()");
     }
-    catch (...) { LogException("UnloadGame()"); }
+    catch (...)
+    {
+      LogException("UnloadGame()");
+    }
 
     Streams().Deinitialize();
   }
@@ -449,7 +478,7 @@ void CGameClient::CloseFile()
 
 void CGameClient::RunFrame()
 {
-  IGameInputCallback *input;
+  IGameInputCallback* input;
 
   {
     CSingleLock lock(m_critSection);
@@ -467,7 +496,10 @@ void CGameClient::RunFrame()
     {
       LogError(m_struct.toAddon.RunFrame(&m_struct), "RunFrame()");
     }
-    catch (...) { LogException("RunFrame()"); }
+    catch (...)
+    {
+      LogException("RunFrame()");
+    }
   }
 }
 
@@ -485,7 +517,10 @@ bool CGameClient::Serialize(uint8_t* data, size_t size)
     {
       bSuccess = LogError(m_struct.toAddon.Serialize(&m_struct, data, size), "Serialize()");
     }
-    catch (...) { LogException("Serialize()"); }
+    catch (...)
+    {
+      LogException("Serialize()");
+    }
   }
 
   return bSuccess;
@@ -505,7 +540,10 @@ bool CGameClient::Deserialize(const uint8_t* data, size_t size)
     {
       bSuccess = LogError(m_struct.toAddon.Deserialize(&m_struct, data, size), "Deserialize()");
     }
-    catch (...) { LogException("Deserialize()"); }
+    catch (...)
+    {
+      LogException("Deserialize()");
+    }
   }
 
   return bSuccess;
@@ -515,10 +553,12 @@ void CGameClient::LogAddonProperties(void) const
 {
   CLog::Log(LOGINFO, "GAME: ------------------------------------");
   CLog::Log(LOGINFO, "GAME: Loaded DLL for %s", ID().c_str());
-  CLog::Log(LOGINFO, "GAME: Client: %s at version %s", Name().c_str(), Version().asString().c_str());
+  CLog::Log(LOGINFO, "GAME: Client: %s at version %s", Name().c_str(),
+            Version().asString().c_str());
   CLog::Log(LOGINFO, "GAME: Valid extensions: %s", StringUtils::Join(m_extensions, " ").c_str());
   CLog::Log(LOGINFO, "GAME: Supports VFS:                  %s", m_bSupportsVFS ? "yes" : "no");
-  CLog::Log(LOGINFO, "GAME: Supports standalone execution: %s", m_bSupportsStandalone ? "yes" : "no");
+  CLog::Log(LOGINFO, "GAME: Supports standalone execution: %s",
+            m_bSupportsStandalone ? "yes" : "no");
   CLog::Log(LOGINFO, "GAME: ------------------------------------");
 }
 
@@ -526,8 +566,8 @@ bool CGameClient::LogError(GAME_ERROR error, const char* strMethod) const
 {
   if (error != GAME_ERROR_NO_ERROR)
   {
-    CLog::Log(LOGERROR, "GAME - %s - addon '%s' returned an error: %s",
-        strMethod, ID().c_str(), CGameClientTranslator::ToString(error));
+    CLog::Log(LOGERROR, "GAME - %s - addon '%s' returned an error: %s", strMethod, ID().c_str(),
+              CGameClientTranslator::ToString(error));
     return false;
   }
   return true;
@@ -536,7 +576,7 @@ bool CGameClient::LogError(GAME_ERROR error, const char* strMethod) const
 void CGameClient::LogException(const char* strFunctionName) const
 {
   CLog::Log(LOGERROR, "GAME: exception caught while trying to call '%s' on add-on %s",
-      strFunctionName, ID().c_str());
+            strFunctionName, ID().c_str());
   CLog::Log(LOGERROR, "Please contact the developer of this add-on: %s", Author().c_str());
 }
 
@@ -545,73 +585,82 @@ void CGameClient::cb_close_game(void* kodiInstance)
 {
   using namespace MESSAGING;
 
-  CApplicationMessenger::GetInstance().PostMsg(TMSG_GUI_ACTION, WINDOW_INVALID, -1, static_cast<void*>(new CAction(ACTION_STOP)));
+  CApplicationMessenger::GetInstance().PostMsg(TMSG_GUI_ACTION, WINDOW_INVALID, -1,
+                                               static_cast<void*>(new CAction(ACTION_STOP)));
 }
 
-void* CGameClient::cb_open_stream(void* kodiInstance, const game_stream_properties *properties)
+void* CGameClient::cb_open_stream(void* kodiInstance, const game_stream_properties* properties)
 {
   if (properties == nullptr)
     return nullptr;
 
-  CGameClient *gameClient = static_cast<CGameClient*>(kodiInstance);
+  CGameClient* gameClient = static_cast<CGameClient*>(kodiInstance);
   if (gameClient == nullptr)
     return nullptr;
 
   return gameClient->Streams().OpenStream(*properties);
 }
 
-bool CGameClient::cb_get_stream_buffer(void* kodiInstance, void *stream, unsigned int width, unsigned int height, game_stream_buffer *buffer)
+bool CGameClient::cb_get_stream_buffer(void* kodiInstance,
+                                       void* stream,
+                                       unsigned int width,
+                                       unsigned int height,
+                                       game_stream_buffer* buffer)
 {
   if (buffer == nullptr)
     return false;
 
-  IGameClientStream *gameClientStream = static_cast<IGameClientStream*>(stream);
+  IGameClientStream* gameClientStream = static_cast<IGameClientStream*>(stream);
   if (gameClientStream == nullptr)
     return false;
 
   return gameClientStream->GetBuffer(width, height, *buffer);
 }
 
-void CGameClient::cb_add_stream_data(void* kodiInstance, void *stream, const game_stream_packet *packet)
+void CGameClient::cb_add_stream_data(void* kodiInstance,
+                                     void* stream,
+                                     const game_stream_packet* packet)
 {
   if (packet == nullptr)
     return;
 
-  IGameClientStream *gameClientStream = static_cast<IGameClientStream*>(stream);
+  IGameClientStream* gameClientStream = static_cast<IGameClientStream*>(stream);
   if (gameClientStream == nullptr)
     return;
 
   gameClientStream->AddData(*packet);
 }
 
-void CGameClient::cb_release_stream_buffer(void* kodiInstance, void *stream, game_stream_buffer *buffer)
+void CGameClient::cb_release_stream_buffer(void* kodiInstance,
+                                           void* stream,
+                                           game_stream_buffer* buffer)
 {
   if (buffer == nullptr)
     return;
 
-  IGameClientStream *gameClientStream = static_cast<IGameClientStream*>(stream);
+  IGameClientStream* gameClientStream = static_cast<IGameClientStream*>(stream);
   if (gameClientStream == nullptr)
     return;
 
   gameClientStream->ReleaseBuffer(*buffer);
 }
 
-void CGameClient::cb_close_stream(void* kodiInstance, void *stream)
+void CGameClient::cb_close_stream(void* kodiInstance, void* stream)
 {
-  CGameClient *gameClient = static_cast<CGameClient*>(kodiInstance);
+  CGameClient* gameClient = static_cast<CGameClient*>(kodiInstance);
   if (gameClient == nullptr)
     return;
 
-  IGameClientStream *gameClientStream = static_cast<IGameClientStream*>(stream);
+  IGameClientStream* gameClientStream = static_cast<IGameClientStream*>(stream);
   if (gameClientStream == nullptr)
     return;
 
   gameClient->Streams().CloseStream(gameClientStream);
 }
 
-game_proc_address_t CGameClient::cb_hw_get_proc_address(void* kodiInstance, const char *sym)
+game_proc_address_t CGameClient::cb_hw_get_proc_address(void* kodiInstance, const char* sym)
 {
-  CGameClient *gameClient = static_cast<CGameClient*>(kodiInstance);
+  CGameClient* gameClient = static_cast<CGameClient*>(kodiInstance);
   if (!gameClient)
     return nullptr;
 
@@ -621,7 +670,7 @@ game_proc_address_t CGameClient::cb_hw_get_proc_address(void* kodiInstance, cons
 
 bool CGameClient::cb_input_event(void* kodiInstance, const game_input_event* event)
 {
-  CGameClient *gameClient = static_cast<CGameClient*>(kodiInstance);
+  CGameClient* gameClient = static_cast<CGameClient*>(kodiInstance);
   if (!gameClient)
     return false;
 
diff --git a/xbmc/games/addons/GameClient.h b/xbmc/games/addons/GameClient.h
index 5a89950c245d..fc7aad44bab7 100644
--- a/xbmc/games/addons/GameClient.h
+++ b/xbmc/games/addons/GameClient.h
@@ -25,7 +25,7 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IStreamManager;
+class IStreamManager;
 }
 
 namespace GAME
@@ -73,14 +73,14 @@ class CGameClient : public ADDON::CAddonDll
   ~CGameClient() override;
 
   // Game subsystems (const)
-  const CGameClientInput &Input() const { return *m_subsystems.Input; }
-  const CGameClientProperties &AddonProperties() const { return *m_subsystems.AddonProperties; }
-  const CGameClientStreams &Streams() const { return *m_subsystems.Streams; }
+  const CGameClientInput& Input() const { return *m_subsystems.Input; }
+  const CGameClientProperties& AddonProperties() const { return *m_subsystems.AddonProperties; }
+  const CGameClientStreams& Streams() const { return *m_subsystems.Streams; }
 
   // Game subsystems (mutable)
-  CGameClientInput &Input() { return *m_subsystems.Input; }
-  CGameClientProperties &AddonProperties() { return *m_subsystems.AddonProperties; }
-  CGameClientStreams &Streams() { return *m_subsystems.Streams; }
+  CGameClientInput& Input() { return *m_subsystems.Input; }
+  CGameClientProperties& AddonProperties() { return *m_subsystems.AddonProperties; }
+  CGameClientStreams& Streams() { return *m_subsystems.Streams; }
 
   // Implementation of IAddon via CAddonDll
   std::string LibPath() const override;
@@ -97,8 +97,10 @@ class CGameClient : public ADDON::CAddonDll
   // Start/stop gameplay
   bool Initialize(void);
   void Unload();
-  bool OpenFile(const CFileItem& file, RETRO::IStreamManager& streamManager, IGameInputCallback *input);
-  bool OpenStandalone(RETRO::IStreamManager& streamManager, IGameInputCallback *input);
+  bool OpenFile(const CFileItem& file,
+                RETRO::IStreamManager& streamManager,
+                IGameInputCallback* input);
+  bool OpenStandalone(RETRO::IStreamManager& streamManager, IGameInputCallback* input);
   void Reset();
   void CloseFile();
   const std::string& GetGamePath() const { return m_gamePath; }
@@ -117,10 +119,10 @@ class CGameClient : public ADDON::CAddonDll
   bool Deserialize(const uint8_t* data, size_t size);
 
   /*!
-    * @brief To get the interface table used between addon and kodi
-    * @todo This function becomes removed after old callback library system
-    * is removed.
-    */
+   * @brief To get the interface table used between addon and kodi
+   * @todo This function becomes removed after old callback library system
+   * is removed.
+   */
   AddonInstance_Game* GetInstanceInterface() { return &m_struct; }
 
   // Helper functions
@@ -129,7 +131,9 @@ class CGameClient : public ADDON::CAddonDll
 
 private:
   // Private gameplay functions
-  bool InitializeGameplay(const std::string& gamePath, RETRO::IStreamManager& streamManager, IGameInputCallback *input);
+  bool InitializeGameplay(const std::string& gamePath,
+                          RETRO::IStreamManager& streamManager,
+                          IGameInputCallback* input);
   bool LoadGameInfo();
   void NotifyError(GAME_ERROR error);
   std::string GetMissingResource();
@@ -142,11 +146,19 @@ class CGameClient : public ADDON::CAddonDll
    */
   //@{
   static void cb_close_game(void* kodiInstance);
-  static void* cb_open_stream(void* kodiInstance, const game_stream_properties *properties);
-  static bool cb_get_stream_buffer(void* kodiInstance, void *stream, unsigned int width, unsigned int height, game_stream_buffer *buffer);
-  static void cb_add_stream_data(void* kodiInstance, void *stream, const game_stream_packet *packet);
-  static void cb_release_stream_buffer(void* kodiInstance, void *stream, game_stream_buffer *buffer);
-  static void cb_close_stream(void* kodiInstance, void *stream);
+  static void* cb_open_stream(void* kodiInstance, const game_stream_properties* properties);
+  static bool cb_get_stream_buffer(void* kodiInstance,
+                                   void* stream,
+                                   unsigned int width,
+                                   unsigned int height,
+                                   game_stream_buffer* buffer);
+  static void cb_add_stream_data(void* kodiInstance,
+                                 void* stream,
+                                 const game_stream_packet* packet);
+  static void cb_release_stream_buffer(void* kodiInstance,
+                                       void* stream,
+                                       game_stream_buffer* buffer);
+  static void cb_close_stream(void* kodiInstance, void* stream);
   static game_proc_address_t cb_hw_get_proc_address(void* kodiInstance, const char* sym);
   static bool cb_input_event(void* kodiInstance, const game_input_event* event);
   //@}
@@ -155,21 +167,21 @@ class CGameClient : public ADDON::CAddonDll
   GameClientSubsystems m_subsystems;
 
   // Game API xml parameters
-  bool                  m_bSupportsVFS;
-  bool                  m_bSupportsStandalone;
+  bool m_bSupportsVFS;
+  bool m_bSupportsStandalone;
   std::set<std::string> m_extensions;
-  bool                  m_bSupportsAllExtensions;
-  //GamePlatforms         m_platforms;
+  bool m_bSupportsAllExtensions;
+  // GamePlatforms         m_platforms;
 
   // Properties of the current playing file
-  std::atomic_bool      m_bIsPlaying;          // True between OpenFile() and CloseFile()
-  std::string           m_gamePath;
-  bool                  m_bRequiresGameLoop = false;
-  size_t                m_serializeSize;
-  IGameInputCallback*   m_input = nullptr;     // The input callback passed to OpenFile()
-  double                m_framerate = 0.0;     // Video frame rate (fps)
-  double                m_samplerate = 0.0;    // Audio sample rate (Hz)
-  GAME_REGION           m_region;              // Region of the loaded game
+  std::atomic_bool m_bIsPlaying; // True between OpenFile() and CloseFile()
+  std::string m_gamePath;
+  bool m_bRequiresGameLoop = false;
+  size_t m_serializeSize;
+  IGameInputCallback* m_input = nullptr; // The input callback passed to OpenFile()
+  double m_framerate = 0.0; // Video frame rate (fps)
+  double m_samplerate = 0.0; // Audio sample rate (Hz)
+  GAME_REGION m_region; // Region of the loaded game
 
   // In-game saves
   std::unique_ptr<CGameClientInGameSaves> m_inGameSaves;
diff --git a/xbmc/games/addons/GameClientCallbacks.h b/xbmc/games/addons/GameClientCallbacks.h
index 5a93f9b63c0f..f4bbe2d74980 100644
--- a/xbmc/games/addons/GameClientCallbacks.h
+++ b/xbmc/games/addons/GameClientCallbacks.h
@@ -12,27 +12,27 @@ namespace KODI
 {
 namespace GAME
 {
+/*!
+ * \brief Input callbacks
+ *
+ * @todo Remove this file when Game API is updated for input polling
+ */
+class IGameInputCallback
+{
+public:
+  virtual ~IGameInputCallback() = default;
+
   /*!
-   * \brief Input callbacks
+   * \brief Return true if the input source accepts input
    *
-   * @todo Remove this file when Game API is updated for input polling
+   * \return True if input should be processed, false otherwise
    */
-  class IGameInputCallback
-  {
-  public:
-    virtual ~IGameInputCallback() = default;
+  virtual bool AcceptsInput() const = 0;
 
-    /*!
-     * \brief Return true if the input source accepts input
-     *
-     * \return True if input should be processed, false otherwise
-     */
-    virtual bool AcceptsInput() const = 0;
-
-    /*!
-     * \brief Poll the input source for input
-     */
-    virtual void PollInput() = 0;
-  };
-}
-}
+  /*!
+   * \brief Poll the input source for input
+   */
+  virtual void PollInput() = 0;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/GameClientInGameSaves.cpp b/xbmc/games/addons/GameClientInGameSaves.cpp
index 44af944aac42..7989173f015b 100644
--- a/xbmc/games/addons/GameClientInGameSaves.cpp
+++ b/xbmc/games/addons/GameClientInGameSaves.cpp
@@ -22,14 +22,13 @@
 using namespace KODI;
 using namespace GAME;
 
-#define INGAME_SAVES_DIRECTORY          "InGameSaves"
+#define INGAME_SAVES_DIRECTORY "InGameSaves"
 #define INGAME_SAVES_EXTENSION_SAVE_RAM ".sav"
-#define INGAME_SAVES_EXTENSION_RTC      ".rtc"
+#define INGAME_SAVES_EXTENSION_RTC ".rtc"
 
 CGameClientInGameSaves::CGameClientInGameSaves(CGameClient* addon,
                                                const AddonInstance_Game* dllStruct)
-  : m_gameClient(addon),
-    m_dllStruct(dllStruct)
+  : m_gameClient(addon), m_dllStruct(dllStruct)
 {
   assert(m_gameClient != nullptr);
   assert(m_dllStruct != nullptr);
@@ -49,8 +48,9 @@ void CGameClientInGameSaves::Save()
 
 std::string CGameClientInGameSaves::GetPath(GAME_MEMORY memoryType)
 {
-  const CGameServices &gameServices = CServiceBroker::GetGameServices();
-  std::string path = URIUtils::AddFileToFolder(gameServices.GetSavestatesFolder(), INGAME_SAVES_DIRECTORY);
+  const CGameServices& gameServices = CServiceBroker::GetGameServices();
+  std::string path =
+      URIUtils::AddFileToFolder(gameServices.GetSavestatesFolder(), INGAME_SAVES_DIRECTORY);
   if (!XFILE::CDirectory::Exists(path))
     XFILE::CDirectory::Create(path);
 
@@ -61,17 +61,19 @@ std::string CGameClientInGameSaves::GetPath(GAME_MEMORY memoryType)
   // Append file extension
   switch (memoryType)
   {
-  case GAME_MEMORY_SAVE_RAM: return path + INGAME_SAVES_EXTENSION_SAVE_RAM;
-  case GAME_MEMORY_RTC:      return path + INGAME_SAVES_EXTENSION_RTC;
-  default:
-    break;
+    case GAME_MEMORY_SAVE_RAM:
+      return path + INGAME_SAVES_EXTENSION_SAVE_RAM;
+    case GAME_MEMORY_RTC:
+      return path + INGAME_SAVES_EXTENSION_RTC;
+    default:
+      break;
   }
   return std::string();
 }
 
 void CGameClientInGameSaves::Load(GAME_MEMORY memoryType)
 {
-  uint8_t *gameMemory = nullptr;
+  uint8_t* gameMemory = nullptr;
   size_t size = 0;
 
   try
@@ -92,27 +94,31 @@ void CGameClientInGameSaves::Load(GAME_MEMORY memoryType)
       ssize_t read = file.Read(gameMemory, size);
       if (read == static_cast<ssize_t>(size))
       {
-        CLog::Log(LOGINFO, "GAME: In-game saves (%s) loaded from %s", CGameClientTranslator::ToString(memoryType), path.c_str());
+        CLog::Log(LOGINFO, "GAME: In-game saves (%s) loaded from %s",
+                  CGameClientTranslator::ToString(memoryType), path.c_str());
       }
       else
       {
-        CLog::Log(LOGERROR, "GAME: Failed to read in-game saves (%s): %ld/%ld bytes read", CGameClientTranslator::ToString(memoryType), read, size);
+        CLog::Log(LOGERROR, "GAME: Failed to read in-game saves (%s): %ld/%ld bytes read",
+                  CGameClientTranslator::ToString(memoryType), read, size);
       }
     }
     else
     {
-      CLog::Log(LOGERROR, "GAME: Unable to open in-game saves (%s) from file %s", CGameClientTranslator::ToString(memoryType), path.c_str());
+      CLog::Log(LOGERROR, "GAME: Unable to open in-game saves (%s) from file %s",
+                CGameClientTranslator::ToString(memoryType), path.c_str());
     }
   }
   else
   {
-    CLog::Log(LOGDEBUG, "GAME: No in-game saves (%s) to load", CGameClientTranslator::ToString(memoryType));
+    CLog::Log(LOGDEBUG, "GAME: No in-game saves (%s) to load",
+              CGameClientTranslator::ToString(memoryType));
   }
 }
 
 void CGameClientInGameSaves::Save(GAME_MEMORY memoryType)
 {
-  uint8_t *gameMemory = nullptr;
+  uint8_t* gameMemory = nullptr;
   size_t size = 0;
 
   try
@@ -135,20 +141,24 @@ void CGameClientInGameSaves::Save(GAME_MEMORY memoryType)
       file.Close();
       if (written == static_cast<ssize_t>(size))
       {
-        CLog::Log(LOGINFO, "GAME: In-game saves (%s) written to %s", CGameClientTranslator::ToString(memoryType), path.c_str());
+        CLog::Log(LOGINFO, "GAME: In-game saves (%s) written to %s",
+                  CGameClientTranslator::ToString(memoryType), path.c_str());
       }
       else
       {
-        CLog::Log(LOGERROR, "GAME: Failed to write in-game saves (%s): %ld/%ld bytes written", CGameClientTranslator::ToString(memoryType), written, size);
+        CLog::Log(LOGERROR, "GAME: Failed to write in-game saves (%s): %ld/%ld bytes written",
+                  CGameClientTranslator::ToString(memoryType), written, size);
       }
     }
     else
     {
-      CLog::Log(LOGERROR, "GAME: Unable to open in-game saves (%s) from file %s", CGameClientTranslator::ToString(memoryType), path.c_str());
+      CLog::Log(LOGERROR, "GAME: Unable to open in-game saves (%s) from file %s",
+                CGameClientTranslator::ToString(memoryType), path.c_str());
     }
   }
   else
   {
-    CLog::Log(LOGDEBUG, "GAME: No in-game saves (%s) to save", CGameClientTranslator::ToString(memoryType));
+    CLog::Log(LOGDEBUG, "GAME: No in-game saves (%s) to save",
+              CGameClientTranslator::ToString(memoryType));
   }
 }
diff --git a/xbmc/games/addons/GameClientInGameSaves.h b/xbmc/games/addons/GameClientInGameSaves.h
index bb460aabfc6c..a6019cffef0f 100644
--- a/xbmc/games/addons/GameClientInGameSaves.h
+++ b/xbmc/games/addons/GameClientInGameSaves.h
@@ -18,48 +18,49 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameClient;
+class CGameClient;
 
+/*!
+ * \brief This class implements in-game saves.
+ *
+ * \details Some games do not implement state persistence on their own, but rely on the frontend for
+ * saving their current memory state to disk. This is mostly the case for emulators for SRAM
+ * (battery backed up ram on cartridges) or memory cards.
+ *
+ * Differences to save states:
+ * - Works only for supported games (e.g. emulated games with SRAM support)
+ * - Often works emulator independent (and can be used to start a game with one emulator and
+ * continue with another)
+ * - Visible in-game (e.g. in-game save game selection menus)
+ */
+class CGameClientInGameSaves
+{
+public:
   /*!
-   * \brief This class implements in-game saves.
-   *
-   * \details Some games do not implement state persistence on their own, but rely on the frontend for saving their current
-   * memory state to disk. This is mostly the case for emulators for SRAM (battery backed up ram on cartridges) or
-   * memory cards.
-   *
-   * Differences to save states:
-   * - Works only for supported games (e.g. emulated games with SRAM support)
-   * - Often works emulator independent (and can be used to start a game with one emulator and continue with another)
-   * - Visible in-game (e.g. in-game save game selection menus)
+   * \brief Constructor.
+   * \param addon The game client implementation.
+   * \param dllStruct The emulator or game for which the in-game saves are processed.
    */
-  class CGameClientInGameSaves
-  {
-  public:
-    /*!
-     * \brief Constructor.
-     * \param addon The game client implementation.
-     * \param dllStruct The emulator or game for which the in-game saves are processed.
-     */
-    CGameClientInGameSaves(CGameClient* addon, const AddonInstance_Game* dllStruct);
+  CGameClientInGameSaves(CGameClient* addon, const AddonInstance_Game* dllStruct);
 
-    /*!
-     * \brief Load in-game data.
-     */
-    void Load();
+  /*!
+   * \brief Load in-game data.
+   */
+  void Load();
 
-    /*!
-     * \brief Save in-game data.
-     */
-    void Save();
+  /*!
+   * \brief Save in-game data.
+   */
+  void Save();
 
-  private:
-    std::string GetPath(GAME_MEMORY memoryType);
+private:
+  std::string GetPath(GAME_MEMORY memoryType);
 
-    void Load(GAME_MEMORY memoryType);
-    void Save(GAME_MEMORY memoryType);
+  void Load(GAME_MEMORY memoryType);
+  void Save(GAME_MEMORY memoryType);
 
-    const CGameClient* const m_gameClient;
-    const AddonInstance_Game* const m_dllStruct;
-  };
-}
-}
+  const CGameClient* const m_gameClient;
+  const AddonInstance_Game* const m_dllStruct;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/GameClientProperties.cpp b/xbmc/games/addons/GameClientProperties.cpp
index 7d5ba3dc19b6..be76601735e4 100644
--- a/xbmc/games/addons/GameClientProperties.cpp
+++ b/xbmc/games/addons/GameClientProperties.cpp
@@ -28,11 +28,10 @@ using namespace ADDON;
 using namespace GAME;
 using namespace XFILE;
 
-#define GAME_CLIENT_RESOURCES_DIRECTORY  "resources"
+#define GAME_CLIENT_RESOURCES_DIRECTORY "resources"
 
 CGameClientProperties::CGameClientProperties(const CGameClient& parent, AddonProps_Game& props)
-  : m_parent(parent),
-    m_properties(props)
+  : m_parent(parent), m_properties(props)
 {
 }
 
@@ -59,15 +58,15 @@ bool CGameClientProperties::InitializeProperties(void)
   if (!GetProxyAddons(addons))
     return false;
 
-  m_properties.game_client_dll_path     = GetLibraryPath();
-  m_properties.proxy_dll_paths          = GetProxyDllPaths(addons);
-  m_properties.proxy_dll_count          = GetProxyDllCount();
-  m_properties.resource_directories     = GetResourceDirectories();
+  m_properties.game_client_dll_path = GetLibraryPath();
+  m_properties.proxy_dll_paths = GetProxyDllPaths(addons);
+  m_properties.proxy_dll_count = GetProxyDllCount();
+  m_properties.resource_directories = GetResourceDirectories();
   m_properties.resource_directory_count = GetResourceDirectoryCount();
-  m_properties.profile_directory        = GetProfileDirectory();
-  m_properties.supports_vfs             = m_parent.SupportsVFS();
-  m_properties.extensions               = GetExtensions();
-  m_properties.extension_count          = GetExtensionCount();
+  m_properties.profile_directory = GetProfileDirectory();
+  m_properties.supports_vfs = m_parent.SupportsVFS();
+  m_properties.extensions = GetExtensions();
+  m_properties.extension_count = GetExtensionCount();
 
   return true;
 }
@@ -84,11 +83,11 @@ const char* CGameClientProperties::GetLibraryPath(void)
   return m_strLibraryPath.c_str();
 }
 
-const char** CGameClientProperties::GetProxyDllPaths(const ADDON::VECADDONS &addons)
+const char** CGameClientProperties::GetProxyDllPaths(const ADDON::VECADDONS& addons)
 {
   if (m_proxyDllPaths.empty())
   {
-    for (const auto &addon : addons)
+    for (const auto& addon : addons)
       AddProxyDll(std::static_pointer_cast<CGameClient>(addon));
   }
 
@@ -195,12 +194,12 @@ unsigned int CGameClientProperties::GetExtensionCount(void) const
   return static_cast<unsigned int>(m_extensions.size());
 }
 
-bool CGameClientProperties::GetProxyAddons(ADDON::VECADDONS &addons)
+bool CGameClientProperties::GetProxyAddons(ADDON::VECADDONS& addons)
 {
   ADDON::VECADDONS ret;
   std::vector<std::string> missingDependencies; // ID or name of missing dependencies
 
-  for (const auto &dependency : m_parent.GetDependencies())
+  for (const auto& dependency : m_parent.GetDependencies())
   {
     AddonPtr addon;
     if (CServiceBroker::GetAddonMgr().GetAddon(dependency.id, addon, ADDON_UNKNOWN, false))
@@ -210,7 +209,7 @@ bool CGameClientProperties::GetProxyAddons(ADDON::VECADDONS &addons)
       {
         // "Failed to play game"
         // "This game depends on a disabled add-on. Would you like to enable it?"
-        if (CGUIDialogYesNo::ShowAndGetInput(CVariant{ 35210 }, CVariant{ 35215 }))
+        if (CGUIDialogYesNo::ShowAndGetInput(CVariant{35210}, CVariant{35215}))
         {
           if (!CServiceBroker::GetAddonMgr().EnableAddon(dependency.id))
           {
@@ -253,7 +252,8 @@ bool CGameClientProperties::GetProxyAddons(ADDON::VECADDONS &addons)
     // "Add-on is incompatible due to unmet dependencies."
     // ""
     // "Missing: {0:s}"
-    MESSAGING::HELPERS::ShowOKDialogLines(CVariant{ 35210 }, CVariant{ 24104 }, CVariant{ "" }, CVariant{ dialogText });
+    MESSAGING::HELPERS::ShowOKDialogLines(CVariant{35210}, CVariant{24104}, CVariant{""},
+                                          CVariant{dialogText});
 
     return false;
   }
diff --git a/xbmc/games/addons/GameClientProperties.h b/xbmc/games/addons/GameClientProperties.h
index d5cdd2bae4e2..a3ac4c45bce8 100644
--- a/xbmc/games/addons/GameClientProperties.h
+++ b/xbmc/games/addons/GameClientProperties.h
@@ -46,7 +46,7 @@ class CGameClientProperties
   const char* GetLibraryPath(void);
 
   // List of proxy DLLs needed to load the game client
-  const char** GetProxyDllPaths(const ADDON::VECADDONS &addons);
+  const char** GetProxyDllPaths(const ADDON::VECADDONS& addons);
 
   // Number of proxy DLLs needed to load the game client
   unsigned int GetProxyDllCount(void) const;
@@ -67,7 +67,7 @@ class CGameClientProperties
   unsigned int GetExtensionCount(void) const;
 
   // Helper functions
-  bool GetProxyAddons(ADDON::VECADDONS &addons);
+  bool GetProxyAddons(ADDON::VECADDONS& addons);
   void AddProxyDll(const GameClientPtr& gameClient);
   bool HasProxyDll(const std::string& strLibPath) const;
 
@@ -76,10 +76,10 @@ class CGameClientProperties
   AddonProps_Game& m_properties;
 
   // Buffers to hold the strings
-  std::string        m_strLibraryPath;
+  std::string m_strLibraryPath;
   std::vector<char*> m_proxyDllPaths;
   std::vector<char*> m_resourceDirectories;
-  std::string        m_strProfileDirectory;
+  std::string m_strProfileDirectory;
   std::vector<char*> m_extensions;
 };
 
diff --git a/xbmc/games/addons/GameClientSubsystem.cpp b/xbmc/games/addons/GameClientSubsystem.cpp
index 4e44c41d4697..1d38b440f6b8 100644
--- a/xbmc/games/addons/GameClientSubsystem.cpp
+++ b/xbmc/games/addons/GameClientSubsystem.cpp
@@ -17,18 +17,18 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientSubsystem::CGameClientSubsystem(CGameClient &gameClient,
-                                           AddonInstance_Game &addonStruct,
-                                           CCriticalSection &clientAccess) :
-  m_gameClient(gameClient),
-  m_struct(addonStruct),
-  m_clientAccess(clientAccess)
+CGameClientSubsystem::CGameClientSubsystem(CGameClient& gameClient,
+                                           AddonInstance_Game& addonStruct,
+                                           CCriticalSection& clientAccess)
+  : m_gameClient(gameClient), m_struct(addonStruct), m_clientAccess(clientAccess)
 {
 }
 
 CGameClientSubsystem::~CGameClientSubsystem() = default;
 
-GameClientSubsystems CGameClientSubsystem::CreateSubsystems(CGameClient &gameClient, AddonInstance_Game &gameStruct, CCriticalSection &clientAccess)
+GameClientSubsystems CGameClientSubsystem::CreateSubsystems(CGameClient& gameClient,
+                                                            AddonInstance_Game& gameStruct,
+                                                            CCriticalSection& clientAccess)
 {
   GameClientSubsystems subsystems = {};
 
@@ -39,24 +39,24 @@ GameClientSubsystems CGameClientSubsystem::CreateSubsystems(CGameClient &gameCli
   return subsystems;
 }
 
-void CGameClientSubsystem::DestroySubsystems(GameClientSubsystems &subsystems)
+void CGameClientSubsystem::DestroySubsystems(GameClientSubsystems& subsystems)
 {
   subsystems.Input.reset();
   subsystems.AddonProperties.reset();
   subsystems.Streams.reset();
 }
 
-CGameClientInput &CGameClientSubsystem::Input() const
+CGameClientInput& CGameClientSubsystem::Input() const
 {
   return m_gameClient.Input();
 }
 
-CGameClientProperties &CGameClientSubsystem::AddonProperties() const
+CGameClientProperties& CGameClientSubsystem::AddonProperties() const
 {
   return m_gameClient.AddonProperties();
 }
 
-CGameClientStreams &CGameClientSubsystem::Streams() const
+CGameClientStreams& CGameClientSubsystem::Streams() const
 {
   return m_gameClient.Streams();
 }
diff --git a/xbmc/games/addons/GameClientSubsystem.h b/xbmc/games/addons/GameClientSubsystem.h
index 42a142d2785c..e9e7c91ac7cc 100644
--- a/xbmc/games/addons/GameClientSubsystem.h
+++ b/xbmc/games/addons/GameClientSubsystem.h
@@ -17,60 +17,62 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameClient;
-  class CGameClientInput;
-  class CGameClientProperties;
-  class CGameClientStreams;
+class CGameClient;
+class CGameClientInput;
+class CGameClientProperties;
+class CGameClientStreams;
 
-  struct GameClientSubsystems
-  {
-    std::unique_ptr<CGameClientInput> Input;
-    std::unique_ptr<CGameClientProperties> AddonProperties;
-    std::unique_ptr<CGameClientStreams> Streams;
-  };
+struct GameClientSubsystems
+{
+  std::unique_ptr<CGameClientInput> Input;
+  std::unique_ptr<CGameClientProperties> AddonProperties;
+  std::unique_ptr<CGameClientStreams> Streams;
+};
 
-  /*!
-   * \brief Base class for game client subsystems
-   */
-  class CGameClientSubsystem
-  {
-  protected:
-    CGameClientSubsystem(CGameClient &gameClient,
-                         AddonInstance_Game &addonStruct,
-                         CCriticalSection &clientAccess);
+/*!
+ * \brief Base class for game client subsystems
+ */
+class CGameClientSubsystem
+{
+protected:
+  CGameClientSubsystem(CGameClient& gameClient,
+                       AddonInstance_Game& addonStruct,
+                       CCriticalSection& clientAccess);
 
-    virtual ~CGameClientSubsystem();
+  virtual ~CGameClientSubsystem();
 
-  public:
-    /*!
-     * \brief Create a struct with the allocated subsystems
-     *
-     * \param gameClient The owner of the subsystems
-     * \param gameStruct The game client's add-on function table
-     * \param clientAccess Mutex guarding client function access
-     *
-     * \return A fully-allocated GameClientSubsystems struct
-     */
-    static GameClientSubsystems CreateSubsystems(CGameClient &gameClient, AddonInstance_Game &gameStruct, CCriticalSection &clientAccess);
+public:
+  /*!
+   * \brief Create a struct with the allocated subsystems
+   *
+   * \param gameClient The owner of the subsystems
+   * \param gameStruct The game client's add-on function table
+   * \param clientAccess Mutex guarding client function access
+   *
+   * \return A fully-allocated GameClientSubsystems struct
+   */
+  static GameClientSubsystems CreateSubsystems(CGameClient& gameClient,
+                                               AddonInstance_Game& gameStruct,
+                                               CCriticalSection& clientAccess);
 
-    /*!
-     * \brief Deallocate subsystems
-     *
-     * \param subsystems The subsystems created by CreateSubsystems()
-     */
-    static void DestroySubsystems(GameClientSubsystems &subsystems);
+  /*!
+   * \brief Deallocate subsystems
+   *
+   * \param subsystems The subsystems created by CreateSubsystems()
+   */
+  static void DestroySubsystems(GameClientSubsystems& subsystems);
 
-  protected:
-    // Subsystems
-    CGameClientInput &Input() const;
-    CGameClientProperties &AddonProperties() const;
-    CGameClientStreams &Streams() const;
+protected:
+  // Subsystems
+  CGameClientInput& Input() const;
+  CGameClientProperties& AddonProperties() const;
+  CGameClientStreams& Streams() const;
 
-    // Construction parameters
-    CGameClient &m_gameClient;
-    AddonInstance_Game &m_struct;
-    CCriticalSection &m_clientAccess;
-  };
+  // Construction parameters
+  CGameClient& m_gameClient;
+  AddonInstance_Game& m_struct;
+  CCriticalSection& m_clientAccess;
+};
 
-}
-}
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/GameClientTranslator.cpp b/xbmc/games/addons/GameClientTranslator.cpp
index 06410b5d3858..c48ba4ac5702 100644
--- a/xbmc/games/addons/GameClientTranslator.cpp
+++ b/xbmc/games/addons/GameClientTranslator.cpp
@@ -15,15 +15,22 @@ const char* CGameClientTranslator::ToString(GAME_ERROR error)
 {
   switch (error)
   {
-  case GAME_ERROR_NO_ERROR:           return "no error";
-  case GAME_ERROR_NOT_IMPLEMENTED:    return "not implemented";
-  case GAME_ERROR_REJECTED:           return "rejected by the client";
-  case GAME_ERROR_INVALID_PARAMETERS: return "invalid parameters for this method";
-  case GAME_ERROR_FAILED:             return "the command failed";
-  case GAME_ERROR_NOT_LOADED:         return "no game is loaded";
-  case GAME_ERROR_RESTRICTED:         return "the required resources are restricted";
-  default:
-    break;
+    case GAME_ERROR_NO_ERROR:
+      return "no error";
+    case GAME_ERROR_NOT_IMPLEMENTED:
+      return "not implemented";
+    case GAME_ERROR_REJECTED:
+      return "rejected by the client";
+    case GAME_ERROR_INVALID_PARAMETERS:
+      return "invalid parameters for this method";
+    case GAME_ERROR_FAILED:
+      return "the command failed";
+    case GAME_ERROR_NOT_LOADED:
+      return "no game is loaded";
+    case GAME_ERROR_RESTRICTED:
+      return "the required resources are restricted";
+    default:
+      break;
   }
   return "unknown error";
 }
@@ -32,39 +39,49 @@ const char* CGameClientTranslator::ToString(GAME_MEMORY memory)
 {
   switch (memory)
   {
-  case GAME_MEMORY_SAVE_RAM:                return "save ram";
-  case GAME_MEMORY_RTC:                     return "rtc";
-  case GAME_MEMORY_SYSTEM_RAM:              return "system ram";
-  case GAME_MEMORY_VIDEO_RAM:               return "video ram";
-  case GAME_MEMORY_SNES_BSX_RAM:            return "snes bsx ram";
-  case GAME_MEMORY_SNES_SUFAMI_TURBO_A_RAM: return "snes sufami turbo a ram";
-  case GAME_MEMORY_SNES_SUFAMI_TURBO_B_RAM: return "snes sufami turbo b ram";
-  case GAME_MEMORY_SNES_GAME_BOY_RAM:       return "snes game boy ram";
-  case GAME_MEMORY_SNES_GAME_BOY_RTC:       return "snes game boy rtc";
-  default:
-    break;
+    case GAME_MEMORY_SAVE_RAM:
+      return "save ram";
+    case GAME_MEMORY_RTC:
+      return "rtc";
+    case GAME_MEMORY_SYSTEM_RAM:
+      return "system ram";
+    case GAME_MEMORY_VIDEO_RAM:
+      return "video ram";
+    case GAME_MEMORY_SNES_BSX_RAM:
+      return "snes bsx ram";
+    case GAME_MEMORY_SNES_SUFAMI_TURBO_A_RAM:
+      return "snes sufami turbo a ram";
+    case GAME_MEMORY_SNES_SUFAMI_TURBO_B_RAM:
+      return "snes sufami turbo b ram";
+    case GAME_MEMORY_SNES_GAME_BOY_RAM:
+      return "snes game boy ram";
+    case GAME_MEMORY_SNES_GAME_BOY_RTC:
+      return "snes game boy rtc";
+    default:
+      break;
   }
   return "unknown memory";
 }
 
-bool CGameClientTranslator::TranslateStreamType(GAME_STREAM_TYPE gameType, RETRO::StreamType &retroType)
+bool CGameClientTranslator::TranslateStreamType(GAME_STREAM_TYPE gameType,
+                                                RETRO::StreamType& retroType)
 {
   switch (gameType)
   {
-  case GAME_STREAM_AUDIO:
-    retroType = RETRO::StreamType::AUDIO;
-    return true;
-  case GAME_STREAM_VIDEO:
-    retroType = RETRO::StreamType::VIDEO;
-    return true;
-  case GAME_STREAM_SW_FRAMEBUFFER:
-    retroType = RETRO::StreamType::SW_BUFFER;
-    return true;
-  case GAME_STREAM_HW_FRAMEBUFFER:
-    retroType = RETRO::StreamType::HW_BUFFER;
-    return true;
-  default:
-    break;
+    case GAME_STREAM_AUDIO:
+      retroType = RETRO::StreamType::AUDIO;
+      return true;
+    case GAME_STREAM_VIDEO:
+      retroType = RETRO::StreamType::VIDEO;
+      return true;
+    case GAME_STREAM_SW_FRAMEBUFFER:
+      retroType = RETRO::StreamType::SW_BUFFER;
+      return true;
+    case GAME_STREAM_HW_FRAMEBUFFER:
+      retroType = RETRO::StreamType::HW_BUFFER;
+      return true;
+    default:
+      break;
   }
   return false;
 }
@@ -73,11 +90,14 @@ AVPixelFormat CGameClientTranslator::TranslatePixelFormat(GAME_PIXEL_FORMAT form
 {
   switch (format)
   {
-  case GAME_PIXEL_FORMAT_0RGB8888: return AV_PIX_FMT_0RGB32;
-  case GAME_PIXEL_FORMAT_RGB565:   return AV_PIX_FMT_RGB565;
-  case GAME_PIXEL_FORMAT_0RGB1555: return AV_PIX_FMT_RGB555;
-  default:
-    break;
+    case GAME_PIXEL_FORMAT_0RGB8888:
+      return AV_PIX_FMT_0RGB32;
+    case GAME_PIXEL_FORMAT_RGB565:
+      return AV_PIX_FMT_RGB565;
+    case GAME_PIXEL_FORMAT_0RGB1555:
+      return AV_PIX_FMT_RGB555;
+    default:
+      break;
   }
   return AV_PIX_FMT_NONE;
 }
@@ -86,11 +106,14 @@ GAME_PIXEL_FORMAT CGameClientTranslator::TranslatePixelFormat(AVPixelFormat form
 {
   switch (format)
   {
-  case AV_PIX_FMT_0RGB32: return GAME_PIXEL_FORMAT_0RGB8888;
-  case AV_PIX_FMT_RGB565: return GAME_PIXEL_FORMAT_RGB565;
-  case AV_PIX_FMT_RGB555: return GAME_PIXEL_FORMAT_0RGB1555;
-  default:
-    break;
+    case AV_PIX_FMT_0RGB32:
+      return GAME_PIXEL_FORMAT_0RGB8888;
+    case AV_PIX_FMT_RGB565:
+      return GAME_PIXEL_FORMAT_RGB565;
+    case AV_PIX_FMT_RGB555:
+      return GAME_PIXEL_FORMAT_0RGB1555;
+    default:
+      break;
   }
   return GAME_PIXEL_FORMAT_UNKNOWN;
 }
@@ -99,9 +122,10 @@ RETRO::PCMFormat CGameClientTranslator::TranslatePCMFormat(GAME_PCM_FORMAT forma
 {
   switch (format)
   {
-  case GAME_PCM_FORMAT_S16NE: return RETRO::PCMFormat::FMT_S16NE;
-  default:
-    break;
+    case GAME_PCM_FORMAT_S16NE:
+      return RETRO::PCMFormat::FMT_S16NE;
+    default:
+      break;
   }
   return RETRO::PCMFormat::FMT_UNKNOWN;
 }
@@ -110,28 +134,48 @@ RETRO::AudioChannel CGameClientTranslator::TranslateAudioChannel(GAME_AUDIO_CHAN
 {
   switch (channel)
   {
-  case GAME_CH_FL:   return RETRO::AudioChannel::CH_FL;
-  case GAME_CH_FR:   return RETRO::AudioChannel::CH_FR;
-  case GAME_CH_FC:   return RETRO::AudioChannel::CH_FC;
-  case GAME_CH_LFE:  return RETRO::AudioChannel::CH_LFE;
-  case GAME_CH_BL:   return RETRO::AudioChannel::CH_BL;
-  case GAME_CH_BR:   return RETRO::AudioChannel::CH_BR;
-  case GAME_CH_FLOC: return RETRO::AudioChannel::CH_FLOC;
-  case GAME_CH_FROC: return RETRO::AudioChannel::CH_FROC;
-  case GAME_CH_BC:   return RETRO::AudioChannel::CH_BC;
-  case GAME_CH_SL:   return RETRO::AudioChannel::CH_SL;
-  case GAME_CH_SR:   return RETRO::AudioChannel::CH_SR;
-  case GAME_CH_TFL:  return RETRO::AudioChannel::CH_TFL;
-  case GAME_CH_TFR:  return RETRO::AudioChannel::CH_TFR;
-  case GAME_CH_TFC:  return RETRO::AudioChannel::CH_TFC;
-  case GAME_CH_TC:   return RETRO::AudioChannel::CH_TC;
-  case GAME_CH_TBL:  return RETRO::AudioChannel::CH_TBL;
-  case GAME_CH_TBR:  return RETRO::AudioChannel::CH_TBR;
-  case GAME_CH_TBC:  return RETRO::AudioChannel::CH_TBC;
-  case GAME_CH_BLOC: return RETRO::AudioChannel::CH_BLOC;
-  case GAME_CH_BROC: return RETRO::AudioChannel::CH_BROC;
-  default:
-    break;
+    case GAME_CH_FL:
+      return RETRO::AudioChannel::CH_FL;
+    case GAME_CH_FR:
+      return RETRO::AudioChannel::CH_FR;
+    case GAME_CH_FC:
+      return RETRO::AudioChannel::CH_FC;
+    case GAME_CH_LFE:
+      return RETRO::AudioChannel::CH_LFE;
+    case GAME_CH_BL:
+      return RETRO::AudioChannel::CH_BL;
+    case GAME_CH_BR:
+      return RETRO::AudioChannel::CH_BR;
+    case GAME_CH_FLOC:
+      return RETRO::AudioChannel::CH_FLOC;
+    case GAME_CH_FROC:
+      return RETRO::AudioChannel::CH_FROC;
+    case GAME_CH_BC:
+      return RETRO::AudioChannel::CH_BC;
+    case GAME_CH_SL:
+      return RETRO::AudioChannel::CH_SL;
+    case GAME_CH_SR:
+      return RETRO::AudioChannel::CH_SR;
+    case GAME_CH_TFL:
+      return RETRO::AudioChannel::CH_TFL;
+    case GAME_CH_TFR:
+      return RETRO::AudioChannel::CH_TFR;
+    case GAME_CH_TFC:
+      return RETRO::AudioChannel::CH_TFC;
+    case GAME_CH_TC:
+      return RETRO::AudioChannel::CH_TC;
+    case GAME_CH_TBL:
+      return RETRO::AudioChannel::CH_TBL;
+    case GAME_CH_TBR:
+      return RETRO::AudioChannel::CH_TBR;
+    case GAME_CH_TBC:
+      return RETRO::AudioChannel::CH_TBC;
+    case GAME_CH_BLOC:
+      return RETRO::AudioChannel::CH_BLOC;
+    case GAME_CH_BROC:
+      return RETRO::AudioChannel::CH_BROC;
+    default:
+      break;
   }
   return RETRO::AudioChannel::CH_NULL;
 }
@@ -140,14 +184,14 @@ RETRO::VideoRotation CGameClientTranslator::TranslateRotation(GAME_VIDEO_ROTATIO
 {
   switch (rotation)
   {
-  case GAME_VIDEO_ROTATION_90_CCW:
-    return RETRO::VideoRotation::ROTATION_90_CCW;
-  case GAME_VIDEO_ROTATION_180_CCW:
-    return RETRO::VideoRotation::ROTATION_180_CCW;
-  case GAME_VIDEO_ROTATION_270_CCW:
-    return RETRO::VideoRotation::ROTATION_270_CCW;
-  default:
-    break;
+    case GAME_VIDEO_ROTATION_90_CCW:
+      return RETRO::VideoRotation::ROTATION_90_CCW;
+    case GAME_VIDEO_ROTATION_180_CCW:
+      return RETRO::VideoRotation::ROTATION_180_CCW;
+    case GAME_VIDEO_ROTATION_270_CCW:
+      return RETRO::VideoRotation::ROTATION_270_CCW;
+    default:
+      break;
   }
   return RETRO::VideoRotation::ROTATION_0;
 }
@@ -158,15 +202,24 @@ GAME_KEY_MOD CGameClientTranslator::GetModifiers(KEYBOARD::Modifier modifier)
 
   unsigned int mods = GAME_KEY_MOD_NONE;
 
-  if (modifier & Modifier::MODIFIER_CTRL)  mods |= GAME_KEY_MOD_CTRL;
-  if (modifier & Modifier::MODIFIER_SHIFT) mods |= GAME_KEY_MOD_SHIFT;
-  if (modifier & Modifier::MODIFIER_ALT)   mods |= GAME_KEY_MOD_ALT;
-  if (modifier & Modifier::MODIFIER_RALT)  mods |= GAME_KEY_MOD_ALT;
-  if (modifier & Modifier::MODIFIER_META)  mods |= GAME_KEY_MOD_META;
-  if (modifier & Modifier::MODIFIER_SUPER) mods |= GAME_KEY_MOD_SUPER;
-  if (modifier & Modifier::MODIFIER_NUMLOCK) mods |= GAME_KEY_MOD_NUMLOCK;
-  if (modifier & Modifier::MODIFIER_CAPSLOCK) mods |= GAME_KEY_MOD_CAPSLOCK;
-  if (modifier & Modifier::MODIFIER_SCROLLLOCK) mods |= GAME_KEY_MOD_SCROLLOCK;
+  if (modifier & Modifier::MODIFIER_CTRL)
+    mods |= GAME_KEY_MOD_CTRL;
+  if (modifier & Modifier::MODIFIER_SHIFT)
+    mods |= GAME_KEY_MOD_SHIFT;
+  if (modifier & Modifier::MODIFIER_ALT)
+    mods |= GAME_KEY_MOD_ALT;
+  if (modifier & Modifier::MODIFIER_RALT)
+    mods |= GAME_KEY_MOD_ALT;
+  if (modifier & Modifier::MODIFIER_META)
+    mods |= GAME_KEY_MOD_META;
+  if (modifier & Modifier::MODIFIER_SUPER)
+    mods |= GAME_KEY_MOD_SUPER;
+  if (modifier & Modifier::MODIFIER_NUMLOCK)
+    mods |= GAME_KEY_MOD_NUMLOCK;
+  if (modifier & Modifier::MODIFIER_CAPSLOCK)
+    mods |= GAME_KEY_MOD_CAPSLOCK;
+  if (modifier & Modifier::MODIFIER_SCROLLLOCK)
+    mods |= GAME_KEY_MOD_SCROLLOCK;
 
   return static_cast<GAME_KEY_MOD>(mods);
 }
@@ -175,10 +228,12 @@ const char* CGameClientTranslator::TranslateRegion(GAME_REGION region)
 {
   switch (region)
   {
-  case GAME_REGION_NTSC: return "NTSC";
-  case GAME_REGION_PAL:  return "PAL";
-  default:
-    break;
+    case GAME_REGION_NTSC:
+      return "NTSC";
+    case GAME_REGION_PAL:
+      return "PAL";
+    default:
+      break;
   }
   return "Unknown";
 }
@@ -187,9 +242,12 @@ PORT_TYPE CGameClientTranslator::TranslatePortType(GAME_PORT_TYPE portType)
 {
   switch (portType)
   {
-    case GAME_PORT_KEYBOARD:    return PORT_TYPE::KEYBOARD;
-    case GAME_PORT_MOUSE:       return PORT_TYPE::MOUSE;
-    case GAME_PORT_CONTROLLER:  return PORT_TYPE::CONTROLLER;
+    case GAME_PORT_KEYBOARD:
+      return PORT_TYPE::KEYBOARD;
+    case GAME_PORT_MOUSE:
+      return PORT_TYPE::MOUSE;
+    case GAME_PORT_CONTROLLER:
+      return PORT_TYPE::CONTROLLER;
     default:
       break;
   }
diff --git a/xbmc/games/addons/GameClientTranslator.h b/xbmc/games/addons/GameClientTranslator.h
index 007e383b9765..5d60a4b15eee 100644
--- a/xbmc/games/addons/GameClientTranslator.h
+++ b/xbmc/games/addons/GameClientTranslator.h
@@ -13,7 +13,8 @@
 #include "games/controllers/ControllerTypes.h"
 #include "input/keyboard/KeyboardTypes.h"
 
-extern "C" {
+extern "C"
+{
 #include <libavutil/pixfmt.h>
 }
 
@@ -21,94 +22,94 @@ namespace KODI
 {
 namespace GAME
 {
+/*!
+ * \ingroup games
+ * \brief Translates data types from Game API to the corresponding format in Kodi.
+ *
+ * This class is stateless.
+ */
+class CGameClientTranslator
+{
+  CGameClientTranslator() = delete;
+
+public:
   /*!
-   * \ingroup games
-   * \brief Translates data types from Game API to the corresponding format in Kodi.
-   *
-   * This class is stateless.
+   * \brief Translates game errors to string representation (e.g. for logging).
+   * \param error The error to translate.
+   * \return Translated error.
    */
-  class CGameClientTranslator
-  {
-    CGameClientTranslator() = delete;
-
-  public:
-    /*!
-     * \brief Translates game errors to string representation (e.g. for logging).
-     * \param error The error to translate.
-     * \return Translated error.
-     */
-    static const char* ToString(GAME_ERROR error);
+  static const char* ToString(GAME_ERROR error);
 
-    /*!
-     * \brief Translates game memory types to string representation (e.g. for logging).
-     * \param memory The memory type to translate.
-     * \return Translated memory type.
-     */
-    static const char* ToString(GAME_MEMORY error);
+  /*!
+   * \brief Translates game memory types to string representation (e.g. for logging).
+   * \param memory The memory type to translate.
+   * \return Translated memory type.
+   */
+  static const char* ToString(GAME_MEMORY error);
 
-    /*!
-     * \brief Translate stream type (Game API to RetroPlayer).
-     * \param gameType The stream type to translate.
-     * \param[out] retroType The translated stream type.
-     * \return True if the Game API type was translated to a valid RetroPlayer type
-     */
-    static bool TranslateStreamType(GAME_STREAM_TYPE gameType, RETRO::StreamType &retroType);
+  /*!
+   * \brief Translate stream type (Game API to RetroPlayer).
+   * \param gameType The stream type to translate.
+   * \param[out] retroType The translated stream type.
+   * \return True if the Game API type was translated to a valid RetroPlayer type
+   */
+  static bool TranslateStreamType(GAME_STREAM_TYPE gameType, RETRO::StreamType& retroType);
 
-    /*!
-     * \brief Translate pixel format (Game API to RetroPlayer/FFMPEG).
-     * \param format The pixel format to translate.
-     * \return Translated pixel format.
-     */
-    static AVPixelFormat TranslatePixelFormat(GAME_PIXEL_FORMAT format);
+  /*!
+   * \brief Translate pixel format (Game API to RetroPlayer/FFMPEG).
+   * \param format The pixel format to translate.
+   * \return Translated pixel format.
+   */
+  static AVPixelFormat TranslatePixelFormat(GAME_PIXEL_FORMAT format);
 
-    /*!
-     * \brief Translate pixel format (RetroPlayer/FFMPEG to Game API).
-     * \param format The pixel format to translate.
-     * \return Translated pixel format.
-     */
-    static GAME_PIXEL_FORMAT TranslatePixelFormat(AVPixelFormat format);
+  /*!
+   * \brief Translate pixel format (RetroPlayer/FFMPEG to Game API).
+   * \param format The pixel format to translate.
+   * \return Translated pixel format.
+   */
+  static GAME_PIXEL_FORMAT TranslatePixelFormat(AVPixelFormat format);
 
-    /*!
-     * \brief Translate audio PCM format (Game API to RetroPlayer).
-     * \param format The audio PCM format to translate.
-     * \return Translated audio PCM format.
-     */
-    static RETRO::PCMFormat TranslatePCMFormat(GAME_PCM_FORMAT format);
+  /*!
+   * \brief Translate audio PCM format (Game API to RetroPlayer).
+   * \param format The audio PCM format to translate.
+   * \return Translated audio PCM format.
+   */
+  static RETRO::PCMFormat TranslatePCMFormat(GAME_PCM_FORMAT format);
 
-    /*!
-     * \brief Translate audio channels (Game API to RetroPlayer).
-     * \param format The audio channels to translate.
-     * \return Translated audio channels.
-     */
-    static RETRO::AudioChannel TranslateAudioChannel(GAME_AUDIO_CHANNEL channel);
+  /*!
+   * \brief Translate audio channels (Game API to RetroPlayer).
+   * \param format The audio channels to translate.
+   * \return Translated audio channels.
+   */
+  static RETRO::AudioChannel TranslateAudioChannel(GAME_AUDIO_CHANNEL channel);
 
-    /*!
-     * \brief Translate video rotation (Game API to RetroPlayer).
-     * \param rotation The video rotation to translate.
-     * \return Translated video rotation.
-     */
-    static RETRO::VideoRotation TranslateRotation(GAME_VIDEO_ROTATION rotation);
+  /*!
+   * \brief Translate video rotation (Game API to RetroPlayer).
+   * \param rotation The video rotation to translate.
+   * \return Translated video rotation.
+   */
+  static RETRO::VideoRotation TranslateRotation(GAME_VIDEO_ROTATION rotation);
 
-    /*!
-     * \brief Translate key modifiers (Kodi to Game API).
-     * \param modifiers The key modifiers to translate (e.g. Shift, Ctrl).
-     * \return Translated key modifiers.
-     */
-    static GAME_KEY_MOD GetModifiers(KEYBOARD::Modifier modifier);
+  /*!
+   * \brief Translate key modifiers (Kodi to Game API).
+   * \param modifiers The key modifiers to translate (e.g. Shift, Ctrl).
+   * \return Translated key modifiers.
+   */
+  static GAME_KEY_MOD GetModifiers(KEYBOARD::Modifier modifier);
 
-    /*!
-     * \brief Translate region to string representation (e.g. for logging).
-     * \param error The region to translate (e.g. PAL, NTSC).
-     * \return Translated region.
-     */
-    static const char* TranslateRegion(GAME_REGION region);
+  /*!
+   * \brief Translate region to string representation (e.g. for logging).
+   * \param error The region to translate (e.g. PAL, NTSC).
+   * \return Translated region.
+   */
+  static const char* TranslateRegion(GAME_REGION region);
 
-    /*!
-     * \brief Translate port type (Game API to Kodi)
-     * \param portType  The port type to translate
-     * \return Translated port type
-     */
-    static PORT_TYPE TranslatePortType(GAME_PORT_TYPE portType);
-  };
-}
-}
+  /*!
+   * \brief Translate port type (Game API to Kodi)
+   * \param portType  The port type to translate
+   * \return Translated port type
+   */
+  static PORT_TYPE TranslatePortType(GAME_PORT_TYPE portType);
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientController.cpp b/xbmc/games/addons/input/GameClientController.cpp
index 5b93ee456202..24a09862f33b 100644
--- a/xbmc/games/addons/input/GameClientController.cpp
+++ b/xbmc/games/addons/input/GameClientController.cpp
@@ -32,13 +32,11 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientController::CGameClientController(CGameClientInput &input, ControllerPtr controller) :
-  m_input(input),
-  m_controller(std::move(controller)),
-  m_controllerId(m_controller->ID())
+CGameClientController::CGameClientController(CGameClientInput& input, ControllerPtr controller)
+  : m_input(input), m_controller(std::move(controller)), m_controllerId(m_controller->ID())
 {
   // Generate arrays of features
-  for (const CControllerFeature &feature : m_controller->Features())
+  for (const CControllerFeature& feature : m_controller->Features())
   {
     // Skip feature if not supported by the game client
     if (!m_input.HasFeature(m_controller->ID(), feature.Name()))
diff --git a/xbmc/games/addons/input/GameClientController.h b/xbmc/games/addons/input/GameClientController.h
index 552605d61eaf..e39c3eafc23f 100644
--- a/xbmc/games/addons/input/GameClientController.h
+++ b/xbmc/games/addons/input/GameClientController.h
@@ -29,42 +29,42 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameClientInput;
+class CGameClientInput;
 
+/*!
+ * \brief A container for the layout of a controller connected to a game
+ *        client input port
+ */
+class CGameClientController
+{
+public:
   /*!
-   * \brief A container for the layout of a controller connected to a game
-   *        client input port
+   * \brief Construct a controller layout
+   *
+   * \brief controller The controller add-on
    */
-  class CGameClientController
-  {
-  public:
-    /*!
-     * \brief Construct a controller layout
-     *
-     * \brief controller The controller add-on
-     */
-    CGameClientController(CGameClientInput &input, ControllerPtr controller);
+  CGameClientController(CGameClientInput& input, ControllerPtr controller);
 
-    /*!
-     * \brief Get a controller layout for the Game API
-     */
-    game_controller_layout TranslateController() const;
+  /*!
+   * \brief Get a controller layout for the Game API
+   */
+  game_controller_layout TranslateController() const;
 
-  private:
-    // Construction parameters
-    CGameClientInput &m_input;
-    const ControllerPtr m_controller;
+private:
+  // Construction parameters
+  CGameClientInput& m_input;
+  const ControllerPtr m_controller;
 
-    // Buffer parameters
-    std::string m_controllerId;
-    std::vector<char*> m_digitalButtons;
-    std::vector<char*> m_analogButtons;
-    std::vector<char*> m_analogSticks;
-    std::vector<char*> m_accelerometers;
-    std::vector<char*> m_keys;
-    std::vector<char*> m_relPointers;
-    std::vector<char*> m_absPointers;
-    std::vector<char*> m_motors;
-  };
+  // Buffer parameters
+  std::string m_controllerId;
+  std::vector<char*> m_digitalButtons;
+  std::vector<char*> m_analogButtons;
+  std::vector<char*> m_analogSticks;
+  std::vector<char*> m_accelerometers;
+  std::vector<char*> m_keys;
+  std::vector<char*> m_relPointers;
+  std::vector<char*> m_absPointers;
+  std::vector<char*> m_motors;
+};
 } // namespace GAME
 } // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientDevice.cpp b/xbmc/games/addons/input/GameClientDevice.cpp
index a6cd3ead3ee1..693e3f4b0782 100644
--- a/xbmc/games/addons/input/GameClientDevice.cpp
+++ b/xbmc/games/addons/input/GameClientDevice.cpp
@@ -21,18 +21,18 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientDevice::CGameClientDevice(const game_input_device &device) :
-  m_controller(GetController(device.controller_id))
+CGameClientDevice::CGameClientDevice(const game_input_device& device)
+  : m_controller(GetController(device.controller_id))
 {
   if (m_controller && device.available_ports != nullptr)
   {
     // Look for matching ports. We enumerate in physical order because logical
     // order can change per emulator.
-    for (const auto &physicalPort : m_controller->Topology().Ports())
+    for (const auto& physicalPort : m_controller->Topology().Ports())
     {
       for (unsigned int i = 0; i < device.port_count; i++)
       {
-        const auto &logicalPort = device.available_ports[i];
+        const auto& logicalPort = device.available_ports[i];
         if (logicalPort.port_id != nullptr && logicalPort.port_id == physicalPort.ID())
         {
           // Handle matching ports
@@ -44,20 +44,20 @@ CGameClientDevice::CGameClientDevice(const game_input_device &device) :
   }
 }
 
-CGameClientDevice::CGameClientDevice(const ControllerPtr &controller) :
-  m_controller(controller)
+CGameClientDevice::CGameClientDevice(const ControllerPtr& controller) : m_controller(controller)
 {
 }
 
 CGameClientDevice::~CGameClientDevice() = default;
 
-void CGameClientDevice::AddPort(const game_input_port &logicalPort, const CControllerPort &physicalPort)
+void CGameClientDevice::AddPort(const game_input_port& logicalPort,
+                                const CControllerPort& physicalPort)
 {
   std::unique_ptr<CGameClientPort> port(new CGameClientPort(logicalPort, physicalPort));
   m_ports.emplace_back(std::move(port));
 }
 
-ControllerPtr CGameClientDevice::GetController(const char *controllerId)
+ControllerPtr CGameClientDevice::GetController(const char* controllerId)
 {
   ControllerPtr controller;
 
diff --git a/xbmc/games/addons/input/GameClientDevice.h b/xbmc/games/addons/input/GameClientDevice.h
index f291c3af155c..778f595d687a 100644
--- a/xbmc/games/addons/input/GameClientDevice.h
+++ b/xbmc/games/addons/input/GameClientDevice.h
@@ -20,58 +20,58 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerPort;
+class CControllerPort;
 
+/*!
+ * \ingroup games
+ * \brief Represents a device connected to a port
+ */
+class CGameClientDevice
+{
+public:
   /*!
-   * \ingroup games
-   * \brief Represents a device connected to a port
+   * \brief Construct a device
+   *
+   * \param device The device Game API struct
    */
-  class CGameClientDevice
-  {
-  public:
-    /*!
-     * \brief Construct a device
-     *
-     * \param device The device Game API struct
-     */
-    CGameClientDevice(const game_input_device &device);
+  CGameClientDevice(const game_input_device& device);
 
-    /*!
-     * \brief Construct a device from a controller add-on
-     *
-     * \param controller The controller add-on
-     */
-    CGameClientDevice(const ControllerPtr &controller);
+  /*!
+   * \brief Construct a device from a controller add-on
+   *
+   * \param controller The controller add-on
+   */
+  CGameClientDevice(const ControllerPtr& controller);
 
-    /*!
-     * \brief Destructor
-     */
-    ~CGameClientDevice();
+  /*!
+   * \brief Destructor
+   */
+  ~CGameClientDevice();
 
-    /*!
-     * \brief The controller profile
-     */
-    const ControllerPtr &Controller() const { return m_controller; }
+  /*!
+   * \brief The controller profile
+   */
+  const ControllerPtr& Controller() const { return m_controller; }
 
-    /*!
-     * \brief The ports on this device
-     */
-    const GameClientPortVec &Ports() const { return m_ports; }
+  /*!
+   * \brief The ports on this device
+   */
+  const GameClientPortVec& Ports() const { return m_ports; }
 
-  private:
-    /*!
-     * \brief Add a controller port
-     *
-     * \param logicalPort The logical port Game API struct
-     * \param physicalPort The physical port definition
-     */
-    void AddPort(const game_input_port &logicalPort, const CControllerPort &physicalPort);
+private:
+  /*!
+   * \brief Add a controller port
+   *
+   * \param logicalPort The logical port Game API struct
+   * \param physicalPort The physical port definition
+   */
+  void AddPort(const game_input_port& logicalPort, const CControllerPort& physicalPort);
 
-    // Helper function
-    static ControllerPtr GetController(const char *controllerId);
+  // Helper function
+  static ControllerPtr GetController(const char* controllerId);
 
-    ControllerPtr m_controller;
-    GameClientPortVec m_ports;
-  };
-}
-}
+  ControllerPtr m_controller;
+  GameClientPortVec m_ports;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientHardware.cpp b/xbmc/games/addons/input/GameClientHardware.cpp
index d55aa5eea8b0..61f0c6adb252 100644
--- a/xbmc/games/addons/input/GameClientHardware.cpp
+++ b/xbmc/games/addons/input/GameClientHardware.cpp
@@ -14,8 +14,7 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientHardware::CGameClientHardware(CGameClient &gameClient) :
-  m_gameClient(gameClient)
+CGameClientHardware::CGameClientHardware(CGameClient& gameClient) : m_gameClient(gameClient)
 {
 }
 
diff --git a/xbmc/games/addons/input/GameClientHardware.h b/xbmc/games/addons/input/GameClientHardware.h
index 5344c002fbd8..1ffc96bae881 100644
--- a/xbmc/games/addons/input/GameClientHardware.h
+++ b/xbmc/games/addons/input/GameClientHardware.h
@@ -14,30 +14,30 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameClient;
+class CGameClient;
 
+/*!
+ * \ingroup games
+ * \brief Handles events for hardware such as reset buttons
+ */
+class CGameClientHardware : public HARDWARE::IHardwareInput
+{
+public:
   /*!
-   * \ingroup games
-   * \brief Handles events for hardware such as reset buttons
+   * \brief Constructor
+   *
+   * \param gameClient The game client implementation
    */
-  class CGameClientHardware : public HARDWARE::IHardwareInput
-  {
-  public:
-    /*!
-     * \brief Constructor
-     *
-     * \param gameClient The game client implementation
-     */
-    explicit CGameClientHardware(CGameClient &gameClient);
+  explicit CGameClientHardware(CGameClient& gameClient);
 
-    ~CGameClientHardware() override = default;
+  ~CGameClientHardware() override = default;
 
-    // Implementation of IHardwareInput
-    void OnResetButton() override;
+  // Implementation of IHardwareInput
+  void OnResetButton() override;
 
-  private:
-    // Construction parameter
-    CGameClient &m_gameClient;
-  };
-}
-}
+private:
+  // Construction parameter
+  CGameClient& m_gameClient;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientInput.cpp b/xbmc/games/addons/input/GameClientInput.cpp
index 481f9686ee83..ef45d5c0a9e3 100644
--- a/xbmc/games/addons/input/GameClientInput.cpp
+++ b/xbmc/games/addons/input/GameClientInput.cpp
@@ -33,11 +33,10 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientInput::CGameClientInput(CGameClient &gameClient,
-                                   AddonInstance_Game &addonStruct,
-                                   CCriticalSection &clientAccess) :
-  CGameClientSubsystem(gameClient, addonStruct, clientAccess),
-  m_topology(new CGameClientTopology)
+CGameClientInput::CGameClientInput(CGameClient& gameClient,
+                                   AddonInstance_Game& addonStruct,
+                                   CCriticalSection& clientAccess)
+  : CGameClientSubsystem(gameClient, addonStruct, clientAccess), m_topology(new CGameClientTopology)
 {
 }
 
@@ -55,21 +54,19 @@ void CGameClientInput::Initialize()
   SetControllerLayouts(m_topology->ControllerTree().GetControllers());
 }
 
-void CGameClientInput::Start(IGameInputCallback *input)
+void CGameClientInput::Start(IGameInputCallback* input)
 {
   m_inputCallback = input;
 
-  const CControllerTree &controllers = m_topology->ControllerTree();
+  const CControllerTree& controllers = m_topology->ControllerTree();
 
   // Open keyboard
   //! @todo Move to player manager
   if (SupportsKeyboard())
   {
-    auto it = std::find_if(controllers.Ports().begin(), controllers.Ports().end(),
-      [](const CControllerPortNode &port)
-      {
-        return port.PortType() == PORT_TYPE::KEYBOARD;
-      });
+    auto it = std::find_if(
+        controllers.Ports().begin(), controllers.Ports().end(),
+        [](const CControllerPortNode& port) { return port.PortType() == PORT_TYPE::KEYBOARD; });
 
     OpenKeyboard(it->ActiveController().Controller());
   }
@@ -78,18 +75,16 @@ void CGameClientInput::Start(IGameInputCallback *input)
   //! @todo Move to player manager
   if (SupportsMouse())
   {
-    auto it = std::find_if(controllers.Ports().begin(), controllers.Ports().end(),
-      [](const CControllerPortNode &port)
-      {
-        return port.PortType() == PORT_TYPE::MOUSE;
-      });
+    auto it = std::find_if(
+        controllers.Ports().begin(), controllers.Ports().end(),
+        [](const CControllerPortNode& port) { return port.PortType() == PORT_TYPE::MOUSE; });
 
     OpenMouse(it->ActiveController().Controller());
   }
 
   // Open joysticks
   //! @todo Move to player manager
-  for (const auto &port : controllers.Ports())
+  for (const auto& port : controllers.Ports())
   {
     if (port.PortType() == PORT_TYPE::CONTROLLER && !port.CompatibleControllers().empty())
     {
@@ -121,10 +116,10 @@ void CGameClientInput::Stop()
   m_hardware.reset();
 
   std::vector<std::string> ports;
-  for (const auto &it : m_joysticks)
+  for (const auto& it : m_joysticks)
     ports.emplace_back(it.first);
 
-  for (const std::string &port : ports)
+  for (const std::string& port : ports)
     CloseJoystick(port);
   m_portMap.clear();
 
@@ -135,7 +130,8 @@ void CGameClientInput::Stop()
   m_inputCallback = nullptr;
 }
 
-bool CGameClientInput::HasFeature(const std::string &controllerId, const std::string &featureName) const
+bool CGameClientInput::HasFeature(const std::string& controllerId,
+                                  const std::string& featureName) const
 {
   bool bHasFeature = false;
 
@@ -162,7 +158,7 @@ bool CGameClientInput::AcceptsInput() const
   return false;
 }
 
-bool CGameClientInput::InputEvent(const game_input_event &event)
+bool CGameClientInput::InputEvent(const game_input_event& event)
 {
   bool bHandled = false;
 
@@ -180,7 +176,7 @@ bool CGameClientInput::InputEvent(const game_input_event &event)
 
 void CGameClientInput::LoadTopology()
 {
-  game_input_topology *topologyStruct = nullptr;
+  game_input_topology* topologyStruct = nullptr;
 
   if (m_gameClient.Initialized())
   {
@@ -188,7 +184,10 @@ void CGameClientInput::LoadTopology()
     {
       topologyStruct = m_struct.toAddon.GetTopology(&m_struct);
     }
-    catch (...) { m_gameClient.LogException("GetTopology()"); }
+    catch (...)
+    {
+      m_gameClient.LogException("GetTopology()");
+    }
   }
 
   GameClientPortVec hardwarePorts;
@@ -198,7 +197,7 @@ void CGameClientInput::LoadTopology()
   {
     //! @todo Guard against infinite loops provided by the game client
 
-    game_input_port *ports = topologyStruct->ports;
+    game_input_port* ports = topologyStruct->ports;
     if (ports != nullptr)
     {
       for (unsigned int i = 0; i < topologyStruct->port_count; i++)
@@ -211,7 +210,10 @@ void CGameClientInput::LoadTopology()
     {
       m_struct.toAddon.FreeTopology(&m_struct, topologyStruct);
     }
-    catch (...) { m_gameClient.LogException("FreeTopology()"); }
+    catch (...)
+    {
+      m_gameClient.LogException("FreeTopology()");
+    }
   }
 
   // If no topology is available, create a default one with a single port that
@@ -222,9 +224,9 @@ void CGameClientInput::LoadTopology()
   m_topology.reset(new CGameClientTopology(std::move(hardwarePorts), playerLimit));
 }
 
-void CGameClientInput::ActivateControllers(CControllerHub &hub)
+void CGameClientInput::ActivateControllers(CControllerHub& hub)
 {
-  for (auto &port : hub.Ports())
+  for (auto& port : hub.Ports())
   {
     port.SetConnected(true);
     port.SetActiveController(0);
@@ -232,12 +234,12 @@ void CGameClientInput::ActivateControllers(CControllerHub &hub)
   }
 }
 
-void CGameClientInput::SetControllerLayouts(const ControllerVector &controllers)
+void CGameClientInput::SetControllerLayouts(const ControllerVector& controllers)
 {
   if (controllers.empty())
     return;
 
-  for (const auto &controller : controllers)
+  for (const auto& controller : controllers)
   {
     const std::string controllerId = controller->ID();
     if (m_controllerLayouts.find(controllerId) == m_controllerLayouts.end())
@@ -245,7 +247,7 @@ void CGameClientInput::SetControllerLayouts(const ControllerVector &controllers)
   }
 
   std::vector<game_controller_layout> controllerStructs;
-  for (const auto &it : m_controllerLayouts)
+  for (const auto& it : m_controllerLayouts)
     controllerStructs.emplace_back(it.second->TranslateController());
 
   try
@@ -259,33 +261,29 @@ void CGameClientInput::SetControllerLayouts(const ControllerVector &controllers)
   }
 }
 
-const CControllerTree &CGameClientInput::GetControllerTree() const
+const CControllerTree& CGameClientInput::GetControllerTree() const
 {
   return m_topology->ControllerTree();
 }
 
 bool CGameClientInput::SupportsKeyboard() const
 {
-  const CControllerTree &controllers = m_topology->ControllerTree();
+  const CControllerTree& controllers = m_topology->ControllerTree();
 
-  auto it = std::find_if(controllers.Ports().begin(), controllers.Ports().end(),
-    [](const CControllerPortNode &port)
-    {
-      return port.PortType() == PORT_TYPE::KEYBOARD;
-    });
+  auto it = std::find_if(
+      controllers.Ports().begin(), controllers.Ports().end(),
+      [](const CControllerPortNode& port) { return port.PortType() == PORT_TYPE::KEYBOARD; });
 
   return it != controllers.Ports().end() && !it->CompatibleControllers().empty();
 }
 
 bool CGameClientInput::SupportsMouse() const
 {
-  const CControllerTree &controllers = m_topology->ControllerTree();
+  const CControllerTree& controllers = m_topology->ControllerTree();
 
-  auto it = std::find_if(controllers.Ports().begin(), controllers.Ports().end(),
-    [](const CControllerPortNode &port)
-    {
-      return port.PortType() == PORT_TYPE::MOUSE;
-    });
+  auto it = std::find_if(
+      controllers.Ports().begin(), controllers.Ports().end(),
+      [](const CControllerPortNode& port) { return port.PortType() == PORT_TYPE::MOUSE; });
 
   return it != controllers.Ports().end() && !it->CompatibleControllers().empty();
 }
@@ -310,7 +308,7 @@ bool CGameClientInput::HasAgent() const
   return false;
 }
 
-bool CGameClientInput::OpenKeyboard(const ControllerPtr &controller)
+bool CGameClientInput::OpenKeyboard(const ControllerPtr& controller)
 {
   using namespace JOYSTICK;
 
@@ -322,7 +320,8 @@ bool CGameClientInput::OpenKeyboard(const ControllerPtr &controller)
 
   //! @todo Move to player manager
   PERIPHERALS::PeripheralVector keyboards;
-  CServiceBroker::GetPeripherals().GetPeripheralsWithFeature(keyboards, PERIPHERALS::FEATURE_KEYBOARD);
+  CServiceBroker::GetPeripherals().GetPeripheralsWithFeature(keyboards,
+                                                             PERIPHERALS::FEATURE_KEYBOARD);
   if (keyboards.empty())
     return false;
 
@@ -346,7 +345,8 @@ bool CGameClientInput::OpenKeyboard(const ControllerPtr &controller)
 
   if (bSuccess)
   {
-    m_keyboard.reset(new CGameClientKeyboard(m_gameClient, controller->ID(), keyboards.at(0).get()));
+    m_keyboard.reset(
+        new CGameClientKeyboard(m_gameClient, controller->ID(), keyboards.at(0).get()));
     return true;
   }
 
@@ -374,7 +374,7 @@ void CGameClientInput::CloseKeyboard()
   }
 }
 
-bool CGameClientInput::OpenMouse(const ControllerPtr &controller)
+bool CGameClientInput::OpenMouse(const ControllerPtr& controller)
 {
   using namespace JOYSTICK;
 
@@ -438,7 +438,7 @@ void CGameClientInput::CloseMouse()
   }
 }
 
-bool CGameClientInput::OpenJoystick(const std::string &portAddress, const ControllerPtr &controller)
+bool CGameClientInput::OpenJoystick(const std::string& portAddress, const ControllerPtr& controller)
 {
   using namespace JOYSTICK;
 
@@ -448,9 +448,9 @@ bool CGameClientInput::OpenJoystick(const std::string &portAddress, const Contro
     return false;
   }
 
-  const CControllerTree &controllerTree = m_topology->ControllerTree();
+  const CControllerTree& controllerTree = m_topology->ControllerTree();
 
-  const CControllerPortNode &port = controllerTree.GetPort(portAddress);
+  const CControllerPortNode& port = controllerTree.GetPort(portAddress);
   if (!port.IsControllerAccepted(portAddress, controller->ID()))
   {
     CLog::Log(LOGERROR, "Failed to open port: Invalid controller \"%s\" on port \"%s\"",
@@ -490,7 +490,7 @@ bool CGameClientInput::OpenJoystick(const std::string &portAddress, const Contro
   return false;
 }
 
-void CGameClientInput::CloseJoystick(const std::string &portAddress)
+void CGameClientInput::CloseJoystick(const std::string& portAddress)
 {
   auto it = m_joysticks.find(portAddress);
   if (it != m_joysticks.end())
@@ -545,7 +545,9 @@ bool CGameClientInput::ReceiveInputEvent(const game_input_event& event)
   return bHandled;
 }
 
-bool CGameClientInput::SetRumble(const std::string &portAddress, const std::string& feature, float magnitude)
+bool CGameClientInput::SetRumble(const std::string& portAddress,
+                                 const std::string& feature,
+                                 float magnitude)
 {
   bool bHandled = false;
 
@@ -560,23 +562,24 @@ void CGameClientInput::Notify(const Observable& obs, const ObservableMessage msg
 {
   switch (msg)
   {
-  case ObservableMessagePeripheralsChanged:
-  {
-    PERIPHERALS::EventLockHandlePtr lock = CServiceBroker::GetPeripherals().RegisterEventLock();
+    case ObservableMessagePeripheralsChanged:
+    {
+      PERIPHERALS::EventLockHandlePtr lock = CServiceBroker::GetPeripherals().RegisterEventLock();
 
-    ProcessJoysticks();
+      ProcessJoysticks();
 
-    break;
-  }
-  default:
-    break;
+      break;
+    }
+    default:
+      break;
   }
 }
 
 void CGameClientInput::ProcessJoysticks()
 {
   PERIPHERALS::PeripheralVector joysticks;
-  CServiceBroker::GetPeripherals().GetPeripheralsWithFeature(joysticks, PERIPHERALS::FEATURE_JOYSTICK);
+  CServiceBroker::GetPeripherals().GetPeripheralsWithFeature(joysticks,
+                                                             PERIPHERALS::FEATURE_JOYSTICK);
 
   // Update expired joysticks
   PortMap portMapCopy = m_portMap;
@@ -585,11 +588,12 @@ void CGameClientInput::ProcessJoysticks()
     JOYSTICK::IInputProvider* inputProvider = it.first;
     CGameClientJoystick* gameJoystick = it.second;
 
-    const bool bExpired = std::find_if(joysticks.begin(), joysticks.end(),
-      [inputProvider](const PERIPHERALS::PeripheralPtr &joystick)
-      {
-        return inputProvider == static_cast<JOYSTICK::IInputProvider*>(joystick.get());
-      }) == joysticks.end();
+    const bool bExpired =
+        std::find_if(joysticks.begin(), joysticks.end(),
+                     [inputProvider](const PERIPHERALS::PeripheralPtr& joystick) {
+                       return inputProvider ==
+                              static_cast<JOYSTICK::IInputProvider*>(joystick.get());
+                     }) == joysticks.end();
 
     if (bExpired)
     {
@@ -605,13 +609,15 @@ void CGameClientInput::ProcessJoysticks()
   for (auto& peripheralJoystick : joysticks)
   {
     // Upcast to input interface
-    JOYSTICK::IInputProvider *inputProvider = peripheralJoystick.get();
+    JOYSTICK::IInputProvider* inputProvider = peripheralJoystick.get();
 
     auto itConnectedPort = newPortMap.find(inputProvider);
     auto itDisconnectedPort = m_portMap.find(inputProvider);
 
-    CGameClientJoystick* newJoystick = itConnectedPort != newPortMap.end() ? itConnectedPort->second : nullptr;
-    CGameClientJoystick* oldJoystick = itDisconnectedPort != m_portMap.end() ? itDisconnectedPort->second : nullptr;
+    CGameClientJoystick* newJoystick =
+        itConnectedPort != newPortMap.end() ? itConnectedPort->second : nullptr;
+    CGameClientJoystick* oldJoystick =
+        itDisconnectedPort != m_portMap.end() ? itDisconnectedPort->second : nullptr;
 
     if (oldJoystick != newJoystick)
     {
@@ -632,8 +638,9 @@ void CGameClientInput::ProcessJoysticks()
   }
 }
 
-CGameClientInput::PortMap CGameClientInput::MapJoysticks(const PERIPHERALS::PeripheralVector &peripheralJoysticks,
-                                                         const JoystickMap &gameClientjoysticks) const
+CGameClientInput::PortMap CGameClientInput::MapJoysticks(
+    const PERIPHERALS::PeripheralVector& peripheralJoysticks,
+    const JoystickMap& gameClientjoysticks) const
 {
   PortMap result;
 
@@ -642,18 +649,17 @@ CGameClientInput::PortMap CGameClientInput::MapJoysticks(const PERIPHERALS::Peri
   // Sort by order of last button press
   PERIPHERALS::PeripheralVector sortedJoysticks = peripheralJoysticks;
   std::sort(sortedJoysticks.begin(), sortedJoysticks.end(),
-    [](const PERIPHERALS::PeripheralPtr &lhs, const PERIPHERALS::PeripheralPtr &rhs)
-    {
-      if (lhs->LastActive().IsValid() && !rhs->LastActive().IsValid())
-        return true;
-      if (!lhs->LastActive().IsValid() && rhs->LastActive().IsValid())
-        return false;
+            [](const PERIPHERALS::PeripheralPtr& lhs, const PERIPHERALS::PeripheralPtr& rhs) {
+              if (lhs->LastActive().IsValid() && !rhs->LastActive().IsValid())
+                return true;
+              if (!lhs->LastActive().IsValid() && rhs->LastActive().IsValid())
+                return false;
 
-      return lhs->LastActive() > rhs->LastActive();
-    });
+              return lhs->LastActive() > rhs->LastActive();
+            });
 
   unsigned int i = 0;
-  for (const auto &it : gameClientjoysticks)
+  for (const auto& it : gameClientjoysticks)
   {
     if (i >= peripheralJoysticks.size())
       break;
@@ -664,8 +670,8 @@ CGameClientInput::PortMap CGameClientInput::MapJoysticks(const PERIPHERALS::Peri
       break;
 
     // Dereference iterators
-    const PERIPHERALS::PeripheralPtr &peripheralJoystick = sortedJoysticks[i++];
-    const std::unique_ptr<CGameClientJoystick> &gameClientJoystick = it.second;
+    const PERIPHERALS::PeripheralPtr& peripheralJoystick = sortedJoysticks[i++];
+    const std::unique_ptr<CGameClientJoystick>& gameClientJoystick = it.second;
 
     // Map input provider to input handler
     result[peripheralJoystick.get()] = gameClientJoystick.get();
@@ -674,7 +680,7 @@ CGameClientInput::PortMap CGameClientInput::MapJoysticks(const PERIPHERALS::Peri
   return result;
 }
 
-ControllerVector CGameClientInput::GetControllers(const CGameClient &gameClient)
+ControllerVector CGameClientInput::GetControllers(const CGameClient& gameClient)
 {
   using namespace ADDON;
 
diff --git a/xbmc/games/addons/input/GameClientInput.h b/xbmc/games/addons/input/GameClientInput.h
index 4607730a72ef..19989f92b910 100644
--- a/xbmc/games/addons/input/GameClientInput.h
+++ b/xbmc/games/addons/input/GameClientInput.h
@@ -25,98 +25,97 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IInputProvider;
+class IInputProvider;
 }
 
 namespace GAME
 {
-  class CGameClient;
-  class CGameClientController;
-  class CGameClientHardware;
-  class CGameClientJoystick;
-  class CGameClientKeyboard;
-  class CGameClientMouse;
-  class CGameClientTopology;
-  class IGameInputCallback;
-
-  class CGameClientInput : protected CGameClientSubsystem,
-                           public Observer
-  {
-  public:
-    CGameClientInput(CGameClient &gameClient,
-                     AddonInstance_Game &addonStruct,
-                     CCriticalSection &clientAccess);
-    ~CGameClientInput() override;
-
-    void Initialize();
-    void Deinitialize();
-
-    void Start(IGameInputCallback *input);
-    void Stop();
-
-    // Input functions
-    bool HasFeature(const std::string &controllerId, const std::string &featureName) const;
-    bool AcceptsInput() const;
-    bool InputEvent(const game_input_event &event);
-
-    // Topology functions
-    const CControllerTree &GetControllerTree() const;
-    bool SupportsKeyboard() const;
-    bool SupportsMouse() const;
-
-    // Agent functions
-    bool HasAgent() const;
-
-    // Keyboard functions
-    bool OpenKeyboard(const ControllerPtr &controller);
-    void CloseKeyboard();
-
-    // Mouse functions
-    bool OpenMouse(const ControllerPtr &controller);
-    void CloseMouse();
-
-    // Joystick functions
-    bool OpenJoystick(const std::string &portAddress, const ControllerPtr &controller);
-    void CloseJoystick(const std::string &portAddress);
-
-    // Hardware input functions
-    void HardwareReset();
-
-    // Input callbacks
-    bool ReceiveInputEvent(const game_input_event& eventStruct);
-
-    // Implementation of Observer
-    void Notify(const Observable& obs, const ObservableMessage msg) override;
-
-  private:
-    using PortAddress = std::string;
-    using JoystickMap = std::map<PortAddress, std::unique_ptr<CGameClientJoystick>>;
-    using PortMap = std::map<JOYSTICK::IInputProvider*, CGameClientJoystick*>;
-
-    // Private input helpers
-    void LoadTopology();
-    void SetControllerLayouts(const ControllerVector &controllers);
-    void ProcessJoysticks();
-    PortMap MapJoysticks(const PERIPHERALS::PeripheralVector &peripheralJoysticks,
-                         const JoystickMap &gameClientjoysticks) const;
-
-    // Private callback helpers
-    bool SetRumble(const std::string &portAddress, const std::string& feature, float magnitude);
-
-    // Helper functions
-    static ControllerVector GetControllers(const CGameClient &gameClient);
-    static void ActivateControllers(CControllerHub &hub);
-
-    // Input properties
-    IGameInputCallback *m_inputCallback = nullptr;
-    std::unique_ptr<CGameClientTopology> m_topology;
-    using ControllerLayoutMap = std::map<std::string, std::unique_ptr<CGameClientController>>;
-    ControllerLayoutMap m_controllerLayouts;
-    JoystickMap m_joysticks;
-    PortMap m_portMap;
-    std::unique_ptr<CGameClientKeyboard> m_keyboard;
-    std::unique_ptr<CGameClientMouse> m_mouse;
-    std::unique_ptr<CGameClientHardware> m_hardware;
-  };
+class CGameClient;
+class CGameClientController;
+class CGameClientHardware;
+class CGameClientJoystick;
+class CGameClientKeyboard;
+class CGameClientMouse;
+class CGameClientTopology;
+class IGameInputCallback;
+
+class CGameClientInput : protected CGameClientSubsystem, public Observer
+{
+public:
+  CGameClientInput(CGameClient& gameClient,
+                   AddonInstance_Game& addonStruct,
+                   CCriticalSection& clientAccess);
+  ~CGameClientInput() override;
+
+  void Initialize();
+  void Deinitialize();
+
+  void Start(IGameInputCallback* input);
+  void Stop();
+
+  // Input functions
+  bool HasFeature(const std::string& controllerId, const std::string& featureName) const;
+  bool AcceptsInput() const;
+  bool InputEvent(const game_input_event& event);
+
+  // Topology functions
+  const CControllerTree& GetControllerTree() const;
+  bool SupportsKeyboard() const;
+  bool SupportsMouse() const;
+
+  // Agent functions
+  bool HasAgent() const;
+
+  // Keyboard functions
+  bool OpenKeyboard(const ControllerPtr& controller);
+  void CloseKeyboard();
+
+  // Mouse functions
+  bool OpenMouse(const ControllerPtr& controller);
+  void CloseMouse();
+
+  // Joystick functions
+  bool OpenJoystick(const std::string& portAddress, const ControllerPtr& controller);
+  void CloseJoystick(const std::string& portAddress);
+
+  // Hardware input functions
+  void HardwareReset();
+
+  // Input callbacks
+  bool ReceiveInputEvent(const game_input_event& eventStruct);
+
+  // Implementation of Observer
+  void Notify(const Observable& obs, const ObservableMessage msg) override;
+
+private:
+  using PortAddress = std::string;
+  using JoystickMap = std::map<PortAddress, std::unique_ptr<CGameClientJoystick>>;
+  using PortMap = std::map<JOYSTICK::IInputProvider*, CGameClientJoystick*>;
+
+  // Private input helpers
+  void LoadTopology();
+  void SetControllerLayouts(const ControllerVector& controllers);
+  void ProcessJoysticks();
+  PortMap MapJoysticks(const PERIPHERALS::PeripheralVector& peripheralJoysticks,
+                       const JoystickMap& gameClientjoysticks) const;
+
+  // Private callback helpers
+  bool SetRumble(const std::string& portAddress, const std::string& feature, float magnitude);
+
+  // Helper functions
+  static ControllerVector GetControllers(const CGameClient& gameClient);
+  static void ActivateControllers(CControllerHub& hub);
+
+  // Input properties
+  IGameInputCallback* m_inputCallback = nullptr;
+  std::unique_ptr<CGameClientTopology> m_topology;
+  using ControllerLayoutMap = std::map<std::string, std::unique_ptr<CGameClientController>>;
+  ControllerLayoutMap m_controllerLayouts;
+  JoystickMap m_joysticks;
+  PortMap m_portMap;
+  std::unique_ptr<CGameClientKeyboard> m_keyboard;
+  std::unique_ptr<CGameClientMouse> m_mouse;
+  std::unique_ptr<CGameClientHardware> m_hardware;
+};
 } // namespace GAME
 } // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientJoystick.cpp b/xbmc/games/addons/input/GameClientJoystick.cpp
index e78f989b761a..6c1a77fc741d 100644
--- a/xbmc/games/addons/input/GameClientJoystick.cpp
+++ b/xbmc/games/addons/input/GameClientJoystick.cpp
@@ -20,25 +20,25 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientJoystick::CGameClientJoystick(CGameClient &gameClient,
-                                         const std::string &portAddress,
-                                         const ControllerPtr& controller) :
-  m_gameClient(gameClient),
-  m_portAddress(portAddress),
-  m_controller(controller),
-  m_port(new CPort(this))
+CGameClientJoystick::CGameClientJoystick(CGameClient& gameClient,
+                                         const std::string& portAddress,
+                                         const ControllerPtr& controller)
+  : m_gameClient(gameClient),
+    m_portAddress(portAddress),
+    m_controller(controller),
+    m_port(new CPort(this))
 {
   assert(m_controller.get() != NULL);
 }
 
 CGameClientJoystick::~CGameClientJoystick() = default;
 
-void CGameClientJoystick::RegisterInput(JOYSTICK::IInputProvider *inputProvider)
+void CGameClientJoystick::RegisterInput(JOYSTICK::IInputProvider* inputProvider)
 {
   m_port->RegisterInput(inputProvider);
 }
 
-void CGameClientJoystick::UnregisterInput(JOYSTICK::IInputProvider *inputProvider)
+void CGameClientJoystick::UnregisterInput(JOYSTICK::IInputProvider* inputProvider)
 {
   m_port->UnregisterInput(inputProvider);
 }
@@ -53,7 +53,7 @@ bool CGameClientJoystick::HasFeature(const std::string& feature) const
   return m_gameClient.Input().HasFeature(m_controller->ID(), feature);
 }
 
-bool CGameClientJoystick::AcceptsInput(const std::string &feature) const
+bool CGameClientJoystick::AcceptsInput(const std::string& feature) const
 {
   return m_gameClient.Input().AcceptsInput();
 }
@@ -64,61 +64,69 @@ bool CGameClientJoystick::OnButtonPress(const std::string& feature, bool bPresse
 
   std::string controllerId = m_controller->ID();
 
-  event.type                   = GAME_INPUT_EVENT_DIGITAL_BUTTON;
-  event.controller_id          = controllerId.c_str();
-  event.port_type              = GAME_PORT_CONTROLLER;
-  event.port_address           = m_portAddress.c_str();
-  event.feature_name           = feature.c_str();
+  event.type = GAME_INPUT_EVENT_DIGITAL_BUTTON;
+  event.controller_id = controllerId.c_str();
+  event.port_type = GAME_PORT_CONTROLLER;
+  event.port_address = m_portAddress.c_str();
+  event.feature_name = feature.c_str();
   event.digital_button.pressed = bPressed;
 
   return m_gameClient.Input().InputEvent(event);
 }
 
-bool CGameClientJoystick::OnButtonMotion(const std::string& feature, float magnitude, unsigned int motionTimeMs)
+bool CGameClientJoystick::OnButtonMotion(const std::string& feature,
+                                         float magnitude,
+                                         unsigned int motionTimeMs)
 {
   game_input_event event;
 
   std::string controllerId = m_controller->ID();
 
-  event.type                    = GAME_INPUT_EVENT_ANALOG_BUTTON;
-  event.controller_id           = controllerId.c_str();
-  event.port_type               = GAME_PORT_CONTROLLER;
-  event.port_address            = m_portAddress.c_str();
-  event.feature_name            = feature.c_str();
+  event.type = GAME_INPUT_EVENT_ANALOG_BUTTON;
+  event.controller_id = controllerId.c_str();
+  event.port_type = GAME_PORT_CONTROLLER;
+  event.port_address = m_portAddress.c_str();
+  event.feature_name = feature.c_str();
   event.analog_button.magnitude = magnitude;
 
 
   return m_gameClient.Input().InputEvent(event);
 }
 
-bool CGameClientJoystick::OnAnalogStickMotion(const std::string& feature, float x, float y, unsigned int motionTimeMs)
+bool CGameClientJoystick::OnAnalogStickMotion(const std::string& feature,
+                                              float x,
+                                              float y,
+                                              unsigned int motionTimeMs)
 {
   game_input_event event;
 
   std::string controllerId = m_controller->ID();
 
-  event.type           = GAME_INPUT_EVENT_ANALOG_STICK;
-  event.controller_id  = controllerId.c_str();
-  event.port_type      = GAME_PORT_CONTROLLER;
-  event.port_address   = m_portAddress.c_str();
-  event.feature_name   = feature.c_str();
+  event.type = GAME_INPUT_EVENT_ANALOG_STICK;
+  event.controller_id = controllerId.c_str();
+  event.port_type = GAME_PORT_CONTROLLER;
+  event.port_address = m_portAddress.c_str();
+  event.feature_name = feature.c_str();
   event.analog_stick.x = x;
   event.analog_stick.y = y;
 
   return m_gameClient.Input().InputEvent(event);
 }
 
-bool CGameClientJoystick::OnAccelerometerMotion(const std::string& feature, float x, float y, float z)
+bool CGameClientJoystick::OnAccelerometerMotion(const std::string& feature,
+                                                float x,
+                                                float y,
+                                                float z)
 {
   game_input_event event;
 
   std::string controllerId = m_controller->ID();
 
-  event.type            = GAME_INPUT_EVENT_ACCELEROMETER;
-  event.controller_id   = controllerId.c_str();
-  event.port_type       = GAME_PORT_CONTROLLER;
-  event.port_address    = m_portAddress.c_str();
-  event.feature_name    = feature.c_str();
+  event.type = GAME_INPUT_EVENT_ACCELEROMETER;
+  event.controller_id = controllerId.c_str();
+  event.port_type = GAME_PORT_CONTROLLER;
+  event.port_address = m_portAddress.c_str();
+  event.feature_name = feature.c_str();
   event.accelerometer.x = x;
   event.accelerometer.y = y;
   event.accelerometer.z = z;
@@ -126,34 +134,38 @@ bool CGameClientJoystick::OnAccelerometerMotion(const std::string& feature, floa
   return m_gameClient.Input().InputEvent(event);
 }
 
-bool CGameClientJoystick::OnWheelMotion(const std::string& feature, float position, unsigned int motionTimeMs)
+bool CGameClientJoystick::OnWheelMotion(const std::string& feature,
+                                        float position,
+                                        unsigned int motionTimeMs)
 {
   game_input_event event;
 
   std::string controllerId = m_controller->ID();
 
-  event.type                    = GAME_INPUT_EVENT_AXIS;
-  event.controller_id           = controllerId.c_str();
-  event.port_type               = GAME_PORT_CONTROLLER;
-  event.port_address            = m_portAddress.c_str();
-  event.feature_name            = feature.c_str();
-  event.axis.position           = position;
+  event.type = GAME_INPUT_EVENT_AXIS;
+  event.controller_id = controllerId.c_str();
+  event.port_type = GAME_PORT_CONTROLLER;
+  event.port_address = m_portAddress.c_str();
+  event.feature_name = feature.c_str();
+  event.axis.position = position;
 
   return m_gameClient.Input().InputEvent(event);
 }
 
-bool CGameClientJoystick::OnThrottleMotion(const std::string& feature, float position, unsigned int motionTimeMs)
+bool CGameClientJoystick::OnThrottleMotion(const std::string& feature,
+                                           float position,
+                                           unsigned int motionTimeMs)
 {
   game_input_event event;
 
   std::string controllerId = m_controller->ID();
 
-  event.type                    = GAME_INPUT_EVENT_AXIS;
-  event.controller_id           = controllerId.c_str();
-  event.port_type               = GAME_PORT_CONTROLLER;
-  event.port_address            = m_portAddress.c_str();
-  event.feature_name            = feature.c_str();
-  event.axis.position           = position;
+  event.type = GAME_INPUT_EVENT_AXIS;
+  event.controller_id = controllerId.c_str();
+  event.port_type = GAME_PORT_CONTROLLER;
+  event.port_address = m_portAddress.c_str();
+  event.feature_name = feature.c_str();
+  event.axis.position = position;
 
   return m_gameClient.Input().InputEvent(event);
 }
diff --git a/xbmc/games/addons/input/GameClientJoystick.h b/xbmc/games/addons/input/GameClientJoystick.h
index c10484a03a9c..a43746ba7210 100644
--- a/xbmc/games/addons/input/GameClientJoystick.h
+++ b/xbmc/games/addons/input/GameClientJoystick.h
@@ -17,61 +17,70 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IInputProvider;
+class IInputProvider;
 }
 
 namespace GAME
 {
-  class CGameClient;
-  class CPort;
+class CGameClient;
+class CPort;
 
+/*!
+ * \ingroup games
+ * \brief Handles game controller events for games.
+ *
+ * Listens to game controller events and forwards them to the games (as game_input_event).
+ */
+class CGameClientJoystick : public JOYSTICK::IInputHandler
+{
+public:
   /*!
-   * \ingroup games
-   * \brief Handles game controller events for games.
-   *
-   * Listens to game controller events and forwards them to the games (as game_input_event).
+   * \brief Constructor.
+   * \param addon The game client implementation.
+   * \param port The port this game controller is associated with.
+   * \param controller The game controller which is used (for controller mapping).
+   * \param dllStruct The emulator or game to which the events are sent.
    */
-  class CGameClientJoystick : public JOYSTICK::IInputHandler
-  {
-  public:
-    /*!
-     * \brief Constructor.
-     * \param addon The game client implementation.
-     * \param port The port this game controller is associated with.
-     * \param controller The game controller which is used (for controller mapping).
-     * \param dllStruct The emulator or game to which the events are sent.
-     */
-    CGameClientJoystick(CGameClient &addon,
-                        const std::string &portAddress,
-                        const ControllerPtr& controller);
+  CGameClientJoystick(CGameClient& addon,
+                      const std::string& portAddress,
+                      const ControllerPtr& controller);
 
-    ~CGameClientJoystick() override;
+  ~CGameClientJoystick() override;
 
-    void RegisterInput(JOYSTICK::IInputProvider *inputProvider);
-    void UnregisterInput(JOYSTICK::IInputProvider *inputProvider);
+  void RegisterInput(JOYSTICK::IInputProvider* inputProvider);
+  void UnregisterInput(JOYSTICK::IInputProvider* inputProvider);
 
-    // Implementation of IInputHandler
-    std::string ControllerID() const override;
-    bool HasFeature(const std::string& feature) const override;
-    bool AcceptsInput(const std::string& feature) const override;
-    bool OnButtonPress(const std::string& feature, bool bPressed) override;
-    void OnButtonHold(const std::string& feature, unsigned int holdTimeMs) override {}
-    bool OnButtonMotion(const std::string& feature, float magnitude, unsigned int motionTimeMs) override;
-    bool OnAnalogStickMotion(const std::string& feature, float x, float y, unsigned int motionTimeMs) override;
-    bool OnAccelerometerMotion(const std::string& feature, float x, float y, float z) override;
-    bool OnWheelMotion(const std::string& feature, float position, unsigned int motionTimeMs) override;
-    bool OnThrottleMotion(const std::string& feature, float position, unsigned int motionTimeMs) override;
+  // Implementation of IInputHandler
+  std::string ControllerID() const override;
+  bool HasFeature(const std::string& feature) const override;
+  bool AcceptsInput(const std::string& feature) const override;
+  bool OnButtonPress(const std::string& feature, bool bPressed) override;
+  void OnButtonHold(const std::string& feature, unsigned int holdTimeMs) override {}
+  bool OnButtonMotion(const std::string& feature,
+                      float magnitude,
+                      unsigned int motionTimeMs) override;
+  bool OnAnalogStickMotion(const std::string& feature,
+                           float x,
+                           float y,
+                           unsigned int motionTimeMs) override;
+  bool OnAccelerometerMotion(const std::string& feature, float x, float y, float z) override;
+  bool OnWheelMotion(const std::string& feature,
+                     float position,
+                     unsigned int motionTimeMs) override;
+  bool OnThrottleMotion(const std::string& feature,
+                        float position,
+                        unsigned int motionTimeMs) override;
 
-    bool SetRumble(const std::string& feature, float magnitude);
+  bool SetRumble(const std::string& feature, float magnitude);
 
-  private:
-    // Construction parameters
-    CGameClient &m_gameClient;
-    const std::string m_portAddress;
-    const ControllerPtr       m_controller;
+private:
+  // Construction parameters
+  CGameClient& m_gameClient;
+  const std::string m_portAddress;
+  const ControllerPtr m_controller;
 
-    // Input parameters
-    std::unique_ptr<CPort> m_port;
-  };
-}
-}
+  // Input parameters
+  std::unique_ptr<CPort> m_port;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientKeyboard.cpp b/xbmc/games/addons/input/GameClientKeyboard.cpp
index 8182ca73ca76..3230d66ad289 100644
--- a/xbmc/games/addons/input/GameClientKeyboard.cpp
+++ b/xbmc/games/addons/input/GameClientKeyboard.cpp
@@ -20,14 +20,14 @@
 using namespace KODI;
 using namespace GAME;
 
-#define BUTTON_INDEX_MASK  0x01ff
+#define BUTTON_INDEX_MASK 0x01ff
 
-CGameClientKeyboard::CGameClientKeyboard(CGameClient &gameClient,
+CGameClientKeyboard::CGameClientKeyboard(CGameClient& gameClient,
                                          std::string controllerId,
-                                         KEYBOARD::IKeyboardInputProvider *inputProvider) :
-  m_gameClient(gameClient),
-  m_controllerId(std::move(controllerId)),
-  m_inputProvider(inputProvider)
+                                         KEYBOARD::IKeyboardInputProvider* inputProvider)
+  : m_gameClient(gameClient),
+    m_controllerId(std::move(controllerId)),
+    m_inputProvider(inputProvider)
 {
   m_inputProvider->RegisterKeyboardHandler(this, false);
 }
@@ -42,12 +42,14 @@ std::string CGameClientKeyboard::ControllerID() const
   return m_controllerId;
 }
 
-bool CGameClientKeyboard::HasKey(const KEYBOARD::KeyName &key) const
+bool CGameClientKeyboard::HasKey(const KEYBOARD::KeyName& key) const
 {
   return m_gameClient.Input().HasFeature(ControllerID(), key);
 }
 
-bool CGameClientKeyboard::OnKeyPress(const KEYBOARD::KeyName &key, KEYBOARD::Modifier mod, uint32_t unicode)
+bool CGameClientKeyboard::OnKeyPress(const KEYBOARD::KeyName& key,
+                                     KEYBOARD::Modifier mod,
+                                     uint32_t unicode)
 {
   // Only allow activated input in fullscreen game
   if (!m_gameClient.Input().AcceptsInput())
@@ -58,30 +60,32 @@ bool CGameClientKeyboard::OnKeyPress(const KEYBOARD::KeyName &key, KEYBOARD::Mod
 
   game_input_event event;
 
-  event.type            = GAME_INPUT_EVENT_KEY;
-  event.controller_id   = m_controllerId.c_str();
-  event.port_type       = GAME_PORT_KEYBOARD;
-  event.port_address    = ""; // Not used
-  event.feature_name    = key.c_str();
-  event.key.pressed     = true;
-  event.key.unicode     = unicode;
-  event.key.modifiers   = CGameClientTranslator::GetModifiers(mod);
+  event.type = GAME_INPUT_EVENT_KEY;
+  event.controller_id = m_controllerId.c_str();
+  event.port_type = GAME_PORT_KEYBOARD;
+  event.port_address = ""; // Not used
+  event.feature_name = key.c_str();
+  event.key.pressed = true;
+  event.key.unicode = unicode;
+  event.key.modifiers = CGameClientTranslator::GetModifiers(mod);
 
   return m_gameClient.Input().InputEvent(event);
 }
 
-void CGameClientKeyboard::OnKeyRelease(const KEYBOARD::KeyName &key, KEYBOARD::Modifier mod, uint32_t unicode)
+void CGameClientKeyboard::OnKeyRelease(const KEYBOARD::KeyName& key,
+                                       KEYBOARD::Modifier mod,
+                                       uint32_t unicode)
 {
   game_input_event event;
 
-  event.type            = GAME_INPUT_EVENT_KEY;
-  event.controller_id   = m_controllerId.c_str();
-  event.port_type       = GAME_PORT_KEYBOARD;
-  event.port_address    = ""; // Not used
-  event.feature_name    = key.c_str();
-  event.key.pressed     = false;
-  event.key.unicode     = unicode;
-  event.key.modifiers   = CGameClientTranslator::GetModifiers(mod);
+  event.type = GAME_INPUT_EVENT_KEY;
+  event.controller_id = m_controllerId.c_str();
+  event.port_type = GAME_PORT_KEYBOARD;
+  event.port_address = ""; // Not used
+  event.feature_name = key.c_str();
+  event.key.pressed = false;
+  event.key.unicode = unicode;
+  event.key.modifiers = CGameClientTranslator::GetModifiers(mod);
 
   m_gameClient.Input().InputEvent(event);
 }
diff --git a/xbmc/games/addons/input/GameClientKeyboard.h b/xbmc/games/addons/input/GameClientKeyboard.h
index 8e4bbdff9543..fbcfc028885b 100644
--- a/xbmc/games/addons/input/GameClientKeyboard.h
+++ b/xbmc/games/addons/input/GameClientKeyboard.h
@@ -14,49 +14,51 @@ namespace KODI
 {
 namespace KEYBOARD
 {
-  class IKeyboardInputProvider;
+class IKeyboardInputProvider;
 }
 
 namespace GAME
 {
-  class CGameClient;
+class CGameClient;
 
+/*!
+ * \ingroup games
+ * \brief Handles keyboard events for games.
+ *
+ * Listens to keyboard events and forwards them to the games (as game_input_event).
+ */
+class CGameClientKeyboard : public KEYBOARD::IKeyboardInputHandler
+{
+public:
   /*!
-   * \ingroup games
-   * \brief Handles keyboard events for games.
-   *
-   * Listens to keyboard events and forwards them to the games (as game_input_event).
+   * \brief Constructor registers for keyboard events at CInputManager.
+   * \param gameClient The game client implementation.
+   * \param controllerId The controller profile used for input
+   * \param dllStruct The emulator or game to which the events are sent.
+   * \param inputProvider The interface providing us with keyboard input.
    */
-  class CGameClientKeyboard : public KEYBOARD::IKeyboardInputHandler
-  {
-  public:
-    /*!
-     * \brief Constructor registers for keyboard events at CInputManager.
-     * \param gameClient The game client implementation.
-     * \param controllerId The controller profile used for input
-     * \param dllStruct The emulator or game to which the events are sent.
-     * \param inputProvider The interface providing us with keyboard input.
-     */
-    CGameClientKeyboard(CGameClient &gameClient,
-                        std::string controllerId,
-                        KEYBOARD::IKeyboardInputProvider *inputProvider);
-
-    /*!
-     * \brief Destructor unregisters from keyboard events from CInputManager.
-     */
-    ~CGameClientKeyboard() override;
-
-    // implementation of IKeyboardInputHandler
-    std::string ControllerID() const override;
-    bool HasKey(const KEYBOARD::KeyName &key) const override;
-    bool OnKeyPress(const KEYBOARD::KeyName &key, KEYBOARD::Modifier mod, uint32_t unicode) override;
-    void OnKeyRelease(const KEYBOARD::KeyName &key, KEYBOARD::Modifier mod, uint32_t unicode) override;
-
-  private:
-    // Construction parameters
-    CGameClient &m_gameClient;
-    const std::string m_controllerId;
-    KEYBOARD::IKeyboardInputProvider *const m_inputProvider;
-  };
-}
-}
+  CGameClientKeyboard(CGameClient& gameClient,
+                      std::string controllerId,
+                      KEYBOARD::IKeyboardInputProvider* inputProvider);
+
+  /*!
+   * \brief Destructor unregisters from keyboard events from CInputManager.
+   */
+  ~CGameClientKeyboard() override;
+
+  // implementation of IKeyboardInputHandler
+  std::string ControllerID() const override;
+  bool HasKey(const KEYBOARD::KeyName& key) const override;
+  bool OnKeyPress(const KEYBOARD::KeyName& key, KEYBOARD::Modifier mod, uint32_t unicode) override;
+  void OnKeyRelease(const KEYBOARD::KeyName& key,
+                    KEYBOARD::Modifier mod,
+                    uint32_t unicode) override;
+
+private:
+  // Construction parameters
+  CGameClient& m_gameClient;
+  const std::string m_controllerId;
+  KEYBOARD::IKeyboardInputProvider* const m_inputProvider;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientMouse.cpp b/xbmc/games/addons/input/GameClientMouse.cpp
index 60b66d295670..f42b51029d0f 100644
--- a/xbmc/games/addons/input/GameClientMouse.cpp
+++ b/xbmc/games/addons/input/GameClientMouse.cpp
@@ -18,12 +18,12 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientMouse::CGameClientMouse(CGameClient &gameClient,
+CGameClientMouse::CGameClientMouse(CGameClient& gameClient,
                                    std::string controllerId,
-                                   MOUSE::IMouseInputProvider *inputProvider) :
-  m_gameClient(gameClient),
-  m_controllerId(std::move(controllerId)),
-  m_inputProvider(inputProvider)
+                                   MOUSE::IMouseInputProvider* inputProvider)
+  : m_gameClient(gameClient),
+    m_controllerId(std::move(controllerId)),
+    m_inputProvider(inputProvider)
 {
   inputProvider->RegisterMouseHandler(this, false);
 }
@@ -50,13 +50,13 @@ bool CGameClientMouse::OnMotion(const std::string& relpointer, int dx, int dy)
 
   game_input_event event;
 
-  event.type            = GAME_INPUT_EVENT_RELATIVE_POINTER;
-  event.controller_id   = m_controllerId.c_str();
-  event.port_type       = GAME_PORT_MOUSE;
-  event.port_address    = ""; // Not used
-  event.feature_name    = relpointer.c_str();
-  event.rel_pointer.x   = dx;
-  event.rel_pointer.y   = dy;
+  event.type = GAME_INPUT_EVENT_RELATIVE_POINTER;
+  event.controller_id = m_controllerId.c_str();
+  event.port_type = GAME_PORT_MOUSE;
+  event.port_address = ""; // Not used
+  event.feature_name = relpointer.c_str();
+  event.rel_pointer.x = dx;
+  event.rel_pointer.y = dy;
 
 
   return m_gameClient.Input().InputEvent(event);
@@ -72,11 +72,11 @@ bool CGameClientMouse::OnButtonPress(const std::string& button)
 
   game_input_event event;
 
-  event.type                   = GAME_INPUT_EVENT_DIGITAL_BUTTON;
-  event.controller_id          = m_controllerId.c_str();
-  event.port_type              = GAME_PORT_MOUSE;
-  event.port_address           = ""; // Not used
-  event.feature_name           = button.c_str();
+  event.type = GAME_INPUT_EVENT_DIGITAL_BUTTON;
+  event.controller_id = m_controllerId.c_str();
+  event.port_type = GAME_PORT_MOUSE;
+  event.port_address = ""; // Not used
+  event.feature_name = button.c_str();
   event.digital_button.pressed = true;
 
 
@@ -87,11 +87,11 @@ void CGameClientMouse::OnButtonRelease(const std::string& button)
 {
   game_input_event event;
 
-  event.type                   = GAME_INPUT_EVENT_DIGITAL_BUTTON;
-  event.controller_id          = m_controllerId.c_str();
-  event.port_type              = GAME_PORT_MOUSE;
-  event.port_address           = ""; // Not used
-  event.feature_name           = button.c_str();
+  event.type = GAME_INPUT_EVENT_DIGITAL_BUTTON;
+  event.controller_id = m_controllerId.c_str();
+  event.port_type = GAME_PORT_MOUSE;
+  event.port_address = ""; // Not used
+  event.feature_name = button.c_str();
   event.digital_button.pressed = false;
 
 
diff --git a/xbmc/games/addons/input/GameClientMouse.h b/xbmc/games/addons/input/GameClientMouse.h
index 9e3f6cb44829..b63aeb933d05 100644
--- a/xbmc/games/addons/input/GameClientMouse.h
+++ b/xbmc/games/addons/input/GameClientMouse.h
@@ -14,49 +14,49 @@ namespace KODI
 {
 namespace MOUSE
 {
-  class IMouseInputProvider;
+class IMouseInputProvider;
 }
 
 namespace GAME
 {
-  class CGameClient;
+class CGameClient;
 
+/*!
+ * \ingroup games
+ * \brief Handles mouse events for games.
+ *
+ * Listens to mouse events and forwards them to the games (as game_input_event).
+ */
+class CGameClientMouse : public MOUSE::IMouseInputHandler
+{
+public:
   /*!
-   * \ingroup games
-   * \brief Handles mouse events for games.
-   *
-   * Listens to mouse events and forwards them to the games (as game_input_event).
+   * \brief Constructor registers for mouse events at CInputManager.
+   * \param gameClient The game client implementation.
+   * \param controllerId The controller profile used for input
+   * \param dllStruct The emulator or game to which the events are sent.
+   * \param inputProvider The interface providing us with mouse input.
    */
-  class CGameClientMouse : public MOUSE::IMouseInputHandler
-  {
-  public:
-    /*!
-     * \brief Constructor registers for mouse events at CInputManager.
-     * \param gameClient The game client implementation.
-     * \param controllerId The controller profile used for input
-     * \param dllStruct The emulator or game to which the events are sent.
-     * \param inputProvider The interface providing us with mouse input.
-     */
-    CGameClientMouse(CGameClient &gameClient,
-                     std::string controllerId,
-                     MOUSE::IMouseInputProvider *inputProvider);
-
-    /*!
-     * \brief Destructor unregisters from mouse events from CInputManager.
-     */
-    ~CGameClientMouse() override;
-
-    // implementation of IMouseInputHandler
-    std::string ControllerID() const override;
-    bool OnMotion(const std::string& relpointer, int dx, int dy) override;
-    bool OnButtonPress(const std::string& button) override;
-    void OnButtonRelease(const std::string& button) override;
-
-  private:
-    // Construction parameters
-    CGameClient &m_gameClient;
-    const std::string m_controllerId;
-    MOUSE::IMouseInputProvider *const m_inputProvider;
-  };
-}
-}
+  CGameClientMouse(CGameClient& gameClient,
+                   std::string controllerId,
+                   MOUSE::IMouseInputProvider* inputProvider);
+
+  /*!
+   * \brief Destructor unregisters from mouse events from CInputManager.
+   */
+  ~CGameClientMouse() override;
+
+  // implementation of IMouseInputHandler
+  std::string ControllerID() const override;
+  bool OnMotion(const std::string& relpointer, int dx, int dy) override;
+  bool OnButtonPress(const std::string& button) override;
+  void OnButtonRelease(const std::string& button) override;
+
+private:
+  // Construction parameters
+  CGameClient& m_gameClient;
+  const std::string m_controllerId;
+  MOUSE::IMouseInputProvider* const m_inputProvider;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientPort.cpp b/xbmc/games/addons/input/GameClientPort.cpp
index d3534eb1b191..ec55dbc78617 100644
--- a/xbmc/games/addons/input/GameClientPort.cpp
+++ b/xbmc/games/addons/input/GameClientPort.cpp
@@ -20,9 +20,9 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientPort::CGameClientPort(const game_input_port &port) :
-  m_type(CGameClientTranslator::TranslatePortType(port.type)),
-  m_portId(port.port_id ? port.port_id : "")
+CGameClientPort::CGameClientPort(const game_input_port& port)
+  : m_type(CGameClientTranslator::TranslatePortType(port.type)),
+    m_portId(port.port_id ? port.port_id : "")
 {
   if (port.accepted_devices != nullptr)
   {
@@ -36,24 +36,23 @@ CGameClientPort::CGameClientPort(const game_input_port &port) :
   }
 }
 
-CGameClientPort::CGameClientPort(const ControllerVector &controllers) :
-  m_type(PORT_TYPE::CONTROLLER),
-  m_portId(DEFAULT_PORT_ID)
+CGameClientPort::CGameClientPort(const ControllerVector& controllers)
+  : m_type(PORT_TYPE::CONTROLLER), m_portId(DEFAULT_PORT_ID)
 {
-  for (const auto &controller : controllers)
+  for (const auto& controller : controllers)
     m_acceptedDevices.emplace_back(new CGameClientDevice(controller));
 }
 
-CGameClientPort::CGameClientPort(const game_input_port &logicalPort, const CControllerPort &physicalPort) :
-  m_type(PORT_TYPE::CONTROLLER),
-  m_portId(physicalPort.ID())
+CGameClientPort::CGameClientPort(const game_input_port& logicalPort,
+                                 const CControllerPort& physicalPort)
+  : m_type(PORT_TYPE::CONTROLLER), m_portId(physicalPort.ID())
 {
   if (logicalPort.accepted_devices != nullptr)
   {
     for (unsigned int i = 0; i < logicalPort.device_count; i++)
     {
       // Ensure device is physically compatible
-      const game_input_device &deviceStruct = logicalPort.accepted_devices[i];
+      const game_input_device& deviceStruct = logicalPort.accepted_devices[i];
       std::string controllerId = deviceStruct.controller_id ? deviceStruct.controller_id : "";
 
       if (physicalPort.IsCompatible(controllerId))
diff --git a/xbmc/games/addons/input/GameClientPort.h b/xbmc/games/addons/input/GameClientPort.h
index a9776b8bfc3d..728236b0d9dd 100644
--- a/xbmc/games/addons/input/GameClientPort.h
+++ b/xbmc/games/addons/input/GameClientPort.h
@@ -20,77 +20,77 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerPort;
+class CControllerPort;
 
+/*!
+ * \ingroup games
+ * \brief Represents a port that devices can connect to
+ */
+class CGameClientPort
+{
+public:
   /*!
-   * \ingroup games
-   * \brief Represents a port that devices can connect to
+   * \brief Construct a hardware port
+   *
+   * \param port The hardware port Game API struct
    */
-  class CGameClientPort
-  {
-  public:
-    /*!
-     * \brief Construct a hardware port
-     *
-     * \param port The hardware port Game API struct
-     */
-    CGameClientPort(const game_input_port &port);
+  CGameClientPort(const game_input_port& port);
 
-    /*!
-     * \brief Construct a hardware port that accepts the given controllers
-     *
-     * \param controllers List of accepted controller profiles
-     *
-     * The port is given the ID specified by DEFAULT_PORT_ID.
-     */
-    CGameClientPort(const ControllerVector &controllers);
+  /*!
+   * \brief Construct a hardware port that accepts the given controllers
+   *
+   * \param controllers List of accepted controller profiles
+   *
+   * The port is given the ID specified by DEFAULT_PORT_ID.
+   */
+  CGameClientPort(const ControllerVector& controllers);
 
-    /*!
-     * \brief Construct a controller port
-     *
-     * \param logicalPort The logical port Game API struct
-     * \param physicalPort The physical port definition
-     *
-     * The physical port is defined by the controller profile. This definition
-     * specifies which controllers the port is physically compatible with.
-     *
-     * The logical port is defined by the emulator's input topology. This
-     * definition specifies which controllers the emulator's logic can handle.
-     *
-     * Obviously, the controllers specified by the logical port must be a subset
-     * of the controllers supported by the physical port.
-     */
-    CGameClientPort(const game_input_port &logicalPort, const CControllerPort &physicalPort);
+  /*!
+   * \brief Construct a controller port
+   *
+   * \param logicalPort The logical port Game API struct
+   * \param physicalPort The physical port definition
+   *
+   * The physical port is defined by the controller profile. This definition
+   * specifies which controllers the port is physically compatible with.
+   *
+   * The logical port is defined by the emulator's input topology. This
+   * definition specifies which controllers the emulator's logic can handle.
+   *
+   * Obviously, the controllers specified by the logical port must be a subset
+   * of the controllers supported by the physical port.
+   */
+  CGameClientPort(const game_input_port& logicalPort, const CControllerPort& physicalPort);
 
-    /*!
-     * \brief Destructor
-     */
-    ~CGameClientPort();
+  /*!
+   * \brief Destructor
+   */
+  ~CGameClientPort();
 
-    /*!
-     * \brief Get the port type
-     *
-     * The port type identifies if this port is for a keyboard, mouse, or
-     * controller.
-     */
-    PORT_TYPE PortType() const { return m_type; }
+  /*!
+   * \brief Get the port type
+   *
+   * The port type identifies if this port is for a keyboard, mouse, or
+   * controller.
+   */
+  PORT_TYPE PortType() const { return m_type; }
 
-    /*!
-     * \brief Get the ID of the port
-     *
-     * The ID is used when creating a toplogical address for the port.
-     */
-    const std::string &ID() const { return m_portId; }
+  /*!
+   * \brief Get the ID of the port
+   *
+   * The ID is used when creating a toplogical address for the port.
+   */
+  const std::string& ID() const { return m_portId; }
 
-    /*!
-     * \brief Get the list of devices accepted by this port
-     */
-    const GameClientDeviceVec &Devices() const { return m_acceptedDevices; }
+  /*!
+   * \brief Get the list of devices accepted by this port
+   */
+  const GameClientDeviceVec& Devices() const { return m_acceptedDevices; }
 
-  private:
-    PORT_TYPE m_type;
-    std::string m_portId;
-    GameClientDeviceVec m_acceptedDevices;
-  };
-}
-}
+private:
+  PORT_TYPE m_type;
+  std::string m_portId;
+  GameClientDeviceVec m_acceptedDevices;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/input/GameClientTopology.cpp b/xbmc/games/addons/input/GameClientTopology.cpp
index 2129daeddf1a..5cf4f307cdfa 100644
--- a/xbmc/games/addons/input/GameClientTopology.cpp
+++ b/xbmc/games/addons/input/GameClientTopology.cpp
@@ -18,12 +18,10 @@
 using namespace KODI;
 using namespace GAME;
 
-#define CONTROLLER_ADDRESS_SEPARATOR  "/"
+#define CONTROLLER_ADDRESS_SEPARATOR "/"
 
-CGameClientTopology::CGameClientTopology(GameClientPortVec ports, int playerLimit) :
-  m_ports(std::move(ports)),
-  m_playerLimit(playerLimit),
-  m_controllers(GetControllerTree(m_ports))
+CGameClientTopology::CGameClientTopology(GameClientPortVec ports, int playerLimit)
+  : m_ports(std::move(ports)), m_playerLimit(playerLimit), m_controllers(GetControllerTree(m_ports))
 {
 }
 
@@ -33,12 +31,12 @@ void CGameClientTopology::Clear()
   m_controllers.Clear();
 }
 
-CControllerTree CGameClientTopology::GetControllerTree(const GameClientPortVec &ports)
+CControllerTree CGameClientTopology::GetControllerTree(const GameClientPortVec& ports)
 {
   CControllerTree tree;
 
   ControllerPortVec controllerPorts;
-  for (const GameClientPortPtr &port : ports)
+  for (const GameClientPortPtr& port : ports)
   {
     CControllerPortNode portNode = GetPortNode(port, "");
     controllerPorts.emplace_back(std::move(portNode));
@@ -49,7 +47,8 @@ CControllerTree CGameClientTopology::GetControllerTree(const GameClientPortVec &
   return tree;
 }
 
-CControllerPortNode CGameClientTopology::GetPortNode(const GameClientPortPtr &port, const std::string &address)
+CControllerPortNode CGameClientTopology::GetPortNode(const GameClientPortPtr& port,
+                                                     const std::string& address)
 {
   CControllerPortNode portNode;
 
@@ -61,7 +60,7 @@ CControllerPortNode CGameClientTopology::GetPortNode(const GameClientPortPtr &po
   portNode.SetAddress(portAddress);
 
   ControllerNodeVec nodes;
-  for (const GameClientDevicePtr &device : port->Devices())
+  for (const GameClientDevicePtr& device : port->Devices())
   {
     CControllerNode controllerNode = GetControllerNode(device, portAddress);
     nodes.emplace_back(std::move(controllerNode));
@@ -71,7 +70,8 @@ CControllerPortNode CGameClientTopology::GetPortNode(const GameClientPortPtr &po
   return portNode;
 }
 
-CControllerNode CGameClientTopology::GetControllerNode(const GameClientDevicePtr &device, const std::string &address)
+CControllerNode CGameClientTopology::GetControllerNode(const GameClientDevicePtr& device,
+                                                       const std::string& address)
 {
   CControllerNode controllerNode;
 
@@ -81,7 +81,7 @@ CControllerNode CGameClientTopology::GetControllerNode(const GameClientDevicePtr
   controllerNode.SetAddress(controllerAddress);
 
   ControllerPortVec ports;
-  for (const GameClientPortPtr &port : device->Ports())
+  for (const GameClientPortPtr& port : device->Ports())
   {
     CControllerPortNode portNode = GetPortNode(port, controllerAddress);
     ports.emplace_back(std::move(portNode));
@@ -94,7 +94,8 @@ CControllerNode CGameClientTopology::GetControllerNode(const GameClientDevicePtr
   return controllerNode;
 }
 
-std::string CGameClientTopology::MakeAddress(const std::string &baseAddress, const std::string &nodeId)
+std::string CGameClientTopology::MakeAddress(const std::string& baseAddress,
+                                             const std::string& nodeId)
 {
   std::ostringstream address;
 
diff --git a/xbmc/games/addons/input/GameClientTopology.h b/xbmc/games/addons/input/GameClientTopology.h
index e43caf18acc0..86c88c14ae6f 100644
--- a/xbmc/games/addons/input/GameClientTopology.h
+++ b/xbmc/games/addons/input/GameClientTopology.h
@@ -17,33 +17,34 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameClientTopology
-  {
-  public:
-    CGameClientTopology() = default;
-    CGameClientTopology(GameClientPortVec ports, int playerLimit);
+class CGameClientTopology
+{
+public:
+  CGameClientTopology() = default;
+  CGameClientTopology(GameClientPortVec ports, int playerLimit);
 
-    void Clear();
+  void Clear();
 
-    int PlayerLimit() const { return m_playerLimit; }
+  int PlayerLimit() const { return m_playerLimit; }
 
-    const CControllerTree &ControllerTree() const { return m_controllers; }
-    CControllerTree &ControllerTree() { return m_controllers; }
+  const CControllerTree& ControllerTree() const { return m_controllers; }
+  CControllerTree& ControllerTree() { return m_controllers; }
 
-  private:
-    static CControllerTree GetControllerTree(const GameClientPortVec &ports);
-    static CControllerPortNode GetPortNode(const GameClientPortPtr &port, const std::string &address);
-    static CControllerNode GetControllerNode(const GameClientDevicePtr &device, const std::string &portAddress);
+private:
+  static CControllerTree GetControllerTree(const GameClientPortVec& ports);
+  static CControllerPortNode GetPortNode(const GameClientPortPtr& port, const std::string& address);
+  static CControllerNode GetControllerNode(const GameClientDevicePtr& device,
+                                           const std::string& portAddress);
 
-    // Utility function
-    static std::string MakeAddress(const std::string &baseAddress, const std::string &nodeId);
+  // Utility function
+  static std::string MakeAddress(const std::string& baseAddress, const std::string& nodeId);
 
-    // Game API parameters
-    GameClientPortVec m_ports;
-    int m_playerLimit = -1;
+  // Game API parameters
+  GameClientPortVec m_ports;
+  int m_playerLimit = -1;
 
-    // Controller parameters
-    CControllerTree m_controllers;
-  };
-}
-}
+  // Controller parameters
+  CControllerTree m_controllers;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/addons/streams/GameClientStreamAudio.cpp b/xbmc/games/addons/streams/GameClientStreamAudio.cpp
index c9df44e8445e..897dfb08f218 100644
--- a/xbmc/games/addons/streams/GameClientStreamAudio.cpp
+++ b/xbmc/games/addons/streams/GameClientStreamAudio.cpp
@@ -15,12 +15,12 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientStreamAudio::CGameClientStreamAudio(double sampleRate) :
-  m_sampleRate(sampleRate)
+CGameClientStreamAudio::CGameClientStreamAudio(double sampleRate) : m_sampleRate(sampleRate)
 {
 }
 
-bool CGameClientStreamAudio::OpenStream(RETRO::IRetroPlayerStream* stream, const game_stream_properties& properties)
+bool CGameClientStreamAudio::OpenStream(RETRO::IRetroPlayerStream* stream,
+                                        const game_stream_properties& properties)
 {
   RETRO::CRetroPlayerAudio* audioStream = dynamic_cast<RETRO::CRetroPlayerAudio*>(stream);
   if (audioStream == nullptr)
@@ -29,7 +29,8 @@ bool CGameClientStreamAudio::OpenStream(RETRO::IRetroPlayerStream* stream, const
     return false;
   }
 
-  std::unique_ptr<RETRO::AudioStreamProperties> audioProperties(TranslateProperties(properties.audio, m_sampleRate));
+  std::unique_ptr<RETRO::AudioStreamProperties> audioProperties(
+      TranslateProperties(properties.audio, m_sampleRate));
   if (audioProperties)
   {
     if (audioStream->OpenStream(static_cast<const RETRO::StreamProperties&>(*audioProperties)))
@@ -48,25 +49,23 @@ void CGameClientStreamAudio::CloseStream()
   }
 }
 
-void CGameClientStreamAudio::AddData(const game_stream_packet &packet)
+void CGameClientStreamAudio::AddData(const game_stream_packet& packet)
 {
   if (packet.type != GAME_STREAM_AUDIO)
     return;
 
   if (m_stream != nullptr)
   {
-    const game_stream_audio_packet &audio = packet.audio;
+    const game_stream_audio_packet& audio = packet.audio;
 
-    RETRO::AudioStreamPacket audioPacket{
-      audio.data,
-      audio.size
-    };
+    RETRO::AudioStreamPacket audioPacket{audio.data, audio.size};
 
     m_stream->AddStreamData(static_cast<RETRO::StreamPacket&>(audioPacket));
   }
 }
 
-RETRO::AudioStreamProperties* CGameClientStreamAudio::TranslateProperties(const game_stream_audio_properties &properties, double sampleRate)
+RETRO::AudioStreamProperties* CGameClientStreamAudio::TranslateProperties(
+    const game_stream_audio_properties& properties, double sampleRate)
 {
   const RETRO::PCMFormat pcmFormat = CGameClientTranslator::TranslatePCMFormat(properties.format);
   if (pcmFormat == RETRO::PCMFormat::FMT_UNKNOWN)
@@ -75,13 +74,12 @@ RETRO::AudioStreamProperties* CGameClientStreamAudio::TranslateProperties(const
     return nullptr;
   }
 
-  RETRO::AudioChannelMap channelMap = { { RETRO::AudioChannel::CH_NULL } };
+  RETRO::AudioChannelMap channelMap = {{RETRO::AudioChannel::CH_NULL}};
   unsigned int i = 0;
   if (properties.channel_map != nullptr)
   {
-    for (const GAME_AUDIO_CHANNEL* channelPtr = properties.channel_map;
-      *channelPtr != GAME_CH_NULL;
-      channelPtr++)
+    for (const GAME_AUDIO_CHANNEL* channelPtr = properties.channel_map; *channelPtr != GAME_CH_NULL;
+         channelPtr++)
     {
       RETRO::AudioChannel channel = CGameClientTranslator::TranslateAudioChannel(*channelPtr);
       if (channel == RETRO::AudioChannel::CH_NULL)
@@ -103,9 +101,5 @@ RETRO::AudioStreamProperties* CGameClientStreamAudio::TranslateProperties(const
     return nullptr;
   }
 
-  return new RETRO::AudioStreamProperties{
-    pcmFormat,
-    sampleRate,
-    channelMap
-  };
+  return new RETRO::AudioStreamProperties{pcmFormat, sampleRate, channelMap};
 }
diff --git a/xbmc/games/addons/streams/GameClientStreamAudio.h b/xbmc/games/addons/streams/GameClientStreamAudio.h
index 8c44a8f1975b..705eda23e608 100644
--- a/xbmc/games/addons/streams/GameClientStreamAudio.h
+++ b/xbmc/games/addons/streams/GameClientStreamAudio.h
@@ -17,9 +17,9 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IRetroPlayerStream;
-  struct AudioStreamProperties;
-}
+class IRetroPlayerStream;
+struct AudioStreamProperties;
+} // namespace RETRO
 
 namespace GAME
 {
@@ -34,11 +34,12 @@ class CGameClientStreamAudio : public IGameClientStream
   bool OpenStream(RETRO::IRetroPlayerStream* stream,
                   const game_stream_properties& properties) override;
   void CloseStream() override;
-  void AddData(const game_stream_packet &packet) override;
+  void AddData(const game_stream_packet& packet) override;
 
 private:
   // Utility functions
-  static RETRO::AudioStreamProperties* TranslateProperties(const game_stream_audio_properties &properties, double sampleRate);
+  static RETRO::AudioStreamProperties* TranslateProperties(
+      const game_stream_audio_properties& properties, double sampleRate);
 
   // Construction parameters
   const double m_sampleRate;
diff --git a/xbmc/games/addons/streams/GameClientStreamSwFramebuffer.cpp b/xbmc/games/addons/streams/GameClientStreamSwFramebuffer.cpp
index f103d008caed..24be2b9bc138 100644
--- a/xbmc/games/addons/streams/GameClientStreamSwFramebuffer.cpp
+++ b/xbmc/games/addons/streams/GameClientStreamSwFramebuffer.cpp
@@ -15,7 +15,9 @@
 using namespace KODI;
 using namespace GAME;
 
-bool CGameClientStreamSwFramebuffer::GetBuffer(unsigned int width, unsigned int height, game_stream_buffer &buffer)
+bool CGameClientStreamSwFramebuffer::GetBuffer(unsigned int width,
+                                               unsigned int height,
+                                               game_stream_buffer& buffer)
 {
   if (m_stream != nullptr)
   {
diff --git a/xbmc/games/addons/streams/GameClientStreamSwFramebuffer.h b/xbmc/games/addons/streams/GameClientStreamSwFramebuffer.h
index 10852e12d40c..2b17dac96e03 100644
--- a/xbmc/games/addons/streams/GameClientStreamSwFramebuffer.h
+++ b/xbmc/games/addons/streams/GameClientStreamSwFramebuffer.h
@@ -22,7 +22,7 @@ class CGameClientStreamSwFramebuffer : public CGameClientStreamVideo
   ~CGameClientStreamSwFramebuffer() override = default;
 
   // Implementation of IGameClientStream via CGameClientStreamVideo
-  bool GetBuffer(unsigned int width, unsigned int height, game_stream_buffer &buffer) override;
+  bool GetBuffer(unsigned int width, unsigned int height, game_stream_buffer& buffer) override;
 };
 
 } // namespace GAME
diff --git a/xbmc/games/addons/streams/GameClientStreamVideo.cpp b/xbmc/games/addons/streams/GameClientStreamVideo.cpp
index d52d06a904ba..6734b36b46fc 100644
--- a/xbmc/games/addons/streams/GameClientStreamVideo.cpp
+++ b/xbmc/games/addons/streams/GameClientStreamVideo.cpp
@@ -15,7 +15,8 @@
 using namespace KODI;
 using namespace GAME;
 
-bool CGameClientStreamVideo::OpenStream(RETRO::IRetroPlayerStream* stream, const game_stream_properties& properties)
+bool CGameClientStreamVideo::OpenStream(RETRO::IRetroPlayerStream* stream,
+                                        const game_stream_properties& properties)
 {
   RETRO::CRetroPlayerVideo* videoStream = dynamic_cast<RETRO::CRetroPlayerVideo*>(stream);
   if (videoStream == nullptr)
@@ -24,7 +25,8 @@ bool CGameClientStreamVideo::OpenStream(RETRO::IRetroPlayerStream* stream, const
     return false;
   }
 
-  std::unique_ptr<RETRO::VideoStreamProperties> videoProperties(TranslateProperties(properties.video));
+  std::unique_ptr<RETRO::VideoStreamProperties> videoProperties(
+      TranslateProperties(properties.video));
   if (videoProperties)
   {
     if (videoStream->OpenStream(static_cast<const RETRO::StreamProperties&>(*videoProperties)))
@@ -55,18 +57,15 @@ void CGameClientStreamVideo::AddData(const game_stream_packet& packet)
     RETRO::VideoRotation rotation = CGameClientTranslator::TranslateRotation(video.rotation);
 
     RETRO::VideoStreamPacket videoPacket{
-      video.width,
-      video.height,
-      rotation,
-      video.data,
-      video.size,
+        video.width, video.height, rotation, video.data, video.size,
     };
 
     m_stream->AddStreamData(static_cast<const RETRO::StreamPacket&>(videoPacket));
   }
 }
 
-RETRO::VideoStreamProperties* CGameClientStreamVideo::TranslateProperties(const game_stream_video_properties &properties)
+RETRO::VideoStreamProperties* CGameClientStreamVideo::TranslateProperties(
+    const game_stream_video_properties& properties)
 {
   const AVPixelFormat pixelFormat = CGameClientTranslator::TranslatePixelFormat(properties.format);
   if (pixelFormat == AV_PIX_FMT_NONE)
@@ -92,7 +91,8 @@ RETRO::VideoStreamProperties* CGameClientStreamVideo::TranslateProperties(const
   }
 
   if (nominalWidth > maxWidth || nominalHeight > maxHeight)
-    CLog::Log(LOGERROR, "GAME: Nominal dimensions (%ux%u) bigger than max dimensions (%ux%u)", nominalWidth, nominalHeight, maxWidth, maxHeight);
+    CLog::Log(LOGERROR, "GAME: Nominal dimensions (%ux%u) bigger than max dimensions (%ux%u)",
+              nominalWidth, nominalHeight, maxWidth, maxHeight);
 
   float pixelAspectRatio;
 
@@ -103,12 +103,6 @@ RETRO::VideoStreamProperties* CGameClientStreamVideo::TranslateProperties(const
   else
     pixelAspectRatio = properties.aspect_ratio * nominalHeight / nominalWidth;
 
-  return new RETRO::VideoStreamProperties{
-    pixelFormat,
-    nominalWidth,
-    nominalHeight,
-    maxWidth,
-    maxHeight,
-    pixelAspectRatio
-  };
+  return new RETRO::VideoStreamProperties{pixelFormat, nominalWidth, nominalHeight,
+                                          maxWidth,    maxHeight,    pixelAspectRatio};
 }
diff --git a/xbmc/games/addons/streams/GameClientStreamVideo.h b/xbmc/games/addons/streams/GameClientStreamVideo.h
index e233eab582bb..4c90c2c1ce66 100644
--- a/xbmc/games/addons/streams/GameClientStreamVideo.h
+++ b/xbmc/games/addons/streams/GameClientStreamVideo.h
@@ -16,9 +16,9 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IRetroPlayerStream;
-  struct VideoStreamProperties;
-}
+class IRetroPlayerStream;
+struct VideoStreamProperties;
+} // namespace RETRO
 
 namespace GAME
 {
@@ -41,7 +41,8 @@ class CGameClientStreamVideo : public IGameClientStream
 
 private:
   // Utility functions
-  static RETRO::VideoStreamProperties* TranslateProperties(const game_stream_video_properties &properties);
+  static RETRO::VideoStreamProperties* TranslateProperties(
+      const game_stream_video_properties& properties);
 };
 
 } // namespace GAME
diff --git a/xbmc/games/addons/streams/GameClientStreams.cpp b/xbmc/games/addons/streams/GameClientStreams.cpp
index e9565db12470..e7d65a81eba0 100644
--- a/xbmc/games/addons/streams/GameClientStreams.cpp
+++ b/xbmc/games/addons/streams/GameClientStreams.cpp
@@ -23,8 +23,7 @@
 using namespace KODI;
 using namespace GAME;
 
-CGameClientStreams::CGameClientStreams(CGameClient &gameClient) :
-  m_gameClient(gameClient)
+CGameClientStreams::CGameClientStreams(CGameClient& gameClient) : m_gameClient(gameClient)
 {
 }
 
@@ -38,7 +37,7 @@ void CGameClientStreams::Deinitialize()
   m_streamManager = nullptr;
 }
 
-IGameClientStream *CGameClientStreams::OpenStream(const game_stream_properties &properties)
+IGameClientStream* CGameClientStreams::OpenStream(const game_stream_properties& properties)
 {
   if (m_streamManager == nullptr)
     return nullptr;
@@ -53,14 +52,16 @@ IGameClientStream *CGameClientStreams::OpenStream(const game_stream_properties &
   std::unique_ptr<IGameClientStream> gameStream = CreateStream(properties.type);
   if (!gameStream)
   {
-    CLog::Log(LOGERROR, "GAME: No stream implementation for type: %d", static_cast<int>(properties.type));
+    CLog::Log(LOGERROR, "GAME: No stream implementation for type: %d",
+              static_cast<int>(properties.type));
     return nullptr;
   }
 
   RETRO::StreamPtr retroStream = m_streamManager->CreateStream(retroStreamType);
   if (!retroStream)
   {
-    CLog::Log(LOGERROR, "GAME:  Invalid RetroPlayer stream type: %$d", static_cast<int>(retroStreamType));
+    CLog::Log(LOGERROR, "GAME:  Invalid RetroPlayer stream type: %$d",
+              static_cast<int>(retroStreamType));
     return nullptr;
   }
 
@@ -75,7 +76,7 @@ IGameClientStream *CGameClientStreams::OpenStream(const game_stream_properties &
   return gameStream.release();
 }
 
-void CGameClientStreams::CloseStream(IGameClientStream *stream)
+void CGameClientStreams::CloseStream(IGameClientStream* stream)
 {
   if (stream != nullptr)
   {
@@ -87,29 +88,30 @@ void CGameClientStreams::CloseStream(IGameClientStream *stream)
   }
 }
 
-std::unique_ptr<IGameClientStream> CGameClientStreams::CreateStream(GAME_STREAM_TYPE streamType) const
+std::unique_ptr<IGameClientStream> CGameClientStreams::CreateStream(
+    GAME_STREAM_TYPE streamType) const
 {
   std::unique_ptr<IGameClientStream> gameStream;
 
   switch (streamType)
   {
-  case GAME_STREAM_AUDIO:
-  {
-    gameStream.reset(new CGameClientStreamAudio(m_gameClient.GetSampleRate()));
-    break;
-  }
-  case GAME_STREAM_VIDEO:
-  {
-    gameStream.reset(new CGameClientStreamVideo);
-    break;
-  }
-  case GAME_STREAM_SW_FRAMEBUFFER:
-  {
-    gameStream.reset(new CGameClientStreamSwFramebuffer);
-    break;
-  }
-  default:
-    break;
+    case GAME_STREAM_AUDIO:
+    {
+      gameStream.reset(new CGameClientStreamAudio(m_gameClient.GetSampleRate()));
+      break;
+    }
+    case GAME_STREAM_VIDEO:
+    {
+      gameStream.reset(new CGameClientStreamVideo);
+      break;
+    }
+    case GAME_STREAM_SW_FRAMEBUFFER:
+    {
+      gameStream.reset(new CGameClientStreamSwFramebuffer);
+      break;
+    }
+    default:
+      break;
   }
 
   return gameStream;
diff --git a/xbmc/games/addons/streams/GameClientStreams.h b/xbmc/games/addons/streams/GameClientStreams.h
index caded4513ece..a4ec42368b42 100644
--- a/xbmc/games/addons/streams/GameClientStreams.h
+++ b/xbmc/games/addons/streams/GameClientStreams.h
@@ -17,7 +17,7 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IStreamManager;
+class IStreamManager;
 }
 
 namespace GAME
@@ -29,12 +29,12 @@ class IGameClientStream;
 class CGameClientStreams
 {
 public:
-  CGameClientStreams(CGameClient &gameClient);
+  CGameClientStreams(CGameClient& gameClient);
 
   void Initialize(RETRO::IStreamManager& streamManager);
   void Deinitialize();
 
-  IGameClientStream* OpenStream(const game_stream_properties &properties);
+  IGameClientStream* OpenStream(const game_stream_properties& properties);
   void CloseStream(IGameClientStream* stream);
 
 private:
diff --git a/xbmc/games/addons/streams/IGameClientStream.h b/xbmc/games/addons/streams/IGameClientStream.h
index 231d4c7ef395..bff7f5532455 100644
--- a/xbmc/games/addons/streams/IGameClientStream.h
+++ b/xbmc/games/addons/streams/IGameClientStream.h
@@ -16,7 +16,7 @@ namespace KODI
 {
 namespace RETRO
 {
-  class IRetroPlayerStream;
+class IRetroPlayerStream;
 }
 
 namespace GAME
@@ -53,14 +53,17 @@ class IGameClientStream
    *
    * \return True if buffer was set, false otherwise
    */
-  virtual bool GetBuffer(unsigned int width, unsigned int height, game_stream_buffer& buffer) { return false; }
+  virtual bool GetBuffer(unsigned int width, unsigned int height, game_stream_buffer& buffer)
+  {
+    return false;
+  }
 
   /*!
    * \brief Free an allocated buffer
    *
    * \param buffer The buffer returned from GetStreamBuffer()
    */
-  virtual void ReleaseBuffer(game_stream_buffer& buffer) { }
+  virtual void ReleaseBuffer(game_stream_buffer& buffer) {}
 
   /*!
    * \brief Add a data packet to a stream
diff --git a/xbmc/games/controllers/Controller.cpp b/xbmc/games/controllers/Controller.cpp
index ecc6e6bfd804..7a0c28662c14 100644
--- a/xbmc/games/controllers/Controller.cpp
+++ b/xbmc/games/controllers/Controller.cpp
@@ -25,9 +25,8 @@ using namespace GAME;
 
 struct FeatureTypeEqual
 {
-  FeatureTypeEqual(FEATURE_TYPE type, JOYSTICK::INPUT_TYPE inputType) :
-    type(type),
-    inputType(inputType)
+  FeatureTypeEqual(FEATURE_TYPE type, JOYSTICK::INPUT_TYPE inputType)
+    : type(type), inputType(inputType)
   {
   }
 
@@ -55,21 +54,18 @@ struct FeatureTypeEqual
 
 const ControllerPtr CController::EmptyPtr;
 
-CController::CController(const ADDON::AddonInfoPtr& addonInfo) :
-  CAddon(addonInfo, ADDON::ADDON_GAME_CONTROLLER),
-  m_layout(new CControllerLayout)
+CController::CController(const ADDON::AddonInfoPtr& addonInfo)
+  : CAddon(addonInfo, ADDON::ADDON_GAME_CONTROLLER), m_layout(new CControllerLayout)
 {
 }
 
 CController::~CController() = default;
 
-const CControllerFeature& CController::GetFeature(const std::string &name) const
+const CControllerFeature& CController::GetFeature(const std::string& name) const
 {
-  auto it = std::find_if(m_features.begin(), m_features.end(),
-    [&name](const CControllerFeature &feature)
-    {
-      return name == feature.Name();
-    });
+  auto it =
+      std::find_if(m_features.begin(), m_features.end(),
+                   [&name](const CControllerFeature& feature) { return name == feature.Name(); });
 
   if (it != m_features.end())
     return *it;
@@ -78,10 +74,12 @@ const CControllerFeature& CController::GetFeature(const std::string &name) const
   return invalid;
 }
 
-unsigned int CController::FeatureCount(FEATURE_TYPE type /* = FEATURE_TYPE::UNKNOWN */,
-                                       JOYSTICK::INPUT_TYPE inputType /* = JOYSTICK::INPUT_TYPE::UNKNOWN */) const
+unsigned int CController::FeatureCount(
+    FEATURE_TYPE type /* = FEATURE_TYPE::UNKNOWN */,
+    JOYSTICK::INPUT_TYPE inputType /* = JOYSTICK::INPUT_TYPE::UNKNOWN */) const
 {
-  auto featureCount = std::count_if(m_features.begin(), m_features.end(), FeatureTypeEqual(type, inputType));
+  auto featureCount =
+      std::count_if(m_features.begin(), m_features.end(), FeatureTypeEqual(type, inputType));
   return static_cast<unsigned int>(featureCount);
 }
 
@@ -95,7 +93,7 @@ void CController::GetFeatures(std::vector<std::string>& features,
   }
 }
 
-JOYSTICK::FEATURE_TYPE CController::FeatureType(const std::string &feature) const
+JOYSTICK::FEATURE_TYPE CController::FeatureType(const std::string& feature) const
 {
   for (auto it = m_features.begin(); it != m_features.end(); ++it)
   {
@@ -121,12 +119,14 @@ bool CController::LoadLayout(void)
   {
     std::string strLayoutXmlPath = LibPath();
 
-    CLog::Log(LOGINFO, "Loading controller layout: %s", CURL::GetRedacted(strLayoutXmlPath).c_str());
+    CLog::Log(LOGINFO, "Loading controller layout: %s",
+              CURL::GetRedacted(strLayoutXmlPath).c_str());
 
     CXBMCTinyXML xmlDoc;
     if (!xmlDoc.LoadFile(strLayoutXmlPath))
     {
-      CLog::Log(LOGDEBUG, "Unable to load file: %s at line %d", xmlDoc.ErrorDesc(), xmlDoc.ErrorRow());
+      CLog::Log(LOGDEBUG, "Unable to load file: %s at line %d", xmlDoc.ErrorDesc(),
+                xmlDoc.ErrorRow());
       return false;
     }
 
diff --git a/xbmc/games/controllers/Controller.h b/xbmc/games/controllers/Controller.h
index 726e0896859b..532e4dc2a027 100644
--- a/xbmc/games/controllers/Controller.h
+++ b/xbmc/games/controllers/Controller.h
@@ -50,7 +50,7 @@ class CController : public ADDON::CAddon
    *
    * \return The feature, or a feature of type FEATURE_TYPE::UNKNOWN if the name is invalid
    */
-  const CControllerFeature& GetFeature(const std::string &name) const;
+  const CControllerFeature& GetFeature(const std::string& name) const;
 
   /*!
    * \brief Get the count of controller features matching the specified types
@@ -68,7 +68,8 @@ class CController : public ADDON::CAddon
    *
    * \param type The feature type, or FEATURE_TYPE::UNKNOWN to get all features
    */
-  void GetFeatures(std::vector<std::string>& features, FEATURE_TYPE type = FEATURE_TYPE::UNKNOWN) const;
+  void GetFeatures(std::vector<std::string>& features,
+                   FEATURE_TYPE type = FEATURE_TYPE::UNKNOWN) const;
 
   /*!
    * \brief Get the type of the specified feature
@@ -77,7 +78,7 @@ class CController : public ADDON::CAddon
    *
    * \return The feature type, or FEATURE_TYPE::UNKNOWN if an invalid feature was specified
    */
-  FEATURE_TYPE FeatureType(const std::string &feature) const;
+  FEATURE_TYPE FeatureType(const std::string& feature) const;
 
   /*!
    * \brief Get the input type of the specified feature
@@ -115,5 +116,5 @@ class CController : public ADDON::CAddon
   bool m_bLoaded = false;
 };
 
-}
-}
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/ControllerDefinitions.h b/xbmc/games/controllers/ControllerDefinitions.h
index 6d48c2b04543..517eb502f67b 100644
--- a/xbmc/games/controllers/ControllerDefinitions.h
+++ b/xbmc/games/controllers/ControllerDefinitions.h
@@ -9,47 +9,47 @@
 #pragma once
 
 // XML definitions
-#define LAYOUT_XML_ROOT                    "layout"
-#define LAYOUT_XML_ELM_CATEGORY            "category"
-#define LAYOUT_XML_ELM_BUTTON              "button"
-#define LAYOUT_XML_ELM_ANALOG_STICK        "analogstick"
-#define LAYOUT_XML_ELM_ACCELEROMETER       "accelerometer"
-#define LAYOUT_XML_ELM_MOTOR               "motor"
-#define LAYOUT_XML_ELM_RELPOINTER          "relpointer"
-#define LAYOUT_XML_ELM_ABSPOINTER          "abspointer"
-#define LAYOUT_XML_ELM_WHEEL               "wheel"
-#define LAYOUT_XML_ELM_THROTTLE            "throttle"
-#define LAYOUT_XML_ELM_KEY                 "key"
-#define LAYOUT_XML_ELM_TOPOLOGY            "physicaltopology"
-#define LAYOUT_XML_ELM_PORT                "port"
-#define LAYOUT_XML_ELM_ACCEPTS             "accepts"
-#define LAYOUT_XML_ATTR_LAYOUT_LABEL       "label"
-#define LAYOUT_XML_ATTR_LAYOUT_ICON        "icon"
-#define LAYOUT_XML_ATTR_LAYOUT_IMAGE       "image"
-#define LAYOUT_XML_ATTR_CATEGORY_NAME      "name"
-#define LAYOUT_XML_ATTR_CATEGORY_LABEL     "label"
-#define LAYOUT_XML_ATTR_FEATURE_NAME       "name"
-#define LAYOUT_XML_ATTR_FEATURE_LABEL      "label"
-#define LAYOUT_XML_ATTR_INPUT_TYPE         "type"
-#define LAYOUT_XML_ATTR_KEY_SYMBOL         "symbol"
-#define LAYOUT_XML_ATTR_PROVIDES_INPUT     "providesinput"
-#define LAYOUT_XML_ATTR_PORT_ID            "id"
-#define LAYOUT_XML_ATTR_CONTROLLER         "controller"
+#define LAYOUT_XML_ROOT "layout"
+#define LAYOUT_XML_ELM_CATEGORY "category"
+#define LAYOUT_XML_ELM_BUTTON "button"
+#define LAYOUT_XML_ELM_ANALOG_STICK "analogstick"
+#define LAYOUT_XML_ELM_ACCELEROMETER "accelerometer"
+#define LAYOUT_XML_ELM_MOTOR "motor"
+#define LAYOUT_XML_ELM_RELPOINTER "relpointer"
+#define LAYOUT_XML_ELM_ABSPOINTER "abspointer"
+#define LAYOUT_XML_ELM_WHEEL "wheel"
+#define LAYOUT_XML_ELM_THROTTLE "throttle"
+#define LAYOUT_XML_ELM_KEY "key"
+#define LAYOUT_XML_ELM_TOPOLOGY "physicaltopology"
+#define LAYOUT_XML_ELM_PORT "port"
+#define LAYOUT_XML_ELM_ACCEPTS "accepts"
+#define LAYOUT_XML_ATTR_LAYOUT_LABEL "label"
+#define LAYOUT_XML_ATTR_LAYOUT_ICON "icon"
+#define LAYOUT_XML_ATTR_LAYOUT_IMAGE "image"
+#define LAYOUT_XML_ATTR_CATEGORY_NAME "name"
+#define LAYOUT_XML_ATTR_CATEGORY_LABEL "label"
+#define LAYOUT_XML_ATTR_FEATURE_NAME "name"
+#define LAYOUT_XML_ATTR_FEATURE_LABEL "label"
+#define LAYOUT_XML_ATTR_INPUT_TYPE "type"
+#define LAYOUT_XML_ATTR_KEY_SYMBOL "symbol"
+#define LAYOUT_XML_ATTR_PROVIDES_INPUT "providesinput"
+#define LAYOUT_XML_ATTR_PORT_ID "id"
+#define LAYOUT_XML_ATTR_CONTROLLER "controller"
 
 // Controller definitions
-#define FEATURE_CATEGORY_FACE              "face"
-#define FEATURE_CATEGORY_SHOULDER          "shoulder"
-#define FEATURE_CATEGORY_TRIGGER           "triggers"
-#define FEATURE_CATEGORY_ANALOG_STICK      "analogsticks"
-#define FEATURE_CATEGORY_ACCELEROMETER     "accelerometer"
-#define FEATURE_CATEGORY_HAPTICS           "haptics"
-#define FEATURE_CATEGORY_MOUSE_BUTTON      "mouse"
-#define FEATURE_CATEGORY_POINTER           "pointer"
-#define FEATURE_CATEGORY_LIGHTGUN          "lightgun"
-#define FEATURE_CATEGORY_OFFSCREEN         "offscreen"
-#define FEATURE_CATEGORY_KEY               "keys"
-#define FEATURE_CATEGORY_KEYPAD            "keypad"
-#define FEATURE_CATEGORY_HARDWARE          "hardware"
-#define FEATURE_CATEGORY_WHEEL             "wheel"
-#define FEATURE_CATEGORY_JOYSTICK          "joysticks"
-#define FEATURE_CATEGORY_PADDLE            "paddles"
+#define FEATURE_CATEGORY_FACE "face"
+#define FEATURE_CATEGORY_SHOULDER "shoulder"
+#define FEATURE_CATEGORY_TRIGGER "triggers"
+#define FEATURE_CATEGORY_ANALOG_STICK "analogsticks"
+#define FEATURE_CATEGORY_ACCELEROMETER "accelerometer"
+#define FEATURE_CATEGORY_HAPTICS "haptics"
+#define FEATURE_CATEGORY_MOUSE_BUTTON "mouse"
+#define FEATURE_CATEGORY_POINTER "pointer"
+#define FEATURE_CATEGORY_LIGHTGUN "lightgun"
+#define FEATURE_CATEGORY_OFFSCREEN "offscreen"
+#define FEATURE_CATEGORY_KEY "keys"
+#define FEATURE_CATEGORY_KEYPAD "keypad"
+#define FEATURE_CATEGORY_HARDWARE "hardware"
+#define FEATURE_CATEGORY_WHEEL "wheel"
+#define FEATURE_CATEGORY_JOYSTICK "joysticks"
+#define FEATURE_CATEGORY_PADDLE "paddles"
diff --git a/xbmc/games/controllers/ControllerFeature.cpp b/xbmc/games/controllers/ControllerFeature.cpp
index 336b7d58ab2f..dace0a3a3ca1 100644
--- a/xbmc/games/controllers/ControllerFeature.cpp
+++ b/xbmc/games/controllers/ControllerFeature.cpp
@@ -102,14 +102,16 @@ bool CControllerFeature::Deserialize(const TiXmlElement* pElement,
   m_strName = XMLUtils::GetAttribute(pElement, LAYOUT_XML_ATTR_FEATURE_NAME);
   if (m_strName.empty())
   {
-    CLog::Log(LOGERROR, "<%s> tag has no \"%s\" attribute", strType.c_str(), LAYOUT_XML_ATTR_FEATURE_NAME);
+    CLog::Log(LOGERROR, "<%s> tag has no \"%s\" attribute", strType.c_str(),
+              LAYOUT_XML_ATTR_FEATURE_NAME);
     return false;
   }
 
   // Label ID
   std::string strLabel = XMLUtils::GetAttribute(pElement, LAYOUT_XML_ATTR_FEATURE_LABEL);
   if (strLabel.empty())
-    CLog::Log(LOGDEBUG, "<%s> tag has no \"%s\" attribute", strType.c_str(), LAYOUT_XML_ATTR_FEATURE_LABEL);
+    CLog::Log(LOGDEBUG, "<%s> tag has no \"%s\" attribute", strType.c_str(),
+              LAYOUT_XML_ATTR_FEATURE_LABEL);
   else
     std::istringstream(strLabel) >> m_labelId;
 
@@ -119,7 +121,8 @@ bool CControllerFeature::Deserialize(const TiXmlElement* pElement,
     std::string strInputType = XMLUtils::GetAttribute(pElement, LAYOUT_XML_ATTR_INPUT_TYPE);
     if (strInputType.empty())
     {
-      CLog::Log(LOGERROR, "<%s> tag has no \"%s\" attribute", strType.c_str(), LAYOUT_XML_ATTR_INPUT_TYPE);
+      CLog::Log(LOGERROR, "<%s> tag has no \"%s\" attribute", strType.c_str(),
+                LAYOUT_XML_ATTR_INPUT_TYPE);
       return false;
     }
     else
@@ -127,8 +130,8 @@ bool CControllerFeature::Deserialize(const TiXmlElement* pElement,
       m_inputType = CControllerTranslator::TranslateInputType(strInputType);
       if (m_inputType == INPUT_TYPE::UNKNOWN)
       {
-        CLog::Log(LOGERROR, "<%s> tag - attribute \"%s\" is invalid: \"%s\"",
-                  strType.c_str(), LAYOUT_XML_ATTR_INPUT_TYPE, strInputType.c_str());
+        CLog::Log(LOGERROR, "<%s> tag - attribute \"%s\" is invalid: \"%s\"", strType.c_str(),
+                  LAYOUT_XML_ATTR_INPUT_TYPE, strInputType.c_str());
         return false;
       }
     }
@@ -140,7 +143,8 @@ bool CControllerFeature::Deserialize(const TiXmlElement* pElement,
     std::string strSymbol = XMLUtils::GetAttribute(pElement, LAYOUT_XML_ATTR_KEY_SYMBOL);
     if (strSymbol.empty())
     {
-      CLog::Log(LOGERROR, "<%s> tag has no \"%s\" attribute", strType.c_str(), LAYOUT_XML_ATTR_KEY_SYMBOL);
+      CLog::Log(LOGERROR, "<%s> tag has no \"%s\" attribute", strType.c_str(),
+                LAYOUT_XML_ATTR_KEY_SYMBOL);
       return false;
     }
     else
@@ -148,8 +152,8 @@ bool CControllerFeature::Deserialize(const TiXmlElement* pElement,
       m_keycode = CControllerTranslator::TranslateKeysym(strSymbol);
       if (m_keycode == XBMCK_UNKNOWN)
       {
-        CLog::Log(LOGERROR, "<%s> tag - attribute \"%s\" is invalid: \"%s\"",
-                  strType.c_str(), LAYOUT_XML_ATTR_KEY_SYMBOL, strSymbol.c_str());
+        CLog::Log(LOGERROR, "<%s> tag - attribute \"%s\" is invalid: \"%s\"", strType.c_str(),
+                  LAYOUT_XML_ATTR_KEY_SYMBOL, strSymbol.c_str());
         return false;
       }
     }
diff --git a/xbmc/games/controllers/ControllerFeature.h b/xbmc/games/controllers/ControllerFeature.h
index 0061e6fd0f68..fd81a71bf3ac 100644
--- a/xbmc/games/controllers/ControllerFeature.h
+++ b/xbmc/games/controllers/ControllerFeature.h
@@ -34,7 +34,7 @@ class CControllerFeature
 
   JOYSTICK::FEATURE_TYPE Type(void) const { return m_type; }
   JOYSTICK::FEATURE_CATEGORY Category(void) const { return m_category; }
-  const std::string &Name(void) const { return m_strName; }
+  const std::string& Name(void) const { return m_strName; }
 
   // GUI properties
   std::string Label(void) const;
@@ -51,7 +51,7 @@ class CControllerFeature
                    int categoryLabelId);
 
 private:
-  const CController *m_controller = nullptr; // Used for translating addon-specific labels
+  const CController* m_controller = nullptr; // Used for translating addon-specific labels
   JOYSTICK::FEATURE_TYPE m_type = JOYSTICK::FEATURE_TYPE::UNKNOWN;
   JOYSTICK::FEATURE_CATEGORY m_category = JOYSTICK::FEATURE_CATEGORY::UNKNOWN;
   int m_categoryLabelId = -1;
@@ -61,5 +61,5 @@ class CControllerFeature
   KEYBOARD::KeySymbol m_keycode = XBMCK_UNKNOWN;
 };
 
-}
-}
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/ControllerIDs.h b/xbmc/games/controllers/ControllerIDs.h
index df2675770b95..a9254e015dfd 100644
--- a/xbmc/games/controllers/ControllerIDs.h
+++ b/xbmc/games/controllers/ControllerIDs.h
@@ -9,7 +9,7 @@
 #pragma once
 
 // Default controller IDs
-#define DEFAULT_CONTROLLER_ID    "game.controller.default"
-#define DEFAULT_KEYBOARD_ID      "game.controller.keyboard"
-#define DEFAULT_MOUSE_ID         "game.controller.mouse"
-#define DEFAULT_REMOTE_ID        "game.controller.remote"
+#define DEFAULT_CONTROLLER_ID "game.controller.default"
+#define DEFAULT_KEYBOARD_ID "game.controller.keyboard"
+#define DEFAULT_MOUSE_ID "game.controller.mouse"
+#define DEFAULT_REMOTE_ID "game.controller.remote"
diff --git a/xbmc/games/controllers/ControllerLayout.cpp b/xbmc/games/controllers/ControllerLayout.cpp
index f1ab133abea9..3e6c7575cee1 100644
--- a/xbmc/games/controllers/ControllerLayout.cpp
+++ b/xbmc/games/controllers/ControllerLayout.cpp
@@ -22,17 +22,16 @@
 using namespace KODI;
 using namespace GAME;
 
-CControllerLayout::CControllerLayout() :
-  m_topology(new CControllerTopology)
+CControllerLayout::CControllerLayout() : m_topology(new CControllerTopology)
 {
 }
 
-CControllerLayout::CControllerLayout(const CControllerLayout &other) :
-  m_controller(other.m_controller),
-  m_labelId(other.m_labelId),
-  m_icon(other.m_icon),
-  m_strImage(other.m_strImage),
-  m_topology(new CControllerTopology(*other.m_topology))
+CControllerLayout::CControllerLayout(const CControllerLayout& other)
+  : m_controller(other.m_controller),
+    m_labelId(other.m_labelId),
+    m_icon(other.m_icon),
+    m_strImage(other.m_strImage),
+    m_topology(new CControllerTopology(*other.m_topology))
 {
 }
 
@@ -52,14 +51,16 @@ bool CControllerLayout::IsValid(bool bLog) const
   if (m_labelId < 0)
   {
     if (bLog)
-      CLog::Log(LOGERROR, "<%s> tag has no \"%s\" attribute", LAYOUT_XML_ROOT, LAYOUT_XML_ATTR_LAYOUT_LABEL);
+      CLog::Log(LOGERROR, "<%s> tag has no \"%s\" attribute", LAYOUT_XML_ROOT,
+                LAYOUT_XML_ATTR_LAYOUT_LABEL);
     return false;
   }
 
   if (m_strImage.empty())
   {
     if (bLog)
-      CLog::Log(LOGDEBUG, "<%s> tag has no \"%s\" attribute", LAYOUT_XML_ROOT, LAYOUT_XML_ATTR_LAYOUT_IMAGE);
+      CLog::Log(LOGDEBUG, "<%s> tag has no \"%s\" attribute", LAYOUT_XML_ROOT,
+                LAYOUT_XML_ATTR_LAYOUT_IMAGE);
     return false;
   }
 
@@ -86,7 +87,9 @@ std::string CControllerLayout::ImagePath(void) const
   return path;
 }
 
-void CControllerLayout::Deserialize(const TiXmlElement* pElement, const CController* controller, std::vector<CControllerFeature> &features)
+void CControllerLayout::Deserialize(const TiXmlElement* pElement,
+                                    const CController* controller,
+                                    std::vector<CControllerFeature>& features)
 {
   if (pElement == nullptr || controller == nullptr)
     return;
@@ -113,23 +116,27 @@ void CControllerLayout::Deserialize(const TiXmlElement* pElement, const CControl
   if (!image.empty())
     m_strImage = image;
 
-  for (const TiXmlElement* pChild = pElement->FirstChildElement(); pChild != nullptr; pChild = pChild->NextSiblingElement())
+  for (const TiXmlElement* pChild = pElement->FirstChildElement(); pChild != nullptr;
+       pChild = pChild->NextSiblingElement())
   {
     if (pChild->ValueStr() == LAYOUT_XML_ELM_CATEGORY)
     {
       // Category
       std::string strCategory = XMLUtils::GetAttribute(pChild, LAYOUT_XML_ATTR_CATEGORY_NAME);
-      JOYSTICK::FEATURE_CATEGORY category = CControllerTranslator::TranslateFeatureCategory(strCategory);
+      JOYSTICK::FEATURE_CATEGORY category =
+          CControllerTranslator::TranslateFeatureCategory(strCategory);
 
       // Category label
       int categoryLabelId = -1;
 
-      std::string strCategoryLabelId = XMLUtils::GetAttribute(pChild, LAYOUT_XML_ATTR_CATEGORY_LABEL);
+      std::string strCategoryLabelId =
+          XMLUtils::GetAttribute(pChild, LAYOUT_XML_ATTR_CATEGORY_LABEL);
       if (!strCategoryLabelId.empty())
         std::istringstream(strCategoryLabelId) >> categoryLabelId;
 
       // Features
-      for (const TiXmlElement* pFeature = pChild->FirstChildElement(); pFeature != nullptr; pFeature = pFeature->NextSiblingElement())
+      for (const TiXmlElement* pFeature = pChild->FirstChildElement(); pFeature != nullptr;
+           pFeature = pFeature->NextSiblingElement())
       {
         CControllerFeature feature;
 
diff --git a/xbmc/games/controllers/ControllerLayout.h b/xbmc/games/controllers/ControllerLayout.h
index 9b4092140de0..4b78b872b5f7 100644
--- a/xbmc/games/controllers/ControllerLayout.h
+++ b/xbmc/games/controllers/ControllerLayout.h
@@ -26,14 +26,14 @@ class CControllerLayout
 {
 public:
   CControllerLayout();
-  CControllerLayout(const CControllerLayout &other);
+  CControllerLayout(const CControllerLayout& other);
   ~CControllerLayout();
 
   void Reset(void);
 
   int LabelID(void) const { return m_labelId; }
   const std::string& Icon(void) const { return m_icon; }
-  const std::string& Image(void) const   { return m_strImage; }
+  const std::string& Image(void) const { return m_strImage; }
 
   /*!
    * \brief Ensures the layout was deserialized correctly, and optionally logs if not
@@ -67,7 +67,7 @@ class CControllerLayout
    *
    * \return The physical topology of the controller
    */
-  const CControllerTopology &Topology(void) const { return *m_topology; }
+  const CControllerTopology& Topology(void) const { return *m_topology; }
 
   /*!
    * \brief Deserialize the specified XML element
@@ -76,15 +76,17 @@ class CControllerLayout
    * \param controller The controller, used to obtain read-only properties
    * \param features The deserialized features, if any
    */
-  void Deserialize(const TiXmlElement* pLayoutElement, const CController* controller, std::vector<CControllerFeature> &features);
+  void Deserialize(const TiXmlElement* pLayoutElement,
+                   const CController* controller,
+                   std::vector<CControllerFeature>& features);
 
 private:
-  const CController *m_controller = nullptr;
+  const CController* m_controller = nullptr;
   int m_labelId = -1;
   std::string m_icon;
   std::string m_strImage;
   std::unique_ptr<CControllerTopology> m_topology;
 };
 
-}
-}
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/ControllerManager.h b/xbmc/games/controllers/ControllerManager.h
index 0470b80cad36..6143d64c9502 100644
--- a/xbmc/games/controllers/ControllerManager.h
+++ b/xbmc/games/controllers/ControllerManager.h
@@ -19,58 +19,58 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerManager
-  {
-  public:
-    CControllerManager() = default;
-    ~CControllerManager() = default;
+class CControllerManager
+{
+public:
+  CControllerManager() = default;
+  ~CControllerManager() = default;
 
-    /*!
-     * \brief Get a controller
-     *
-     * A cache is used to avoid reloading controllers each time they are
-     * requested.
-     *
-     * \param controllerId The controller's ID
-     *
-     * \return The controller, or empty if the controller isn't installed or
-     *         can't be loaded
-     */
-    ControllerPtr GetController(const std::string& controllerId);
+  /*!
+   * \brief Get a controller
+   *
+   * A cache is used to avoid reloading controllers each time they are
+   * requested.
+   *
+   * \param controllerId The controller's ID
+   *
+   * \return The controller, or empty if the controller isn't installed or
+   *         can't be loaded
+   */
+  ControllerPtr GetController(const std::string& controllerId);
 
-    /*!
-     * \brief Get the default controller
-     *
-     * \return The default controller, or empty if the controller failed to load
-     */
-    ControllerPtr GetDefaultController();
+  /*!
+   * \brief Get the default controller
+   *
+   * \return The default controller, or empty if the controller failed to load
+   */
+  ControllerPtr GetDefaultController();
 
-    /*!
-     * \brief Get the default keyboard
-     *
-     * \return The keyboard controller, or empty if the controller failed to load
-     */
-    ControllerPtr GetDefaultKeyboard();
+  /*!
+   * \brief Get the default keyboard
+   *
+   * \return The keyboard controller, or empty if the controller failed to load
+   */
+  ControllerPtr GetDefaultKeyboard();
 
-    /*!
-     * \brief Get the default mouse
-     *
-     * \return The mouse controller, or empty if the controller failed to load
-     */
-    ControllerPtr GetDefaultMouse();
+  /*!
+   * \brief Get the default mouse
+   *
+   * \return The mouse controller, or empty if the controller failed to load
+   */
+  ControllerPtr GetDefaultMouse();
 
-    /*!
-     * \brief Get installed controllers
-     *
-     * \return The installed controllers that loaded successfully
-     */
-    ControllerVector GetControllers();
+  /*!
+   * \brief Get installed controllers
+   *
+   * \return The installed controllers that loaded successfully
+   */
+  ControllerVector GetControllers();
 
-  private:
-    ControllerPtr LoadController(ADDON::AddonPtr addon);
+private:
+  ControllerPtr LoadController(ADDON::AddonPtr addon);
 
-    std::map<std::string, ControllerPtr> m_cache;
-    std::set<std::string> m_failedControllers; // Controllers that failed to load
-  };
-}
-}
+  std::map<std::string, ControllerPtr> m_cache;
+  std::set<std::string> m_failedControllers; // Controllers that failed to load
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/ControllerTopology.cpp b/xbmc/games/controllers/ControllerTopology.cpp
index a26214c3229a..2d0932ff819c 100644
--- a/xbmc/games/controllers/ControllerTopology.cpp
+++ b/xbmc/games/controllers/ControllerTopology.cpp
@@ -19,9 +19,8 @@ using namespace GAME;
 
 // --- CControllerPort ---------------------------------------------------------
 
-CControllerPort::CControllerPort(std::string portId, std::vector<std::string> accepts) :
-  m_portId(std::move(portId)),
-  m_accepts(std::move(accepts))
+CControllerPort::CControllerPort(std::string portId, std::vector<std::string> accepts)
+  : m_portId(std::move(portId)), m_accepts(std::move(accepts))
 {
 }
 
@@ -31,7 +30,7 @@ void CControllerPort::Reset(void)
   *this = std::move(defaultPort);
 }
 
-bool CControllerPort::IsCompatible(const std::string &controllerId) const
+bool CControllerPort::IsCompatible(const std::string& controllerId) const
 {
   return std::find(m_accepts.begin(), m_accepts.end(), controllerId) != m_accepts.end();
 }
@@ -45,7 +44,8 @@ bool CControllerPort::Deserialize(const TiXmlElement* pElement)
 
   m_portId = XMLUtils::GetAttribute(pElement, LAYOUT_XML_ATTR_PORT_ID);
 
-  for (const TiXmlElement* pChild = pElement->FirstChildElement(); pChild != nullptr; pChild = pChild->NextSiblingElement())
+  for (const TiXmlElement* pChild = pElement->FirstChildElement(); pChild != nullptr;
+       pChild = pChild->NextSiblingElement())
   {
     if (pChild->ValueStr() == LAYOUT_XML_ELM_ACCEPTS)
     {
@@ -54,7 +54,8 @@ bool CControllerPort::Deserialize(const TiXmlElement* pElement)
       if (!controller.empty())
         m_accepts.emplace_back(std::move(controller));
       else
-        CLog::Log(LOGWARNING, "<%s> tag is missing \"%s\" attribute", LAYOUT_XML_ELM_ACCEPTS, LAYOUT_XML_ATTR_CONTROLLER);
+        CLog::Log(LOGWARNING, "<%s> tag is missing \"%s\" attribute", LAYOUT_XML_ELM_ACCEPTS,
+                  LAYOUT_XML_ATTR_CONTROLLER);
     }
     else
     {
@@ -67,9 +68,8 @@ bool CControllerPort::Deserialize(const TiXmlElement* pElement)
 
 // --- CControllerTopology -----------------------------------------------------
 
-CControllerTopology::CControllerTopology(bool bProvidesInput, std::vector<CControllerPort> ports) :
-  m_bProvidesInput(bProvidesInput),
-  m_ports(std::move(ports))
+CControllerTopology::CControllerTopology(bool bProvidesInput, std::vector<CControllerPort> ports)
+  : m_bProvidesInput(bProvidesInput), m_ports(std::move(ports))
 {
 }
 
@@ -88,7 +88,8 @@ bool CControllerTopology::Deserialize(const TiXmlElement* pElement)
 
   m_bProvidesInput = (XMLUtils::GetAttribute(pElement, LAYOUT_XML_ATTR_PROVIDES_INPUT) != "false");
 
-  for (const TiXmlElement* pChild = pElement->FirstChildElement(); pChild != nullptr; pChild = pChild->NextSiblingElement())
+  for (const TiXmlElement* pChild = pElement->FirstChildElement(); pChild != nullptr;
+       pChild = pChild->NextSiblingElement())
   {
     if (pChild->ValueStr() == LAYOUT_XML_ELM_PORT)
     {
diff --git a/xbmc/games/controllers/ControllerTopology.h b/xbmc/games/controllers/ControllerTopology.h
index f691d3035c2f..4ac538544f9a 100644
--- a/xbmc/games/controllers/ControllerTopology.h
+++ b/xbmc/games/controllers/ControllerTopology.h
@@ -38,21 +38,21 @@ class CControllerPort
    *
    * \return The port's ID, e.g. "1", as a string
    */
-  const std::string &ID() const { return m_portId; }
+  const std::string& ID() const { return m_portId; }
 
   /*!
    * \brief Get the controllers that can connect to this port
    *
    * \return A list of controllers that are physically compatible with this port
    */
-  const std::vector<std::string> &Accepts() const { return m_accepts; }
+  const std::vector<std::string>& Accepts() const { return m_accepts; }
 
   /*!
    * \brief Check if the controller is compatible with this port
    *
    * \return True if the controller is accepted, false otherwise
    */
-  bool IsCompatible(const std::string &controllerId) const;
+  bool IsCompatible(const std::string& controllerId) const;
 
   bool Deserialize(const TiXmlElement* pElement);
 
@@ -90,7 +90,7 @@ class CControllerTopology
    *
    * \return The ports
    */
-  const std::vector<CControllerPort> &Ports() const { return m_ports; }
+  const std::vector<CControllerPort>& Ports() const { return m_ports; }
 
   bool Deserialize(const TiXmlElement* pElement);
 
@@ -99,5 +99,5 @@ class CControllerTopology
   std::vector<CControllerPort> m_ports;
 };
 
-}
-}
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/ControllerTranslator.cpp b/xbmc/games/controllers/ControllerTranslator.cpp
index eaf050371386..df8641be2858 100644
--- a/xbmc/games/controllers/ControllerTranslator.cpp
+++ b/xbmc/games/controllers/ControllerTranslator.cpp
@@ -18,15 +18,24 @@ const char* CControllerTranslator::TranslateFeatureType(FEATURE_TYPE type)
 {
   switch (type)
   {
-    case FEATURE_TYPE::SCALAR:           return LAYOUT_XML_ELM_BUTTON;
-    case FEATURE_TYPE::ANALOG_STICK:     return LAYOUT_XML_ELM_ANALOG_STICK;
-    case FEATURE_TYPE::ACCELEROMETER:    return LAYOUT_XML_ELM_ACCELEROMETER;
-    case FEATURE_TYPE::MOTOR:            return LAYOUT_XML_ELM_MOTOR;
-    case FEATURE_TYPE::RELPOINTER:       return LAYOUT_XML_ELM_RELPOINTER;
-    case FEATURE_TYPE::ABSPOINTER:       return LAYOUT_XML_ELM_ABSPOINTER;
-    case FEATURE_TYPE::WHEEL:            return LAYOUT_XML_ELM_WHEEL;
-    case FEATURE_TYPE::THROTTLE:         return LAYOUT_XML_ELM_THROTTLE;
-    case FEATURE_TYPE::KEY:              return LAYOUT_XML_ELM_KEY;
+    case FEATURE_TYPE::SCALAR:
+      return LAYOUT_XML_ELM_BUTTON;
+    case FEATURE_TYPE::ANALOG_STICK:
+      return LAYOUT_XML_ELM_ANALOG_STICK;
+    case FEATURE_TYPE::ACCELEROMETER:
+      return LAYOUT_XML_ELM_ACCELEROMETER;
+    case FEATURE_TYPE::MOTOR:
+      return LAYOUT_XML_ELM_MOTOR;
+    case FEATURE_TYPE::RELPOINTER:
+      return LAYOUT_XML_ELM_RELPOINTER;
+    case FEATURE_TYPE::ABSPOINTER:
+      return LAYOUT_XML_ELM_ABSPOINTER;
+    case FEATURE_TYPE::WHEEL:
+      return LAYOUT_XML_ELM_WHEEL;
+    case FEATURE_TYPE::THROTTLE:
+      return LAYOUT_XML_ELM_THROTTLE;
+    case FEATURE_TYPE::KEY:
+      return LAYOUT_XML_ELM_KEY;
     default:
       break;
   }
@@ -35,15 +44,24 @@ const char* CControllerTranslator::TranslateFeatureType(FEATURE_TYPE type)
 
 FEATURE_TYPE CControllerTranslator::TranslateFeatureType(const std::string& strType)
 {
-  if (strType == LAYOUT_XML_ELM_BUTTON)           return FEATURE_TYPE::SCALAR;
-  if (strType == LAYOUT_XML_ELM_ANALOG_STICK)     return FEATURE_TYPE::ANALOG_STICK;
-  if (strType == LAYOUT_XML_ELM_ACCELEROMETER)    return FEATURE_TYPE::ACCELEROMETER;
-  if (strType == LAYOUT_XML_ELM_MOTOR)            return FEATURE_TYPE::MOTOR;
-  if (strType == LAYOUT_XML_ELM_RELPOINTER)       return FEATURE_TYPE::RELPOINTER;
-  if (strType == LAYOUT_XML_ELM_ABSPOINTER)       return FEATURE_TYPE::ABSPOINTER;
-  if (strType == LAYOUT_XML_ELM_WHEEL)            return FEATURE_TYPE::WHEEL;
-  if (strType == LAYOUT_XML_ELM_THROTTLE)         return FEATURE_TYPE::THROTTLE;
-  if (strType == LAYOUT_XML_ELM_KEY)              return FEATURE_TYPE::KEY;
+  if (strType == LAYOUT_XML_ELM_BUTTON)
+    return FEATURE_TYPE::SCALAR;
+  if (strType == LAYOUT_XML_ELM_ANALOG_STICK)
+    return FEATURE_TYPE::ANALOG_STICK;
+  if (strType == LAYOUT_XML_ELM_ACCELEROMETER)
+    return FEATURE_TYPE::ACCELEROMETER;
+  if (strType == LAYOUT_XML_ELM_MOTOR)
+    return FEATURE_TYPE::MOTOR;
+  if (strType == LAYOUT_XML_ELM_RELPOINTER)
+    return FEATURE_TYPE::RELPOINTER;
+  if (strType == LAYOUT_XML_ELM_ABSPOINTER)
+    return FEATURE_TYPE::ABSPOINTER;
+  if (strType == LAYOUT_XML_ELM_WHEEL)
+    return FEATURE_TYPE::WHEEL;
+  if (strType == LAYOUT_XML_ELM_THROTTLE)
+    return FEATURE_TYPE::THROTTLE;
+  if (strType == LAYOUT_XML_ELM_KEY)
+    return FEATURE_TYPE::KEY;
 
   return FEATURE_TYPE::UNKNOWN;
 }
@@ -52,22 +70,38 @@ const char* CControllerTranslator::TranslateFeatureCategory(FEATURE_CATEGORY cat
 {
   switch (category)
   {
-    case FEATURE_CATEGORY::FACE:          return FEATURE_CATEGORY_FACE;
-    case FEATURE_CATEGORY::SHOULDER:      return FEATURE_CATEGORY_SHOULDER;
-    case FEATURE_CATEGORY::TRIGGER:       return FEATURE_CATEGORY_TRIGGER;
-    case FEATURE_CATEGORY::ANALOG_STICK:  return FEATURE_CATEGORY_ANALOG_STICK;
-    case FEATURE_CATEGORY::ACCELEROMETER: return FEATURE_CATEGORY_ACCELEROMETER;
-    case FEATURE_CATEGORY::HAPTICS:       return FEATURE_CATEGORY_HAPTICS;
-    case FEATURE_CATEGORY::MOUSE_BUTTON:  return FEATURE_CATEGORY_MOUSE_BUTTON;
-    case FEATURE_CATEGORY::POINTER:       return FEATURE_CATEGORY_POINTER;
-    case FEATURE_CATEGORY::LIGHTGUN:      return FEATURE_CATEGORY_LIGHTGUN;
-    case FEATURE_CATEGORY::OFFSCREEN:     return FEATURE_CATEGORY_OFFSCREEN;
-    case FEATURE_CATEGORY::KEY:           return FEATURE_CATEGORY_KEY;
-    case FEATURE_CATEGORY::KEYPAD:        return FEATURE_CATEGORY_KEYPAD;
-    case FEATURE_CATEGORY::HARDWARE:      return FEATURE_CATEGORY_HARDWARE;
-    case FEATURE_CATEGORY::WHEEL:         return FEATURE_CATEGORY_WHEEL;
-    case FEATURE_CATEGORY::JOYSTICK:      return FEATURE_CATEGORY_JOYSTICK;
-    case FEATURE_CATEGORY::PADDLE:        return FEATURE_CATEGORY_PADDLE;
+    case FEATURE_CATEGORY::FACE:
+      return FEATURE_CATEGORY_FACE;
+    case FEATURE_CATEGORY::SHOULDER:
+      return FEATURE_CATEGORY_SHOULDER;
+    case FEATURE_CATEGORY::TRIGGER:
+      return FEATURE_CATEGORY_TRIGGER;
+    case FEATURE_CATEGORY::ANALOG_STICK:
+      return FEATURE_CATEGORY_ANALOG_STICK;
+    case FEATURE_CATEGORY::ACCELEROMETER:
+      return FEATURE_CATEGORY_ACCELEROMETER;
+    case FEATURE_CATEGORY::HAPTICS:
+      return FEATURE_CATEGORY_HAPTICS;
+    case FEATURE_CATEGORY::MOUSE_BUTTON:
+      return FEATURE_CATEGORY_MOUSE_BUTTON;
+    case FEATURE_CATEGORY::POINTER:
+      return FEATURE_CATEGORY_POINTER;
+    case FEATURE_CATEGORY::LIGHTGUN:
+      return FEATURE_CATEGORY_LIGHTGUN;
+    case FEATURE_CATEGORY::OFFSCREEN:
+      return FEATURE_CATEGORY_OFFSCREEN;
+    case FEATURE_CATEGORY::KEY:
+      return FEATURE_CATEGORY_KEY;
+    case FEATURE_CATEGORY::KEYPAD:
+      return FEATURE_CATEGORY_KEYPAD;
+    case FEATURE_CATEGORY::HARDWARE:
+      return FEATURE_CATEGORY_HARDWARE;
+    case FEATURE_CATEGORY::WHEEL:
+      return FEATURE_CATEGORY_WHEEL;
+    case FEATURE_CATEGORY::JOYSTICK:
+      return FEATURE_CATEGORY_JOYSTICK;
+    case FEATURE_CATEGORY::PADDLE:
+      return FEATURE_CATEGORY_PADDLE;
     default:
       break;
   }
@@ -76,22 +110,38 @@ const char* CControllerTranslator::TranslateFeatureCategory(FEATURE_CATEGORY cat
 
 FEATURE_CATEGORY CControllerTranslator::TranslateFeatureCategory(const std::string& strCategory)
 {
-  if (strCategory == FEATURE_CATEGORY_FACE)           return FEATURE_CATEGORY::FACE;
-  if (strCategory == FEATURE_CATEGORY_SHOULDER)       return FEATURE_CATEGORY::SHOULDER;
-  if (strCategory == FEATURE_CATEGORY_TRIGGER)        return FEATURE_CATEGORY::TRIGGER;
-  if (strCategory == FEATURE_CATEGORY_ANALOG_STICK)   return FEATURE_CATEGORY::ANALOG_STICK;
-  if (strCategory == FEATURE_CATEGORY_ACCELEROMETER)  return FEATURE_CATEGORY::ACCELEROMETER;
-  if (strCategory == FEATURE_CATEGORY_HAPTICS)        return FEATURE_CATEGORY::HAPTICS;
-  if (strCategory == FEATURE_CATEGORY_MOUSE_BUTTON)   return FEATURE_CATEGORY::MOUSE_BUTTON;
-  if (strCategory == FEATURE_CATEGORY_POINTER)        return FEATURE_CATEGORY::POINTER;
-  if (strCategory == FEATURE_CATEGORY_LIGHTGUN)       return FEATURE_CATEGORY::LIGHTGUN;
-  if (strCategory == FEATURE_CATEGORY_OFFSCREEN)      return FEATURE_CATEGORY::OFFSCREEN;
-  if (strCategory == FEATURE_CATEGORY_KEY)            return FEATURE_CATEGORY::KEY;
-  if (strCategory == FEATURE_CATEGORY_KEYPAD)         return FEATURE_CATEGORY::KEYPAD;
-  if (strCategory == FEATURE_CATEGORY_HARDWARE)       return FEATURE_CATEGORY::HARDWARE;
-  if (strCategory == FEATURE_CATEGORY_WHEEL)          return FEATURE_CATEGORY::WHEEL;
-  if (strCategory == FEATURE_CATEGORY_JOYSTICK)       return FEATURE_CATEGORY::JOYSTICK;
-  if (strCategory == FEATURE_CATEGORY_PADDLE)         return FEATURE_CATEGORY::PADDLE;
+  if (strCategory == FEATURE_CATEGORY_FACE)
+    return FEATURE_CATEGORY::FACE;
+  if (strCategory == FEATURE_CATEGORY_SHOULDER)
+    return FEATURE_CATEGORY::SHOULDER;
+  if (strCategory == FEATURE_CATEGORY_TRIGGER)
+    return FEATURE_CATEGORY::TRIGGER;
+  if (strCategory == FEATURE_CATEGORY_ANALOG_STICK)
+    return FEATURE_CATEGORY::ANALOG_STICK;
+  if (strCategory == FEATURE_CATEGORY_ACCELEROMETER)
+    return FEATURE_CATEGORY::ACCELEROMETER;
+  if (strCategory == FEATURE_CATEGORY_HAPTICS)
+    return FEATURE_CATEGORY::HAPTICS;
+  if (strCategory == FEATURE_CATEGORY_MOUSE_BUTTON)
+    return FEATURE_CATEGORY::MOUSE_BUTTON;
+  if (strCategory == FEATURE_CATEGORY_POINTER)
+    return FEATURE_CATEGORY::POINTER;
+  if (strCategory == FEATURE_CATEGORY_LIGHTGUN)
+    return FEATURE_CATEGORY::LIGHTGUN;
+  if (strCategory == FEATURE_CATEGORY_OFFSCREEN)
+    return FEATURE_CATEGORY::OFFSCREEN;
+  if (strCategory == FEATURE_CATEGORY_KEY)
+    return FEATURE_CATEGORY::KEY;
+  if (strCategory == FEATURE_CATEGORY_KEYPAD)
+    return FEATURE_CATEGORY::KEYPAD;
+  if (strCategory == FEATURE_CATEGORY_HARDWARE)
+    return FEATURE_CATEGORY::HARDWARE;
+  if (strCategory == FEATURE_CATEGORY_WHEEL)
+    return FEATURE_CATEGORY::WHEEL;
+  if (strCategory == FEATURE_CATEGORY_JOYSTICK)
+    return FEATURE_CATEGORY::JOYSTICK;
+  if (strCategory == FEATURE_CATEGORY_PADDLE)
+    return FEATURE_CATEGORY::PADDLE;
 
   return FEATURE_CATEGORY::UNKNOWN;
 }
@@ -100,8 +150,10 @@ const char* CControllerTranslator::TranslateInputType(INPUT_TYPE type)
 {
   switch (type)
   {
-    case INPUT_TYPE::DIGITAL: return "digital";
-    case INPUT_TYPE::ANALOG:  return "analog";
+    case INPUT_TYPE::DIGITAL:
+      return "digital";
+    case INPUT_TYPE::ANALOG:
+      return "analog";
     default:
       break;
   }
@@ -110,300 +162,580 @@ const char* CControllerTranslator::TranslateInputType(INPUT_TYPE type)
 
 INPUT_TYPE CControllerTranslator::TranslateInputType(const std::string& strType)
 {
-  if (strType == "digital") return INPUT_TYPE::DIGITAL;
-  if (strType == "analog")  return INPUT_TYPE::ANALOG;
+  if (strType == "digital")
+    return INPUT_TYPE::DIGITAL;
+  if (strType == "analog")
+    return INPUT_TYPE::ANALOG;
 
   return INPUT_TYPE::UNKNOWN;
 }
 
-KEYBOARD::KeySymbol CControllerTranslator::TranslateKeysym(const std::string &symbol)
+KEYBOARD::KeySymbol CControllerTranslator::TranslateKeysym(const std::string& symbol)
 {
-  if (symbol == "backspace") return XBMCK_BACKSPACE;
-  if (symbol == "tab") return XBMCK_TAB;
-  if (symbol == "clear") return XBMCK_CLEAR;
-  if (symbol == "enter") return XBMCK_RETURN;
-  if (symbol == "pause") return XBMCK_PAUSE;
-  if (symbol == "escape") return XBMCK_ESCAPE;
-  if (symbol == "space") return XBMCK_SPACE;
-  if (symbol == "exclaim") return XBMCK_EXCLAIM;
-  if (symbol == "doublequote") return XBMCK_QUOTEDBL;
-  if (symbol == "hash") return XBMCK_HASH;
-  if (symbol == "dollar") return XBMCK_DOLLAR;
-  if (symbol == "ampersand") return XBMCK_AMPERSAND;
-  if (symbol == "quote") return XBMCK_QUOTE;
-  if (symbol == "leftparen") return XBMCK_LEFTPAREN;
-  if (symbol == "rightparen") return XBMCK_RIGHTPAREN;
-  if (symbol == "asterisk") return XBMCK_ASTERISK;
-  if (symbol == "plus") return XBMCK_PLUS;
-  if (symbol == "comma") return XBMCK_COMMA;
-  if (symbol == "minus") return XBMCK_MINUS;
-  if (symbol == "period") return XBMCK_PERIOD;
-  if (symbol == "slash") return XBMCK_SLASH;
-  if (symbol == "0") return XBMCK_0;
-  if (symbol == "1") return XBMCK_1;
-  if (symbol == "2") return XBMCK_2;
-  if (symbol == "3") return XBMCK_3;
-  if (symbol == "4") return XBMCK_4;
-  if (symbol == "5") return XBMCK_5;
-  if (symbol == "6") return XBMCK_6;
-  if (symbol == "7") return XBMCK_7;
-  if (symbol == "8") return XBMCK_8;
-  if (symbol == "9") return XBMCK_9;
-  if (symbol == "colon") return XBMCK_COLON;
-  if (symbol == "semicolon") return XBMCK_SEMICOLON;
-  if (symbol == "less") return XBMCK_LESS;
-  if (symbol == "equals") return XBMCK_EQUALS;
-  if (symbol == "greater") return XBMCK_GREATER;
-  if (symbol == "question") return XBMCK_QUESTION;
-  if (symbol == "at") return XBMCK_AT;
-  if (symbol == "leftbracket") return XBMCK_LEFTBRACKET;
-  if (symbol == "backslash") return XBMCK_BACKSLASH;
-  if (symbol == "rightbracket") return XBMCK_RIGHTBRACKET;
-  if (symbol == "caret") return XBMCK_CARET;
-  if (symbol == "underscore") return XBMCK_UNDERSCORE;
-  if (symbol == "grave") return XBMCK_BACKQUOTE;
-  if (symbol == "a") return XBMCK_a;
-  if (symbol == "b") return XBMCK_b;
-  if (symbol == "c") return XBMCK_c;
-  if (symbol == "d") return XBMCK_d;
-  if (symbol == "e") return XBMCK_e;
-  if (symbol == "f") return XBMCK_f;
-  if (symbol == "g") return XBMCK_g;
-  if (symbol == "h") return XBMCK_h;
-  if (symbol == "i") return XBMCK_i;
-  if (symbol == "j") return XBMCK_j;
-  if (symbol == "k") return XBMCK_k;
-  if (symbol == "l") return XBMCK_l;
-  if (symbol == "m") return XBMCK_m;
-  if (symbol == "n") return XBMCK_n;
-  if (symbol == "o") return XBMCK_o;
-  if (symbol == "p") return XBMCK_p;
-  if (symbol == "q") return XBMCK_q;
-  if (symbol == "r") return XBMCK_r;
-  if (symbol == "s") return XBMCK_s;
-  if (symbol == "t") return XBMCK_t;
-  if (symbol == "u") return XBMCK_u;
-  if (symbol == "v") return XBMCK_v;
-  if (symbol == "w") return XBMCK_w;
-  if (symbol == "x") return XBMCK_x;
-  if (symbol == "y") return XBMCK_y;
-  if (symbol == "z") return XBMCK_z;
-  if (symbol == "leftbrace") return XBMCK_LEFTBRACE;
-  if (symbol == "bar") return XBMCK_PIPE;
-  if (symbol == "rightbrace") return XBMCK_RIGHTBRACE;
-  if (symbol == "tilde") return XBMCK_TILDE;
-  if (symbol == "delete") return XBMCK_DELETE;
-  if (symbol == "kp0") return XBMCK_KP0;
-  if (symbol == "kp1") return XBMCK_KP1;
-  if (symbol == "kp2") return XBMCK_KP2;
-  if (symbol == "kp3") return XBMCK_KP3;
-  if (symbol == "kp4") return XBMCK_KP4;
-  if (symbol == "kp5") return XBMCK_KP5;
-  if (symbol == "kp6") return XBMCK_KP6;
-  if (symbol == "kp7") return XBMCK_KP7;
-  if (symbol == "kp8") return XBMCK_KP8;
-  if (symbol == "kp9") return XBMCK_KP9;
-  if (symbol == "kpperiod") return XBMCK_KP_PERIOD;
-  if (symbol == "kpdivide") return XBMCK_KP_DIVIDE;
-  if (symbol == "kpmultiply") return XBMCK_KP_MULTIPLY;
-  if (symbol == "kpminus") return XBMCK_KP_MINUS;
-  if (symbol == "kpplus") return XBMCK_KP_PLUS;
-  if (symbol == "kpenter") return XBMCK_KP_ENTER;
-  if (symbol == "kpequals") return XBMCK_KP_EQUALS;
-  if (symbol == "up") return XBMCK_UP;
-  if (symbol == "down") return XBMCK_DOWN;
-  if (symbol == "right") return XBMCK_RIGHT;
-  if (symbol == "left") return XBMCK_LEFT;
-  if (symbol == "insert") return XBMCK_INSERT;
-  if (symbol == "home") return XBMCK_HOME;
-  if (symbol == "end") return XBMCK_END;
-  if (symbol == "pageup") return XBMCK_PAGEUP;
-  if (symbol == "pagedown") return XBMCK_PAGEDOWN;
-  if (symbol == "f1") return XBMCK_F1;
-  if (symbol == "f2") return XBMCK_F2;
-  if (symbol == "f3") return XBMCK_F3;
-  if (symbol == "f4") return XBMCK_F4;
-  if (symbol == "f5") return XBMCK_F5;
-  if (symbol == "f6") return XBMCK_F6;
-  if (symbol == "f7") return XBMCK_F7;
-  if (symbol == "f8") return XBMCK_F8;
-  if (symbol == "f9") return XBMCK_F9;
-  if (symbol == "f10") return XBMCK_F10;
-  if (symbol == "f11") return XBMCK_F11;
-  if (symbol == "f12") return XBMCK_F12;
-  if (symbol == "f13") return XBMCK_F13;
-  if (symbol == "f14") return XBMCK_F14;
-  if (symbol == "f15") return XBMCK_F15;
-  if (symbol == "numlock") return XBMCK_NUMLOCK;
-  if (symbol == "capslock") return XBMCK_CAPSLOCK;
-  if (symbol == "scrolllock") return XBMCK_SCROLLOCK;
-  if (symbol == "leftshift") return XBMCK_LSHIFT;
-  if (symbol == "rightshift") return XBMCK_RSHIFT;
-  if (symbol == "leftctrl") return XBMCK_LCTRL;
-  if (symbol == "rightctrl") return XBMCK_RCTRL;
-  if (symbol == "leftalt") return XBMCK_LALT;
-  if (symbol == "rightalt") return XBMCK_RALT;
-  if (symbol == "leftmeta") return XBMCK_LMETA;
-  if (symbol == "rightmeta") return XBMCK_RMETA;
-  if (symbol == "leftsuper") return XBMCK_LSUPER;
-  if (symbol == "rightsuper") return XBMCK_RSUPER;
-  if (symbol == "mode") return XBMCK_MODE;
-  if (symbol == "compose") return XBMCK_COMPOSE;
-  if (symbol == "help") return XBMCK_HELP;
-  if (symbol == "printscreen") return XBMCK_PRINT;
-  if (symbol == "sysreq") return XBMCK_SYSREQ;
-  if (symbol == "break") return XBMCK_BREAK;
-  if (symbol == "menu") return XBMCK_MENU;
-  if (symbol == "power") return XBMCK_POWER;
-  if (symbol == "euro") return XBMCK_EURO;
-  if (symbol == "undo") return XBMCK_UNDO;
+  if (symbol == "backspace")
+    return XBMCK_BACKSPACE;
+  if (symbol == "tab")
+    return XBMCK_TAB;
+  if (symbol == "clear")
+    return XBMCK_CLEAR;
+  if (symbol == "enter")
+    return XBMCK_RETURN;
+  if (symbol == "pause")
+    return XBMCK_PAUSE;
+  if (symbol == "escape")
+    return XBMCK_ESCAPE;
+  if (symbol == "space")
+    return XBMCK_SPACE;
+  if (symbol == "exclaim")
+    return XBMCK_EXCLAIM;
+  if (symbol == "doublequote")
+    return XBMCK_QUOTEDBL;
+  if (symbol == "hash")
+    return XBMCK_HASH;
+  if (symbol == "dollar")
+    return XBMCK_DOLLAR;
+  if (symbol == "ampersand")
+    return XBMCK_AMPERSAND;
+  if (symbol == "quote")
+    return XBMCK_QUOTE;
+  if (symbol == "leftparen")
+    return XBMCK_LEFTPAREN;
+  if (symbol == "rightparen")
+    return XBMCK_RIGHTPAREN;
+  if (symbol == "asterisk")
+    return XBMCK_ASTERISK;
+  if (symbol == "plus")
+    return XBMCK_PLUS;
+  if (symbol == "comma")
+    return XBMCK_COMMA;
+  if (symbol == "minus")
+    return XBMCK_MINUS;
+  if (symbol == "period")
+    return XBMCK_PERIOD;
+  if (symbol == "slash")
+    return XBMCK_SLASH;
+  if (symbol == "0")
+    return XBMCK_0;
+  if (symbol == "1")
+    return XBMCK_1;
+  if (symbol == "2")
+    return XBMCK_2;
+  if (symbol == "3")
+    return XBMCK_3;
+  if (symbol == "4")
+    return XBMCK_4;
+  if (symbol == "5")
+    return XBMCK_5;
+  if (symbol == "6")
+    return XBMCK_6;
+  if (symbol == "7")
+    return XBMCK_7;
+  if (symbol == "8")
+    return XBMCK_8;
+  if (symbol == "9")
+    return XBMCK_9;
+  if (symbol == "colon")
+    return XBMCK_COLON;
+  if (symbol == "semicolon")
+    return XBMCK_SEMICOLON;
+  if (symbol == "less")
+    return XBMCK_LESS;
+  if (symbol == "equals")
+    return XBMCK_EQUALS;
+  if (symbol == "greater")
+    return XBMCK_GREATER;
+  if (symbol == "question")
+    return XBMCK_QUESTION;
+  if (symbol == "at")
+    return XBMCK_AT;
+  if (symbol == "leftbracket")
+    return XBMCK_LEFTBRACKET;
+  if (symbol == "backslash")
+    return XBMCK_BACKSLASH;
+  if (symbol == "rightbracket")
+    return XBMCK_RIGHTBRACKET;
+  if (symbol == "caret")
+    return XBMCK_CARET;
+  if (symbol == "underscore")
+    return XBMCK_UNDERSCORE;
+  if (symbol == "grave")
+    return XBMCK_BACKQUOTE;
+  if (symbol == "a")
+    return XBMCK_a;
+  if (symbol == "b")
+    return XBMCK_b;
+  if (symbol == "c")
+    return XBMCK_c;
+  if (symbol == "d")
+    return XBMCK_d;
+  if (symbol == "e")
+    return XBMCK_e;
+  if (symbol == "f")
+    return XBMCK_f;
+  if (symbol == "g")
+    return XBMCK_g;
+  if (symbol == "h")
+    return XBMCK_h;
+  if (symbol == "i")
+    return XBMCK_i;
+  if (symbol == "j")
+    return XBMCK_j;
+  if (symbol == "k")
+    return XBMCK_k;
+  if (symbol == "l")
+    return XBMCK_l;
+  if (symbol == "m")
+    return XBMCK_m;
+  if (symbol == "n")
+    return XBMCK_n;
+  if (symbol == "o")
+    return XBMCK_o;
+  if (symbol == "p")
+    return XBMCK_p;
+  if (symbol == "q")
+    return XBMCK_q;
+  if (symbol == "r")
+    return XBMCK_r;
+  if (symbol == "s")
+    return XBMCK_s;
+  if (symbol == "t")
+    return XBMCK_t;
+  if (symbol == "u")
+    return XBMCK_u;
+  if (symbol == "v")
+    return XBMCK_v;
+  if (symbol == "w")
+    return XBMCK_w;
+  if (symbol == "x")
+    return XBMCK_x;
+  if (symbol == "y")
+    return XBMCK_y;
+  if (symbol == "z")
+    return XBMCK_z;
+  if (symbol == "leftbrace")
+    return XBMCK_LEFTBRACE;
+  if (symbol == "bar")
+    return XBMCK_PIPE;
+  if (symbol == "rightbrace")
+    return XBMCK_RIGHTBRACE;
+  if (symbol == "tilde")
+    return XBMCK_TILDE;
+  if (symbol == "delete")
+    return XBMCK_DELETE;
+  if (symbol == "kp0")
+    return XBMCK_KP0;
+  if (symbol == "kp1")
+    return XBMCK_KP1;
+  if (symbol == "kp2")
+    return XBMCK_KP2;
+  if (symbol == "kp3")
+    return XBMCK_KP3;
+  if (symbol == "kp4")
+    return XBMCK_KP4;
+  if (symbol == "kp5")
+    return XBMCK_KP5;
+  if (symbol == "kp6")
+    return XBMCK_KP6;
+  if (symbol == "kp7")
+    return XBMCK_KP7;
+  if (symbol == "kp8")
+    return XBMCK_KP8;
+  if (symbol == "kp9")
+    return XBMCK_KP9;
+  if (symbol == "kpperiod")
+    return XBMCK_KP_PERIOD;
+  if (symbol == "kpdivide")
+    return XBMCK_KP_DIVIDE;
+  if (symbol == "kpmultiply")
+    return XBMCK_KP_MULTIPLY;
+  if (symbol == "kpminus")
+    return XBMCK_KP_MINUS;
+  if (symbol == "kpplus")
+    return XBMCK_KP_PLUS;
+  if (symbol == "kpenter")
+    return XBMCK_KP_ENTER;
+  if (symbol == "kpequals")
+    return XBMCK_KP_EQUALS;
+  if (symbol == "up")
+    return XBMCK_UP;
+  if (symbol == "down")
+    return XBMCK_DOWN;
+  if (symbol == "right")
+    return XBMCK_RIGHT;
+  if (symbol == "left")
+    return XBMCK_LEFT;
+  if (symbol == "insert")
+    return XBMCK_INSERT;
+  if (symbol == "home")
+    return XBMCK_HOME;
+  if (symbol == "end")
+    return XBMCK_END;
+  if (symbol == "pageup")
+    return XBMCK_PAGEUP;
+  if (symbol == "pagedown")
+    return XBMCK_PAGEDOWN;
+  if (symbol == "f1")
+    return XBMCK_F1;
+  if (symbol == "f2")
+    return XBMCK_F2;
+  if (symbol == "f3")
+    return XBMCK_F3;
+  if (symbol == "f4")
+    return XBMCK_F4;
+  if (symbol == "f5")
+    return XBMCK_F5;
+  if (symbol == "f6")
+    return XBMCK_F6;
+  if (symbol == "f7")
+    return XBMCK_F7;
+  if (symbol == "f8")
+    return XBMCK_F8;
+  if (symbol == "f9")
+    return XBMCK_F9;
+  if (symbol == "f10")
+    return XBMCK_F10;
+  if (symbol == "f11")
+    return XBMCK_F11;
+  if (symbol == "f12")
+    return XBMCK_F12;
+  if (symbol == "f13")
+    return XBMCK_F13;
+  if (symbol == "f14")
+    return XBMCK_F14;
+  if (symbol == "f15")
+    return XBMCK_F15;
+  if (symbol == "numlock")
+    return XBMCK_NUMLOCK;
+  if (symbol == "capslock")
+    return XBMCK_CAPSLOCK;
+  if (symbol == "scrolllock")
+    return XBMCK_SCROLLOCK;
+  if (symbol == "leftshift")
+    return XBMCK_LSHIFT;
+  if (symbol == "rightshift")
+    return XBMCK_RSHIFT;
+  if (symbol == "leftctrl")
+    return XBMCK_LCTRL;
+  if (symbol == "rightctrl")
+    return XBMCK_RCTRL;
+  if (symbol == "leftalt")
+    return XBMCK_LALT;
+  if (symbol == "rightalt")
+    return XBMCK_RALT;
+  if (symbol == "leftmeta")
+    return XBMCK_LMETA;
+  if (symbol == "rightmeta")
+    return XBMCK_RMETA;
+  if (symbol == "leftsuper")
+    return XBMCK_LSUPER;
+  if (symbol == "rightsuper")
+    return XBMCK_RSUPER;
+  if (symbol == "mode")
+    return XBMCK_MODE;
+  if (symbol == "compose")
+    return XBMCK_COMPOSE;
+  if (symbol == "help")
+    return XBMCK_HELP;
+  if (symbol == "printscreen")
+    return XBMCK_PRINT;
+  if (symbol == "sysreq")
+    return XBMCK_SYSREQ;
+  if (symbol == "break")
+    return XBMCK_BREAK;
+  if (symbol == "menu")
+    return XBMCK_MENU;
+  if (symbol == "power")
+    return XBMCK_POWER;
+  if (symbol == "euro")
+    return XBMCK_EURO;
+  if (symbol == "undo")
+    return XBMCK_UNDO;
 
   return XBMCK_UNKNOWN;
 }
 
-const char *CControllerTranslator::TranslateKeycode(KEYBOARD::KeySymbol keycode)
+const char* CControllerTranslator::TranslateKeycode(KEYBOARD::KeySymbol keycode)
 {
   switch (keycode)
   {
-    case XBMCK_BACKSPACE: return "backspace";
-    case XBMCK_TAB: return "tab";
-    case XBMCK_CLEAR: return "clear";
-    case XBMCK_RETURN: return "enter";
-    case XBMCK_PAUSE: return "pause";
-    case XBMCK_ESCAPE: return "escape";
-    case XBMCK_SPACE: return "space";
-    case XBMCK_EXCLAIM: return "exclaim";
-    case XBMCK_QUOTEDBL: return "doublequote";
-    case XBMCK_HASH: return "hash";
-    case XBMCK_DOLLAR: return "dollar";
-    case XBMCK_AMPERSAND: return "ampersand";
-    case XBMCK_QUOTE: return "quote";
-    case XBMCK_LEFTPAREN: return "leftparen";
-    case XBMCK_RIGHTPAREN: return "rightparen";
-    case XBMCK_ASTERISK: return "asterisk";
-    case XBMCK_PLUS: return "plus";
-    case XBMCK_COMMA: return "comma";
-    case XBMCK_MINUS: return "minus";
-    case XBMCK_PERIOD: return "period";
-    case XBMCK_SLASH: return "slash";
-    case XBMCK_0: return "0";
-    case XBMCK_1: return "1";
-    case XBMCK_2: return "2";
-    case XBMCK_3: return "3";
-    case XBMCK_4: return "4";
-    case XBMCK_5: return "5";
-    case XBMCK_6: return "6";
-    case XBMCK_7: return "7";
-    case XBMCK_8: return "8";
-    case XBMCK_9: return "9";
-    case XBMCK_COLON: return "colon";
-    case XBMCK_SEMICOLON: return "semicolon";
-    case XBMCK_LESS: return "less";
-    case XBMCK_EQUALS: return "equals";
-    case XBMCK_GREATER: return "greater";
-    case XBMCK_QUESTION: return "question";
-    case XBMCK_AT: return "at";
-    case XBMCK_LEFTBRACKET: return "leftbracket";
-    case XBMCK_BACKSLASH: return "backslash";
-    case XBMCK_RIGHTBRACKET: return "rightbracket";
-    case XBMCK_CARET: return "caret";
-    case XBMCK_UNDERSCORE: return "underscore";
-    case XBMCK_BACKQUOTE: return "grave";
-    case XBMCK_a: return "a";
-    case XBMCK_b: return "b";
-    case XBMCK_c: return "c";
-    case XBMCK_d: return "d";
-    case XBMCK_e: return "e";
-    case XBMCK_f: return "f";
-    case XBMCK_g: return "g";
-    case XBMCK_h: return "h";
-    case XBMCK_i: return "i";
-    case XBMCK_j: return "j";
-    case XBMCK_k: return "k";
-    case XBMCK_l: return "l";
-    case XBMCK_m: return "m";
-    case XBMCK_n: return "n";
-    case XBMCK_o: return "o";
-    case XBMCK_p: return "p";
-    case XBMCK_q: return "q";
-    case XBMCK_r: return "r";
-    case XBMCK_s: return "s";
-    case XBMCK_t: return "t";
-    case XBMCK_u: return "u";
-    case XBMCK_v: return "v";
-    case XBMCK_w: return "w";
-    case XBMCK_x: return "x";
-    case XBMCK_y: return "y";
-    case XBMCK_z: return "z";
-    case XBMCK_LEFTBRACE: return "leftbrace";
-    case XBMCK_PIPE: return "bar";
-    case XBMCK_RIGHTBRACE: return "rightbrace";
-    case XBMCK_TILDE: return "tilde";
-    case XBMCK_DELETE: return "delete";
-    case XBMCK_KP0: return "kp0";
-    case XBMCK_KP1: return "kp1";
-    case XBMCK_KP2: return "kp2";
-    case XBMCK_KP3: return "kp3";
-    case XBMCK_KP4: return "kp4";
-    case XBMCK_KP5: return "kp5";
-    case XBMCK_KP6: return "kp6";
-    case XBMCK_KP7: return "kp7";
-    case XBMCK_KP8: return "kp8";
-    case XBMCK_KP9: return "kp9";
-    case XBMCK_KP_PERIOD: return "kpperiod";
-    case XBMCK_KP_DIVIDE: return "kpdivide";
-    case XBMCK_KP_MULTIPLY: return "kpmultiply";
-    case XBMCK_KP_MINUS: return "kpminus";
-    case XBMCK_KP_PLUS: return "kpplus";
-    case XBMCK_KP_ENTER: return "kpenter";
-    case XBMCK_KP_EQUALS: return "kpequals";
-    case XBMCK_UP: return "up";
-    case XBMCK_DOWN: return "down";
-    case XBMCK_RIGHT: return "right";
-    case XBMCK_LEFT: return "left";
-    case XBMCK_INSERT: return "insert";
-    case XBMCK_HOME: return "home";
-    case XBMCK_END: return "end";
-    case XBMCK_PAGEUP: return "pageup";
-    case XBMCK_PAGEDOWN: return "pagedown";
-    case XBMCK_F1: return "f1";
-    case XBMCK_F2: return "f2";
-    case XBMCK_F3: return "f3";
-    case XBMCK_F4: return "f4";
-    case XBMCK_F5: return "f5";
-    case XBMCK_F6: return "f6";
-    case XBMCK_F7: return "f7";
-    case XBMCK_F8: return "f8";
-    case XBMCK_F9: return "f9";
-    case XBMCK_F10: return "f10";
-    case XBMCK_F11: return "f11";
-    case XBMCK_F12: return "f12";
-    case XBMCK_F13: return "f13";
-    case XBMCK_F14: return "f14";
-    case XBMCK_F15: return "f15";
-    case XBMCK_NUMLOCK: return "numlock";
-    case XBMCK_CAPSLOCK: return "capslock";
-    case XBMCK_SCROLLOCK: return "scrolllock";
-    case XBMCK_LSHIFT: return "leftshift";
-    case XBMCK_RSHIFT: return "rightshift";
-    case XBMCK_LCTRL: return "leftctrl";
-    case XBMCK_RCTRL: return "rightctrl";
-    case XBMCK_LALT: return "leftalt";
-    case XBMCK_RALT: return "rightalt";
-    case XBMCK_LMETA: return "leftmeta";
-    case XBMCK_RMETA: return "rightmeta";
-    case XBMCK_LSUPER: return "leftsuper";
-    case XBMCK_RSUPER: return "rightsuper";
-    case XBMCK_MODE: return "mode";
-    case XBMCK_COMPOSE: return "compose";
-    case XBMCK_HELP: return "help";
-    case XBMCK_PRINT: return "printscreen";
-    case XBMCK_SYSREQ: return "sysreq";
-    case XBMCK_BREAK: return "break";
-    case XBMCK_MENU: return "menu";
-    case XBMCK_POWER: return "power";
-    case XBMCK_EURO: return "euro";
-    case XBMCK_UNDO: return "undo";
+    case XBMCK_BACKSPACE:
+      return "backspace";
+    case XBMCK_TAB:
+      return "tab";
+    case XBMCK_CLEAR:
+      return "clear";
+    case XBMCK_RETURN:
+      return "enter";
+    case XBMCK_PAUSE:
+      return "pause";
+    case XBMCK_ESCAPE:
+      return "escape";
+    case XBMCK_SPACE:
+      return "space";
+    case XBMCK_EXCLAIM:
+      return "exclaim";
+    case XBMCK_QUOTEDBL:
+      return "doublequote";
+    case XBMCK_HASH:
+      return "hash";
+    case XBMCK_DOLLAR:
+      return "dollar";
+    case XBMCK_AMPERSAND:
+      return "ampersand";
+    case XBMCK_QUOTE:
+      return "quote";
+    case XBMCK_LEFTPAREN:
+      return "leftparen";
+    case XBMCK_RIGHTPAREN:
+      return "rightparen";
+    case XBMCK_ASTERISK:
+      return "asterisk";
+    case XBMCK_PLUS:
+      return "plus";
+    case XBMCK_COMMA:
+      return "comma";
+    case XBMCK_MINUS:
+      return "minus";
+    case XBMCK_PERIOD:
+      return "period";
+    case XBMCK_SLASH:
+      return "slash";
+    case XBMCK_0:
+      return "0";
+    case XBMCK_1:
+      return "1";
+    case XBMCK_2:
+      return "2";
+    case XBMCK_3:
+      return "3";
+    case XBMCK_4:
+      return "4";
+    case XBMCK_5:
+      return "5";
+    case XBMCK_6:
+      return "6";
+    case XBMCK_7:
+      return "7";
+    case XBMCK_8:
+      return "8";
+    case XBMCK_9:
+      return "9";
+    case XBMCK_COLON:
+      return "colon";
+    case XBMCK_SEMICOLON:
+      return "semicolon";
+    case XBMCK_LESS:
+      return "less";
+    case XBMCK_EQUALS:
+      return "equals";
+    case XBMCK_GREATER:
+      return "greater";
+    case XBMCK_QUESTION:
+      return "question";
+    case XBMCK_AT:
+      return "at";
+    case XBMCK_LEFTBRACKET:
+      return "leftbracket";
+    case XBMCK_BACKSLASH:
+      return "backslash";
+    case XBMCK_RIGHTBRACKET:
+      return "rightbracket";
+    case XBMCK_CARET:
+      return "caret";
+    case XBMCK_UNDERSCORE:
+      return "underscore";
+    case XBMCK_BACKQUOTE:
+      return "grave";
+    case XBMCK_a:
+      return "a";
+    case XBMCK_b:
+      return "b";
+    case XBMCK_c:
+      return "c";
+    case XBMCK_d:
+      return "d";
+    case XBMCK_e:
+      return "e";
+    case XBMCK_f:
+      return "f";
+    case XBMCK_g:
+      return "g";
+    case XBMCK_h:
+      return "h";
+    case XBMCK_i:
+      return "i";
+    case XBMCK_j:
+      return "j";
+    case XBMCK_k:
+      return "k";
+    case XBMCK_l:
+      return "l";
+    case XBMCK_m:
+      return "m";
+    case XBMCK_n:
+      return "n";
+    case XBMCK_o:
+      return "o";
+    case XBMCK_p:
+      return "p";
+    case XBMCK_q:
+      return "q";
+    case XBMCK_r:
+      return "r";
+    case XBMCK_s:
+      return "s";
+    case XBMCK_t:
+      return "t";
+    case XBMCK_u:
+      return "u";
+    case XBMCK_v:
+      return "v";
+    case XBMCK_w:
+      return "w";
+    case XBMCK_x:
+      return "x";
+    case XBMCK_y:
+      return "y";
+    case XBMCK_z:
+      return "z";
+    case XBMCK_LEFTBRACE:
+      return "leftbrace";
+    case XBMCK_PIPE:
+      return "bar";
+    case XBMCK_RIGHTBRACE:
+      return "rightbrace";
+    case XBMCK_TILDE:
+      return "tilde";
+    case XBMCK_DELETE:
+      return "delete";
+    case XBMCK_KP0:
+      return "kp0";
+    case XBMCK_KP1:
+      return "kp1";
+    case XBMCK_KP2:
+      return "kp2";
+    case XBMCK_KP3:
+      return "kp3";
+    case XBMCK_KP4:
+      return "kp4";
+    case XBMCK_KP5:
+      return "kp5";
+    case XBMCK_KP6:
+      return "kp6";
+    case XBMCK_KP7:
+      return "kp7";
+    case XBMCK_KP8:
+      return "kp8";
+    case XBMCK_KP9:
+      return "kp9";
+    case XBMCK_KP_PERIOD:
+      return "kpperiod";
+    case XBMCK_KP_DIVIDE:
+      return "kpdivide";
+    case XBMCK_KP_MULTIPLY:
+      return "kpmultiply";
+    case XBMCK_KP_MINUS:
+      return "kpminus";
+    case XBMCK_KP_PLUS:
+      return "kpplus";
+    case XBMCK_KP_ENTER:
+      return "kpenter";
+    case XBMCK_KP_EQUALS:
+      return "kpequals";
+    case XBMCK_UP:
+      return "up";
+    case XBMCK_DOWN:
+      return "down";
+    case XBMCK_RIGHT:
+      return "right";
+    case XBMCK_LEFT:
+      return "left";
+    case XBMCK_INSERT:
+      return "insert";
+    case XBMCK_HOME:
+      return "home";
+    case XBMCK_END:
+      return "end";
+    case XBMCK_PAGEUP:
+      return "pageup";
+    case XBMCK_PAGEDOWN:
+      return "pagedown";
+    case XBMCK_F1:
+      return "f1";
+    case XBMCK_F2:
+      return "f2";
+    case XBMCK_F3:
+      return "f3";
+    case XBMCK_F4:
+      return "f4";
+    case XBMCK_F5:
+      return "f5";
+    case XBMCK_F6:
+      return "f6";
+    case XBMCK_F7:
+      return "f7";
+    case XBMCK_F8:
+      return "f8";
+    case XBMCK_F9:
+      return "f9";
+    case XBMCK_F10:
+      return "f10";
+    case XBMCK_F11:
+      return "f11";
+    case XBMCK_F12:
+      return "f12";
+    case XBMCK_F13:
+      return "f13";
+    case XBMCK_F14:
+      return "f14";
+    case XBMCK_F15:
+      return "f15";
+    case XBMCK_NUMLOCK:
+      return "numlock";
+    case XBMCK_CAPSLOCK:
+      return "capslock";
+    case XBMCK_SCROLLOCK:
+      return "scrolllock";
+    case XBMCK_LSHIFT:
+      return "leftshift";
+    case XBMCK_RSHIFT:
+      return "rightshift";
+    case XBMCK_LCTRL:
+      return "leftctrl";
+    case XBMCK_RCTRL:
+      return "rightctrl";
+    case XBMCK_LALT:
+      return "leftalt";
+    case XBMCK_RALT:
+      return "rightalt";
+    case XBMCK_LMETA:
+      return "leftmeta";
+    case XBMCK_RMETA:
+      return "rightmeta";
+    case XBMCK_LSUPER:
+      return "leftsuper";
+    case XBMCK_RSUPER:
+      return "rightsuper";
+    case XBMCK_MODE:
+      return "mode";
+    case XBMCK_COMPOSE:
+      return "compose";
+    case XBMCK_HELP:
+      return "help";
+    case XBMCK_PRINT:
+      return "printscreen";
+    case XBMCK_SYSREQ:
+      return "sysreq";
+    case XBMCK_BREAK:
+      return "break";
+    case XBMCK_MENU:
+      return "menu";
+    case XBMCK_POWER:
+      return "power";
+    case XBMCK_EURO:
+      return "euro";
+    case XBMCK_UNDO:
+      return "undo";
     default:
       break;
   }
diff --git a/xbmc/games/controllers/ControllerTranslator.h b/xbmc/games/controllers/ControllerTranslator.h
index 4ab4be56f391..0bf4bf16a762 100644
--- a/xbmc/games/controllers/ControllerTranslator.h
+++ b/xbmc/games/controllers/ControllerTranslator.h
@@ -37,7 +37,7 @@ class CControllerTranslator
    *
    * \return The layout-independent keycode associated with the key
    */
-  static KEYBOARD::KeySymbol TranslateKeysym(const std::string &symbol);
+  static KEYBOARD::KeySymbol TranslateKeysym(const std::string& symbol);
 
   /*!
    * \brief Translate a Kodi key code to a keyboard symbol
@@ -46,8 +46,8 @@ class CControllerTranslator
    *
    * \return The key's symbol,or an empty string if no symbol is defined for the keycode
    */
-  static const char *TranslateKeycode(KEYBOARD::KeySymbol keycode);
+  static const char* TranslateKeycode(KEYBOARD::KeySymbol keycode);
 };
 
-}
-}
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/ControllerTypes.h b/xbmc/games/controllers/ControllerTypes.h
index db9581aaf866..838a07dbd010 100644
--- a/xbmc/games/controllers/ControllerTypes.h
+++ b/xbmc/games/controllers/ControllerTypes.h
@@ -15,19 +15,19 @@ namespace KODI
 {
 namespace GAME
 {
-  class CController;
-  using ControllerPtr = std::shared_ptr<CController>;
-  using ControllerVector = std::vector<ControllerPtr>;
+class CController;
+using ControllerPtr = std::shared_ptr<CController>;
+using ControllerVector = std::vector<ControllerPtr>;
 
-  /*!
-   * \brief Type of input provided by a hardware or controller port
-   */
-  enum class PORT_TYPE
-  {
-    UNKNOWN,
-    KEYBOARD,
-    MOUSE,
-    CONTROLLER,
-  };
-}
-}
+/*!
+ * \brief Type of input provided by a hardware or controller port
+ */
+enum class PORT_TYPE
+{
+  UNKNOWN,
+  KEYBOARD,
+  MOUSE,
+  CONTROLLER,
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/dialogs/GUIDialogAxisDetection.cpp b/xbmc/games/controllers/dialogs/GUIDialogAxisDetection.cpp
index c93027b90552..b7f7ef4895f6 100644
--- a/xbmc/games/controllers/dialogs/GUIDialogAxisDetection.cpp
+++ b/xbmc/games/controllers/dialogs/GUIDialogAxisDetection.cpp
@@ -54,16 +54,17 @@ bool CGUIDialogAxisDetection::AcceptsPrimitive(JOYSTICK::PRIMITIVE_TYPE type) co
 {
   switch (type)
   {
-  case JOYSTICK::PRIMITIVE_TYPE::SEMIAXIS:
-    return true;
-  default:
-    break;
+    case JOYSTICK::PRIMITIVE_TYPE::SEMIAXIS:
+      return true;
+    default:
+      break;
   }
 
   return false;
 }
 
-void CGUIDialogAxisDetection::OnLateAxis(const JOYSTICK::IButtonMap* buttonMap, unsigned int axisIndex)
+void CGUIDialogAxisDetection::OnLateAxis(const JOYSTICK::IButtonMap* buttonMap,
+                                         unsigned int axisIndex)
 {
   AddAxis(buttonMap->DeviceName(), axisIndex);
 }
@@ -71,11 +72,9 @@ void CGUIDialogAxisDetection::OnLateAxis(const JOYSTICK::IButtonMap* buttonMap,
 void CGUIDialogAxisDetection::AddAxis(const std::string& deviceName, unsigned int axisIndex)
 {
   auto it = std::find_if(m_detectedAxes.begin(), m_detectedAxes.end(),
-    [&deviceName, axisIndex](const AxisEntry& axis)
-    {
-      return axis.first == deviceName &&
-             axis.second == axisIndex;
-    });
+                         [&deviceName, axisIndex](const AxisEntry& axis) {
+                           return axis.first == deviceName && axis.second == axisIndex;
+                         });
 
   if (it == m_detectedAxes.end())
   {
diff --git a/xbmc/games/controllers/dialogs/GUIDialogAxisDetection.h b/xbmc/games/controllers/dialogs/GUIDialogAxisDetection.h
index 662643cbf122..2148118dfc40 100644
--- a/xbmc/games/controllers/dialogs/GUIDialogAxisDetection.h
+++ b/xbmc/games/controllers/dialogs/GUIDialogAxisDetection.h
@@ -18,37 +18,37 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIDialogAxisDetection : public CGUIDialogButtonCapture
-  {
-  public:
-    CGUIDialogAxisDetection() = default;
-
-    ~CGUIDialogAxisDetection() override = default;
-
-    // specialization of IButtonMapper via CGUIDialogButtonCapture
-    bool AcceptsPrimitive(JOYSTICK::PRIMITIVE_TYPE type) const override;
-    void OnLateAxis(const JOYSTICK::IButtonMap* buttonMap, unsigned int axisIndex) override;
-
-  protected:
-    // implementation of CGUIDialogButtonCapture
-    std::string GetDialogText() override;
-    std::string GetDialogHeader() override;
-    bool MapPrimitiveInternal(JOYSTICK::IButtonMap* buttonMap,
-                              IKeymap* keymap,
-                              const JOYSTICK::CDriverPrimitive& primitive) override;
-    void OnClose(bool bAccepted) override {}
-
-  private:
-    void AddAxis(const std::string& deviceName, unsigned int axisIndex);
-
-    // Axis types
-    using DeviceName = std::string;
-    using AxisIndex = unsigned int;
-    using AxisEntry = std::pair<DeviceName, AxisIndex>;
-    using AxisVector = std::vector<AxisEntry>;
-
-    // Axis detection
-    AxisVector m_detectedAxes;
-  };
-}
-}
+class CGUIDialogAxisDetection : public CGUIDialogButtonCapture
+{
+public:
+  CGUIDialogAxisDetection() = default;
+
+  ~CGUIDialogAxisDetection() override = default;
+
+  // specialization of IButtonMapper via CGUIDialogButtonCapture
+  bool AcceptsPrimitive(JOYSTICK::PRIMITIVE_TYPE type) const override;
+  void OnLateAxis(const JOYSTICK::IButtonMap* buttonMap, unsigned int axisIndex) override;
+
+protected:
+  // implementation of CGUIDialogButtonCapture
+  std::string GetDialogText() override;
+  std::string GetDialogHeader() override;
+  bool MapPrimitiveInternal(JOYSTICK::IButtonMap* buttonMap,
+                            IKeymap* keymap,
+                            const JOYSTICK::CDriverPrimitive& primitive) override;
+  void OnClose(bool bAccepted) override {}
+
+private:
+  void AddAxis(const std::string& deviceName, unsigned int axisIndex);
+
+  // Axis types
+  using DeviceName = std::string;
+  using AxisIndex = unsigned int;
+  using AxisEntry = std::pair<DeviceName, AxisIndex>;
+  using AxisVector = std::vector<AxisEntry>;
+
+  // Axis detection
+  AxisVector m_detectedAxes;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/dialogs/GUIDialogButtonCapture.cpp b/xbmc/games/controllers/dialogs/GUIDialogButtonCapture.cpp
index 61b238f8cfb1..9bf8dbc54c95 100644
--- a/xbmc/games/controllers/dialogs/GUIDialogButtonCapture.cpp
+++ b/xbmc/games/controllers/dialogs/GUIDialogButtonCapture.cpp
@@ -25,8 +25,7 @@ using namespace KODI;
 using namespace GAME;
 using namespace KODI::MESSAGING;
 
-CGUIDialogButtonCapture::CGUIDialogButtonCapture() :
-  CThread("ButtonCaptureDlg")
+CGUIDialogButtonCapture::CGUIDialogButtonCapture() : CThread("ButtonCaptureDlg")
 {
 }
 
@@ -43,7 +42,8 @@ void CGUIDialogButtonCapture::Show()
 
     Create();
 
-    bool bAccepted = HELPERS::ShowOKDialogText(CVariant{ GetDialogHeader() }, CVariant{ GetDialogText() });
+    bool bAccepted =
+        HELPERS::ShowOKDialogText(CVariant{GetDialogHeader()}, CVariant{GetDialogText()});
 
     StopThread(false);
 
@@ -65,7 +65,7 @@ void CGUIDialogButtonCapture::Process()
       break;
 
     //! @todo Move to rendering thread when there is a rendering thread
-    HELPERS::UpdateOKDialogText(CVariant{ 35013 }, CVariant{ GetDialogText() });
+    HELPERS::UpdateOKDialogText(CVariant{35013}, CVariant{GetDialogText()});
   }
 }
 
@@ -82,17 +82,18 @@ bool CGUIDialogButtonCapture::MapPrimitive(JOYSTICK::IButtonMap* buttonMap,
     std::string feature;
     if (buttonMap->GetFeature(primitive, feature))
     {
-      const auto &actions = keymap->GetActions(JOYSTICK::CJoystickUtils::MakeKeyName(feature)).actions;
+      const auto& actions =
+          keymap->GetActions(JOYSTICK::CJoystickUtils::MakeKeyName(feature)).actions;
       if (!actions.empty())
       {
         switch (actions.begin()->actionId)
         {
-        case ACTION_SELECT_ITEM:
-        case ACTION_NAV_BACK:
-        case ACTION_PREVIOUS_MENU:
-          return false;
-        default:
-          break;
+          case ACTION_SELECT_ITEM:
+          case ACTION_NAV_BACK:
+          case ACTION_PREVIOUS_MENU:
+            return false;
+          default:
+            break;
         }
       }
     }
@@ -117,13 +118,13 @@ void CGUIDialogButtonCapture::Notify(const Observable& obs, const ObservableMess
 {
   switch (msg)
   {
-  case ObservableMessagePeripheralsChanged:
-  {
-    CServiceBroker::GetPeripherals().UnregisterJoystickButtonMapper(this);
-    CServiceBroker::GetPeripherals().RegisterJoystickButtonMapper(this);
-    break;
-  }
-  default:
-    break;
+    case ObservableMessagePeripheralsChanged:
+    {
+      CServiceBroker::GetPeripherals().UnregisterJoystickButtonMapper(this);
+      CServiceBroker::GetPeripherals().RegisterJoystickButtonMapper(this);
+      break;
+    }
+    default:
+      break;
   }
 }
diff --git a/xbmc/games/controllers/dialogs/GUIDialogButtonCapture.h b/xbmc/games/controllers/dialogs/GUIDialogButtonCapture.h
index 8ae18ff650f0..97795c698fe0 100644
--- a/xbmc/games/controllers/dialogs/GUIDialogButtonCapture.h
+++ b/xbmc/games/controllers/dialogs/GUIDialogButtonCapture.h
@@ -20,48 +20,46 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIDialogButtonCapture : public JOYSTICK::IButtonMapper,
-                                  public Observer,
-                                  protected CThread
-  {
-  public:
-    CGUIDialogButtonCapture();
+class CGUIDialogButtonCapture : public JOYSTICK::IButtonMapper, public Observer, protected CThread
+{
+public:
+  CGUIDialogButtonCapture();
 
-    ~CGUIDialogButtonCapture() override = default;
+  ~CGUIDialogButtonCapture() override = default;
 
-    // implementation of IButtonMapper
-    std::string ControllerID() const override;
-    bool NeedsCooldown() const override { return false; }
-    bool MapPrimitive(JOYSTICK::IButtonMap* buttonMap,
-                      IKeymap* keymap,
-                      const JOYSTICK::CDriverPrimitive& primitive) override;
-    void OnEventFrame(const JOYSTICK::IButtonMap* buttonMap, bool bMotion) override {}
-    void OnLateAxis(const JOYSTICK::IButtonMap* buttonMap, unsigned int axisIndex) override {}
+  // implementation of IButtonMapper
+  std::string ControllerID() const override;
+  bool NeedsCooldown() const override { return false; }
+  bool MapPrimitive(JOYSTICK::IButtonMap* buttonMap,
+                    IKeymap* keymap,
+                    const JOYSTICK::CDriverPrimitive& primitive) override;
+  void OnEventFrame(const JOYSTICK::IButtonMap* buttonMap, bool bMotion) override {}
+  void OnLateAxis(const JOYSTICK::IButtonMap* buttonMap, unsigned int axisIndex) override {}
 
-    // implementation of Observer
-    void Notify(const Observable& obs, const ObservableMessage msg) override;
+  // implementation of Observer
+  void Notify(const Observable& obs, const ObservableMessage msg) override;
 
-    /*!
-     * \brief Show the dialog
-     */
-    void Show();
+  /*!
+   * \brief Show the dialog
+   */
+  void Show();
 
-  protected:
-    // implementation of CThread
-    void Process() override;
+protected:
+  // implementation of CThread
+  void Process() override;
 
-    virtual std::string GetDialogText() = 0;
-    virtual std::string GetDialogHeader() = 0;
-    virtual bool MapPrimitiveInternal(JOYSTICK::IButtonMap* buttonMap,
-                                      IKeymap* keymap,
-                                      const JOYSTICK::CDriverPrimitive& primitive) = 0;
-    virtual void OnClose(bool bAccepted) = 0;
+  virtual std::string GetDialogText() = 0;
+  virtual std::string GetDialogHeader() = 0;
+  virtual bool MapPrimitiveInternal(JOYSTICK::IButtonMap* buttonMap,
+                                    IKeymap* keymap,
+                                    const JOYSTICK::CDriverPrimitive& primitive) = 0;
+  virtual void OnClose(bool bAccepted) = 0;
 
-    CEvent m_captureEvent;
+  CEvent m_captureEvent;
 
-  private:
-    void InstallHooks();
-    void RemoveHooks();
-  };
-}
-}
+private:
+  void InstallHooks();
+  void RemoveHooks();
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/dialogs/GUIDialogIgnoreInput.cpp b/xbmc/games/controllers/dialogs/GUIDialogIgnoreInput.cpp
index f38f61386c6d..943b4d26ec4a 100644
--- a/xbmc/games/controllers/dialogs/GUIDialogIgnoreInput.cpp
+++ b/xbmc/games/controllers/dialogs/GUIDialogIgnoreInput.cpp
@@ -25,11 +25,11 @@ bool CGUIDialogIgnoreInput::AcceptsPrimitive(JOYSTICK::PRIMITIVE_TYPE type) cons
 {
   switch (type)
   {
-  case JOYSTICK::PRIMITIVE_TYPE::BUTTON:
-  case JOYSTICK::PRIMITIVE_TYPE::SEMIAXIS:
-    return true;
-  default:
-    break;
+    case JOYSTICK::PRIMITIVE_TYPE::BUTTON:
+    case JOYSTICK::PRIMITIVE_TYPE::SEMIAXIS:
+      return true;
+    default:
+      break;
   }
 
   return false;
@@ -43,11 +43,10 @@ std::string CGUIDialogIgnoreInput::GetDialogText()
 
   std::vector<std::string> primitives;
 
-  std::transform(m_capturedPrimitives.begin(), m_capturedPrimitives.end(), std::back_inserter(primitives),
-    [](const JOYSTICK::CDriverPrimitive& primitive)
-    {
-      return JOYSTICK::CJoystickTranslator::GetPrimitiveName(primitive);
-    });
+  std::transform(m_capturedPrimitives.begin(), m_capturedPrimitives.end(),
+                 std::back_inserter(primitives), [](const JOYSTICK::CDriverPrimitive& primitive) {
+                   return JOYSTICK::CJoystickTranslator::GetPrimitiveName(primitive);
+                 });
 
   return StringUtils::Format(dialogText.c_str(), StringUtils::Join(primitives, " | ").c_str());
 }
@@ -68,13 +67,15 @@ bool CGUIDialogIgnoreInput::MapPrimitiveInternal(JOYSTICK::IButtonMap* buttonMap
   // If a primitive comes from a different device, ignore it
   if (bHasDevice && m_deviceName != buttonMap->DeviceName())
   {
-    CLog::Log(LOGDEBUG, "%s: ignoring input from device %s", buttonMap->ControllerID().c_str(), buttonMap->DeviceName().c_str());
+    CLog::Log(LOGDEBUG, "%s: ignoring input from device %s", buttonMap->ControllerID().c_str(),
+              buttonMap->DeviceName().c_str());
     return false;
   }
 
   if (!bHasDevice)
   {
-    CLog::Log(LOGDEBUG, "%s: capturing input for device %s", buttonMap->ControllerID().c_str(), buttonMap->DeviceName().c_str());
+    CLog::Log(LOGDEBUG, "%s: capturing input for device %s", buttonMap->ControllerID().c_str(),
+              buttonMap->DeviceName().c_str());
     m_deviceName = buttonMap->DeviceName();
   }
 
@@ -113,13 +114,12 @@ bool CGUIDialogIgnoreInput::AddPrimitive(const JOYSTICK::CDriverPrimitive& primi
   if (primitive.Type() == JOYSTICK::PRIMITIVE_TYPE::BUTTON ||
       primitive.Type() == JOYSTICK::PRIMITIVE_TYPE::SEMIAXIS)
   {
-    auto PrimitiveMatch = [&primitive](const JOYSTICK::CDriverPrimitive& other)
-      {
-        return primitive.Type() == other.Type() &&
-               primitive.Index() == other.Index();
-      };
+    auto PrimitiveMatch = [&primitive](const JOYSTICK::CDriverPrimitive& other) {
+      return primitive.Type() == other.Type() && primitive.Index() == other.Index();
+    };
 
-    bValid = std::find_if(m_capturedPrimitives.begin(), m_capturedPrimitives.end(), PrimitiveMatch) == m_capturedPrimitives.end();
+    bValid = std::find_if(m_capturedPrimitives.begin(), m_capturedPrimitives.end(),
+                          PrimitiveMatch) == m_capturedPrimitives.end();
   }
 
   if (bValid)
diff --git a/xbmc/games/controllers/dialogs/GUIDialogIgnoreInput.h b/xbmc/games/controllers/dialogs/GUIDialogIgnoreInput.h
index 73d50dabc9e1..6650ab7a8cc8 100644
--- a/xbmc/games/controllers/dialogs/GUIDialogIgnoreInput.h
+++ b/xbmc/games/controllers/dialogs/GUIDialogIgnoreInput.h
@@ -18,30 +18,30 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIDialogIgnoreInput : public CGUIDialogButtonCapture
-  {
-  public:
-    CGUIDialogIgnoreInput() = default;
-
-    ~CGUIDialogIgnoreInput() override = default;
-
-    // specialization of IButtonMapper via CGUIDialogButtonCapture
-    bool AcceptsPrimitive(JOYSTICK::PRIMITIVE_TYPE type) const override;
-
-  protected:
-    // implementation of CGUIDialogButtonCapture
-    std::string GetDialogText() override;
-    std::string GetDialogHeader() override;
-    bool MapPrimitiveInternal(JOYSTICK::IButtonMap* buttonMap,
-                              IKeymap* keymap,
-                              const JOYSTICK::CDriverPrimitive& primitive) override;
-    void OnClose(bool bAccepted) override;
-
-  private:
-    bool AddPrimitive(const JOYSTICK::CDriverPrimitive& primitive);
-
-    std::string m_deviceName;
-    std::vector<JOYSTICK::CDriverPrimitive> m_capturedPrimitives;
-  };
-}
-}
+class CGUIDialogIgnoreInput : public CGUIDialogButtonCapture
+{
+public:
+  CGUIDialogIgnoreInput() = default;
+
+  ~CGUIDialogIgnoreInput() override = default;
+
+  // specialization of IButtonMapper via CGUIDialogButtonCapture
+  bool AcceptsPrimitive(JOYSTICK::PRIMITIVE_TYPE type) const override;
+
+protected:
+  // implementation of CGUIDialogButtonCapture
+  std::string GetDialogText() override;
+  std::string GetDialogHeader() override;
+  bool MapPrimitiveInternal(JOYSTICK::IButtonMap* buttonMap,
+                            IKeymap* keymap,
+                            const JOYSTICK::CDriverPrimitive& primitive) override;
+  void OnClose(bool bAccepted) override;
+
+private:
+  bool AddPrimitive(const JOYSTICK::CDriverPrimitive& primitive);
+
+  std::string m_deviceName;
+  std::vector<JOYSTICK::CDriverPrimitive> m_capturedPrimitives;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUICardinalFeatureButton.cpp b/xbmc/games/controllers/guicontrols/GUICardinalFeatureButton.cpp
index c8bd8710a2e3..f78bcfb1c7bd 100644
--- a/xbmc/games/controllers/guicontrols/GUICardinalFeatureButton.cpp
+++ b/xbmc/games/controllers/guicontrols/GUICardinalFeatureButton.cpp
@@ -18,8 +18,8 @@ using namespace GAME;
 CGUICardinalFeatureButton::CGUICardinalFeatureButton(const CGUIButtonControl& buttonTemplate,
                                                      IConfigurationWizard* wizard,
                                                      const CControllerFeature& feature,
-                                                     unsigned int index) :
-  CGUIFeatureButton(buttonTemplate, wizard, feature, index)
+                                                     unsigned int index)
+  : CGUIFeatureButton(buttonTemplate, wizard, feature, index)
 {
   Reset();
 }
@@ -37,19 +37,19 @@ bool CGUICardinalFeatureButton::PromptForInput(CEvent& waitEvent)
   {
     case STATE::CARDINAL_DIRECTION_UP:
       strPrompt = g_localizeStrings.Get(35092); // "Move %s up"
-      strWarn   = g_localizeStrings.Get(35093); // "Move %s up (%d)"
+      strWarn = g_localizeStrings.Get(35093); // "Move %s up (%d)"
       break;
     case STATE::CARDINAL_DIRECTION_RIGHT:
       strPrompt = g_localizeStrings.Get(35096); // "Move %s right"
-      strWarn   = g_localizeStrings.Get(35097); // "Move %s right (%d)"
+      strWarn = g_localizeStrings.Get(35097); // "Move %s right (%d)"
       break;
     case STATE::CARDINAL_DIRECTION_DOWN:
       strPrompt = g_localizeStrings.Get(35094); // "Move %s down"
-      strWarn   = g_localizeStrings.Get(35095); // "Move %s down (%d)"
+      strWarn = g_localizeStrings.Get(35095); // "Move %s down (%d)"
       break;
     case STATE::CARDINAL_DIRECTION_LEFT:
       strPrompt = g_localizeStrings.Get(35098); // "Move %s left"
-      strWarn   = g_localizeStrings.Get(35099); // "Move %s left (%d)"
+      strWarn = g_localizeStrings.Get(35099); // "Move %s left (%d)"
       break;
     default:
       break;
@@ -79,10 +79,14 @@ KODI::INPUT::CARDINAL_DIRECTION CGUICardinalFeatureButton::GetCardinalDirection(
 
   switch (m_state)
   {
-    case STATE::CARDINAL_DIRECTION_UP:    return CARDINAL_DIRECTION::UP;
-    case STATE::CARDINAL_DIRECTION_RIGHT: return CARDINAL_DIRECTION::RIGHT;
-    case STATE::CARDINAL_DIRECTION_DOWN:  return CARDINAL_DIRECTION::DOWN;
-    case STATE::CARDINAL_DIRECTION_LEFT:  return CARDINAL_DIRECTION::LEFT;
+    case STATE::CARDINAL_DIRECTION_UP:
+      return CARDINAL_DIRECTION::UP;
+    case STATE::CARDINAL_DIRECTION_RIGHT:
+      return CARDINAL_DIRECTION::RIGHT;
+    case STATE::CARDINAL_DIRECTION_DOWN:
+      return CARDINAL_DIRECTION::DOWN;
+    case STATE::CARDINAL_DIRECTION_LEFT:
+      return CARDINAL_DIRECTION::LEFT;
     default:
       break;
   }
diff --git a/xbmc/games/controllers/guicontrols/GUICardinalFeatureButton.h b/xbmc/games/controllers/guicontrols/GUICardinalFeatureButton.h
index b7a545923baf..70c544e342ec 100644
--- a/xbmc/games/controllers/guicontrols/GUICardinalFeatureButton.h
+++ b/xbmc/games/controllers/guicontrols/GUICardinalFeatureButton.h
@@ -14,36 +14,36 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUICardinalFeatureButton : public CGUIFeatureButton
+class CGUICardinalFeatureButton : public CGUIFeatureButton
+{
+public:
+  CGUICardinalFeatureButton(const CGUIButtonControl& buttonTemplate,
+                            IConfigurationWizard* wizard,
+                            const CControllerFeature& feature,
+                            unsigned int index);
+
+  ~CGUICardinalFeatureButton() override = default;
+
+  // implementation of IFeatureButton
+  bool PromptForInput(CEvent& waitEvent) override;
+  bool IsFinished() const override;
+  INPUT::CARDINAL_DIRECTION GetCardinalDirection() const override;
+  void Reset() override;
+
+private:
+  enum class STATE
   {
-  public:
-    CGUICardinalFeatureButton(const CGUIButtonControl& buttonTemplate,
-                              IConfigurationWizard* wizard,
-                              const CControllerFeature& feature,
-                              unsigned int index);
-
-    ~CGUICardinalFeatureButton() override = default;
-
-    // implementation of IFeatureButton
-    bool PromptForInput(CEvent& waitEvent) override;
-    bool IsFinished() const override;
-    INPUT::CARDINAL_DIRECTION GetCardinalDirection() const override;
-    void Reset() override;
-
-  private:
-    enum class STATE
-    {
-      CARDINAL_DIRECTION_UP,
-      CARDINAL_DIRECTION_RIGHT,
-      CARDINAL_DIRECTION_DOWN,
-      CARDINAL_DIRECTION_LEFT,
-      FINISHED,
-    };
-
-    STATE m_state;
+    CARDINAL_DIRECTION_UP,
+    CARDINAL_DIRECTION_RIGHT,
+    CARDINAL_DIRECTION_DOWN,
+    CARDINAL_DIRECTION_LEFT,
+    FINISHED,
   };
 
-  using CGUIAnalogStickButton = CGUICardinalFeatureButton;
-  using CGUIRelativePointerButton = CGUICardinalFeatureButton;
-}
-}
+  STATE m_state;
+};
+
+using CGUIAnalogStickButton = CGUICardinalFeatureButton;
+using CGUIRelativePointerButton = CGUICardinalFeatureButton;
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIControlTypes.h b/xbmc/games/controllers/guicontrols/GUIControlTypes.h
index 2aae0cb2e3e5..bf91b6ea4fc3 100644
--- a/xbmc/games/controllers/guicontrols/GUIControlTypes.h
+++ b/xbmc/games/controllers/guicontrols/GUIControlTypes.h
@@ -12,18 +12,18 @@ namespace KODI
 {
 namespace GAME
 {
-  /*!
-   * \brief Types of button controls that can populate the feature list
-   */
-  enum class BUTTON_TYPE
-  {
-    UNKNOWN,
-    BUTTON,
-    ANALOG_STICK,
-    RELATIVE_POINTER,
-    WHEEL,
-    THROTTLE,
-    SELECT_KEY,
-  };
-}
-}
+/*!
+ * \brief Types of button controls that can populate the feature list
+ */
+enum class BUTTON_TYPE
+{
+  UNKNOWN,
+  BUTTON,
+  ANALOG_STICK,
+  RELATIVE_POINTER,
+  WHEEL,
+  THROTTLE,
+  SELECT_KEY,
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIControllerButton.cpp b/xbmc/games/controllers/guicontrols/GUIControllerButton.cpp
index 70bad5a03a18..c8156ce2e221 100644
--- a/xbmc/games/controllers/guicontrols/GUIControllerButton.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIControllerButton.cpp
@@ -13,8 +13,10 @@
 using namespace KODI;
 using namespace GAME;
 
-CGUIControllerButton::CGUIControllerButton(const CGUIButtonControl& buttonControl, const std::string& label, unsigned int index) :
-  CGUIButtonControl(buttonControl)
+CGUIControllerButton::CGUIControllerButton(const CGUIButtonControl& buttonControl,
+                                           const std::string& label,
+                                           unsigned int index)
+  : CGUIButtonControl(buttonControl)
 {
   // Initialize CGUIButtonControl
   SetLabel(label);
diff --git a/xbmc/games/controllers/guicontrols/GUIControllerButton.h b/xbmc/games/controllers/guicontrols/GUIControllerButton.h
index 93dda5d89947..ebdc9249e43b 100644
--- a/xbmc/games/controllers/guicontrols/GUIControllerButton.h
+++ b/xbmc/games/controllers/guicontrols/GUIControllerButton.h
@@ -16,12 +16,14 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIControllerButton : public CGUIButtonControl
-  {
-  public:
-    CGUIControllerButton(const CGUIButtonControl& buttonControl, const std::string& label, unsigned int index);
+class CGUIControllerButton : public CGUIButtonControl
+{
+public:
+  CGUIControllerButton(const CGUIButtonControl& buttonControl,
+                       const std::string& label,
+                       unsigned int index);
 
-    ~CGUIControllerButton() override = default;
-  };
-}
-}
+  ~CGUIControllerButton() override = default;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIFeatureButton.cpp b/xbmc/games/controllers/guicontrols/GUIFeatureButton.cpp
index e65dcc2013a3..9dcb1cb7d015 100644
--- a/xbmc/games/controllers/guicontrols/GUIFeatureButton.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIFeatureButton.cpp
@@ -21,10 +21,8 @@ using namespace GAME;
 CGUIFeatureButton::CGUIFeatureButton(const CGUIButtonControl& buttonTemplate,
                                      IConfigurationWizard* wizard,
                                      const CControllerFeature& feature,
-                                     unsigned int index) :
-  CGUIButtonControl(buttonTemplate),
-  m_feature(feature),
-  m_wizard(wizard)
+                                     unsigned int index)
+  : CGUIButtonControl(buttonTemplate), m_feature(feature), m_wizard(wizard)
 {
   // Initialize CGUIButtonControl
   SetLabel(m_feature.Label());
@@ -39,7 +37,10 @@ void CGUIFeatureButton::OnUnFocus(void)
   m_wizard->OnUnfocus(this);
 }
 
-bool CGUIFeatureButton::DoPrompt(const std::string& strPrompt, const std::string& strWarn, const std::string& strFeature, CEvent& waitEvent)
+bool CGUIFeatureButton::DoPrompt(const std::string& strPrompt,
+                                 const std::string& strWarn,
+                                 const std::string& strFeature,
+                                 CEvent& waitEvent)
 {
   using namespace MESSAGING;
 
diff --git a/xbmc/games/controllers/guicontrols/GUIFeatureButton.h b/xbmc/games/controllers/guicontrols/GUIFeatureButton.h
index 2b715ba57884..4f0e4a920afb 100644
--- a/xbmc/games/controllers/guicontrols/GUIFeatureButton.h
+++ b/xbmc/games/controllers/guicontrols/GUIFeatureButton.h
@@ -18,43 +18,51 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIFeatureButton : public CGUIButtonControl,
-                            public IFeatureButton
+class CGUIFeatureButton : public CGUIButtonControl, public IFeatureButton
+{
+public:
+  CGUIFeatureButton(const CGUIButtonControl& buttonTemplate,
+                    IConfigurationWizard* wizard,
+                    const CControllerFeature& feature,
+                    unsigned int index);
+
+  ~CGUIFeatureButton() override = default;
+
+  // implementation of CGUIControl via CGUIButtonControl
+  void OnUnFocus() override;
+
+  // partial implementation of IFeatureButton
+  const CControllerFeature& Feature() const override { return m_feature; }
+  INPUT::CARDINAL_DIRECTION GetCardinalDirection() const override
+  {
+    return INPUT::CARDINAL_DIRECTION::NONE;
+  }
+  JOYSTICK::WHEEL_DIRECTION GetWheelDirection() const override
+  {
+    return JOYSTICK::WHEEL_DIRECTION::NONE;
+  }
+  JOYSTICK::THROTTLE_DIRECTION GetThrottleDirection() const override
   {
-  public:
-    CGUIFeatureButton(const CGUIButtonControl& buttonTemplate,
-                      IConfigurationWizard* wizard,
-                      const CControllerFeature& feature,
-                      unsigned int index);
-
-    ~CGUIFeatureButton() override = default;
-
-    // implementation of CGUIControl via CGUIButtonControl
-    void OnUnFocus() override;
-
-    // partial implementation of IFeatureButton
-    const CControllerFeature& Feature() const override { return m_feature; }
-    INPUT::CARDINAL_DIRECTION GetCardinalDirection() const override { return INPUT::CARDINAL_DIRECTION::NONE; }
-    JOYSTICK::WHEEL_DIRECTION GetWheelDirection() const override { return JOYSTICK::WHEEL_DIRECTION::NONE; }
-    JOYSTICK::THROTTLE_DIRECTION GetThrottleDirection() const override
-    {
-      return JOYSTICK::THROTTLE_DIRECTION::NONE;
-    }
-
-  protected:
-    bool DoPrompt(const std::string& strPrompt, const std::string& strWarn, const std::string& strFeature, CEvent& waitEvent);
-
-    // FSM helper
-    template <typename T>
-    T GetNextState(T state)
-    {
-      return static_cast<T>(static_cast<int>(state) + 1);
-    }
-
-    const CControllerFeature m_feature;
-
-  private:
-    IConfigurationWizard* const  m_wizard;
-  };
-}
-}
+    return JOYSTICK::THROTTLE_DIRECTION::NONE;
+  }
+
+protected:
+  bool DoPrompt(const std::string& strPrompt,
+                const std::string& strWarn,
+                const std::string& strFeature,
+                CEvent& waitEvent);
+
+  // FSM helper
+  template<typename T>
+  T GetNextState(T state)
+  {
+    return static_cast<T>(static_cast<int>(state) + 1);
+  }
+
+  const CControllerFeature m_feature;
+
+private:
+  IConfigurationWizard* const m_wizard;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIFeatureControls.cpp b/xbmc/games/controllers/guicontrols/GUIFeatureControls.cpp
index cc9130bdd95c..63d475768b25 100644
--- a/xbmc/games/controllers/guicontrols/GUIFeatureControls.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIFeatureControls.cpp
@@ -13,8 +13,10 @@
 using namespace KODI;
 using namespace GAME;
 
-CGUIFeatureGroupTitle::CGUIFeatureGroupTitle(const CGUILabelControl& groupTitleTemplate, const std::string& groupName, unsigned int buttonIndex) :
-  CGUILabelControl(groupTitleTemplate)
+CGUIFeatureGroupTitle::CGUIFeatureGroupTitle(const CGUILabelControl& groupTitleTemplate,
+                                             const std::string& groupName,
+                                             unsigned int buttonIndex)
+  : CGUILabelControl(groupTitleTemplate)
 {
   // Initialize CGUILabelControl
   SetLabel(groupName);
@@ -23,8 +25,9 @@ CGUIFeatureGroupTitle::CGUIFeatureGroupTitle(const CGUILabelControl& groupTitleT
   AllocResources();
 }
 
-CGUIFeatureSeparator::CGUIFeatureSeparator(const CGUIImage& separatorTemplate, unsigned int buttonIndex) :
-  CGUIImage(separatorTemplate)
+CGUIFeatureSeparator::CGUIFeatureSeparator(const CGUIImage& separatorTemplate,
+                                           unsigned int buttonIndex)
+  : CGUIImage(separatorTemplate)
 {
   // Initialize CGUIImage
   SetID(CONTROL_FEATURE_SEPARATORS_START + buttonIndex);
diff --git a/xbmc/games/controllers/guicontrols/GUIFeatureControls.h b/xbmc/games/controllers/guicontrols/GUIFeatureControls.h
index 595e559bdb7b..c72a11a0df04 100644
--- a/xbmc/games/controllers/guicontrols/GUIFeatureControls.h
+++ b/xbmc/games/controllers/guicontrols/GUIFeatureControls.h
@@ -17,20 +17,22 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIFeatureGroupTitle : public CGUILabelControl
-  {
-  public:
-    CGUIFeatureGroupTitle(const CGUILabelControl& groupTitleTemplate, const std::string& groupName, unsigned int buttonIndex);
+class CGUIFeatureGroupTitle : public CGUILabelControl
+{
+public:
+  CGUIFeatureGroupTitle(const CGUILabelControl& groupTitleTemplate,
+                        const std::string& groupName,
+                        unsigned int buttonIndex);
 
-    ~CGUIFeatureGroupTitle() override = default;
-  };
+  ~CGUIFeatureGroupTitle() override = default;
+};
 
-  class CGUIFeatureSeparator : public CGUIImage
-  {
-  public:
-    CGUIFeatureSeparator(const CGUIImage& separatorTemplate, unsigned int buttonIndex);
+class CGUIFeatureSeparator : public CGUIImage
+{
+public:
+  CGUIFeatureSeparator(const CGUIImage& separatorTemplate, unsigned int buttonIndex);
 
-    ~CGUIFeatureSeparator() override = default;
-  };
-}
-}
+  ~CGUIFeatureSeparator() override = default;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIFeatureFactory.cpp b/xbmc/games/controllers/guicontrols/GUIFeatureFactory.cpp
index 7b8325d6f494..dfba9a1205ae 100644
--- a/xbmc/games/controllers/guicontrols/GUIFeatureFactory.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIFeatureFactory.cpp
@@ -25,26 +25,26 @@ CGUIButtonControl* CGUIFeatureFactory::CreateButton(BUTTON_TYPE type,
 {
   switch (type)
   {
-  case BUTTON_TYPE::BUTTON:
-    return new CGUIScalarFeatureButton(buttonTemplate, wizard, feature, index);
+    case BUTTON_TYPE::BUTTON:
+      return new CGUIScalarFeatureButton(buttonTemplate, wizard, feature, index);
 
-  case BUTTON_TYPE::ANALOG_STICK:
-    return new CGUIAnalogStickButton(buttonTemplate, wizard, feature, index);
+    case BUTTON_TYPE::ANALOG_STICK:
+      return new CGUIAnalogStickButton(buttonTemplate, wizard, feature, index);
 
-  case BUTTON_TYPE::WHEEL:
-    return new CGUIWheelButton(buttonTemplate, wizard, feature, index);
+    case BUTTON_TYPE::WHEEL:
+      return new CGUIWheelButton(buttonTemplate, wizard, feature, index);
 
-  case BUTTON_TYPE::THROTTLE:
-    return new CGUIThrottleButton(buttonTemplate, wizard, feature, index);
+    case BUTTON_TYPE::THROTTLE:
+      return new CGUIThrottleButton(buttonTemplate, wizard, feature, index);
 
-  case BUTTON_TYPE::SELECT_KEY:
-    return new CGUISelectKeyButton(buttonTemplate, wizard, index);
+    case BUTTON_TYPE::SELECT_KEY:
+      return new CGUISelectKeyButton(buttonTemplate, wizard, index);
 
-  case BUTTON_TYPE::RELATIVE_POINTER:
-    return new CGUIRelativePointerButton(buttonTemplate, wizard, feature, index);
+    case BUTTON_TYPE::RELATIVE_POINTER:
+      return new CGUIRelativePointerButton(buttonTemplate, wizard, feature, index);
 
-  default:
-    break;
+    default:
+      break;
   }
 
   return nullptr;
diff --git a/xbmc/games/controllers/guicontrols/GUIFeatureFactory.h b/xbmc/games/controllers/guicontrols/GUIFeatureFactory.h
index 2d0ed42de226..69d7df9f744c 100644
--- a/xbmc/games/controllers/guicontrols/GUIFeatureFactory.h
+++ b/xbmc/games/controllers/guicontrols/GUIFeatureFactory.h
@@ -16,22 +16,22 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerFeature;
-  class IConfigurationWizard;
+class CControllerFeature;
+class IConfigurationWizard;
 
-  class CGUIFeatureFactory
-  {
-  public:
-    /*!
-     * \brief Create a button of the specified type
-     * \param type The type of button control being created
-     * \return A button control, or nullptr if type is invalid
-     */
-    static CGUIButtonControl* CreateButton(BUTTON_TYPE type,
-                                           const CGUIButtonControl& buttonTemplate,
-                                           IConfigurationWizard* wizard,
-                                           const CControllerFeature& feature,
-                                           unsigned int index);
-  };
-}
-}
+class CGUIFeatureFactory
+{
+public:
+  /*!
+   * \brief Create a button of the specified type
+   * \param type The type of button control being created
+   * \return A button control, or nullptr if type is invalid
+   */
+  static CGUIButtonControl* CreateButton(BUTTON_TYPE type,
+                                         const CGUIButtonControl& buttonTemplate,
+                                         IConfigurationWizard* wizard,
+                                         const CControllerFeature& feature,
+                                         unsigned int index);
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIFeatureTranslator.cpp b/xbmc/games/controllers/guicontrols/GUIFeatureTranslator.cpp
index d4d82d3d8e80..ab941c54d411 100644
--- a/xbmc/games/controllers/guicontrols/GUIFeatureTranslator.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIFeatureTranslator.cpp
@@ -15,24 +15,24 @@ BUTTON_TYPE CGUIFeatureTranslator::GetButtonType(JOYSTICK::FEATURE_TYPE featureT
 {
   switch (featureType)
   {
-  case JOYSTICK::FEATURE_TYPE::SCALAR:
-  case JOYSTICK::FEATURE_TYPE::KEY:
-    return BUTTON_TYPE::BUTTON;
+    case JOYSTICK::FEATURE_TYPE::SCALAR:
+    case JOYSTICK::FEATURE_TYPE::KEY:
+      return BUTTON_TYPE::BUTTON;
 
-  case JOYSTICK::FEATURE_TYPE::ANALOG_STICK:
-    return BUTTON_TYPE::ANALOG_STICK;
+    case JOYSTICK::FEATURE_TYPE::ANALOG_STICK:
+      return BUTTON_TYPE::ANALOG_STICK;
 
-  case JOYSTICK::FEATURE_TYPE::RELPOINTER:
-    return BUTTON_TYPE::RELATIVE_POINTER;
+    case JOYSTICK::FEATURE_TYPE::RELPOINTER:
+      return BUTTON_TYPE::RELATIVE_POINTER;
 
-  case JOYSTICK::FEATURE_TYPE::WHEEL:
-    return BUTTON_TYPE::WHEEL;
+    case JOYSTICK::FEATURE_TYPE::WHEEL:
+      return BUTTON_TYPE::WHEEL;
 
-  case JOYSTICK::FEATURE_TYPE::THROTTLE:
-    return BUTTON_TYPE::THROTTLE;
+    case JOYSTICK::FEATURE_TYPE::THROTTLE:
+      return BUTTON_TYPE::THROTTLE;
 
-  default:
-    break;
+    default:
+      break;
   }
 
   return BUTTON_TYPE::UNKNOWN;
diff --git a/xbmc/games/controllers/guicontrols/GUIFeatureTranslator.h b/xbmc/games/controllers/guicontrols/GUIFeatureTranslator.h
index 229b3d4a77bc..8e28d161ba5f 100644
--- a/xbmc/games/controllers/guicontrols/GUIFeatureTranslator.h
+++ b/xbmc/games/controllers/guicontrols/GUIFeatureTranslator.h
@@ -15,13 +15,13 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIFeatureTranslator
-  {
-  public:
-    /*!
-     * \brief Get the type of button control used to map the feature
-     */
-    static BUTTON_TYPE GetButtonType(JOYSTICK::FEATURE_TYPE featureType);
-  };
-}
-}
+class CGUIFeatureTranslator
+{
+public:
+  /*!
+   * \brief Get the type of button control used to map the feature
+   */
+  static BUTTON_TYPE GetButtonType(JOYSTICK::FEATURE_TYPE featureType);
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIGameController.cpp b/xbmc/games/controllers/guicontrols/GUIGameController.cpp
index e14634ce1735..ad951539817a 100644
--- a/xbmc/games/controllers/guicontrols/GUIGameController.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIGameController.cpp
@@ -16,15 +16,15 @@
 using namespace KODI;
 using namespace GAME;
 
-CGUIGameController::CGUIGameController(int parentID, int controlID, float posX, float posY, float width, float height)
+CGUIGameController::CGUIGameController(
+    int parentID, int controlID, float posX, float posY, float width, float height)
   : CGUIImage(parentID, controlID, posX, posY, width, height, CTextureInfo())
 {
   // Initialize CGUIControl
   ControlType = GUICONTROL_GAMECONTROLLER;
 }
 
-CGUIGameController::CGUIGameController(const CGUIGameController &from)
-  : CGUIImage(from)
+CGUIGameController::CGUIGameController(const CGUIGameController& from) : CGUIImage(from)
 {
   // Initialize CGUIControl
   ControlType = GUICONTROL_GAMECONTROLLER;
diff --git a/xbmc/games/controllers/guicontrols/GUIGameController.h b/xbmc/games/controllers/guicontrols/GUIGameController.h
index 21eddbb1bdff..d62819abf6be 100644
--- a/xbmc/games/controllers/guicontrols/GUIGameController.h
+++ b/xbmc/games/controllers/guicontrols/GUIGameController.h
@@ -16,23 +16,24 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIGameController : public CGUIImage
-  {
-  public:
-    CGUIGameController(int parentID, int controlID, float posX, float posY, float width, float height);
-    CGUIGameController(const CGUIGameController &from);
+class CGUIGameController : public CGUIImage
+{
+public:
+  CGUIGameController(
+      int parentID, int controlID, float posX, float posY, float width, float height);
+  CGUIGameController(const CGUIGameController& from);
 
-    ~CGUIGameController() override = default;
+  ~CGUIGameController() override = default;
 
-    // implementation of CGUIControl via CGUIImage
-    CGUIGameController* Clone() const override;
-    void Render() override;
+  // implementation of CGUIControl via CGUIImage
+  CGUIGameController* Clone() const override;
+  void Render() override;
 
-    void ActivateController(const ControllerPtr& controller);
+  void ActivateController(const ControllerPtr& controller);
 
-  private:
-    ControllerPtr       m_currentController;
-    CCriticalSection    m_mutex;
-  };
-}
-}
+private:
+  ControllerPtr m_currentController;
+  CCriticalSection m_mutex;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.cpp b/xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.cpp
index 5d9570cfce20..aa8a5b6b83a0 100644
--- a/xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.cpp
@@ -18,8 +18,8 @@ using namespace GAME;
 CGUIScalarFeatureButton::CGUIScalarFeatureButton(const CGUIButtonControl& buttonTemplate,
                                                  IConfigurationWizard* wizard,
                                                  const CControllerFeature& feature,
-                                                 unsigned int index) :
-  CGUIFeatureButton(buttonTemplate, wizard, feature, index)
+                                                 unsigned int index)
+  : CGUIFeatureButton(buttonTemplate, wizard, feature, index)
 {
   Reset();
 }
@@ -32,8 +32,8 @@ bool CGUIScalarFeatureButton::PromptForInput(CEvent& waitEvent)
   {
     case STATE::NEED_INPUT:
     {
-      std::string strPrompt = g_localizeStrings.Get(35090);  // "Press %s"
-      std::string strWarn = g_localizeStrings.Get(35091);  // "Press %s (%d)"
+      std::string strPrompt = g_localizeStrings.Get(35090); // "Press %s"
+      std::string strWarn = g_localizeStrings.Get(35091); // "Press %s (%d)"
 
       bInterrupted = DoPrompt(strPrompt, strWarn, m_feature.Label(), waitEvent);
 
diff --git a/xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.h b/xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.h
index d6b0b900ba4b..8881225d0ea7 100644
--- a/xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.h
+++ b/xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.h
@@ -14,29 +14,29 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIScalarFeatureButton : public CGUIFeatureButton
-  {
-  public:
-    CGUIScalarFeatureButton(const CGUIButtonControl& buttonTemplate,
-                            IConfigurationWizard* wizard,
-                            const CControllerFeature& feature,
-                            unsigned int index);
-
-    ~CGUIScalarFeatureButton() override = default;
+class CGUIScalarFeatureButton : public CGUIFeatureButton
+{
+public:
+  CGUIScalarFeatureButton(const CGUIButtonControl& buttonTemplate,
+                          IConfigurationWizard* wizard,
+                          const CControllerFeature& feature,
+                          unsigned int index);
 
-    // implementation of IFeatureButton
-    bool PromptForInput(CEvent& waitEvent) override;
-    bool IsFinished() const override;
-    void Reset() override;
+  ~CGUIScalarFeatureButton() override = default;
 
-  private:
-    enum class STATE
-    {
-      NEED_INPUT,
-      FINISHED,
-    };
+  // implementation of IFeatureButton
+  bool PromptForInput(CEvent& waitEvent) override;
+  bool IsFinished() const override;
+  void Reset() override;
 
-    STATE m_state;
+private:
+  enum class STATE
+  {
+    NEED_INPUT,
+    FINISHED,
   };
-}
-}
+
+  STATE m_state;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUISelectKeyButton.cpp b/xbmc/games/controllers/guicontrols/GUISelectKeyButton.cpp
index 649f9f584eed..3713719196c0 100644
--- a/xbmc/games/controllers/guicontrols/GUISelectKeyButton.cpp
+++ b/xbmc/games/controllers/guicontrols/GUISelectKeyButton.cpp
@@ -17,8 +17,8 @@ using namespace GAME;
 
 CGUISelectKeyButton::CGUISelectKeyButton(const CGUIButtonControl& buttonTemplate,
                                          IConfigurationWizard* wizard,
-                                         unsigned int index) :
-  CGUIFeatureButton(buttonTemplate, wizard, GetFeature(), index)
+                                         unsigned int index)
+  : CGUIFeatureButton(buttonTemplate, wizard, GetFeature(), index)
 {
 }
 
@@ -38,8 +38,8 @@ bool CGUISelectKeyButton::PromptForInput(CEvent& waitEvent)
   {
     case STATE::NEED_KEY:
     {
-      std::string strPrompt = g_localizeStrings.Get(35169);  // "Press a key"
-      std::string strWarn = g_localizeStrings.Get(35170);  // "Press a key ({1:d})"
+      std::string strPrompt = g_localizeStrings.Get(35169); // "Press a key"
+      std::string strWarn = g_localizeStrings.Get(35170); // "Press a key ({1:d})"
 
       bInterrupted = DoPrompt(strPrompt, strWarn, "", waitEvent);
 
@@ -49,8 +49,8 @@ bool CGUISelectKeyButton::PromptForInput(CEvent& waitEvent)
     }
     case STATE::NEED_INPUT:
     {
-      std::string strPrompt = g_localizeStrings.Get(35090);  // "Press {0:s}"
-      std::string strWarn = g_localizeStrings.Get(35091);  // "Press {0:s} ({1:d})"
+      std::string strPrompt = g_localizeStrings.Get(35090); // "Press {0:s}"
+      std::string strWarn = g_localizeStrings.Get(35091); // "Press {0:s} ({1:d})"
 
       bInterrupted = DoPrompt(strPrompt, strWarn, m_selectedKey.Label(), waitEvent);
 
@@ -70,7 +70,7 @@ bool CGUISelectKeyButton::IsFinished(void) const
   return m_state >= STATE::FINISHED;
 }
 
-void CGUISelectKeyButton::SetKey(const CControllerFeature &key)
+void CGUISelectKeyButton::SetKey(const CControllerFeature& key)
 {
   m_selectedKey = key;
 }
diff --git a/xbmc/games/controllers/guicontrols/GUISelectKeyButton.h b/xbmc/games/controllers/guicontrols/GUISelectKeyButton.h
index 1fe85930a9e8..9232886ae7ac 100644
--- a/xbmc/games/controllers/guicontrols/GUISelectKeyButton.h
+++ b/xbmc/games/controllers/guicontrols/GUISelectKeyButton.h
@@ -15,37 +15,37 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUISelectKeyButton : public CGUIFeatureButton
+class CGUISelectKeyButton : public CGUIFeatureButton
+{
+public:
+  CGUISelectKeyButton(const CGUIButtonControl& buttonTemplate,
+                      IConfigurationWizard* wizard,
+                      unsigned int index);
+
+  ~CGUISelectKeyButton() override = default;
+
+  // implementation of IFeatureButton
+  const CControllerFeature& Feature(void) const override;
+  bool AllowWizard() const override { return false; }
+  bool PromptForInput(CEvent& waitEvent) override;
+  bool IsFinished() const override;
+  bool NeedsKey() const override { return m_state == STATE::NEED_KEY; }
+  void SetKey(const CControllerFeature& key) override;
+  void Reset() override;
+
+private:
+  static CControllerFeature GetFeature();
+
+  enum class STATE
   {
-  public:
-    CGUISelectKeyButton(const CGUIButtonControl& buttonTemplate,
-                        IConfigurationWizard* wizard,
-                        unsigned int index);
-
-    ~CGUISelectKeyButton() override = default;
-
-    // implementation of IFeatureButton
-    const CControllerFeature& Feature(void) const override;
-    bool AllowWizard() const override { return false; }
-    bool PromptForInput(CEvent& waitEvent) override;
-    bool IsFinished() const override;
-    bool NeedsKey() const override { return m_state == STATE::NEED_KEY; }
-    void SetKey(const CControllerFeature &key) override;
-    void Reset() override;
-
-  private:
-    static CControllerFeature GetFeature();
-
-    enum class STATE
-    {
-      NEED_KEY,
-      NEED_INPUT,
-      FINISHED,
-    };
-
-    STATE m_state = STATE::NEED_KEY;
-
-    CControllerFeature m_selectedKey;
+    NEED_KEY,
+    NEED_INPUT,
+    FINISHED,
   };
-}
-}
+
+  STATE m_state = STATE::NEED_KEY;
+
+  CControllerFeature m_selectedKey;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIThrottleButton.cpp b/xbmc/games/controllers/guicontrols/GUIThrottleButton.cpp
index 958756dcfc10..02c7d18fbc0d 100644
--- a/xbmc/games/controllers/guicontrols/GUIThrottleButton.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIThrottleButton.cpp
@@ -18,8 +18,8 @@ using namespace GAME;
 CGUIThrottleButton::CGUIThrottleButton(const CGUIButtonControl& buttonTemplate,
                                        IConfigurationWizard* wizard,
                                        const CControllerFeature& feature,
-                                       unsigned int index) :
-  CGUIFeatureButton(buttonTemplate, wizard, feature, index)
+                                       unsigned int index)
+  : CGUIFeatureButton(buttonTemplate, wizard, feature, index)
 {
   Reset();
 }
@@ -37,11 +37,11 @@ bool CGUIThrottleButton::PromptForInput(CEvent& waitEvent)
   {
     case STATE::THROTTLE_UP:
       strPrompt = g_localizeStrings.Get(35092); // "Move %s up"
-      strWarn   = g_localizeStrings.Get(35093); // "Move %s up (%d)"
+      strWarn = g_localizeStrings.Get(35093); // "Move %s up (%d)"
       break;
     case STATE::THROTTLE_DOWN:
       strPrompt = g_localizeStrings.Get(35094); // "Move %s down"
-      strWarn   = g_localizeStrings.Get(35095); // "Move %s down (%d)"
+      strWarn = g_localizeStrings.Get(35095); // "Move %s down (%d)"
       break;
     default:
       break;
@@ -71,8 +71,10 @@ JOYSTICK::THROTTLE_DIRECTION CGUIThrottleButton::GetThrottleDirection(void) cons
 
   switch (m_state)
   {
-    case STATE::THROTTLE_UP:    return THROTTLE_DIRECTION::UP;
-    case STATE::THROTTLE_DOWN:  return THROTTLE_DIRECTION::DOWN;
+    case STATE::THROTTLE_UP:
+      return THROTTLE_DIRECTION::UP;
+    case STATE::THROTTLE_DOWN:
+      return THROTTLE_DIRECTION::DOWN;
     default:
       break;
   }
diff --git a/xbmc/games/controllers/guicontrols/GUIThrottleButton.h b/xbmc/games/controllers/guicontrols/GUIThrottleButton.h
index 41d44376d4a8..effc98f68961 100644
--- a/xbmc/games/controllers/guicontrols/GUIThrottleButton.h
+++ b/xbmc/games/controllers/guicontrols/GUIThrottleButton.h
@@ -14,31 +14,31 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIThrottleButton : public CGUIFeatureButton
-  {
-  public:
-    CGUIThrottleButton(const CGUIButtonControl& buttonTemplate,
-                       IConfigurationWizard* wizard,
-                       const CControllerFeature& feature,
-                       unsigned int index);
-
-    ~CGUIThrottleButton() override = default;
+class CGUIThrottleButton : public CGUIFeatureButton
+{
+public:
+  CGUIThrottleButton(const CGUIButtonControl& buttonTemplate,
+                     IConfigurationWizard* wizard,
+                     const CControllerFeature& feature,
+                     unsigned int index);
 
-    // implementation of IFeatureButton
-    bool PromptForInput(CEvent& waitEvent) override;
-    bool IsFinished() const override;
-    JOYSTICK::THROTTLE_DIRECTION GetThrottleDirection() const override;
-    void Reset() override;
+  ~CGUIThrottleButton() override = default;
 
-  private:
-    enum class STATE
-    {
-      THROTTLE_UP,
-      THROTTLE_DOWN,
-      FINISHED,
-    };
+  // implementation of IFeatureButton
+  bool PromptForInput(CEvent& waitEvent) override;
+  bool IsFinished() const override;
+  JOYSTICK::THROTTLE_DIRECTION GetThrottleDirection() const override;
+  void Reset() override;
 
-    STATE m_state;
+private:
+  enum class STATE
+  {
+    THROTTLE_UP,
+    THROTTLE_DOWN,
+    FINISHED,
   };
-}
-}
+
+  STATE m_state;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/guicontrols/GUIWheelButton.cpp b/xbmc/games/controllers/guicontrols/GUIWheelButton.cpp
index 3994aea04450..9df07fb568a7 100644
--- a/xbmc/games/controllers/guicontrols/GUIWheelButton.cpp
+++ b/xbmc/games/controllers/guicontrols/GUIWheelButton.cpp
@@ -18,8 +18,8 @@ using namespace GAME;
 CGUIWheelButton::CGUIWheelButton(const CGUIButtonControl& buttonTemplate,
                                  IConfigurationWizard* wizard,
                                  const CControllerFeature& feature,
-                                 unsigned int index) :
-  CGUIFeatureButton(buttonTemplate, wizard, feature, index)
+                                 unsigned int index)
+  : CGUIFeatureButton(buttonTemplate, wizard, feature, index)
 {
   Reset();
 }
@@ -37,11 +37,11 @@ bool CGUIWheelButton::PromptForInput(CEvent& waitEvent)
   {
     case STATE::WHEEL_LEFT:
       strPrompt = g_localizeStrings.Get(35098); // "Move %s left"
-      strWarn   = g_localizeStrings.Get(35099); // "Move %s left (%d)"
+      strWarn = g_localizeStrings.Get(35099); // "Move %s left (%d)"
       break;
     case STATE::WHEEL_RIGHT:
       strPrompt = g_localizeStrings.Get(35096); // "Move %s right"
-      strWarn   = g_localizeStrings.Get(35097); // "Move %s right (%d)"
+      strWarn = g_localizeStrings.Get(35097); // "Move %s right (%d)"
       break;
     default:
       break;
@@ -71,8 +71,10 @@ JOYSTICK::WHEEL_DIRECTION CGUIWheelButton::GetWheelDirection(void) const
 
   switch (m_state)
   {
-    case STATE::WHEEL_LEFT:  return WHEEL_DIRECTION::LEFT;
-    case STATE::WHEEL_RIGHT: return WHEEL_DIRECTION::RIGHT;
+    case STATE::WHEEL_LEFT:
+      return WHEEL_DIRECTION::LEFT;
+    case STATE::WHEEL_RIGHT:
+      return WHEEL_DIRECTION::RIGHT;
     default:
       break;
   }
diff --git a/xbmc/games/controllers/guicontrols/GUIWheelButton.h b/xbmc/games/controllers/guicontrols/GUIWheelButton.h
index 9fdbad49fd78..b099c17c8d2f 100644
--- a/xbmc/games/controllers/guicontrols/GUIWheelButton.h
+++ b/xbmc/games/controllers/guicontrols/GUIWheelButton.h
@@ -14,31 +14,31 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIWheelButton : public CGUIFeatureButton
-  {
-  public:
-    CGUIWheelButton(const CGUIButtonControl& buttonTemplate,
-                    IConfigurationWizard* wizard,
-                    const CControllerFeature& feature,
-                    unsigned int index);
-
-    ~CGUIWheelButton() override = default;
+class CGUIWheelButton : public CGUIFeatureButton
+{
+public:
+  CGUIWheelButton(const CGUIButtonControl& buttonTemplate,
+                  IConfigurationWizard* wizard,
+                  const CControllerFeature& feature,
+                  unsigned int index);
 
-    // implementation of IFeatureButton
-    bool PromptForInput(CEvent& waitEvent) override;
-    bool IsFinished() const override;
-    JOYSTICK::WHEEL_DIRECTION GetWheelDirection() const override;
-    void Reset() override;
+  ~CGUIWheelButton() override = default;
 
-  private:
-    enum class STATE
-    {
-      WHEEL_LEFT,
-      WHEEL_RIGHT,
-      FINISHED,
-    };
+  // implementation of IFeatureButton
+  bool PromptForInput(CEvent& waitEvent) override;
+  bool IsFinished() const override;
+  JOYSTICK::WHEEL_DIRECTION GetWheelDirection() const override;
+  void Reset() override;
 
-    STATE m_state;
+private:
+  enum class STATE
+  {
+    WHEEL_LEFT,
+    WHEEL_RIGHT,
+    FINISHED,
   };
-}
-}
+
+  STATE m_state;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/types/ControllerGrid.cpp b/xbmc/games/controllers/types/ControllerGrid.cpp
index 3446037b4622..6271c51ff4e7 100644
--- a/xbmc/games/controllers/types/ControllerGrid.cpp
+++ b/xbmc/games/controllers/types/ControllerGrid.cpp
@@ -19,7 +19,7 @@ using namespace GAME;
 
 CControllerGrid::~CControllerGrid() = default;
 
-void CControllerGrid::SetControllerTree(const CControllerTree &controllerTree)
+void CControllerGrid::SetControllerTree(const CControllerTree& controllerTree)
 {
   // Clear the result
   m_grid.clear();
@@ -34,7 +34,7 @@ ControllerVector CControllerGrid::GetControllers(unsigned int playerIndex) const
 
   if (playerIndex < m_grid.size())
   {
-    for (const auto &controllerVertex : m_grid[playerIndex].vertices)
+    for (const auto& controllerVertex : m_grid[playerIndex].vertices)
     {
       if (controllerVertex.controller)
         controllers.emplace_back(controllerVertex.controller);
@@ -44,27 +44,21 @@ ControllerVector CControllerGrid::GetControllers(unsigned int playerIndex) const
   return controllers;
 }
 
-unsigned int CControllerGrid::AddPorts(const ControllerPortVec &ports, ControllerGrid &grid)
+unsigned int CControllerGrid::AddPorts(const ControllerPortVec& ports, ControllerGrid& grid)
 {
   unsigned int height = 0;
 
-  auto itKeyboard = std::find_if(ports.begin(), ports.end(),
-    [](const CControllerPortNode &port)
-    {
-      return port.PortType() == PORT_TYPE::KEYBOARD;
-    });
+  auto itKeyboard = std::find_if(ports.begin(), ports.end(), [](const CControllerPortNode& port) {
+    return port.PortType() == PORT_TYPE::KEYBOARD;
+  });
 
-  auto itMouse = std::find_if(ports.begin(), ports.end(),
-    [](const CControllerPortNode &port)
-    {
-      return port.PortType() == PORT_TYPE::MOUSE;
-    });
+  auto itMouse = std::find_if(ports.begin(), ports.end(), [](const CControllerPortNode& port) {
+    return port.PortType() == PORT_TYPE::MOUSE;
+  });
 
-  auto itController = std::find_if(ports.begin(), ports.end(),
-    [](const CControllerPortNode &port)
-    {
-      return port.PortType() == PORT_TYPE::CONTROLLER;
-    });
+  auto itController = std::find_if(ports.begin(), ports.end(), [](const CControllerPortNode& port) {
+    return port.PortType() == PORT_TYPE::CONTROLLER;
+  });
 
   // Keyboard and mouse are not allowed to have ports because they might
   // overlap with controllers
@@ -83,14 +77,16 @@ unsigned int CControllerGrid::AddPorts(const ControllerPortVec &ports, Controlle
   {
     // Add controller ports
     bool bFirstPlayer = true;
-    for (const CControllerPortNode &port : ports)
+    for (const CControllerPortNode& port : ports)
     {
       ControllerColumn column;
 
       if (port.PortType() == PORT_TYPE::CONTROLLER)
       {
         // Add controller
-        height = std::max(height, AddController(port, static_cast<unsigned int>(column.vertices.size()), column.vertices, grid));
+        height =
+            std::max(height, AddController(port, static_cast<unsigned int>(column.vertices.size()),
+                                           column.vertices, grid));
 
         if (bFirstPlayer)
         {
@@ -98,9 +94,14 @@ unsigned int CControllerGrid::AddPorts(const ControllerPortVec &ports, Controlle
 
           // Keyboard and mouse are added below the first controller
           if (itKeyboard != ports.end())
-            height = std::max(height, AddController(*itKeyboard, static_cast<unsigned int>(column.vertices.size()), column.vertices, grid));
+            height =
+                std::max(height, AddController(*itKeyboard,
+                                               static_cast<unsigned int>(column.vertices.size()),
+                                               column.vertices, grid));
           if (itMouse != ports.end())
-            height = std::max(height, AddController(*itMouse, static_cast<unsigned int>(column.vertices.size()), column.vertices, grid));
+            height = std::max(
+                height, AddController(*itMouse, static_cast<unsigned int>(column.vertices.size()),
+                                      column.vertices, grid));
         }
       }
 
@@ -114,9 +115,13 @@ unsigned int CControllerGrid::AddPorts(const ControllerPortVec &ports, Controlle
     ControllerColumn column;
 
     if (itKeyboard != ports.end())
-      height = std::max(height, AddController(*itKeyboard, static_cast<unsigned int>(column.vertices.size()), column.vertices, grid));
+      height = std::max(height, AddController(*itKeyboard,
+                                              static_cast<unsigned int>(column.vertices.size()),
+                                              column.vertices, grid));
     if (itMouse != ports.end())
-      height = std::max(height, AddController(*itMouse, static_cast<unsigned int>(column.vertices.size()), column.vertices, grid));
+      height = std::max(height,
+                        AddController(*itMouse, static_cast<unsigned int>(column.vertices.size()),
+                                      column.vertices, grid));
 
     if (!column.vertices.empty())
       grid.emplace_back(std::move(column));
@@ -125,14 +130,16 @@ unsigned int CControllerGrid::AddPorts(const ControllerPortVec &ports, Controlle
   return height;
 }
 
-unsigned int CControllerGrid::AddController(const CControllerPortNode &port, unsigned int height,
-                                            std::vector<ControllerVertex> &column, ControllerGrid &grid)
+unsigned int CControllerGrid::AddController(const CControllerPortNode& port,
+                                            unsigned int height,
+                                            std::vector<ControllerVertex>& column,
+                                            ControllerGrid& grid)
 {
   // Add spacers
   while (column.size() < height)
     AddInvisible(column);
 
-  const CControllerNode &activeController = port.ActiveController();
+  const CControllerNode& activeController = port.ActiveController();
 
   // Add vertex
   ControllerVertex vertex;
@@ -141,49 +148,51 @@ unsigned int CControllerGrid::AddController(const CControllerPortNode &port, uns
   vertex.portType = port.PortType();
   vertex.controller = activeController.Controller();
   vertex.address = activeController.Address();
-  for (const CControllerNode &node : port.CompatibleControllers())
+  for (const CControllerNode& node : port.CompatibleControllers())
     vertex.compatible.emplace_back(node.Controller());
   column.emplace_back(std::move(vertex));
 
   height++;
 
   // Process ports
-  const ControllerPortVec &ports = activeController.Hub().Ports();
+  const ControllerPortVec& ports = activeController.Hub().Ports();
   if (!ports.empty())
   {
     switch (GetDirection(activeController))
     {
-    case GRID_DIRECTION::RIGHT:
-    {
-      height = std::max(height, AddHub(ports, height - 1, false, grid));
-      break;
-    }
-    case GRID_DIRECTION::DOWN:
-    {
-      const unsigned int row = height;
+      case GRID_DIRECTION::RIGHT:
+      {
+        height = std::max(height, AddHub(ports, height - 1, false, grid));
+        break;
+      }
+      case GRID_DIRECTION::DOWN:
+      {
+        const unsigned int row = height;
 
-      // Add the first controller to the column
-      const CControllerPortNode &firstController = ports.at(0);
-      height = std::max(height, AddController(firstController, row, column, grid));
+        // Add the first controller to the column
+        const CControllerPortNode& firstController = ports.at(0);
+        height = std::max(height, AddController(firstController, row, column, grid));
 
-      // Add the remaining controllers on the same row
-      height = std::max(height, AddHub(ports, row, true, grid));
+        // Add the remaining controllers on the same row
+        height = std::max(height, AddHub(ports, row, true, grid));
 
-      break;
-    }
+        break;
+      }
     }
   }
 
   return height;
 }
 
-unsigned int CControllerGrid::AddHub(const ControllerPortVec &ports, unsigned int height, bool bSkipFirst,
-                                     ControllerGrid &grid)
+unsigned int CControllerGrid::AddHub(const ControllerPortVec& ports,
+                                     unsigned int height,
+                                     bool bSkipFirst,
+                                     ControllerGrid& grid)
 {
   const unsigned int row = height;
 
   unsigned int port = 0;
-  for (const auto &controllerPort : ports)
+  for (const auto& controllerPort : ports)
   {
     // If controller has no player, it has already added the hub's first controller
     if (bSkipFirst && port == 0)
@@ -191,7 +200,7 @@ unsigned int CControllerGrid::AddHub(const ControllerPortVec &ports, unsigned in
 
     // Add a column for this controller
     grid.emplace_back();
-    ControllerColumn &column = grid.back();
+    ControllerColumn& column = grid.back();
 
     height = std::max(height, AddController(controllerPort, row, column.vertices, grid));
 
@@ -201,23 +210,23 @@ unsigned int CControllerGrid::AddHub(const ControllerPortVec &ports, unsigned in
   return height;
 }
 
-void CControllerGrid::AddInvisible(std::vector<ControllerVertex> &column)
+void CControllerGrid::AddInvisible(std::vector<ControllerVertex>& column)
 {
   ControllerVertex vertex;
   vertex.bVisible = false;
   column.emplace_back(std::move(vertex));
 }
 
-void CControllerGrid::SetHeight(unsigned int height, ControllerGrid &grid)
+void CControllerGrid::SetHeight(unsigned int height, ControllerGrid& grid)
 {
-  for (auto &column : grid)
+  for (auto& column : grid)
   {
     while (static_cast<unsigned int>(column.vertices.size()) < height)
       AddInvisible(column.vertices);
   }
 }
 
-CControllerGrid::GRID_DIRECTION CControllerGrid::GetDirection(const CControllerNode &node)
+CControllerGrid::GRID_DIRECTION CControllerGrid::GetDirection(const CControllerNode& node)
 {
   // Hub controllers are added horizontally, one per row.
   //
diff --git a/xbmc/games/controllers/types/ControllerGrid.h b/xbmc/games/controllers/types/ControllerGrid.h
index 71c189252bbc..bc31e2c2869c 100644
--- a/xbmc/games/controllers/types/ControllerGrid.h
+++ b/xbmc/games/controllers/types/ControllerGrid.h
@@ -18,146 +18,150 @@ namespace KODI
 {
 namespace GAME
 {
+/*!
+ * \brief Vertex in the grid of controllers
+ */
+struct ControllerVertex
+{
+  bool bVisible = true;
+  bool bConnected = false;
+  ControllerPtr controller; // Mandatory if connected
+  PORT_TYPE portType = PORT_TYPE::UNKNOWN; // Optional
+  std::string address; // Optional
+  ControllerVector compatible; // Compatible controllers
+};
+
+/*!
+ * \brief Column of controllers in the grid
+ */
+struct ControllerColumn
+{
+  std::vector<ControllerVertex> vertices;
+};
+
+/*!
+ * \brief Collection of controllers in a grid layout
+ */
+using ControllerGrid = std::vector<ControllerColumn>;
+
+/*!
+ * \brief Class to encapsulate grid operations
+ */
+class CControllerGrid
+{
+public:
+  CControllerGrid() = default;
+  CControllerGrid(const CControllerGrid& other) = default;
+  ~CControllerGrid();
+
   /*!
-   * \brief Vertex in the grid of controllers
+   * \brief Create a grid from a controller tree
    */
-  struct ControllerVertex
-  {
-    bool bVisible = true;
-    bool bConnected = false;
-    ControllerPtr controller; // Mandatory if connected
-    PORT_TYPE portType = PORT_TYPE::UNKNOWN; // Optional
-    std::string address; // Optional
-    ControllerVector compatible; // Compatible controllers
-  };
+  void SetControllerTree(const CControllerTree& controllerTree);
 
   /*!
-   * \brief Column of controllers in the grid
+   * \brief Get the width of the controller grid
    */
-  struct ControllerColumn
-  {
-    std::vector<ControllerVertex> vertices;
-  };
+  unsigned int Width() const { return static_cast<unsigned int>(m_grid.size()); }
+
+  /*!
+   * \brief Get the height (deepest controller) of the controller grid
+   *
+   * The height is cached when the controller grid is created to avoid
+   * iterating the grid
+   */
+  unsigned int Height() const { return m_height; }
+
+  /*!
+   * \brief Access the controller grid
+   */
+  const ControllerGrid& Grid() const { return m_grid; }
 
   /*!
-   * \brief Collection of controllers in a grid layout
+   * \brief Get the controllers in use by the specified player
+   *
+   * \param playerIndex The column in the grid to get controllers from
    */
-  using ControllerGrid = std::vector<ControllerColumn>;
+  ControllerVector GetControllers(unsigned int playerIndex) const;
 
+private:
   /*!
-   * \brief Class to encapsulate grid operations
+   * \brief Directions of vertex traversal
    */
-  class CControllerGrid
+  enum class GRID_DIRECTION
   {
-  public:
-    CControllerGrid() = default;
-    CControllerGrid(const CControllerGrid& other) = default;
-    ~CControllerGrid();
-
-    /*!
-     * \brief Create a grid from a controller tree
-     */
-    void SetControllerTree(const CControllerTree &controllerTree);
-
-    /*!
-     * \brief Get the width of the controller grid
-     */
-    unsigned int Width() const { return static_cast<unsigned int>(m_grid.size()); }
-
-    /*!
-     * \brief Get the height (deepest controller) of the controller grid
-     *
-     * The height is cached when the controller grid is created to avoid
-     * iterating the grid
-     */
-    unsigned int Height() const { return m_height; }
-
-    /*!
-     * \brief Access the controller grid
-     */
-    const ControllerGrid &Grid() const { return m_grid; }
-
-    /*!
-     * \brief Get the controllers in use by the specified player
-     *
-     * \param playerIndex The column in the grid to get controllers from
-     */
-    ControllerVector GetControllers(unsigned int playerIndex) const;
-
-  private:
-    /*!
-     * \brief Directions of vertex traversal
-     */
-    enum class GRID_DIRECTION
-    {
-      RIGHT,
-      DOWN,
-    };
-
-    /*!
-     * \brief Add ports to the grid
-     *
-     * \param ports The ports on a console or controller
-     * \param[out] grid The controller grid being created
-     *
-     * \return The height of the grid determined by the maximum column height
-     */
-    static unsigned int AddPorts(const ControllerPortVec &ports, ControllerGrid &grid);
-
-    /*!
-     * \brief Draw a controller to the column at the specified height
-     *
-     * \param port The controller's port node
-     * \param height The hight to draw the controller at
-     * \param column[in/out] The column to draw to
-     * \param grid[in/out] The grid to add additional columns to
-     *
-     * \return The height of the grid
-     */
-    static unsigned int AddController(const CControllerPortNode &port, unsigned int height,
-                                      std::vector<ControllerVertex> &column, ControllerGrid &grid);
-
-    /*!
-     * \brief Draw a series of controllers to the grid at the specified height
-     *
-     * \param ports The ports of the controllers to draw
-     * \param height The height to start drawing the controllers at
-     * \param bSkipFirst True if the first controller has already been drawn to
-     *                   a column, false to start drawing at the first controller
-     * \param grid[in/out] The grid to add columns to
-     *
-     * \return The height of the grid
-     */
-    static unsigned int AddHub(const ControllerPortVec &ports, unsigned int height, bool bSkipFirst,
-                               ControllerGrid &grid);
-
-    /*!
-     * \brief Draw an invisible vertex to the column
-     *
-     * \param[in/out] column The column in a controller grid
-     */
-    static void AddInvisible(std::vector<ControllerVertex> &column);
-
-    /*!
-     * \brief Fill all columns with invisible vertices until the specified height
-     *
-     * \param height The height to make all columns
-     * \param[in/out] grid The grid to update
-     */
-    static void SetHeight(unsigned int height, ControllerGrid &grid);
-
-    /*!
-     * \brief Get the direction of traversal for the next vertex
-     *
-     * \param node The node in the controller tree being visited
-     *
-     * \return The direction of the next vertex, or GRID_DIRECTION::UNKNOWN if
-     *         unknown
-     */
-    static GRID_DIRECTION GetDirection(const CControllerNode &node);
-
-    ControllerGrid m_grid;
-    unsigned int m_height = 0;
+    RIGHT,
+    DOWN,
   };
-}
-}
+
+  /*!
+   * \brief Add ports to the grid
+   *
+   * \param ports The ports on a console or controller
+   * \param[out] grid The controller grid being created
+   *
+   * \return The height of the grid determined by the maximum column height
+   */
+  static unsigned int AddPorts(const ControllerPortVec& ports, ControllerGrid& grid);
+
+  /*!
+   * \brief Draw a controller to the column at the specified height
+   *
+   * \param port The controller's port node
+   * \param height The hight to draw the controller at
+   * \param column[in/out] The column to draw to
+   * \param grid[in/out] The grid to add additional columns to
+   *
+   * \return The height of the grid
+   */
+  static unsigned int AddController(const CControllerPortNode& port,
+                                    unsigned int height,
+                                    std::vector<ControllerVertex>& column,
+                                    ControllerGrid& grid);
+
+  /*!
+   * \brief Draw a series of controllers to the grid at the specified height
+   *
+   * \param ports The ports of the controllers to draw
+   * \param height The height to start drawing the controllers at
+   * \param bSkipFirst True if the first controller has already been drawn to
+   *                   a column, false to start drawing at the first controller
+   * \param grid[in/out] The grid to add columns to
+   *
+   * \return The height of the grid
+   */
+  static unsigned int AddHub(const ControllerPortVec& ports,
+                             unsigned int height,
+                             bool bSkipFirst,
+                             ControllerGrid& grid);
+
+  /*!
+   * \brief Draw an invisible vertex to the column
+   *
+   * \param[in/out] column The column in a controller grid
+   */
+  static void AddInvisible(std::vector<ControllerVertex>& column);
+
+  /*!
+   * \brief Fill all columns with invisible vertices until the specified height
+   *
+   * \param height The height to make all columns
+   * \param[in/out] grid The grid to update
+   */
+  static void SetHeight(unsigned int height, ControllerGrid& grid);
+
+  /*!
+   * \brief Get the direction of traversal for the next vertex
+   *
+   * \param node The node in the controller tree being visited
+   *
+   * \return The direction of the next vertex, or GRID_DIRECTION::UNKNOWN if
+   *         unknown
+   */
+  static GRID_DIRECTION GetDirection(const CControllerNode& node);
+
+  ControllerGrid m_grid;
+  unsigned int m_height = 0;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/types/ControllerTree.cpp b/xbmc/games/controllers/types/ControllerTree.cpp
index ec4bc2bfe606..b8345e7f0355 100644
--- a/xbmc/games/controllers/types/ControllerTree.cpp
+++ b/xbmc/games/controllers/types/ControllerTree.cpp
@@ -19,14 +19,13 @@ using namespace GAME;
 
 // --- CControllerNode ---------------------------------------------------------
 
-CControllerNode::CControllerNode() :
-  m_hub(new CControllerHub)
+CControllerNode::CControllerNode() : m_hub(new CControllerHub)
 {
 }
 
 CControllerNode::~CControllerNode() = default;
 
-CControllerNode &CControllerNode::operator=(const CControllerNode &rhs)
+CControllerNode& CControllerNode::operator=(const CControllerNode& rhs)
 {
   if (this != &rhs)
   {
@@ -50,15 +49,14 @@ void CControllerNode::SetController(ControllerPtr controller)
   m_controller = std::move(controller);
 }
 
-void CControllerNode::GetControllers(ControllerVector &controllers) const
+void CControllerNode::GetControllers(ControllerVector& controllers) const
 {
-  const ControllerPtr &myController = m_controller;
+  const ControllerPtr& myController = m_controller;
 
   auto it = std::find_if(controllers.begin(), controllers.end(),
-    [&myController](const ControllerPtr &controller)
-    {
-      return myController->ID() == controller->ID();
-    });
+                         [&myController](const ControllerPtr& controller) {
+                           return myController->ID() == controller->ID();
+                         });
 
   if (it == controllers.end())
     controllers.emplace_back(m_controller);
@@ -76,11 +74,11 @@ void CControllerNode::SetHub(CControllerHub hub)
   m_hub.reset(new CControllerHub(std::move(hub)));
 }
 
-bool CControllerNode::IsControllerAccepted(const std::string &controllerId) const
+bool CControllerNode::IsControllerAccepted(const std::string& controllerId) const
 {
   bool bAccepted = false;
 
-  for (const auto &port : m_hub->Ports())
+  for (const auto& port : m_hub->Ports())
   {
     if (port.IsControllerAccepted(controllerId))
     {
@@ -92,12 +90,12 @@ bool CControllerNode::IsControllerAccepted(const std::string &controllerId) cons
   return bAccepted;
 }
 
-bool CControllerNode::IsControllerAccepted(const std::string &portAddress,
-                                           const std::string &controllerId) const
+bool CControllerNode::IsControllerAccepted(const std::string& portAddress,
+                                           const std::string& controllerId) const
 {
   bool bAccepted = false;
 
-  for (const auto &port : m_hub->Ports())
+  for (const auto& port : m_hub->Ports())
   {
     if (port.IsControllerAccepted(portAddress, controllerId))
     {
@@ -118,7 +116,7 @@ bool CControllerNode::ProvidesInput() const
 
 CControllerPortNode::~CControllerPortNode() = default;
 
-CControllerPortNode &CControllerPortNode::operator=(const CControllerPortNode &rhs)
+CControllerPortNode& CControllerPortNode::operator=(const CControllerPortNode& rhs)
 {
   if (this != &rhs)
   {
@@ -133,7 +131,7 @@ CControllerPortNode &CControllerPortNode::operator=(const CControllerPortNode &r
   return *this;
 }
 
-const CControllerNode &CControllerPortNode::ActiveController() const
+const CControllerNode& CControllerPortNode::ActiveController() const
 {
   if (m_bConnected && m_active < m_controllers.size())
     return m_controllers[m_active];
@@ -142,7 +140,7 @@ const CControllerNode &CControllerPortNode::ActiveController() const
   return invalid;
 }
 
-CControllerNode &CControllerPortNode::ActiveController()
+CControllerNode& CControllerPortNode::ActiveController()
 {
   if (m_bConnected && m_active < m_controllers.size())
     return m_controllers[m_active];
@@ -167,7 +165,7 @@ void CControllerPortNode::SetCompatibleControllers(ControllerNodeVec controllers
   m_controllers = std::move(controllers);
 }
 
-bool CControllerPortNode::IsControllerAccepted(const std::string &controllerId) const
+bool CControllerPortNode::IsControllerAccepted(const std::string& controllerId) const
 {
   // Base case
   CControllerPort port;
@@ -176,7 +174,7 @@ bool CControllerPortNode::IsControllerAccepted(const std::string &controllerId)
     return true;
 
   // Visit nodes
-  for (const auto &node : m_controllers)
+  for (const auto& node : m_controllers)
   {
     if (node.IsControllerAccepted(controllerId))
       return true;
@@ -185,8 +183,8 @@ bool CControllerPortNode::IsControllerAccepted(const std::string &controllerId)
   return false;
 }
 
-bool CControllerPortNode::IsControllerAccepted(const std::string &portAddress,
-                                               const std::string &controllerId) const
+bool CControllerPortNode::IsControllerAccepted(const std::string& portAddress,
+                                               const std::string& controllerId) const
 {
   bool bAccepted = false;
 
@@ -201,7 +199,7 @@ bool CControllerPortNode::IsControllerAccepted(const std::string &portAddress,
   else
   {
     // Visit nodes
-    for (const auto &node : m_controllers)
+    for (const auto& node : m_controllers)
     {
       if (node.IsControllerAccepted(portAddress, controllerId))
       {
@@ -214,10 +212,10 @@ bool CControllerPortNode::IsControllerAccepted(const std::string &portAddress,
   return bAccepted;
 }
 
-void CControllerPortNode::GetControllerPort(CControllerPort &port) const
+void CControllerPortNode::GetControllerPort(CControllerPort& port) const
 {
   std::vector<std::string> accepts;
-  for (const CControllerNode &node : m_controllers)
+  for (const CControllerNode& node : m_controllers)
     accepts.emplace_back(node.Controller()->ID());
 
   port = CControllerPort(m_portId, std::move(accepts));
@@ -227,7 +225,7 @@ void CControllerPortNode::GetControllerPort(CControllerPort &port) const
 
 CControllerHub::~CControllerHub() = default;
 
-CControllerHub &CControllerHub::operator=(const CControllerHub &rhs)
+CControllerHub& CControllerHub::operator=(const CControllerHub& rhs)
 {
   if (this != &rhs)
   {
@@ -247,11 +245,11 @@ void CControllerHub::SetPorts(ControllerPortVec ports)
   m_ports = std::move(ports);
 }
 
-bool CControllerHub::IsControllerAccepted(const std::string &controllerId) const
+bool CControllerHub::IsControllerAccepted(const std::string& controllerId) const
 {
   bool bAccepted = false;
 
-  for (const CControllerPortNode &port : m_ports)
+  for (const CControllerPortNode& port : m_ports)
   {
     if (port.IsControllerAccepted(controllerId))
     {
@@ -263,12 +261,12 @@ bool CControllerHub::IsControllerAccepted(const std::string &controllerId) const
   return bAccepted;
 }
 
-bool CControllerHub::IsControllerAccepted(const std::string &portAddress,
-                                          const std::string &controllerId) const
+bool CControllerHub::IsControllerAccepted(const std::string& portAddress,
+                                          const std::string& controllerId) const
 {
   bool bAccepted = false;
 
-  for (const CControllerPortNode &port : m_ports)
+  for (const CControllerPortNode& port : m_ports)
   {
     if (port.IsControllerAccepted(portAddress, controllerId))
     {
@@ -287,30 +285,31 @@ ControllerVector CControllerHub::GetControllers() const
   return controllers;
 }
 
-void CControllerHub::GetControllers(ControllerVector &controllers) const
+void CControllerHub::GetControllers(ControllerVector& controllers) const
 {
-  for (const CControllerPortNode &port : m_ports)
+  for (const CControllerPortNode& port : m_ports)
   {
-    for (const CControllerNode &node : port.CompatibleControllers())
+    for (const CControllerNode& node : port.CompatibleControllers())
       node.GetControllers(controllers);
   }
 }
 
-const CControllerPortNode &CControllerHub::GetPort(const std::string &address) const
+const CControllerPortNode& CControllerHub::GetPort(const std::string& address) const
 {
   return GetPort(m_ports, address);
 }
 
-const CControllerPortNode &CControllerHub::GetPort(const ControllerPortVec &ports, const std::string &address)
+const CControllerPortNode& CControllerHub::GetPort(const ControllerPortVec& ports,
+                                                   const std::string& address)
 {
-  for (const CControllerPortNode &port : ports)
+  for (const CControllerPortNode& port : ports)
   {
     if (port.Address() == address)
       return port;
 
-    for (const CControllerNode &controller : port.CompatibleControllers())
+    for (const CControllerNode& controller : port.CompatibleControllers())
     {
-      for (const CControllerPortNode &controllerPort : controller.Hub().Ports())
+      for (const CControllerPortNode& controllerPort : controller.Hub().Ports())
       {
         if (port.Address() == address)
           return controllerPort;
diff --git a/xbmc/games/controllers/types/ControllerTree.h b/xbmc/games/controllers/types/ControllerTree.h
index a9e043a4a82c..0bc28c3ea443 100644
--- a/xbmc/games/controllers/types/ControllerTree.h
+++ b/xbmc/games/controllers/types/ControllerTree.h
@@ -19,225 +19,223 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerHub;
-  class CControllerPort;
+class CControllerHub;
+class CControllerPort;
+
+/*!
+ * \brief Node in the controller tree
+ *
+ * The node identifies the controller profile, and optionally the available
+ * controller ports.
+ */
+class CControllerNode
+{
+public:
+  CControllerNode();
+  CControllerNode(const CControllerNode& other) { *this = other; }
+  CControllerNode(CControllerNode&& other) = default;
+  CControllerNode& operator=(const CControllerNode& rhs);
+  ~CControllerNode();
+
+  void Clear();
 
   /*!
-   * \brief Node in the controller tree
+   * \brief Controller profile of this code
    *
-   * The node identifies the controller profile, and optionally the available
-   * controller ports.
+   * \return Controller profile, or empty if this node is invalid
+   *
+   * \sa IsValid()
    */
-  class CControllerNode
-  {
-  public:
-    CControllerNode();
-    CControllerNode(const CControllerNode &other) { *this = other; }
-    CControllerNode(CControllerNode &&other) = default;
-    CControllerNode &operator=(const CControllerNode &rhs);
-    ~CControllerNode();
-
-    void Clear();
-
-    /*!
-     * \brief Controller profile of this code
-     *
-     * \return Controller profile, or empty if this node is invalid
-     *
-     * \sa IsValid()
-     */
-    const ControllerPtr &Controller() const { return m_controller; }
-    void SetController(ControllerPtr controller);
-
-    void GetControllers(ControllerVector &controllers) const;
-
-    /*!
-     * \brief Address given to the node by the implementation
-     */
-    const std::string &Address() const { return m_address; }
-    void SetAddress(std::string address);
-
-    /*!
-     * \brief Collection of ports on this controller
-     *
-     * \return A hub with controller ports, or an empty hub if this controller
-     *         has no available ports
-     */
-    const CControllerHub &Hub() const { return *m_hub; }
-    CControllerHub &Hub() { return *m_hub; }
-    void SetHub(CControllerHub hub);
-
-    /*!
-     * \brief Check if this node has a valid controller profile
-     */
-    bool IsValid() const { return m_controller.get() != nullptr; }
-
-    /*!
-     * \brief Check to see if a controller is compatible with a controller port
-     *
-     * \param controllerId The ID of the controller
-     *
-     * \return True if the controller is compatible with a port, false otherwise
-     */
-    bool IsControllerAccepted(const std::string &controllerId) const;
-
-    /*!
-     * \brief Check to see if a controller is compatible with a controller port
-     *
-     * \param portAddress The port address
-     * \param controllerId The ID of the controller
-     *
-     * \return True if the controller is compatible with a port, false otherwise
-     */
-    bool IsControllerAccepted(const std::string &portAddress,
-                              const std::string &controllerId) const;
-
-    /*!
-     * \brief Check if this node provides input
-     */
-    bool ProvidesInput() const;
-
-  private:
-    ControllerPtr m_controller;
-    std::string m_address;
-    std::unique_ptr<CControllerHub> m_hub;
-  };
-
-  using ControllerNodeVec = std::vector<CControllerNode>;
+  const ControllerPtr& Controller() const { return m_controller; }
+  void SetController(ControllerPtr controller);
+
+  void GetControllers(ControllerVector& controllers) const;
 
   /*!
-   * \brief Collection of nodes that can be connected to this port
+   * \brief Address given to the node by the implementation
    */
-  class CControllerPortNode
-  {
-  public:
-    CControllerPortNode() = default;
-    CControllerPortNode(const CControllerPortNode &other) { *this = other; }
-    CControllerPortNode(CControllerPortNode &&other) = default;
-    CControllerPortNode &operator=(const CControllerPortNode &rhs);
-    ~CControllerPortNode();
-
-    /*!
-     * \brief Connection state of the port
-     *
-     * \return True if a controller is connected, false otherwise
-     */
-    bool Connected() const { return m_bConnected; }
-    void SetConnected(bool bConnected) { m_bConnected = bConnected; }
-
-    /*!
-     * \brief The controller that is active on this port
-     *
-     * \return The active controller, or invalid if port is disconnected
-     */
-    const CControllerNode &ActiveController() const;
-    CControllerNode &ActiveController();
-    void SetActiveController(unsigned int controllerIndex) { m_active = controllerIndex; }
-
-    /*!
-     * \brief The port type
-     *
-     * \return The port type, if known
-     */
-    PORT_TYPE PortType() const { return m_portType; }
-    void SetPortType(PORT_TYPE type) { m_portType = type; }
-
-    /*!
-     * \brief The hardware or controller port ID
-     *
-     * \return The port ID of the hardware port or controller port, or empty if
-     *         the port is only identified by its type
-     */
-    const std::string &PortID() const { return m_portId; }
-    void SetPortID(std::string portId);
-
-    /*!
-     * \brief Address given to the node by the implementation
-     */
-    const std::string &Address() const { return m_address; }
-    void SetAddress(std::string address);
-
-    /*!
-     * \brief Return the controller profiles that are compatible with this port
-     *
-     * \return The controller profiles, or empty if this port doesn't support
-     *         any controller profiles
-     */
-    const ControllerNodeVec &CompatibleControllers() const { return m_controllers; }
-    void SetCompatibleControllers(ControllerNodeVec controllers);
-
-    /*!
-     * \brief Check to see if a controller is compatible with this tree
-     *
-     * \param controllerId The ID of the controller
-     *
-     * \return True if the controller is compatible with the tree, false otherwise
-     */
-    bool IsControllerAccepted(const std::string &controllerId) const;
-
-    /*!
-     * \brief Check to see if a controller is compatible with this tree
-     *
-     * \param portAddress The port address
-     * \param controllerId The ID of the controller
-     *
-     * \return True if the controller is compatible with the tree, false otherwise
-     */
-    bool IsControllerAccepted(const std::string &portAddress,
-                              const std::string &controllerId) const;
-
-  private:
-    void GetControllerPort(CControllerPort &port) const;
-
-    bool m_bConnected = false;
-    unsigned int m_active = 0;
-    PORT_TYPE m_portType = PORT_TYPE::UNKNOWN;
-    std::string m_portId;
-    std::string m_address;
-    ControllerNodeVec m_controllers;
-  };
+  const std::string& Address() const { return m_address; }
+  void SetAddress(std::string address);
 
   /*!
-   * \brief Collection of port nodes
+   * \brief Collection of ports on this controller
+   *
+   * \return A hub with controller ports, or an empty hub if this controller
+   *         has no available ports
    */
-  using ControllerPortVec = std::vector<CControllerPortNode>;
+  const CControllerHub& Hub() const { return *m_hub; }
+  CControllerHub& Hub() { return *m_hub; }
+  void SetHub(CControllerHub hub);
 
   /*!
-   * \brief A branch in the controller tree
+   * \brief Check if this node has a valid controller profile
    */
-  class CControllerHub
-  {
-  public:
-    CControllerHub() = default;
-    CControllerHub(const CControllerHub &other) { *this = other; }
-    CControllerHub(CControllerHub &&other) = default;
-    CControllerHub &operator=(const CControllerHub &rhs);
-    ~CControllerHub();
+  bool IsValid() const { return m_controller.get() != nullptr; }
 
-    void Clear();
+  /*!
+   * \brief Check to see if a controller is compatible with a controller port
+   *
+   * \param controllerId The ID of the controller
+   *
+   * \return True if the controller is compatible with a port, false otherwise
+   */
+  bool IsControllerAccepted(const std::string& controllerId) const;
 
-    bool HasPorts() const { return !m_ports.empty(); }
-    ControllerPortVec &Ports() { return m_ports; }
-    const ControllerPortVec &Ports() const { return m_ports; }
-    void SetPorts(ControllerPortVec ports);
+  /*!
+   * \brief Check to see if a controller is compatible with a controller port
+   *
+   * \param portAddress The port address
+   * \param controllerId The ID of the controller
+   *
+   * \return True if the controller is compatible with a port, false otherwise
+   */
+  bool IsControllerAccepted(const std::string& portAddress, const std::string& controllerId) const;
 
-    bool IsControllerAccepted(const std::string &controllerId) const;
-    bool IsControllerAccepted(const std::string &portAddress,
-                              const std::string &controllerId) const;
-    ControllerVector GetControllers() const;
-    void GetControllers(ControllerVector &controllers) const;
+  /*!
+   * \brief Check if this node provides input
+   */
+  bool ProvidesInput() const;
+
+private:
+  ControllerPtr m_controller;
+  std::string m_address;
+  std::unique_ptr<CControllerHub> m_hub;
+};
+
+using ControllerNodeVec = std::vector<CControllerNode>;
+
+/*!
+ * \brief Collection of nodes that can be connected to this port
+ */
+class CControllerPortNode
+{
+public:
+  CControllerPortNode() = default;
+  CControllerPortNode(const CControllerPortNode& other) { *this = other; }
+  CControllerPortNode(CControllerPortNode&& other) = default;
+  CControllerPortNode& operator=(const CControllerPortNode& rhs);
+  ~CControllerPortNode();
 
-    const CControllerPortNode &GetPort(const std::string &address) const;
+  /*!
+   * \brief Connection state of the port
+   *
+   * \return True if a controller is connected, false otherwise
+   */
+  bool Connected() const { return m_bConnected; }
+  void SetConnected(bool bConnected) { m_bConnected = bConnected; }
 
-  private:
-    static const CControllerPortNode &GetPort(const ControllerPortVec &ports, const std::string &address);
+  /*!
+   * \brief The controller that is active on this port
+   *
+   * \return The active controller, or invalid if port is disconnected
+   */
+  const CControllerNode& ActiveController() const;
+  CControllerNode& ActiveController();
+  void SetActiveController(unsigned int controllerIndex) { m_active = controllerIndex; }
 
-    ControllerPortVec m_ports;
-  };
+  /*!
+   * \brief The port type
+   *
+   * \return The port type, if known
+   */
+  PORT_TYPE PortType() const { return m_portType; }
+  void SetPortType(PORT_TYPE type) { m_portType = type; }
 
   /*!
-   * \brief Collection of ports on a console
+   * \brief The hardware or controller port ID
+   *
+   * \return The port ID of the hardware port or controller port, or empty if
+   *         the port is only identified by its type
    */
-  using CControllerTree = CControllerHub;
-}
-}
+  const std::string& PortID() const { return m_portId; }
+  void SetPortID(std::string portId);
+
+  /*!
+   * \brief Address given to the node by the implementation
+   */
+  const std::string& Address() const { return m_address; }
+  void SetAddress(std::string address);
+
+  /*!
+   * \brief Return the controller profiles that are compatible with this port
+   *
+   * \return The controller profiles, or empty if this port doesn't support
+   *         any controller profiles
+   */
+  const ControllerNodeVec& CompatibleControllers() const { return m_controllers; }
+  void SetCompatibleControllers(ControllerNodeVec controllers);
+
+  /*!
+   * \brief Check to see if a controller is compatible with this tree
+   *
+   * \param controllerId The ID of the controller
+   *
+   * \return True if the controller is compatible with the tree, false otherwise
+   */
+  bool IsControllerAccepted(const std::string& controllerId) const;
+
+  /*!
+   * \brief Check to see if a controller is compatible with this tree
+   *
+   * \param portAddress The port address
+   * \param controllerId The ID of the controller
+   *
+   * \return True if the controller is compatible with the tree, false otherwise
+   */
+  bool IsControllerAccepted(const std::string& portAddress, const std::string& controllerId) const;
+
+private:
+  void GetControllerPort(CControllerPort& port) const;
+
+  bool m_bConnected = false;
+  unsigned int m_active = 0;
+  PORT_TYPE m_portType = PORT_TYPE::UNKNOWN;
+  std::string m_portId;
+  std::string m_address;
+  ControllerNodeVec m_controllers;
+};
+
+/*!
+ * \brief Collection of port nodes
+ */
+using ControllerPortVec = std::vector<CControllerPortNode>;
+
+/*!
+ * \brief A branch in the controller tree
+ */
+class CControllerHub
+{
+public:
+  CControllerHub() = default;
+  CControllerHub(const CControllerHub& other) { *this = other; }
+  CControllerHub(CControllerHub&& other) = default;
+  CControllerHub& operator=(const CControllerHub& rhs);
+  ~CControllerHub();
+
+  void Clear();
+
+  bool HasPorts() const { return !m_ports.empty(); }
+  ControllerPortVec& Ports() { return m_ports; }
+  const ControllerPortVec& Ports() const { return m_ports; }
+  void SetPorts(ControllerPortVec ports);
+
+  bool IsControllerAccepted(const std::string& controllerId) const;
+  bool IsControllerAccepted(const std::string& portAddress, const std::string& controllerId) const;
+  ControllerVector GetControllers() const;
+  void GetControllers(ControllerVector& controllers) const;
+
+  const CControllerPortNode& GetPort(const std::string& address) const;
+
+private:
+  static const CControllerPortNode& GetPort(const ControllerPortVec& ports,
+                                            const std::string& address);
+
+  ControllerPortVec m_ports;
+};
+
+/*!
+ * \brief Collection of ports on a console
+ */
+using CControllerTree = CControllerHub;
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/windows/ControllerInstaller.cpp b/xbmc/games/controllers/windows/ControllerInstaller.cpp
index a301b41bf7c1..b1b4e3fa5fc2 100644
--- a/xbmc/games/controllers/windows/ControllerInstaller.cpp
+++ b/xbmc/games/controllers/windows/ControllerInstaller.cpp
@@ -26,18 +26,17 @@
 using namespace KODI;
 using namespace GAME;
 
-CControllerInstaller::CControllerInstaller() :
-  CThread("ControllerInstaller")
+CControllerInstaller::CControllerInstaller() : CThread("ControllerInstaller")
 {
 }
 
 void CControllerInstaller::Process()
 {
-  CGUIComponent *gui = CServiceBroker::GetGUI();
+  CGUIComponent* gui = CServiceBroker::GetGUI();
   if (gui == nullptr)
     return;
 
-  CGUIWindowManager &windowManager = gui->GetWindowManager();
+  CGUIWindowManager& windowManager = gui->GetWindowManager();
 
   auto pSelectDialog = windowManager.GetWindow<CGUIDialogSelect>(WINDOW_DIALOG_SELECT);
   if (pSelectDialog == nullptr)
@@ -48,19 +47,21 @@ void CControllerInstaller::Process()
     return;
 
   ADDON::VECADDONS installableAddons;
-  CServiceBroker::GetAddonMgr().GetInstallableAddons(installableAddons, ADDON::ADDON_GAME_CONTROLLER);
+  CServiceBroker::GetAddonMgr().GetInstallableAddons(installableAddons,
+                                                     ADDON::ADDON_GAME_CONTROLLER);
   if (installableAddons.empty())
   {
     // "Controller profiles"
     // "All available controller profiles are installed."
-    MESSAGING::HELPERS::ShowOKDialogText(CVariant{ 35050 }, CVariant{ 35062 });
+    MESSAGING::HELPERS::ShowOKDialogText(CVariant{35050}, CVariant{35062});
     return;
   }
 
-  CLog::Log(LOGDEBUG, "Controller installer: Found %u controller add-ons", installableAddons.size());
+  CLog::Log(LOGDEBUG, "Controller installer: Found %u controller add-ons",
+            installableAddons.size());
 
   CFileItemList items;
-  for (const auto &addon : installableAddons)
+  for (const auto& addon : installableAddons)
   {
     CFileItemPtr item(new CFileItem(addon->Name()));
     item->SetArt("icon", addon->Icon());
@@ -71,7 +72,7 @@ void CControllerInstaller::Process()
   pSelectDialog->SetHeading(39020); // "The following additional add-ons will be installed"
   pSelectDialog->SetUseDetails(true);
   pSelectDialog->EnableButton(true, 186); // "OK""
-  for (const auto &it : items)
+  for (const auto& it : items)
     pSelectDialog->Add(*it);
   pSelectDialog->Open();
 
@@ -81,27 +82,29 @@ void CControllerInstaller::Process()
     return;
   }
 
-  CLog::Log(LOGDEBUG, "Controller installer: Installing %u controller add-ons", installableAddons.size());
+  CLog::Log(LOGDEBUG, "Controller installer: Installing %u controller add-ons",
+            installableAddons.size());
 
-  pProgressDialog->SetHeading(CVariant{ 24086 }); // "Installing add-on..."
-  pProgressDialog->SetLine(0, CVariant{ "" });
-  pProgressDialog->SetLine(1, CVariant{ "" });
-  pProgressDialog->SetLine(2, CVariant{ "" });
+  pProgressDialog->SetHeading(CVariant{24086}); // "Installing add-on..."
+  pProgressDialog->SetLine(0, CVariant{""});
+  pProgressDialog->SetLine(1, CVariant{""});
+  pProgressDialog->SetLine(2, CVariant{""});
 
   pProgressDialog->Open();
 
   unsigned int installedCount = 0;
   while (installedCount < installableAddons.size())
   {
-    const auto &addon = installableAddons[installedCount];
+    const auto& addon = installableAddons[installedCount];
 
     // Set dialog text
     const std::string progressTemplate = g_localizeStrings.Get(24057); // "Installing {0:s}..."
     const std::string progressText = StringUtils::Format(progressTemplate, addon->Name());
-    pProgressDialog->SetLine(0, CVariant{ progressText });
+    pProgressDialog->SetLine(0, CVariant{progressText});
 
     // Set dialog percentage
-    const unsigned int percentage = 100 * (installedCount + 1) / static_cast<unsigned int>(installableAddons.size());
+    const unsigned int percentage =
+        100 * (installedCount + 1) / static_cast<unsigned int>(installableAddons.size());
     pProgressDialog->SetPercentage(percentage);
 
     if (!CAddonInstaller::GetInstance().InstallOrUpdate(addon->ID(), false, false))
diff --git a/xbmc/games/controllers/windows/ControllerInstaller.h b/xbmc/games/controllers/windows/ControllerInstaller.h
index 585a45d93a4b..9863e2754b9f 100644
--- a/xbmc/games/controllers/windows/ControllerInstaller.h
+++ b/xbmc/games/controllers/windows/ControllerInstaller.h
@@ -14,15 +14,15 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerInstaller : public CThread
-  {
-  public:
-    CControllerInstaller();
-    ~CControllerInstaller() override = default;
+class CControllerInstaller : public CThread
+{
+public:
+  CControllerInstaller();
+  ~CControllerInstaller() override = default;
 
-  protected:
-    // implementation of CThread
-    void Process() override;
-  };
-}
-}
+protected:
+  // implementation of CThread
+  void Process() override;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/windows/GUIConfigurationWizard.cpp b/xbmc/games/controllers/windows/GUIConfigurationWizard.cpp
index 9c14812f3946..2fbc765d7295 100644
--- a/xbmc/games/controllers/windows/GUIConfigurationWizard.cpp
+++ b/xbmc/games/controllers/windows/GUIConfigurationWizard.cpp
@@ -26,15 +26,14 @@
 using namespace KODI;
 using namespace GAME;
 
-#define ESC_KEY_CODE  27
-#define SKIPPING_DETECTION_MS  200
+#define ESC_KEY_CODE 27
+#define SKIPPING_DETECTION_MS 200
 
 // Duration to wait for axes to neutralize after mapping is finished
-#define POST_MAPPING_WAIT_TIME_MS  (5 * 1000)
+#define POST_MAPPING_WAIT_TIME_MS (5 * 1000)
 
-CGUIConfigurationWizard::CGUIConfigurationWizard() :
-  CThread("GUIConfigurationWizard"),
-  m_actionMap(new KEYBOARD::CKeymapActionMap)
+CGUIConfigurationWizard::CGUIConfigurationWizard()
+  : CThread("GUIConfigurationWizard"), m_actionMap(new KEYBOARD::CKeymapActionMap)
 {
   InitializeState();
 }
@@ -52,7 +51,8 @@ void CGUIConfigurationWizard::InitializeState(void)
   m_deviceName.clear();
 }
 
-void CGUIConfigurationWizard::Run(const std::string& strControllerId, const std::vector<IFeatureButton*>& buttons)
+void CGUIConfigurationWizard::Run(const std::string& strControllerId,
+                                  const std::vector<IFeatureButton*>& buttons)
 {
   Abort();
 
@@ -98,7 +98,7 @@ bool CGUIConfigurationWizard::Abort(bool bWait /* = true */)
   return bWasRunning;
 }
 
-void CGUIConfigurationWizard::RegisterKey(const CControllerFeature &key)
+void CGUIConfigurationWizard::RegisterKey(const CControllerFeature& key)
 {
   if (key.Keycode() != XBMCK_UNKNOWN)
     m_keyMap[key.Keycode()] = key;
@@ -140,7 +140,8 @@ void CGUIConfigurationWizard::Process(void)
           if (button->Feature().Type() == FEATURE_TYPE::UNKNOWN)
             CLog::Log(LOGDEBUG, "%s: Waiting for input", m_strControllerId.c_str());
           else
-            CLog::Log(LOGDEBUG, "%s: Waiting for input for feature \"%s\"", m_strControllerId.c_str(), button->Feature().Name().c_str());
+            CLog::Log(LOGDEBUG, "%s: Waiting for input for feature \"%s\"",
+                      m_strControllerId.c_str(), button->Feature().Name().c_str());
 
           if (!button->PromptForInput(m_inputEvent))
             Abort(false);
@@ -183,7 +184,8 @@ void CGUIConfigurationWizard::Process(void)
 
     if (bInMotion)
     {
-      CLog::Log(LOGDEBUG, "Configuration wizard: waiting %ums for axes to neutralize", POST_MAPPING_WAIT_TIME_MS);
+      CLog::Log(LOGDEBUG, "Configuration wizard: waiting %ums for axes to neutralize",
+                POST_MAPPING_WAIT_TIME_MS);
       m_motionlessEvent.WaitMSec(POST_MAPPING_WAIT_TIME_MS);
     }
   }
@@ -212,7 +214,7 @@ bool CGUIConfigurationWizard::MapPrimitive(JOYSTICK::IButtonMap* buttonMap,
       std::string feature;
       if (buttonMap->GetFeature(primitive, feature))
       {
-        const auto &actions = keymap->GetActions(CJoystickUtils::MakeKeyName(feature)).actions;
+        const auto& actions = keymap->GetActions(CJoystickUtils::MakeKeyName(feature)).actions;
         if (!actions.empty())
         {
           //! @todo Handle multiple actions mapped to the same key
@@ -258,7 +260,7 @@ bool CGUIConfigurationWizard::MapPrimitive(JOYSTICK::IButtonMap* buttonMap,
           auto it = m_keyMap.find(primitive.Keycode());
           if (it != m_keyMap.end())
           {
-            const CControllerFeature &key = it->second;
+            const CControllerFeature& key = it->second;
             currentButton->SetKey(key);
             m_inputEvent.Set();
           }
@@ -280,8 +282,8 @@ bool CGUIConfigurationWizard::MapPrimitive(JOYSTICK::IButtonMap* buttonMap,
         }
         else
         {
-          CLog::Log(LOGDEBUG, "%s: mapping feature \"%s\" for device %s",
-            m_strControllerId.c_str(), feature.Name().c_str(), buttonMap->DeviceName().c_str());
+          CLog::Log(LOGDEBUG, "%s: mapping feature \"%s\" for device %s", m_strControllerId.c_str(),
+                    feature.Name().c_str(), buttonMap->DeviceName().c_str());
 
           switch (feature.Type())
           {
@@ -357,7 +359,8 @@ void CGUIConfigurationWizard::OnEventFrame(const JOYSTICK::IButtonMap* buttonMap
     OnMotionless(buttonMap);
 }
 
-void CGUIConfigurationWizard::OnLateAxis(const JOYSTICK::IButtonMap* buttonMap, unsigned int axisIndex)
+void CGUIConfigurationWizard::OnLateAxis(const JOYSTICK::IButtonMap* buttonMap,
+                                         unsigned int axisIndex)
 {
   CSingleLock lock(m_stateMutex);
 
@@ -443,7 +446,7 @@ bool CGUIConfigurationWizard::IsMapping() const
   return !m_deviceName.empty();
 }
 
-bool CGUIConfigurationWizard::IsMapping(const std::string &deviceName) const
+bool CGUIConfigurationWizard::IsMapping(const std::string& deviceName) const
 {
   return m_deviceName == deviceName;
 }
diff --git a/xbmc/games/controllers/windows/GUIConfigurationWizard.h b/xbmc/games/controllers/windows/GUIConfigurationWizard.h
index 35822a2c475d..73194f90e2e5 100644
--- a/xbmc/games/controllers/windows/GUIConfigurationWizard.h
+++ b/xbmc/games/controllers/windows/GUIConfigurationWizard.h
@@ -29,88 +29,89 @@ namespace KODI
 {
 namespace KEYBOARD
 {
-  class IActionMap;
+class IActionMap;
 }
 
 namespace GAME
 {
-  class CGUIConfigurationWizard : public IConfigurationWizard,
-                                  public JOYSTICK::IButtonMapper,
-                                  public KEYBOARD::IKeyboardDriverHandler,
-                                  public Observer,
-                                  protected CThread
-  {
-  public:
-    CGUIConfigurationWizard();
-
-    ~CGUIConfigurationWizard() override;
-
-    // implementation of IConfigurationWizard
-    void Run(const std::string& strControllerId, const std::vector<IFeatureButton*>& buttons) override;
-    void OnUnfocus(IFeatureButton* button) override;
-    bool Abort(bool bWait = true) override;
-    void RegisterKey(const CControllerFeature &key) override;
-    void UnregisterKeys() override;
-
-    // implementation of IButtonMapper
-    std::string ControllerID() const override { return m_strControllerId; }
-    bool NeedsCooldown() const override { return true; }
-    bool AcceptsPrimitive(JOYSTICK::PRIMITIVE_TYPE type) const override { return true; }
-    bool MapPrimitive(JOYSTICK::IButtonMap* buttonMap,
-                      IKeymap* keymap,
-                      const JOYSTICK::CDriverPrimitive& primitive) override;
-    void OnEventFrame(const JOYSTICK::IButtonMap* buttonMap, bool bMotion) override;
-    void OnLateAxis(const JOYSTICK::IButtonMap* buttonMap, unsigned int axisIndex) override;
-
-    // implementation of IKeyboardDriverHandler
-    bool OnKeyPress(const CKey& key) override;
-    void OnKeyRelease(const CKey& key) override {}
-
-    // implementation of Observer
-    void Notify(const Observable& obs, const ObservableMessage msg) override;
-
-  protected:
-    // implementation of CThread
-    void Process() override;
-
-  private:
-    void InitializeState(void);
-
-    bool IsMapping() const;
-    bool IsMapping(const std::string &deviceName) const;
-
-    void InstallHooks(void);
-    void RemoveHooks(void);
-
-    void OnMotion(const JOYSTICK::IButtonMap* buttonMap);
-    void OnMotionless(const JOYSTICK::IButtonMap* buttonMap);
-
-    bool OnAction(unsigned int actionId);
-
-    // Run() parameters
-    std::string                          m_strControllerId;
-    std::vector<IFeatureButton*>         m_buttons;
-
-    // State variables and mutex
-    IFeatureButton*                      m_currentButton;
-    INPUT::CARDINAL_DIRECTION            m_cardinalDirection;
-    JOYSTICK::WHEEL_DIRECTION            m_wheelDirection;
-    JOYSTICK::THROTTLE_DIRECTION         m_throttleDirection;
-    std::set<JOYSTICK::CDriverPrimitive> m_history; // History to avoid repeated features
-    bool                                 m_lateAxisDetected; // Set to true if an axis is detected during button mapping
-    std::string                          m_deviceName; // Name of device that we're mapping
-    bool                                 m_bIsKeyboard = false; // True if we're mapping keyboard keys
-    CCriticalSection                     m_stateMutex;
-
-    // Synchronization events
-    CEvent                               m_inputEvent;
-    CEvent                               m_motionlessEvent;
-    CCriticalSection                     m_motionMutex;
-    std::set<const JOYSTICK::IButtonMap*> m_bInMotion;
-
-    // Keyboard handling
-    std::unique_ptr<KEYBOARD::IActionMap> m_actionMap;
-    std::map<XBMCKey, CControllerFeature> m_keyMap; // Keycode -> feature
-  };
-}
-}
+class CGUIConfigurationWizard : public IConfigurationWizard,
+                                public JOYSTICK::IButtonMapper,
+                                public KEYBOARD::IKeyboardDriverHandler,
+                                public Observer,
+                                protected CThread
+{
+public:
+  CGUIConfigurationWizard();
+
+  ~CGUIConfigurationWizard() override;
+
+  // implementation of IConfigurationWizard
+  void Run(const std::string& strControllerId,
+           const std::vector<IFeatureButton*>& buttons) override;
+  void OnUnfocus(IFeatureButton* button) override;
+  bool Abort(bool bWait = true) override;
+  void RegisterKey(const CControllerFeature& key) override;
+  void UnregisterKeys() override;
+
+  // implementation of IButtonMapper
+  std::string ControllerID() const override { return m_strControllerId; }
+  bool NeedsCooldown() const override { return true; }
+  bool AcceptsPrimitive(JOYSTICK::PRIMITIVE_TYPE type) const override { return true; }
+  bool MapPrimitive(JOYSTICK::IButtonMap* buttonMap,
+                    IKeymap* keymap,
+                    const JOYSTICK::CDriverPrimitive& primitive) override;
+  void OnEventFrame(const JOYSTICK::IButtonMap* buttonMap, bool bMotion) override;
+  void OnLateAxis(const JOYSTICK::IButtonMap* buttonMap, unsigned int axisIndex) override;
+
+  // implementation of IKeyboardDriverHandler
+  bool OnKeyPress(const CKey& key) override;
+  void OnKeyRelease(const CKey& key) override {}
+
+  // implementation of Observer
+  void Notify(const Observable& obs, const ObservableMessage msg) override;
+
+protected:
+  // implementation of CThread
+  void Process() override;
+
+private:
+  void InitializeState(void);
+
+  bool IsMapping() const;
+  bool IsMapping(const std::string& deviceName) const;
+
+  void InstallHooks(void);
+  void RemoveHooks(void);
+
+  void OnMotion(const JOYSTICK::IButtonMap* buttonMap);
+  void OnMotionless(const JOYSTICK::IButtonMap* buttonMap);
+
+  bool OnAction(unsigned int actionId);
+
+  // Run() parameters
+  std::string m_strControllerId;
+  std::vector<IFeatureButton*> m_buttons;
+
+  // State variables and mutex
+  IFeatureButton* m_currentButton;
+  INPUT::CARDINAL_DIRECTION m_cardinalDirection;
+  JOYSTICK::WHEEL_DIRECTION m_wheelDirection;
+  JOYSTICK::THROTTLE_DIRECTION m_throttleDirection;
+  std::set<JOYSTICK::CDriverPrimitive> m_history; // History to avoid repeated features
+  bool m_lateAxisDetected; // Set to true if an axis is detected during button mapping
+  std::string m_deviceName; // Name of device that we're mapping
+  bool m_bIsKeyboard = false; // True if we're mapping keyboard keys
+  CCriticalSection m_stateMutex;
+
+  // Synchronization events
+  CEvent m_inputEvent;
+  CEvent m_motionlessEvent;
+  CCriticalSection m_motionMutex;
+  std::set<const JOYSTICK::IButtonMap*> m_bInMotion;
+
+  // Keyboard handling
+  std::unique_ptr<KEYBOARD::IActionMap> m_actionMap;
+  std::map<XBMCKey, CControllerFeature> m_keyMap; // Keycode -> feature
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/windows/GUIControllerDefines.h b/xbmc/games/controllers/windows/GUIControllerDefines.h
index 3805a28b5c41..64d21420d87f 100644
--- a/xbmc/games/controllers/windows/GUIControllerDefines.h
+++ b/xbmc/games/controllers/windows/GUIControllerDefines.h
@@ -9,37 +9,37 @@
 #pragma once
 
 // Duration to wait for input from the user
-#define COUNTDOWN_DURATION_SEC  6
+#define COUNTDOWN_DURATION_SEC 6
 
 // Warn the user that time is running out after this duration
-#define WAIT_TO_WARN_SEC        2
+#define WAIT_TO_WARN_SEC 2
 
 // GUI Control IDs
-#define CONTROL_CONTROLLER_LIST             3
-#define CONTROL_FEATURE_LIST                5
-#define CONTROL_FEATURE_BUTTON_TEMPLATE     7
-#define CONTROL_FEATURE_GROUP_TITLE         8
-#define CONTROL_FEATURE_SEPARATOR           9
-#define CONTROL_CONTROLLER_BUTTON_TEMPLATE  10
-#define CONTROL_GAME_CONTROLLER             31
-#define CONTROL_CONTROLLER_DESCRIPTION      32
+#define CONTROL_CONTROLLER_LIST 3
+#define CONTROL_FEATURE_LIST 5
+#define CONTROL_FEATURE_BUTTON_TEMPLATE 7
+#define CONTROL_FEATURE_GROUP_TITLE 8
+#define CONTROL_FEATURE_SEPARATOR 9
+#define CONTROL_CONTROLLER_BUTTON_TEMPLATE 10
+#define CONTROL_GAME_CONTROLLER 31
+#define CONTROL_CONTROLLER_DESCRIPTION 32
 
 // GUI button IDs
-#define CONTROL_HELP_BUTTON                 17
-#define CONTROL_CLOSE_BUTTON                18
-#define CONTROL_RESET_BUTTON                19
-#define CONTROL_GET_MORE                    20
-#define CONTROL_FIX_SKIPPING                21
-#define CONTROL_GET_ALL                     22
+#define CONTROL_HELP_BUTTON 17
+#define CONTROL_CLOSE_BUTTON 18
+#define CONTROL_RESET_BUTTON 19
+#define CONTROL_GET_MORE 20
+#define CONTROL_FIX_SKIPPING 21
+#define CONTROL_GET_ALL 22
 
-#define MAX_CONTROLLER_COUNT  100 // large enough
-#define MAX_FEATURE_COUNT     200 // large enough
+#define MAX_CONTROLLER_COUNT 100 // large enough
+#define MAX_FEATURE_COUNT 200 // large enough
 
-#define CONTROL_CONTROLLER_BUTTONS_START  100
-#define CONTROL_CONTROLLER_BUTTONS_END    (CONTROL_CONTROLLER_BUTTONS_START + MAX_CONTROLLER_COUNT)
-#define CONTROL_FEATURE_BUTTONS_START     CONTROL_CONTROLLER_BUTTONS_END
-#define CONTROL_FEATURE_BUTTONS_END       (CONTROL_FEATURE_BUTTONS_START + MAX_FEATURE_COUNT)
-#define CONTROL_FEATURE_GROUPS_START      CONTROL_FEATURE_BUTTONS_END
-#define CONTROL_FEATURE_GROUPS_END        (CONTROL_FEATURE_GROUPS_START + MAX_FEATURE_COUNT)
-#define CONTROL_FEATURE_SEPARATORS_START  CONTROL_FEATURE_GROUPS_END
-#define CONTROL_FEATURE_SEPARATORS_END    (CONTROL_FEATURE_SEPARATORS_START + MAX_FEATURE_COUNT)
+#define CONTROL_CONTROLLER_BUTTONS_START 100
+#define CONTROL_CONTROLLER_BUTTONS_END (CONTROL_CONTROLLER_BUTTONS_START + MAX_CONTROLLER_COUNT)
+#define CONTROL_FEATURE_BUTTONS_START CONTROL_CONTROLLER_BUTTONS_END
+#define CONTROL_FEATURE_BUTTONS_END (CONTROL_FEATURE_BUTTONS_START + MAX_FEATURE_COUNT)
+#define CONTROL_FEATURE_GROUPS_START CONTROL_FEATURE_BUTTONS_END
+#define CONTROL_FEATURE_GROUPS_END (CONTROL_FEATURE_GROUPS_START + MAX_FEATURE_COUNT)
+#define CONTROL_FEATURE_SEPARATORS_START CONTROL_FEATURE_GROUPS_END
+#define CONTROL_FEATURE_SEPARATORS_END (CONTROL_FEATURE_SEPARATORS_START + MAX_FEATURE_COUNT)
diff --git a/xbmc/games/controllers/windows/GUIControllerList.cpp b/xbmc/games/controllers/windows/GUIControllerList.cpp
index a4474ef7a2c8..2be89da41559 100644
--- a/xbmc/games/controllers/windows/GUIControllerList.cpp
+++ b/xbmc/games/controllers/windows/GUIControllerList.cpp
@@ -39,21 +39,25 @@ using namespace KODI;
 using namespace ADDON;
 using namespace GAME;
 
-CGUIControllerList::CGUIControllerList(CGUIWindow* window, IFeatureList* featureList, GameClientPtr gameClient) :
-  m_guiWindow(window),
-  m_featureList(featureList),
-  m_controllerList(nullptr),
-  m_controllerButton(nullptr),
-  m_focusedController(-1), // Initially unfocused
-  m_gameClient(std::move(gameClient))
+CGUIControllerList::CGUIControllerList(CGUIWindow* window,
+                                       IFeatureList* featureList,
+                                       GameClientPtr gameClient)
+  : m_guiWindow(window),
+    m_featureList(featureList),
+    m_controllerList(nullptr),
+    m_controllerButton(nullptr),
+    m_focusedController(-1), // Initially unfocused
+    m_gameClient(std::move(gameClient))
 {
   assert(m_featureList != nullptr);
 }
 
 bool CGUIControllerList::Initialize(void)
 {
-  m_controllerList = dynamic_cast<CGUIControlGroupList*>(m_guiWindow->GetControl(CONTROL_CONTROLLER_LIST));
-  m_controllerButton = dynamic_cast<CGUIButtonControl*>(m_guiWindow->GetControl(CONTROL_CONTROLLER_BUTTON_TEMPLATE));
+  m_controllerList =
+      dynamic_cast<CGUIControlGroupList*>(m_guiWindow->GetControl(CONTROL_CONTROLLER_LIST));
+  m_controllerButton =
+      dynamic_cast<CGUIButtonControl*>(m_guiWindow->GetControl(CONTROL_CONTROLLER_BUTTON_TEMPLATE));
 
   if (m_controllerButton)
     m_controllerButton->SetVisible(false);
@@ -61,8 +65,7 @@ bool CGUIControllerList::Initialize(void)
   CServiceBroker::GetAddonMgr().Events().Subscribe(this, &CGUIControllerList::OnEvent);
   Refresh("");
 
-  return m_controllerList != nullptr &&
-         m_controllerButton != nullptr;
+  return m_controllerList != nullptr && m_controllerButton != nullptr;
 }
 
 void CGUIControllerList::Deinitialize(void)
@@ -96,7 +99,8 @@ bool CGUIControllerList::Refresh(const std::string& controllerId)
     unsigned int buttonId = 0;
     for (const auto& controller : m_controllers)
     {
-      CGUIButtonControl* pButton = new CGUIControllerButton(*m_controllerButton, controller->Layout().Label(), buttonId++);
+      CGUIButtonControl* pButton =
+          new CGUIControllerButton(*m_controllerButton, controller->Layout().Label(), buttonId++);
       m_controllerList->AddControl(pButton);
 
       if (!focusController.empty() && controller->ID() == focusController)
@@ -124,7 +128,8 @@ void CGUIControllerList::OnFocus(unsigned int controllerIndex)
     m_featureList->Load(controller);
 
     //! @todo Activate controller for all game controller controls
-    CGUIGameController* pController = dynamic_cast<CGUIGameController*>(m_guiWindow->GetControl(CONTROL_GAME_CONTROLLER));
+    CGUIGameController* pController =
+        dynamic_cast<CGUIGameController*>(m_guiWindow->GetControl(CONTROL_GAME_CONTROLLER));
     if (pController)
       pController->ActivateController(controller);
 
@@ -159,7 +164,7 @@ void CGUIControllerList::ResetController(void)
 
 void CGUIControllerList::OnEvent(const ADDON::AddonEvent& event)
 {
-  if (typeid(event) == typeid(ADDON::AddonEvents::Enabled) ||  // also called on install,
+  if (typeid(event) == typeid(ADDON::AddonEvents::Enabled) || // also called on install,
       typeid(event) == typeid(ADDON::AddonEvents::Disabled) || // not called on uninstall
       typeid(event) == typeid(ADDON::AddonEvents::ReInstalled) ||
       typeid(event) == typeid(ADDON::AddonEvents::UnInstalled))
@@ -185,28 +190,28 @@ bool CGUIControllerList::RefreshControllers(void)
   // Filter by current game add-on
   if (m_gameClient)
   {
-    const CControllerTree &controllers = m_gameClient->Input().GetControllerTree();
+    const CControllerTree& controllers = m_gameClient->Input().GetControllerTree();
 
-    auto ControllerNotAccepted = [&controllers](const ControllerPtr &controller)
-      {
-        return !controllers.IsControllerAccepted(controller->ID());
-      };
+    auto ControllerNotAccepted = [&controllers](const ControllerPtr& controller) {
+      return !controllers.IsControllerAccepted(controller->ID());
+    };
 
     if (!std::all_of(newControllers.begin(), newControllers.end(), ControllerNotAccepted))
-      newControllers.erase(std::remove_if(newControllers.begin(), newControllers.end(), ControllerNotAccepted), newControllers.end());
+      newControllers.erase(
+          std::remove_if(newControllers.begin(), newControllers.end(), ControllerNotAccepted),
+          newControllers.end());
   }
 
   // Check for changes
   std::set<std::string> oldControllerIds;
   std::set<std::string> newControllerIds;
 
-  auto GetControllerID = [](const ControllerPtr& controller)
-    {
-      return controller->ID();
-    };
+  auto GetControllerID = [](const ControllerPtr& controller) { return controller->ID(); };
 
-  std::transform(m_controllers.begin(), m_controllers.end(), std::inserter(oldControllerIds, oldControllerIds.begin()), GetControllerID);
-  std::transform(newControllers.begin(), newControllers.end(), std::inserter(newControllerIds, newControllerIds.begin()), GetControllerID);
+  std::transform(m_controllers.begin(), m_controllers.end(),
+                 std::inserter(oldControllerIds, oldControllerIds.begin()), GetControllerID);
+  std::transform(newControllers.begin(), newControllers.end(),
+                 std::inserter(newControllerIds, newControllerIds.begin()), GetControllerID);
 
   const bool bChanged = (oldControllerIds != newControllerIds);
   if (bChanged)
@@ -215,13 +220,14 @@ bool CGUIControllerList::RefreshControllers(void)
 
     // Sort add-ons, with default controller first
     std::sort(m_controllers.begin(), m_controllers.end(),
-      [](const ControllerPtr& i, const ControllerPtr& j)
-      {
-        if (i->ID() == DEFAULT_CONTROLLER_ID && j->ID() != DEFAULT_CONTROLLER_ID) return true;
-        if (i->ID() != DEFAULT_CONTROLLER_ID && j->ID() == DEFAULT_CONTROLLER_ID) return false;
-
-        return StringUtils::CompareNoCase(i->Layout().Label(), j->Layout().Label()) < 0;
-      });
+              [](const ControllerPtr& i, const ControllerPtr& j) {
+                if (i->ID() == DEFAULT_CONTROLLER_ID && j->ID() != DEFAULT_CONTROLLER_ID)
+                  return true;
+                if (i->ID() != DEFAULT_CONTROLLER_ID && j->ID() == DEFAULT_CONTROLLER_ID)
+                  return false;
+
+                return StringUtils::CompareNoCase(i->Layout().Label(), j->Layout().Label()) < 0;
+              });
   }
 
   return bChanged;
diff --git a/xbmc/games/controllers/windows/GUIControllerList.h b/xbmc/games/controllers/windows/GUIControllerList.h
index ca2e22b2bb6e..8292889414aa 100644
--- a/xbmc/games/controllers/windows/GUIControllerList.h
+++ b/xbmc/games/controllers/windows/GUIControllerList.h
@@ -24,39 +24,39 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIControllerWindow;
-
-  class CGUIControllerList : public IControllerList
-  {
-  public:
-    CGUIControllerList(CGUIWindow* window, IFeatureList* featureList, GameClientPtr gameClient);
-    ~CGUIControllerList() override { Deinitialize(); }
-
-    // implementation of IControllerList
-    bool Initialize() override;
-    void Deinitialize() override;
-    bool Refresh(const std::string& controllerId) override;
-    void OnFocus(unsigned int controllerIndex) override;
-    void OnSelect(unsigned int controllerIndex) override;
-    int GetFocusedController() const override { return m_focusedController; }
-    void ResetController() override;
-
-  private:
-    bool RefreshControllers(void);
-
-    void CleanupButtons(void);
-    void OnEvent(const ADDON::AddonEvent& event);
-
-    // GUI stuff
-    CGUIWindow* const     m_guiWindow;
-    IFeatureList* const   m_featureList;
-    CGUIControlGroupList* m_controllerList;
-    CGUIButtonControl*    m_controllerButton;
-
-    // Game stuff
-    ControllerVector      m_controllers;
-    int                   m_focusedController;
-    GameClientPtr         m_gameClient;
-  };
-}
-}
+class CGUIControllerWindow;
+
+class CGUIControllerList : public IControllerList
+{
+public:
+  CGUIControllerList(CGUIWindow* window, IFeatureList* featureList, GameClientPtr gameClient);
+  ~CGUIControllerList() override { Deinitialize(); }
+
+  // implementation of IControllerList
+  bool Initialize() override;
+  void Deinitialize() override;
+  bool Refresh(const std::string& controllerId) override;
+  void OnFocus(unsigned int controllerIndex) override;
+  void OnSelect(unsigned int controllerIndex) override;
+  int GetFocusedController() const override { return m_focusedController; }
+  void ResetController() override;
+
+private:
+  bool RefreshControllers(void);
+
+  void CleanupButtons(void);
+  void OnEvent(const ADDON::AddonEvent& event);
+
+  // GUI stuff
+  CGUIWindow* const m_guiWindow;
+  IFeatureList* const m_featureList;
+  CGUIControlGroupList* m_controllerList;
+  CGUIButtonControl* m_controllerButton;
+
+  // Game stuff
+  ControllerVector m_controllers;
+  int m_focusedController;
+  GameClientPtr m_gameClient;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/windows/GUIControllerWindow.cpp b/xbmc/games/controllers/windows/GUIControllerWindow.cpp
index 2e225bdf2806..ade612c89b4f 100644
--- a/xbmc/games/controllers/windows/GUIControllerWindow.cpp
+++ b/xbmc/games/controllers/windows/GUIControllerWindow.cpp
@@ -7,13 +7,15 @@
  */
 
 #include "GUIControllerWindow.h"
+
 #include "ControllerInstaller.h"
 #include "GUIControllerDefines.h"
 #include "GUIControllerList.h"
 #include "GUIFeatureList.h"
+#include "ServiceBroker.h"
+#include "addons/AddonManager.h"
 #include "addons/GUIWindowAddonBrowser.h"
 #include "addons/IAddon.h"
-#include "addons/AddonManager.h"
 #include "cores/RetroPlayer/guibridge/GUIGameRenderManager.h"
 #include "cores/RetroPlayer/guibridge/GUIGameSettingsHandle.h"
 #include "games/addons/GameClient.h"
@@ -23,7 +25,6 @@
 #include "guilib/GUIMessage.h"
 #include "guilib/WindowIDs.h"
 #include "messaging/helpers/DialogOKHelper.h"
-#include "ServiceBroker.h"
 
 // To enable button mapping support
 #include "peripherals/Peripherals.h"
@@ -32,9 +33,9 @@ using namespace KODI;
 using namespace GAME;
 using namespace KODI::MESSAGING;
 
-CGUIControllerWindow::CGUIControllerWindow(void) :
-  CGUIDialog(WINDOW_DIALOG_GAME_CONTROLLERS, "DialogGameControllers.xml"),
-  m_installer(new CControllerInstaller)
+CGUIControllerWindow::CGUIControllerWindow(void)
+  : CGUIDialog(WINDOW_DIALOG_GAME_CONTROLLERS, "DialogGameControllers.xml"),
+    m_installer(new CControllerInstaller)
 {
   // initialize CGUIWindow
   m_loadType = KEEP_IN_MEMORY;
@@ -46,7 +47,7 @@ CGUIControllerWindow::~CGUIControllerWindow(void)
   delete m_featureList;
 }
 
-void CGUIControllerWindow::DoProcess(unsigned int currentTime, CDirtyRegionList &dirtyregions)
+void CGUIControllerWindow::DoProcess(unsigned int currentTime, CDirtyRegionList& dirtyregions)
 {
   /*
    * Apply the faded focus texture to the current controller when unfocused
@@ -57,7 +58,8 @@ void CGUIControllerWindow::DoProcess(unsigned int currentTime, CDirtyRegionList
 
   if (m_controllerList && m_controllerList->GetFocusedController() >= 0)
   {
-    control = GetFirstFocusableControl(CONTROL_CONTROLLER_BUTTONS_START + m_controllerList->GetFocusedController());
+    control = GetFirstFocusableControl(CONTROL_CONTROLLER_BUTTONS_START +
+                                       m_controllerList->GetFocusedController());
     if (control && !control->HasFocus())
     {
       if (control->GetControlType() == CGUIControl::GUICONTROL_BUTTON)
@@ -119,12 +121,14 @@ bool CGUIControllerWindow::OnMessage(CGUIMessage& message)
       {
         ShowButtonCaptureDialog();
       }
-      else if (CONTROL_CONTROLLER_BUTTONS_START <= controlId && controlId < CONTROL_CONTROLLER_BUTTONS_END)
+      else if (CONTROL_CONTROLLER_BUTTONS_START <= controlId &&
+               controlId < CONTROL_CONTROLLER_BUTTONS_END)
       {
         OnControllerSelected(controlId - CONTROL_CONTROLLER_BUTTONS_START);
         bHandled = true;
       }
-      else if (CONTROL_FEATURE_BUTTONS_START <= controlId && controlId < CONTROL_FEATURE_BUTTONS_END)
+      else if (CONTROL_FEATURE_BUTTONS_START <= controlId &&
+               controlId < CONTROL_FEATURE_BUTTONS_END)
       {
         OnFeatureSelected(controlId - CONTROL_FEATURE_BUTTONS_START);
         bHandled = true;
@@ -135,11 +139,13 @@ bool CGUIControllerWindow::OnMessage(CGUIMessage& message)
     {
       int controlId = message.GetControlId();
 
-      if (CONTROL_CONTROLLER_BUTTONS_START <= controlId && controlId < CONTROL_CONTROLLER_BUTTONS_END)
+      if (CONTROL_CONTROLLER_BUTTONS_START <= controlId &&
+          controlId < CONTROL_CONTROLLER_BUTTONS_END)
       {
         OnControllerFocused(controlId - CONTROL_CONTROLLER_BUTTONS_START);
       }
-      else if (CONTROL_FEATURE_BUTTONS_START <= controlId && controlId < CONTROL_FEATURE_BUTTONS_END)
+      else if (CONTROL_FEATURE_BUTTONS_START <= controlId &&
+               controlId < CONTROL_FEATURE_BUTTONS_END)
       {
         OnFeatureFocused(controlId - CONTROL_FEATURE_BUTTONS_START);
       }
@@ -149,11 +155,13 @@ bool CGUIControllerWindow::OnMessage(CGUIMessage& message)
     {
       int controlId = message.GetControlId();
 
-      if (CONTROL_CONTROLLER_BUTTONS_START <= controlId && controlId < CONTROL_CONTROLLER_BUTTONS_END)
+      if (CONTROL_CONTROLLER_BUTTONS_START <= controlId &&
+          controlId < CONTROL_CONTROLLER_BUTTONS_END)
       {
         OnControllerFocused(controlId - CONTROL_CONTROLLER_BUTTONS_START);
       }
-      else if (CONTROL_FEATURE_BUTTONS_START <= controlId && controlId < CONTROL_FEATURE_BUTTONS_END)
+      else if (CONTROL_FEATURE_BUTTONS_START <= controlId &&
+               controlId < CONTROL_FEATURE_BUTTONS_END)
       {
         OnFeatureFocused(controlId - CONTROL_FEATURE_BUTTONS_START);
       }
@@ -214,7 +222,8 @@ void CGUIControllerWindow::OnInitWindow(void)
     if (gameSettingsHandle)
     {
       ADDON::AddonPtr addon;
-      if (CServiceBroker::GetAddonMgr().GetAddon(gameSettingsHandle->GameClientID(), addon, ADDON::ADDON_GAMEDLL))
+      if (CServiceBroker::GetAddonMgr().GetAddon(gameSettingsHandle->GameClientID(), addon,
+                                                 ADDON::ADDON_GAMEDLL))
         gameClient = std::static_pointer_cast<CGameClient>(addon);
     }
   }
@@ -316,7 +325,9 @@ void CGUIControllerWindow::UpdateButtons(void)
   }
   else
   {
-    const bool bEnable = CServiceBroker::GetAddonMgr().GetInstallableAddons(addons, ADDON::ADDON_GAME_CONTROLLER) && !addons.empty();
+    const bool bEnable =
+        CServiceBroker::GetAddonMgr().GetInstallableAddons(addons, ADDON::ADDON_GAME_CONTROLLER) &&
+        !addons.empty();
     CONTROL_ENABLE_ON_CONDITION(CONTROL_GET_MORE, bEnable);
     CONTROL_ENABLE_ON_CONDITION(CONTROL_GET_ALL, bEnable);
   }
@@ -325,11 +336,12 @@ void CGUIControllerWindow::UpdateButtons(void)
 void CGUIControllerWindow::GetMoreControllers(void)
 {
   std::string strAddonId;
-  if (CGUIWindowAddonBrowser::SelectAddonID(ADDON::ADDON_GAME_CONTROLLER, strAddonId, false, true, false, true, false) < 0)
+  if (CGUIWindowAddonBrowser::SelectAddonID(ADDON::ADDON_GAME_CONTROLLER, strAddonId, false, true,
+                                            false, true, false) < 0)
   {
     // "Controller profiles"
     // "All available controller profiles are installed."
-    HELPERS::ShowOKDialogText(CVariant{ 35050 }, CVariant{ 35062 });
+    HELPERS::ShowOKDialogText(CVariant{35050}, CVariant{35062});
     return;
   }
 }
diff --git a/xbmc/games/controllers/windows/GUIControllerWindow.h b/xbmc/games/controllers/windows/GUIControllerWindow.h
index 4dbc2c854aa5..98e6ae81b5b4 100644
--- a/xbmc/games/controllers/windows/GUIControllerWindow.h
+++ b/xbmc/games/controllers/windows/GUIControllerWindow.h
@@ -18,51 +18,51 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerInstaller;
-  class IControllerList;
-  class IFeatureList;
+class CControllerInstaller;
+class IControllerList;
+class IFeatureList;
 
-  class CGUIControllerWindow : public CGUIDialog
-  {
-  public:
-    CGUIControllerWindow(void);
-    ~CGUIControllerWindow() override;
+class CGUIControllerWindow : public CGUIDialog
+{
+public:
+  CGUIControllerWindow(void);
+  ~CGUIControllerWindow() override;
 
-    // implementation of CGUIControl via CGUIDialog
-    void DoProcess(unsigned int currentTime, CDirtyRegionList& dirtyregions) override;
-    bool OnMessage(CGUIMessage& message) override;
+  // implementation of CGUIControl via CGUIDialog
+  void DoProcess(unsigned int currentTime, CDirtyRegionList& dirtyregions) override;
+  bool OnMessage(CGUIMessage& message) override;
 
-  protected:
-    // implementation of CGUIWindow via CGUIDialog
-    void OnInitWindow() override;
-    void OnDeinitWindow(int nextWindowID) override;
+protected:
+  // implementation of CGUIWindow via CGUIDialog
+  void OnInitWindow() override;
+  void OnDeinitWindow(int nextWindowID) override;
 
-  private:
-    void OnControllerFocused(unsigned int controllerIndex);
-    void OnControllerSelected(unsigned int controllerIndex);
-    void OnFeatureFocused(unsigned int featureIndex);
-    void OnFeatureSelected(unsigned int featureIndex);
-    void UpdateButtons(void);
+private:
+  void OnControllerFocused(unsigned int controllerIndex);
+  void OnControllerSelected(unsigned int controllerIndex);
+  void OnFeatureFocused(unsigned int featureIndex);
+  void OnFeatureSelected(unsigned int featureIndex);
+  void UpdateButtons(void);
 
-    // Callbacks for events
-    void OnEvent(const ADDON::CRepositoryUpdater::RepositoryUpdated& event);
-    void OnEvent(const ADDON::AddonEvent& event);
+  // Callbacks for events
+  void OnEvent(const ADDON::CRepositoryUpdater::RepositoryUpdated& event);
+  void OnEvent(const ADDON::AddonEvent& event);
 
-    // Action for the available button
-    void GetMoreControllers(void);
-    void GetAllControllers();
-    void ResetController(void);
-    void ShowHelp(void);
-    void ShowButtonCaptureDialog(void);
+  // Action for the available button
+  void GetMoreControllers(void);
+  void GetAllControllers();
+  void ResetController(void);
+  void ShowHelp(void);
+  void ShowButtonCaptureDialog(void);
 
-    IControllerList* m_controllerList = nullptr;
-    IFeatureList* m_featureList = nullptr;
+  IControllerList* m_controllerList = nullptr;
+  IFeatureList* m_featureList = nullptr;
 
-    // Game paremeters
-    GameClientPtr m_gameClient;
+  // Game paremeters
+  GameClientPtr m_gameClient;
 
-    // Controller parameters
-    std::unique_ptr<CControllerInstaller> m_installer;
-  };
-}
-}
+  // Controller parameters
+  std::unique_ptr<CControllerInstaller> m_installer;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/windows/GUIFeatureList.cpp b/xbmc/games/controllers/windows/GUIFeatureList.cpp
index 92e4459de5d9..617b83a977a7 100644
--- a/xbmc/games/controllers/windows/GUIFeatureList.cpp
+++ b/xbmc/games/controllers/windows/GUIFeatureList.cpp
@@ -28,14 +28,14 @@
 using namespace KODI;
 using namespace GAME;
 
-CGUIFeatureList::CGUIFeatureList(CGUIWindow* window, GameClientPtr gameClient) :
-  m_window(window),
-  m_guiList(nullptr),
-  m_guiButtonTemplate(nullptr),
-  m_guiGroupTitle(nullptr),
-  m_guiFeatureSeparator(nullptr),
-  m_gameClient(std::move(gameClient)),
-  m_wizard(new CGUIConfigurationWizard)
+CGUIFeatureList::CGUIFeatureList(CGUIWindow* window, GameClientPtr gameClient)
+  : m_window(window),
+    m_guiList(nullptr),
+    m_guiButtonTemplate(nullptr),
+    m_guiGroupTitle(nullptr),
+    m_guiFeatureSeparator(nullptr),
+    m_gameClient(std::move(gameClient)),
+    m_wizard(new CGUIConfigurationWizard)
 {
 }
 
@@ -48,8 +48,10 @@ CGUIFeatureList::~CGUIFeatureList(void)
 bool CGUIFeatureList::Initialize(void)
 {
   m_guiList = dynamic_cast<CGUIControlGroupList*>(m_window->GetControl(CONTROL_FEATURE_LIST));
-  m_guiButtonTemplate = dynamic_cast<CGUIButtonControl*>(m_window->GetControl(CONTROL_FEATURE_BUTTON_TEMPLATE));
-  m_guiGroupTitle = dynamic_cast<CGUILabelControl*>(m_window->GetControl(CONTROL_FEATURE_GROUP_TITLE));
+  m_guiButtonTemplate =
+      dynamic_cast<CGUIButtonControl*>(m_window->GetControl(CONTROL_FEATURE_BUTTON_TEMPLATE));
+  m_guiGroupTitle =
+      dynamic_cast<CGUILabelControl*>(m_window->GetControl(CONTROL_FEATURE_GROUP_TITLE));
   m_guiFeatureSeparator = dynamic_cast<CGUIImage*>(m_window->GetControl(CONTROL_FEATURE_SEPARATOR));
 
   if (m_guiButtonTemplate)
@@ -118,14 +120,16 @@ void CGUIFeatureList::Load(const ControllerPtr& controller)
     // Add a separator if the group list isn't empty
     if (m_guiFeatureSeparator && m_guiList->GetTotalSize() > 0)
     {
-      CGUIFeatureSeparator* pSeparator = new CGUIFeatureSeparator(*m_guiFeatureSeparator, m_buttonCount);
+      CGUIFeatureSeparator* pSeparator =
+          new CGUIFeatureSeparator(*m_guiFeatureSeparator, m_buttonCount);
       m_guiList->AddControl(pSeparator);
     }
 
     // Add the group title
     if (m_guiGroupTitle && !groupName.empty())
     {
-      CGUIFeatureGroupTitle* pGroupTitle = new CGUIFeatureGroupTitle(*m_guiGroupTitle, groupName, m_buttonCount);
+      CGUIFeatureGroupTitle* pGroupTitle =
+          new CGUIFeatureGroupTitle(*m_guiGroupTitle, groupName, m_buttonCount);
       m_guiList->AddControl(pGroupTitle);
     }
 
@@ -141,7 +145,7 @@ void CGUIFeatureList::OnSelect(unsigned int buttonIndex)
 {
   // Generate list of buttons for the wizard
   std::vector<IFeatureButton*> buttons;
-  for ( ; buttonIndex < m_buttonCount; buttonIndex++)
+  for (; buttonIndex < m_buttonCount; buttonIndex++)
   {
     IFeatureButton* control = GetButtonControl(buttonIndex);
     if (control == nullptr)
@@ -179,7 +183,8 @@ void CGUIFeatureList::CleanupButtons(void)
     m_guiList->ClearAll();
 }
 
-std::vector<CGUIFeatureList::FeatureGroup> CGUIFeatureList::GetFeatureGroups(const std::vector<CControllerFeature>& features) const
+std::vector<CGUIFeatureList::FeatureGroup> CGUIFeatureList::GetFeatureGroups(
+    const std::vector<CControllerFeature>& features) const
 {
   std::vector<FeatureGroup> groups;
 
@@ -198,7 +203,7 @@ std::vector<CGUIFeatureList::FeatureGroup> CGUIFeatureList::GetFeatureGroups(con
 
     if (!groups.empty())
     {
-      FeatureGroup &previousGroup = *groups.rbegin();
+      FeatureGroup& previousGroup = *groups.rbegin();
       if (feature.CategoryLabel() == previousGroup.groupName)
       {
         // Add feature to previous group
@@ -208,7 +213,7 @@ std::vector<CGUIFeatureList::FeatureGroup> CGUIFeatureList::GetFeatureGroups(con
         // If feature is a key, add it to the preceding virtual group as well
         if (feature.Category() == JOYSTICK::FEATURE_CATEGORY::KEY && groups.size() >= 2)
         {
-          FeatureGroup &virtualGroup = *(groups.rbegin() + 1);
+          FeatureGroup& virtualGroup = *(groups.rbegin() + 1);
           if (virtualGroup.bIsVirtualKey)
             virtualGroup.features.emplace_back(feature);
         }
@@ -252,7 +257,8 @@ bool CGUIFeatureList::HasButton(JOYSTICK::FEATURE_TYPE type) const
   return CGUIFeatureTranslator::GetButtonType(type) != BUTTON_TYPE::UNKNOWN;
 }
 
-std::vector<CGUIButtonControl*> CGUIFeatureList::GetButtons(const std::vector<CControllerFeature>& features, unsigned int startIndex)
+std::vector<CGUIButtonControl*> CGUIFeatureList::GetButtons(
+    const std::vector<CControllerFeature>& features, unsigned int startIndex)
 {
   std::vector<CGUIButtonControl*> buttons;
 
@@ -262,7 +268,8 @@ std::vector<CGUIButtonControl*> CGUIFeatureList::GetButtons(const std::vector<CC
   {
     BUTTON_TYPE buttonType = CGUIFeatureTranslator::GetButtonType(feature.Type());
 
-    CGUIButtonControl* pButton = CGUIFeatureFactory::CreateButton(buttonType, *m_guiButtonTemplate, m_wizard, feature, buttonIndex);
+    CGUIButtonControl* pButton = CGUIFeatureFactory::CreateButton(buttonType, *m_guiButtonTemplate,
+                                                                  m_wizard, feature, buttonIndex);
 
     // If successful, add button to result
     if (pButton != nullptr)
@@ -275,7 +282,8 @@ std::vector<CGUIButtonControl*> CGUIFeatureList::GetButtons(const std::vector<CC
   return buttons;
 }
 
-CGUIButtonControl* CGUIFeatureList::GetSelectKeyButton(const std::vector<CControllerFeature>& features, unsigned int buttonIndex)
+CGUIButtonControl* CGUIFeatureList::GetSelectKeyButton(
+    const std::vector<CControllerFeature>& features, unsigned int buttonIndex)
 {
   // Expose keycodes to the wizard
   for (const CControllerFeature& feature : features)
@@ -284,5 +292,6 @@ CGUIButtonControl* CGUIFeatureList::GetSelectKeyButton(const std::vector<CContro
       m_wizard->RegisterKey(feature);
   }
 
-  return CGUIFeatureFactory::CreateButton(BUTTON_TYPE::SELECT_KEY, *m_guiButtonTemplate, m_wizard, CControllerFeature(), buttonIndex);
+  return CGUIFeatureFactory::CreateButton(BUTTON_TYPE::SELECT_KEY, *m_guiButtonTemplate, m_wizard,
+                                          CControllerFeature(), buttonIndex);
 }
diff --git a/xbmc/games/controllers/windows/GUIFeatureList.h b/xbmc/games/controllers/windows/GUIFeatureList.h
index e94398aa4e0e..c01f07ff70da 100644
--- a/xbmc/games/controllers/windows/GUIFeatureList.h
+++ b/xbmc/games/controllers/windows/GUIFeatureList.h
@@ -24,52 +24,54 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIFeatureList : public IFeatureList
-  {
-  public:
-    CGUIFeatureList(CGUIWindow* window, GameClientPtr gameClient);
-    ~CGUIFeatureList() override;
+class CGUIFeatureList : public IFeatureList
+{
+public:
+  CGUIFeatureList(CGUIWindow* window, GameClientPtr gameClient);
+  ~CGUIFeatureList() override;
 
-    // implementation of IFeatureList
-    bool Initialize() override;
-    void Deinitialize() override;
-    bool HasButton(JOYSTICK::FEATURE_TYPE type) const override;
-    void Load(const ControllerPtr& controller) override;
-    void OnFocus(unsigned int buttonIndex) override {}
-    void OnSelect(unsigned int buttonIndex) override;
+  // implementation of IFeatureList
+  bool Initialize() override;
+  void Deinitialize() override;
+  bool HasButton(JOYSTICK::FEATURE_TYPE type) const override;
+  void Load(const ControllerPtr& controller) override;
+  void OnFocus(unsigned int buttonIndex) override {}
+  void OnSelect(unsigned int buttonIndex) override;
 
-  private:
-    IFeatureButton* GetButtonControl(unsigned int buttonIndex);
+private:
+  IFeatureButton* GetButtonControl(unsigned int buttonIndex);
 
-    void CleanupButtons(void);
+  void CleanupButtons(void);
 
-    // Helper functions
-    struct FeatureGroup
-    {
-      std::string groupName;
-      std::vector<CControllerFeature> features;
-      /*!
-       * True if this group is a button that allows the user to map a key of
-       * their choosing.
-       */
-      bool bIsVirtualKey = false;
-    };
-    std::vector<FeatureGroup> GetFeatureGroups(const std::vector<CControllerFeature>& features) const;
-    std::vector<CGUIButtonControl*> GetButtons(const std::vector<CControllerFeature>& features, unsigned int startIndex);
-    CGUIButtonControl* GetSelectKeyButton(const std::vector<CControllerFeature>& features, unsigned int buttonIndex);
+  // Helper functions
+  struct FeatureGroup
+  {
+    std::string groupName;
+    std::vector<CControllerFeature> features;
+    /*!
+     * True if this group is a button that allows the user to map a key of
+     * their choosing.
+     */
+    bool bIsVirtualKey = false;
+  };
+  std::vector<FeatureGroup> GetFeatureGroups(const std::vector<CControllerFeature>& features) const;
+  std::vector<CGUIButtonControl*> GetButtons(const std::vector<CControllerFeature>& features,
+                                             unsigned int startIndex);
+  CGUIButtonControl* GetSelectKeyButton(const std::vector<CControllerFeature>& features,
+                                        unsigned int buttonIndex);
 
-    // GUI stuff
-    CGUIWindow* const       m_window;
-    unsigned int            m_buttonCount = 0;
-    CGUIControlGroupList*   m_guiList;
-    CGUIButtonControl*      m_guiButtonTemplate;
-    CGUILabelControl*       m_guiGroupTitle;
-    CGUIImage*              m_guiFeatureSeparator;
+  // GUI stuff
+  CGUIWindow* const m_window;
+  unsigned int m_buttonCount = 0;
+  CGUIControlGroupList* m_guiList;
+  CGUIButtonControl* m_guiButtonTemplate;
+  CGUILabelControl* m_guiGroupTitle;
+  CGUIImage* m_guiFeatureSeparator;
 
-    // Game window stuff
-    GameClientPtr           m_gameClient;
-    ControllerPtr           m_controller;
-    IConfigurationWizard*   m_wizard;
-  };
-}
-}
+  // Game window stuff
+  GameClientPtr m_gameClient;
+  ControllerPtr m_controller;
+  IConfigurationWizard* m_wizard;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/controllers/windows/IConfigurationWindow.h b/xbmc/games/controllers/windows/IConfigurationWindow.h
index 622963dd6814..6620de39bea5 100644
--- a/xbmc/games/controllers/windows/IConfigurationWindow.h
+++ b/xbmc/games/controllers/windows/IConfigurationWindow.h
@@ -40,222 +40,223 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerFeature;
+class CControllerFeature;
+
+/*!
+ * \brief A list populated by installed controllers
+ */
+class IControllerList
+{
+public:
+  virtual ~IControllerList() = default;
+
+  /*!
+   * \brief  Initialize the resource
+   * \return true if the resource is initialized and can be used
+   *         false if the resource failed to initialize and must not be used
+   */
+  virtual bool Initialize(void) = 0;
+
+  /*!
+   * \brief  Deinitialize the resource
+   */
+  virtual void Deinitialize(void) = 0;
+
+  /*!
+   * \brief Refresh the contents of the list
+   * \param controllerId The controller to focus, or empty to leave focus unchanged
+   * \return True if the list was changed
+   */
+  virtual bool Refresh(const std::string& controllerId) = 0;
+
+  /*
+   * \brief  The specified controller has been focused
+   * \param  controllerIndex The index of the controller being focused
+   */
+  virtual void OnFocus(unsigned int controllerIndex) = 0;
+
+  /*!
+   * \brief  The specified controller has been selected
+   * \param  controllerIndex The index of the controller being selected
+   */
+  virtual void OnSelect(unsigned int controllerIndex) = 0;
+
+  /*!
+   * \brief Get the index of the focused controller
+   * \return The index of the focused controller, or -1 if no controller has been focused yet
+   */
+  virtual int GetFocusedController() const = 0;
+
+  /*!
+   * \brief Reset the focused controller
+   */
+  virtual void ResetController(void) = 0;
+};
+
+/*!
+ * \brief A list populated by the controller's features
+ */
+class IFeatureList
+{
+public:
+  virtual ~IFeatureList() = default;
+
+  /*!
+   * \brief  Initialize the resource
+   * \return true if the resource is initialized and can be used
+   *         false if the resource failed to initialize and must not be used
+   */
+  virtual bool Initialize(void) = 0;
+
+  /*!
+   * \brief  Deinitialize the resource
+   * \remark This must be called if Initialize() returned true
+   */
+  virtual void Deinitialize(void) = 0;
+
+  /*!
+   * \brief Check if the feature type has any buttons in the GUI
+   * \param The type of the feature being added to the GUI
+   * \return True if the type is support, false otherwise
+   */
+  virtual bool HasButton(JOYSTICK::FEATURE_TYPE type) const = 0;
+
+  /*!
+   * \brief Load the features for the specified controller
+   * \param controller The controller to load
+   */
+  virtual void Load(const ControllerPtr& controller) = 0;
+
+  /*!
+   * \brief  Focus has been set to the specified GUI button
+   * \param  buttonIndex The index of the button being focused
+   */
+  virtual void OnFocus(unsigned int buttonIndex) = 0;
+
+  /*!
+   * \brief  The specified GUI button has been selected
+   * \param  buttonIndex The index of the button being selected
+   */
+  virtual void OnSelect(unsigned int buttonIndex) = 0;
+};
+
+/*!
+ * \brief A GUI button in a feature list
+ */
+class IFeatureButton
+{
+public:
+  virtual ~IFeatureButton() = default;
+
+  /*!
+   * \brief Get the feature represented by this button
+   */
+  virtual const CControllerFeature& Feature(void) const = 0;
+
+  /*!
+   * \brief Allow the wizard to include this feature in a list of buttons
+   *        to map
+   */
+  virtual bool AllowWizard() const { return true; }
+
+  /*!
+   * \brief Prompt the user for a single input element
+   * \param waitEvent The event to block on while prompting for input
+   * \return true if input was received (event fired), false if the prompt timed out
+   *
+   * After the button has finished prompting the user for all the input
+   * elements it requires, this will return false until Reset() is called.
+   */
+  virtual bool PromptForInput(CEvent& waitEvent) = 0;
+
+  /*!
+   * \brief Check if the button supports further calls to PromptForInput()
+   * \return true if the button requires no more input elements from the user
+   */
+  virtual bool IsFinished(void) const = 0;
+
+  /*!
+   * \brief Get the direction of the next analog stick or relative pointer
+   *        prompt
+   * \return The next direction to be prompted, or UNKNOWN if this isn't a
+   *         cardinal feature or the prompt is finished
+   */
+  virtual INPUT::CARDINAL_DIRECTION GetCardinalDirection(void) const = 0;
+
+  /*!
+   * \brief Get the direction of the next wheel prompt
+   * \return The next direction to be prompted, or UNKNOWN if this isn't a
+   *         wheel or the prompt is finished
+   */
+  virtual JOYSTICK::WHEEL_DIRECTION GetWheelDirection(void) const = 0;
+
+  /*!
+   * \brief Get the direction of the next throttle prompt
+   * \return The next direction to be prompted, or UNKNOWN if this isn't a
+   *         throttle or the prompt is finished
+   */
+  virtual JOYSTICK::THROTTLE_DIRECTION GetThrottleDirection(void) const = 0;
+
+  /*!
+   * \brief True if the button is waiting for a key press
+   */
+  virtual bool NeedsKey() const { return false; }
+
+  /*!
+   * \brief Set the pressed key that the user will be prompted to map
+   *
+   * \param key The key that was pressed
+   */
+  virtual void SetKey(const CControllerFeature& key) {}
+
+  /*!
+   * \brief Reset button after prompting for input has finished
+   */
+  virtual void Reset(void) = 0;
+};
+
+/*!
+ * \brief A wizard to direct user input
+ */
+class IConfigurationWizard
+{
+public:
+  virtual ~IConfigurationWizard() = default;
+
+  /*!
+   * \brief Start the wizard for the specified buttons
+   * \param controllerId The controller ID being mapped
+   * \param buttons The buttons to map
+   */
+  virtual void Run(const std::string& strControllerId,
+                   const std::vector<IFeatureButton*>& buttons) = 0;
 
   /*!
-   * \brief A list populated by installed controllers
+   * \brief Callback for feature losing focus
+   * \param button The feature button losing focus
    */
-  class IControllerList
-  {
-  public:
-    virtual ~IControllerList() = default;
-
-    /*!
-     * \brief  Initialize the resource
-     * \return true if the resource is initialized and can be used
-     *         false if the resource failed to initialize and must not be used
-     */
-    virtual bool Initialize(void) = 0;
-
-    /*!
-     * \brief  Deinitialize the resource
-     */
-    virtual void Deinitialize(void) = 0;
-
-    /*!
-     * \brief Refresh the contents of the list
-     * \param controllerId The controller to focus, or empty to leave focus unchanged
-     * \return True if the list was changed
-     */
-    virtual bool Refresh(const std::string& controllerId) = 0;
-
-    /*
-     * \brief  The specified controller has been focused
-     * \param  controllerIndex The index of the controller being focused
-     */
-    virtual void OnFocus(unsigned int controllerIndex) = 0;
-
-    /*!
-     * \brief  The specified controller has been selected
-     * \param  controllerIndex The index of the controller being selected
-     */
-    virtual void OnSelect(unsigned int controllerIndex) = 0;
-
-    /*!
-     * \brief Get the index of the focused controller
-     * \return The index of the focused controller, or -1 if no controller has been focused yet
-     */
-    virtual int GetFocusedController() const = 0;
-
-    /*!
-     * \brief Reset the focused controller
-     */
-    virtual void ResetController(void) = 0;
-  };
+  virtual void OnUnfocus(IFeatureButton* button) = 0;
 
   /*!
-   * \brief A list populated by the controller's features
+   * \brief Abort a running wizard
+   * \param bWait True if the call should block until the wizard is fully aborted
+   * \return true if aborted, or false if the wizard wasn't running
    */
-  class IFeatureList
-  {
-  public:
-    virtual ~IFeatureList() = default;
-
-    /*!
-     * \brief  Initialize the resource
-     * \return true if the resource is initialized and can be used
-     *         false if the resource failed to initialize and must not be used
-     */
-    virtual bool Initialize(void) = 0;
-
-    /*!
-     * \brief  Deinitialize the resource
-     * \remark This must be called if Initialize() returned true
-     */
-    virtual void Deinitialize(void) = 0;
-
-    /*!
-     * \brief Check if the feature type has any buttons in the GUI
-     * \param The type of the feature being added to the GUI
-     * \return True if the type is support, false otherwise
-     */
-    virtual bool HasButton(JOYSTICK::FEATURE_TYPE type) const = 0;
-
-    /*!
-     * \brief Load the features for the specified controller
-     * \param controller The controller to load
-     */
-    virtual void Load(const ControllerPtr& controller) = 0;
-
-    /*!
-     * \brief  Focus has been set to the specified GUI button
-     * \param  buttonIndex The index of the button being focused
-     */
-    virtual void OnFocus(unsigned int buttonIndex) = 0;
-
-    /*!
-     * \brief  The specified GUI button has been selected
-     * \param  buttonIndex The index of the button being selected
-     */
-    virtual void OnSelect(unsigned int buttonIndex) = 0;
-  };
+  virtual bool Abort(bool bWait = true) = 0;
 
   /*!
-   * \brief A GUI button in a feature list
+   * \brief Register a key by its keycode
+   * \param key A key with a valid keycode
+   *
+   * This should be called before Run(). It allows the user to choose a key
+   * to map instead of scrolling through a long list.
    */
-  class IFeatureButton
-  {
-  public:
-    virtual ~IFeatureButton() = default;
-
-    /*!
-     * \brief Get the feature represented by this button
-     */
-    virtual const CControllerFeature& Feature(void) const = 0;
-
-    /*!
-     * \brief Allow the wizard to include this feature in a list of buttons
-     *        to map
-     */
-    virtual bool AllowWizard() const { return true; }
-
-    /*!
-     * \brief Prompt the user for a single input element
-     * \param waitEvent The event to block on while prompting for input
-     * \return true if input was received (event fired), false if the prompt timed out
-     *
-     * After the button has finished prompting the user for all the input
-     * elements it requires, this will return false until Reset() is called.
-     */
-    virtual bool PromptForInput(CEvent& waitEvent) = 0;
-
-    /*!
-     * \brief Check if the button supports further calls to PromptForInput()
-     * \return true if the button requires no more input elements from the user
-     */
-    virtual bool IsFinished(void) const = 0;
-
-    /*!
-     * \brief Get the direction of the next analog stick or relative pointer
-     *        prompt
-     * \return The next direction to be prompted, or UNKNOWN if this isn't a
-     *         cardinal feature or the prompt is finished
-     */
-    virtual INPUT::CARDINAL_DIRECTION GetCardinalDirection(void) const = 0;
-
-    /*!
-     * \brief Get the direction of the next wheel prompt
-     * \return The next direction to be prompted, or UNKNOWN if this isn't a
-     *         wheel or the prompt is finished
-     */
-    virtual JOYSTICK::WHEEL_DIRECTION GetWheelDirection(void) const = 0;
-
-    /*!
-     * \brief Get the direction of the next throttle prompt
-     * \return The next direction to be prompted, or UNKNOWN if this isn't a
-     *         throttle or the prompt is finished
-     */
-    virtual JOYSTICK::THROTTLE_DIRECTION GetThrottleDirection(void) const = 0;
-
-    /*!
-     * \brief True if the button is waiting for a key press
-     */
-    virtual bool NeedsKey() const { return false; }
-
-    /*!
-     * \brief Set the pressed key that the user will be prompted to map
-     *
-     * \param key The key that was pressed
-     */
-    virtual void SetKey(const CControllerFeature &key) { }
-
-    /*!
-     * \brief Reset button after prompting for input has finished
-     */
-    virtual void Reset(void) = 0;
-  };
+  virtual void RegisterKey(const CControllerFeature& key) = 0;
 
   /*!
-   * \brief A wizard to direct user input
+   * \brief Unregister all registered keys
    */
-  class IConfigurationWizard
-  {
-  public:
-    virtual ~IConfigurationWizard() = default;
-
-    /*!
-     * \brief Start the wizard for the specified buttons
-     * \param controllerId The controller ID being mapped
-     * \param buttons The buttons to map
-     */
-    virtual void Run(const std::string& strControllerId, const std::vector<IFeatureButton*>& buttons) = 0;
-
-    /*!
-     * \brief Callback for feature losing focus
-     * \param button The feature button losing focus
-     */
-    virtual void OnUnfocus(IFeatureButton* button) = 0;
-
-    /*!
-     * \brief Abort a running wizard
-     * \param bWait True if the call should block until the wizard is fully aborted
-     * \return true if aborted, or false if the wizard wasn't running
-     */
-    virtual bool Abort(bool bWait = true) = 0;
-
-    /*!
-     * \brief Register a key by its keycode
-     * \param key A key with a valid keycode
-     *
-     * This should be called before Run(). It allows the user to choose a key
-     * to map instead of scrolling through a long list.
-     */
-    virtual void RegisterKey(const CControllerFeature &key) = 0;
-
-    /*!
-     * \brief Unregister all registered keys
-     */
-    virtual void UnregisterKeys() = 0;
-  };
-}
-}
+  virtual void UnregisterKeys() = 0;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/GUIDialogSelectGameClient.cpp b/xbmc/games/dialogs/GUIDialogSelectGameClient.cpp
index 74f72ceced47..d8336d69ebbb 100644
--- a/xbmc/games/dialogs/GUIDialogSelectGameClient.cpp
+++ b/xbmc/games/dialogs/GUIDialogSelectGameClient.cpp
@@ -29,7 +29,9 @@ using namespace KODI;
 using namespace KODI::MESSAGING;
 using namespace GAME;
 
-std::string CGUIDialogSelectGameClient::ShowAndGetGameClient(const std::string &gamePath, const GameClientVector& candidates, const GameClientVector& installable)
+std::string CGUIDialogSelectGameClient::ShowAndGetGameClient(const std::string& gamePath,
+                                                             const GameClientVector& candidates,
+                                                             const GameClientVector& installable)
 {
   std::string gameClient;
 
@@ -53,13 +55,14 @@ std::string CGUIDialogSelectGameClient::ShowAndGetGameClient(const std::string &
   }
 
   // "Select emulator for {0:s}"
-  CGUIDialogSelect *dialog = GetDialog(StringUtils::Format(g_localizeStrings.Get(35258), extension));
+  CGUIDialogSelect* dialog =
+      GetDialog(StringUtils::Format(g_localizeStrings.Get(35258), extension));
   if (dialog != nullptr)
   {
     // Turn the addons into items
     CFileItemList items;
     CFileItemList installableItems;
-    for (const auto &candidate : candidates)
+    for (const auto& candidate : candidates)
     {
       CFileItemPtr item(XFILE::CAddonsDirectory::FileItemFromAddon(candidate, candidate->ID()));
       item->SetLabel2(g_localizeStrings.Get(35257)); // "Installed"
@@ -67,7 +70,7 @@ std::string CGUIDialogSelectGameClient::ShowAndGetGameClient(const std::string &
         item->SetLabel2(item->GetLabel2() + ", " + g_localizeStrings.Get(35259)); // "Saved"
       items.Add(std::move(item));
     }
-    for (const auto &addon : installable)
+    for (const auto& addon : installable)
     {
       CFileItemPtr item(XFILE::CAddonsDirectory::FileItemFromAddon(addon, addon->ID()));
       installableItems.Add(std::move(item));
@@ -96,7 +99,8 @@ std::string CGUIDialogSelectGameClient::ShowAndGetGameClient(const std::string &
       {
         gameClient = items[selectedIndex]->GetPath();
 
-        CLog::Log(LOGDEBUG, "Select game client dialog: User selected emulator %s", gameClient.c_str());
+        CLog::Log(LOGDEBUG, "Select game client dialog: User selected emulator %s",
+                  gameClient.c_str());
 
         if (Install(gameClient))
         {
@@ -109,7 +113,8 @@ std::string CGUIDialogSelectGameClient::ShowAndGetGameClient(const std::string &
       }
       else
       {
-        CLog::Log(LOGDEBUG, "Select game client dialog: User selected invalid emulator %d", selectedIndex);
+        CLog::Log(LOGDEBUG, "Select game client dialog: User selected invalid emulator %d",
+                  selectedIndex);
       }
     }
     else
@@ -121,7 +126,7 @@ std::string CGUIDialogSelectGameClient::ShowAndGetGameClient(const std::string &
   return gameClient;
 }
 
-bool CGUIDialogSelectGameClient::Install(const std::string &gameClient)
+bool CGUIDialogSelectGameClient::Install(const std::string& gameClient)
 {
   // If the addon isn't installed we need to install it
   bool bInstalled = CServiceBroker::GetAddonMgr().IsAddonInstalled(gameClient);
@@ -141,7 +146,7 @@ bool CGUIDialogSelectGameClient::Install(const std::string &gameClient)
   return bInstalled;
 }
 
-bool CGUIDialogSelectGameClient::Enable(const std::string &gameClient)
+bool CGUIDialogSelectGameClient::Enable(const std::string& gameClient)
 {
   bool bSuccess = true;
 
@@ -151,28 +156,33 @@ bool CGUIDialogSelectGameClient::Enable(const std::string &gameClient)
   return bSuccess;
 }
 
-CGUIDialogSelect *CGUIDialogSelectGameClient::GetDialog(const std::string &title)
+CGUIDialogSelect* CGUIDialogSelectGameClient::GetDialog(const std::string& title)
 {
-  CGUIDialogSelect *dialog = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogSelect>(WINDOW_DIALOG_SELECT);
+  CGUIDialogSelect* dialog =
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogSelect>(
+          WINDOW_DIALOG_SELECT);
   if (dialog != nullptr)
   {
     dialog->Reset();
-    dialog->SetHeading(CVariant{ title });
+    dialog->SetHeading(CVariant{title});
     dialog->SetUseDetails(true);
   }
 
   return dialog;
 }
 
-void CGUIDialogSelectGameClient::LogGameClients(const GameClientVector& candidates, const GameClientVector& installable)
+void CGUIDialogSelectGameClient::LogGameClients(const GameClientVector& candidates,
+                                                const GameClientVector& installable)
 {
-  CLog::Log(LOGDEBUG, "Select game client dialog: Found %u candidates", static_cast<unsigned int>(candidates.size()));
+  CLog::Log(LOGDEBUG, "Select game client dialog: Found %u candidates",
+            static_cast<unsigned int>(candidates.size()));
   for (const auto& gameClient : candidates)
     CLog::Log(LOGDEBUG, "Adding %s as a candidate", gameClient->ID().c_str());
 
   if (!installable.empty())
   {
-    CLog::Log(LOGDEBUG, "Select game client dialog: Found %u installable clients", static_cast<unsigned int>(installable.size()));
+    CLog::Log(LOGDEBUG, "Select game client dialog: Found %u installable clients",
+              static_cast<unsigned int>(installable.size()));
     for (const auto& gameClient : installable)
       CLog::Log(LOGDEBUG, "Adding %s as an installable client", gameClient->ID().c_str());
   }
diff --git a/xbmc/games/dialogs/GUIDialogSelectGameClient.h b/xbmc/games/dialogs/GUIDialogSelectGameClient.h
index b419e537cccc..21db5650b148 100644
--- a/xbmc/games/dialogs/GUIDialogSelectGameClient.h
+++ b/xbmc/games/dialogs/GUIDialogSelectGameClient.h
@@ -18,62 +18,65 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIDialogSelectGameClient
-  {
-  public:
-    /*!
-     * \brief Show a series of dialogs that results in a game client being
-     *        selected
-     *
-     * \param gamePath    The path of the file being played
-     * \param candidates  A list of installed candidates that the user can
-     *                    select from
-     * \param installable A list of installable candidates that the user can
-     *                    select from
-     *
-     * \return The ID of the selected game client, or empty if no game client
-     *         was selected
-     */
-    static std::string ShowAndGetGameClient(const std::string &gamePath, const GameClientVector& candidates, const GameClientVector& installable);
+class CGUIDialogSelectGameClient
+{
+public:
+  /*!
+   * \brief Show a series of dialogs that results in a game client being
+   *        selected
+   *
+   * \param gamePath    The path of the file being played
+   * \param candidates  A list of installed candidates that the user can
+   *                    select from
+   * \param installable A list of installable candidates that the user can
+   *                    select from
+   *
+   * \return The ID of the selected game client, or empty if no game client
+   *         was selected
+   */
+  static std::string ShowAndGetGameClient(const std::string& gamePath,
+                                          const GameClientVector& candidates,
+                                          const GameClientVector& installable);
 
-  private:
-    /*!
-     * \brief Install the specified game client
-     *
-     * If the game client is not installed, a model dialog is shown installing
-     * the game client. If the installation fails, an error dialog is shown.
-     *
-     * \param gameClient The game client to install
-     *
-     * \return True if the game client is installed, false otherwise
-     */
-    static bool Install(const std::string &gameClient);
+private:
+  /*!
+   * \brief Install the specified game client
+   *
+   * If the game client is not installed, a model dialog is shown installing
+   * the game client. If the installation fails, an error dialog is shown.
+   *
+   * \param gameClient The game client to install
+   *
+   * \return True if the game client is installed, false otherwise
+   */
+  static bool Install(const std::string& gameClient);
 
-    /*!
-     * \brief Enable the specified game client
-     *
-     * \param gameClient the game client to enable
-     *
-     * \return True if the game client is enabled, false otherwise
-     */
-    static bool Enable(const std::string &gameClient);
+  /*!
+   * \brief Enable the specified game client
+   *
+   * \param gameClient the game client to enable
+   *
+   * \return True if the game client is enabled, false otherwise
+   */
+  static bool Enable(const std::string& gameClient);
 
-    /*!
-     * \brief Get an initialized select dialog
-     *
-     * \param title The title of the select dialog
-     *
-     * \return A select dialog with its properties initialized, or nullptr if
-     *         the dialog isn't found
-     */
-    static CGUIDialogSelect *GetDialog(const std::string &title);
+  /*!
+   * \brief Get an initialized select dialog
+   *
+   * \param title The title of the select dialog
+   *
+   * \return A select dialog with its properties initialized, or nullptr if
+   *         the dialog isn't found
+   */
+  static CGUIDialogSelect* GetDialog(const std::string& title);
 
-    /*!
-     * \brief Log the candidates and installable game clients
-     *
-     * Other than logging, this has no side effects.
-     */
-    static void LogGameClients(const GameClientVector& candidates, const GameClientVector& installable);
-  };
-}
-}
+  /*!
+   * \brief Log the candidates and installable game clients
+   *
+   * Other than logging, this has no side effects.
+   */
+  static void LogGameClients(const GameClientVector& candidates,
+                             const GameClientVector& installable);
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/osd/DialogGameAdvancedSettings.cpp b/xbmc/games/dialogs/osd/DialogGameAdvancedSettings.cpp
index 21717ca052b7..a30f3bbf1e9d 100644
--- a/xbmc/games/dialogs/osd/DialogGameAdvancedSettings.cpp
+++ b/xbmc/games/dialogs/osd/DialogGameAdvancedSettings.cpp
@@ -19,32 +19,33 @@
 using namespace KODI;
 using namespace GAME;
 
-CDialogGameAdvancedSettings::CDialogGameAdvancedSettings() :
-  CGUIDialog(WINDOW_DIALOG_GAME_ADVANCED_SETTINGS, "")
+CDialogGameAdvancedSettings::CDialogGameAdvancedSettings()
+  : CGUIDialog(WINDOW_DIALOG_GAME_ADVANCED_SETTINGS, "")
 {
 }
 
-bool CDialogGameAdvancedSettings::OnMessage(CGUIMessage &message)
+bool CDialogGameAdvancedSettings::OnMessage(CGUIMessage& message)
 {
   switch (message.GetMessage())
   {
-  case GUI_MSG_WINDOW_INIT:
-  {
-    auto gameSettingsHandle = CServiceBroker::GetGameRenderManager().RegisterGameSettingsDialog();
-    if (gameSettingsHandle)
+    case GUI_MSG_WINDOW_INIT:
     {
-      ADDON::AddonPtr addon;
-      if (CServiceBroker::GetAddonMgr().GetAddon(gameSettingsHandle->GameClientID(), addon, ADDON::ADDON_GAMEDLL))
+      auto gameSettingsHandle = CServiceBroker::GetGameRenderManager().RegisterGameSettingsDialog();
+      if (gameSettingsHandle)
       {
-        gameSettingsHandle.reset();
-        CGUIDialogAddonSettings::ShowForAddon(addon);
+        ADDON::AddonPtr addon;
+        if (CServiceBroker::GetAddonMgr().GetAddon(gameSettingsHandle->GameClientID(), addon,
+                                                   ADDON::ADDON_GAMEDLL))
+        {
+          gameSettingsHandle.reset();
+          CGUIDialogAddonSettings::ShowForAddon(addon);
+        }
       }
-    }
 
-    return false;
-  }
-  default:
-    break;
+      return false;
+    }
+    default:
+      break;
   }
 
   return CGUIDialog::OnMessage(message);
diff --git a/xbmc/games/dialogs/osd/DialogGameAdvancedSettings.h b/xbmc/games/dialogs/osd/DialogGameAdvancedSettings.h
index 0ef365908171..8f41b80ddffe 100644
--- a/xbmc/games/dialogs/osd/DialogGameAdvancedSettings.h
+++ b/xbmc/games/dialogs/osd/DialogGameAdvancedSettings.h
@@ -14,19 +14,19 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGUIGameSettingsHandle;
+class CGUIGameSettingsHandle;
 }
 
 namespace GAME
 {
-  class CDialogGameAdvancedSettings: public CGUIDialog
-  {
-  public:
-    CDialogGameAdvancedSettings();
-    ~CDialogGameAdvancedSettings() override = default;
+class CDialogGameAdvancedSettings : public CGUIDialog
+{
+public:
+  CDialogGameAdvancedSettings();
+  ~CDialogGameAdvancedSettings() override = default;
 
-    // implementation of CGUIControl via CGUIDialog
-    bool OnMessage(CGUIMessage &message) override;
-  };
-}
-}
+  // implementation of CGUIControl via CGUIDialog
+  bool OnMessage(CGUIMessage& message) override;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/osd/DialogGameOSD.cpp b/xbmc/games/dialogs/osd/DialogGameOSD.cpp
index 9f485974b051..3a0eb529e006 100644
--- a/xbmc/games/dialogs/osd/DialogGameOSD.cpp
+++ b/xbmc/games/dialogs/osd/DialogGameOSD.cpp
@@ -19,15 +19,14 @@
 using namespace KODI;
 using namespace GAME;
 
-CDialogGameOSD::CDialogGameOSD() :
-  CGUIDialog(WINDOW_DIALOG_GAME_OSD, "GameOSD.xml"),
-  m_helpDialog(new CDialogGameOSDHelp(*this))
+CDialogGameOSD::CDialogGameOSD()
+  : CGUIDialog(WINDOW_DIALOG_GAME_OSD, "GameOSD.xml"), m_helpDialog(new CDialogGameOSDHelp(*this))
 {
   // Initialize CGUIWindow
   m_loadType = KEEP_IN_MEMORY;
 }
 
-bool CDialogGameOSD::OnAction(const CAction &action)
+bool CDialogGameOSD::OnAction(const CAction& action)
 {
   switch (action.GetID())
   {
@@ -40,7 +39,7 @@ bool CDialogGameOSD::OnAction(const CAction &action)
       // Disable OSD help if visible
       if (m_helpDialog->IsVisible() && CServiceBroker::IsServiceManagerUp())
       {
-        GAME::CGameSettings &gameSettings = CServiceBroker::GetGameServices().GameSettings();
+        GAME::CGameSettings& gameSettings = CServiceBroker::GetGameServices().GameSettings();
         if (gameSettings.ShowOSDHelp())
         {
           gameSettings.SetShowOSDHelp(false);
@@ -71,7 +70,7 @@ void CDialogGameOSD::OnDeinitWindow(int nextWindowID)
 
   if (CServiceBroker::IsServiceManagerUp())
   {
-    GAME::CGameSettings &gameSettings = CServiceBroker::GetGameServices().GameSettings();
+    GAME::CGameSettings& gameSettings = CServiceBroker::GetGameServices().GameSettings();
     gameSettings.SetShowOSDHelp(false);
   }
 }
diff --git a/xbmc/games/dialogs/osd/DialogGameOSD.h b/xbmc/games/dialogs/osd/DialogGameOSD.h
index 7a4cc77dfd31..3a8127b6095b 100644
--- a/xbmc/games/dialogs/osd/DialogGameOSD.h
+++ b/xbmc/games/dialogs/osd/DialogGameOSD.h
@@ -16,39 +16,39 @@ namespace KODI
 {
 namespace GAME
 {
-  class CDialogGameOSDHelp;
-
-  class CDialogGameOSD : public CGUIDialog
-  {
-  public:
-    CDialogGameOSD();
-
-    ~CDialogGameOSD() override = default;
-
-    // Implementation of CGUIControl via CGUIDialog
-    bool OnAction(const CAction &action) override;
-
-    // Implementation of CGUIWindow via CGUIDialog
-    void OnDeinitWindow(int nextWindowID) override;
-
-    /*!
-     * \brief Decide if the game should play behind the given dialog
-     *
-     * If true, the game should be played at regular speed.
-     *
-     * \param dialog The current dialog
-     *
-     * \return True if the game should be played at regular speed behind the
-     *         dialog, false otherwise
-     */
-    static bool PlayInBackground(int dialogId);
-
-  protected:
-    // Implementation of CGUIWindow via CGUIDialog
-    void OnInitWindow() override;
-
-  private:
-    std::unique_ptr<CDialogGameOSDHelp> m_helpDialog;
- };
-}
-}
+class CDialogGameOSDHelp;
+
+class CDialogGameOSD : public CGUIDialog
+{
+public:
+  CDialogGameOSD();
+
+  ~CDialogGameOSD() override = default;
+
+  // Implementation of CGUIControl via CGUIDialog
+  bool OnAction(const CAction& action) override;
+
+  // Implementation of CGUIWindow via CGUIDialog
+  void OnDeinitWindow(int nextWindowID) override;
+
+  /*!
+   * \brief Decide if the game should play behind the given dialog
+   *
+   * If true, the game should be played at regular speed.
+   *
+   * \param dialog The current dialog
+   *
+   * \return True if the game should be played at regular speed behind the
+   *         dialog, false otherwise
+   */
+  static bool PlayInBackground(int dialogId);
+
+protected:
+  // Implementation of CGUIWindow via CGUIDialog
+  void OnInitWindow() override;
+
+private:
+  std::unique_ptr<CDialogGameOSDHelp> m_helpDialog;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/osd/DialogGameOSDHelp.cpp b/xbmc/games/dialogs/osd/DialogGameOSDHelp.cpp
index e76799993d6d..315217210782 100644
--- a/xbmc/games/dialogs/osd/DialogGameOSDHelp.cpp
+++ b/xbmc/games/dialogs/osd/DialogGameOSDHelp.cpp
@@ -23,8 +23,7 @@ using namespace GAME;
 const int CDialogGameOSDHelp::CONTROL_ID_HELP_TEXT = 1101;
 const int CDialogGameOSDHelp::CONTROL_ID_GAME_CONTROLLER = 1102;
 
-CDialogGameOSDHelp::CDialogGameOSDHelp(CDialogGameOSD &dialog) :
-  m_dialog(dialog)
+CDialogGameOSDHelp::CDialogGameOSDHelp(CDialogGameOSD& dialog) : m_dialog(dialog)
 {
 }
 
@@ -49,7 +48,8 @@ void CDialogGameOSDHelp::OnInitWindow()
     if (controller)
     {
       //! @todo Activate controller for all game controller controls
-      CGUIGameController* guiController = dynamic_cast<CGUIGameController*>(m_dialog.GetControl(CONTROL_ID_GAME_CONTROLLER));
+      CGUIGameController* guiController =
+          dynamic_cast<CGUIGameController*>(m_dialog.GetControl(CONTROL_ID_GAME_CONTROLLER));
       if (guiController != nullptr)
         guiController->ActivateController(controller);
     }
@@ -58,13 +58,12 @@ void CDialogGameOSDHelp::OnInitWindow()
 
 bool CDialogGameOSDHelp::IsVisible()
 {
-  return IsVisible(CONTROL_ID_HELP_TEXT) ||
-         IsVisible(CONTROL_ID_GAME_CONTROLLER);
+  return IsVisible(CONTROL_ID_HELP_TEXT) || IsVisible(CONTROL_ID_GAME_CONTROLLER);
 }
 
 bool CDialogGameOSDHelp::IsVisible(int windowId)
 {
-  CGUIControl *control = m_dialog.GetControl(windowId);
+  CGUIControl* control = m_dialog.GetControl(windowId);
   if (control != nullptr)
     return control->IsVisible();
 
diff --git a/xbmc/games/dialogs/osd/DialogGameOSDHelp.h b/xbmc/games/dialogs/osd/DialogGameOSDHelp.h
index 3e8d37b4acdf..6153075613a9 100644
--- a/xbmc/games/dialogs/osd/DialogGameOSDHelp.h
+++ b/xbmc/games/dialogs/osd/DialogGameOSDHelp.h
@@ -12,29 +12,29 @@ namespace KODI
 {
 namespace GAME
 {
-  class CDialogGameOSD;
+class CDialogGameOSD;
 
-  class CDialogGameOSDHelp
-  {
-  public:
-    CDialogGameOSDHelp(CDialogGameOSD &dialog);
+class CDialogGameOSDHelp
+{
+public:
+  CDialogGameOSDHelp(CDialogGameOSD& dialog);
 
-    // Initialize help controls
-    void OnInitWindow();
+  // Initialize help controls
+  void OnInitWindow();
 
-    // Check if any help controls are visible
-    bool IsVisible();
+  // Check if any help controls are visible
+  bool IsVisible();
 
-  private:
-    // Utility functions
-    bool IsVisible(int windowId);
+private:
+  // Utility functions
+  bool IsVisible(int windowId);
 
-    // Construction parameters
-    CDialogGameOSD &m_dialog;
+  // Construction parameters
+  CDialogGameOSD& m_dialog;
 
-    // Help control IDs
-    static const int CONTROL_ID_HELP_TEXT;
-    static const int CONTROL_ID_GAME_CONTROLLER;
- };
-}
-}
+  // Help control IDs
+  static const int CONTROL_ID_HELP_TEXT;
+  static const int CONTROL_ID_GAME_CONTROLLER;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/osd/DialogGameStretchMode.cpp b/xbmc/games/dialogs/osd/DialogGameStretchMode.cpp
index 8e55993c1405..c4240ba7b635 100644
--- a/xbmc/games/dialogs/osd/DialogGameStretchMode.cpp
+++ b/xbmc/games/dialogs/osd/DialogGameStretchMode.cpp
@@ -20,17 +20,18 @@
 using namespace KODI;
 using namespace GAME;
 
-const std::vector<CDialogGameStretchMode::StretchModeProperties> CDialogGameStretchMode::m_allStretchModes =
-{
-  { 630,   RETRO::STRETCHMODE::Normal },
-//  { 631,   RETRO::STRETCHMODE::Zoom }, //! @todo RetroArch allows trimming some outer pixels
-  { 632,   RETRO::STRETCHMODE::Stretch4x3 },
-  { 35232, RETRO::STRETCHMODE::Fullscreen },
-  { 635,   RETRO::STRETCHMODE::Original },
+const std::vector<CDialogGameStretchMode::StretchModeProperties>
+    CDialogGameStretchMode::m_allStretchModes = {
+        {630, RETRO::STRETCHMODE::Normal},
+        //  { 631,   RETRO::STRETCHMODE::Zoom }, //! @todo RetroArch allows trimming some outer
+        //  pixels
+        {632, RETRO::STRETCHMODE::Stretch4x3},
+        {35232, RETRO::STRETCHMODE::Fullscreen},
+        {635, RETRO::STRETCHMODE::Original},
 };
 
-CDialogGameStretchMode::CDialogGameStretchMode() :
-  CDialogGameVideoSelect(WINDOW_DIALOG_GAME_STRETCH_MODE)
+CDialogGameStretchMode::CDialogGameStretchMode()
+  : CDialogGameVideoSelect(WINDOW_DIALOG_GAME_STRETCH_MODE)
 {
 }
 
@@ -43,7 +44,7 @@ void CDialogGameStretchMode::PreInit()
 {
   m_stretchModes.clear();
 
-  for (const auto &stretchMode : m_allStretchModes)
+  for (const auto& stretchMode : m_allStretchModes)
   {
     bool bSupported = false;
 
@@ -72,15 +73,16 @@ void CDialogGameStretchMode::PreInit()
   }
 }
 
-void CDialogGameStretchMode::GetItems(CFileItemList &items)
+void CDialogGameStretchMode::GetItems(CFileItemList& items)
 {
-  for (const auto &stretchMode : m_stretchModes)
+  for (const auto& stretchMode : m_stretchModes)
   {
     CFileItemPtr item = std::make_shared<CFileItem>(g_localizeStrings.Get(stretchMode.stringIndex));
 
-    const std::string stretchModeId = RETRO::CRetroPlayerUtils::StretchModeToIdentifier(stretchMode.stretchMode);
+    const std::string stretchModeId =
+        RETRO::CRetroPlayerUtils::StretchModeToIdentifier(stretchMode.stretchMode);
     if (!stretchModeId.empty())
-      item->SetProperty("game.stretchmode", CVariant{ stretchModeId });
+      item->SetProperty("game.stretchmode", CVariant{stretchModeId});
     items.Add(std::move(item));
   }
 }
@@ -91,7 +93,7 @@ void CDialogGameStretchMode::OnItemFocus(unsigned int index)
   {
     const RETRO::STRETCHMODE stretchMode = m_stretchModes[index].stretchMode;
 
-    CGameSettings &gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
+    CGameSettings& gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
     if (gameSettings.StretchMode() != stretchMode)
     {
       gameSettings.SetStretchMode(stretchMode);
@@ -102,7 +104,7 @@ void CDialogGameStretchMode::OnItemFocus(unsigned int index)
 
 unsigned int CDialogGameStretchMode::GetFocusedItem() const
 {
-  CGameSettings &gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
+  CGameSettings& gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
 
   for (unsigned int i = 0; i < m_stretchModes.size(); i++)
   {
diff --git a/xbmc/games/dialogs/osd/DialogGameStretchMode.h b/xbmc/games/dialogs/osd/DialogGameStretchMode.h
index cd6ab81d8f52..e7aa616e0671 100644
--- a/xbmc/games/dialogs/osd/DialogGameStretchMode.h
+++ b/xbmc/games/dialogs/osd/DialogGameStretchMode.h
@@ -17,34 +17,34 @@ namespace KODI
 {
 namespace GAME
 {
-  class CDialogGameStretchMode : public CDialogGameVideoSelect
+class CDialogGameStretchMode : public CDialogGameVideoSelect
+{
+public:
+  CDialogGameStretchMode();
+  ~CDialogGameStretchMode() override = default;
+
+protected:
+  // implementation of CDialogGameVideoSelect
+  std::string GetHeading() override;
+  void PreInit() override;
+  void GetItems(CFileItemList& items) override;
+  void OnItemFocus(unsigned int index) override;
+  unsigned int GetFocusedItem() const override;
+  void PostExit() override;
+
+private:
+  struct StretchModeProperties
   {
-  public:
-    CDialogGameStretchMode();
-    ~CDialogGameStretchMode() override = default;
-
-  protected:
-    // implementation of CDialogGameVideoSelect
-    std::string GetHeading() override;
-    void PreInit() override;
-    void GetItems(CFileItemList &items) override;
-    void OnItemFocus(unsigned int index) override;
-    unsigned int GetFocusedItem() const override;
-    void PostExit() override;
-
-  private:
-    struct StretchModeProperties
-    {
-      int stringIndex;
-      RETRO::STRETCHMODE stretchMode;
-    };
-
-    std::vector<StretchModeProperties> m_stretchModes;
-
-    /*!
-     * \brief The list of all the stretch modes along with their properties
-     */
-    static const std::vector<StretchModeProperties> m_allStretchModes;
+    int stringIndex;
+    RETRO::STRETCHMODE stretchMode;
   };
-}
-}
+
+  std::vector<StretchModeProperties> m_stretchModes;
+
+  /*!
+   * \brief The list of all the stretch modes along with their properties
+   */
+  static const std::vector<StretchModeProperties> m_allStretchModes;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/osd/DialogGameVideoFilter.cpp b/xbmc/games/dialogs/osd/DialogGameVideoFilter.cpp
index 730aa06de5e5..629930657d5a 100644
--- a/xbmc/games/dialogs/osd/DialogGameVideoFilter.cpp
+++ b/xbmc/games/dialogs/osd/DialogGameVideoFilter.cpp
@@ -22,23 +22,22 @@ using namespace GAME;
 
 namespace
 {
-  struct ScalingMethodProperties
-  {
-    int nameIndex;
-    int categoryIndex;
-    int descriptionIndex;
-    RETRO::SCALINGMETHOD scalingMethod;
-  };
-
-  const std::vector<ScalingMethodProperties> scalingMethods =
-  {
-    { 16301, 16296, 16298, RETRO::SCALINGMETHOD::NEAREST },
-    { 16302, 16297, 16299, RETRO::SCALINGMETHOD::LINEAR },
-  };
-}
-
-CDialogGameVideoFilter::CDialogGameVideoFilter() :
-  CDialogGameVideoSelect(WINDOW_DIALOG_GAME_VIDEO_FILTER)
+struct ScalingMethodProperties
+{
+  int nameIndex;
+  int categoryIndex;
+  int descriptionIndex;
+  RETRO::SCALINGMETHOD scalingMethod;
+};
+
+const std::vector<ScalingMethodProperties> scalingMethods = {
+    {16301, 16296, 16298, RETRO::SCALINGMETHOD::NEAREST},
+    {16302, 16297, 16299, RETRO::SCALINGMETHOD::LINEAR},
+};
+} // namespace
+
+CDialogGameVideoFilter::CDialogGameVideoFilter()
+  : CDialogGameVideoSelect(WINDOW_DIALOG_GAME_VIDEO_FILTER)
 {
 }
 
@@ -66,26 +65,28 @@ void CDialogGameVideoFilter::InitVideoFilters()
 {
   if (m_gameVideoHandle)
   {
-    for (const auto &scalingMethodProps : scalingMethods)
+    for (const auto& scalingMethodProps : scalingMethods)
     {
       if (m_gameVideoHandle->SupportsScalingMethod(scalingMethodProps.scalingMethod))
       {
         RETRO::CRenderVideoSettings videoSettings;
         videoSettings.SetScalingMethod(scalingMethodProps.scalingMethod);
 
-        CFileItemPtr item = std::make_shared<CFileItem>(g_localizeStrings.Get(scalingMethodProps.nameIndex));
+        CFileItemPtr item =
+            std::make_shared<CFileItem>(g_localizeStrings.Get(scalingMethodProps.nameIndex));
         item->SetLabel2(g_localizeStrings.Get(scalingMethodProps.categoryIndex));
-        item->SetProperty("game.videofilter", CVariant{ videoSettings.GetVideoFilter() });
-        item->SetProperty("game.videofilterdescription", CVariant{ g_localizeStrings.Get(scalingMethodProps.descriptionIndex) });
+        item->SetProperty("game.videofilter", CVariant{videoSettings.GetVideoFilter()});
+        item->SetProperty("game.videofilterdescription",
+                          CVariant{g_localizeStrings.Get(scalingMethodProps.descriptionIndex)});
         m_items.Add(std::move(item));
       }
     }
   }
 }
 
-void CDialogGameVideoFilter::GetItems(CFileItemList &items)
+void CDialogGameVideoFilter::GetItems(CFileItemList& items)
 {
-  for (const auto &item : m_items)
+  for (const auto& item : m_items)
     items.Add(item);
 }
 
@@ -99,7 +100,7 @@ void CDialogGameVideoFilter::OnItemFocus(unsigned int index)
     std::string description;
     GetProperties(*item, videoFilter, description);
 
-    CGameSettings &gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
+    CGameSettings& gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
 
     if (gameSettings.VideoFilter() != videoFilter)
     {
@@ -119,7 +120,7 @@ void CDialogGameVideoFilter::OnItemFocus(unsigned int index)
 
 unsigned int CDialogGameVideoFilter::GetFocusedItem() const
 {
-  CGameSettings &gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
+  CGameSettings& gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
 
   for (int i = 0; i < m_items.Size(); i++)
   {
@@ -141,7 +142,9 @@ void CDialogGameVideoFilter::PostExit()
   m_items.Clear();
 }
 
-void CDialogGameVideoFilter::GetProperties(const CFileItem &item, std::string &videoFilter, std::string &description)
+void CDialogGameVideoFilter::GetProperties(const CFileItem& item,
+                                           std::string& videoFilter,
+                                           std::string& description)
 {
   videoFilter = item.GetProperty("game.videofilter").asString();
   description = item.GetProperty("game.videofilterdescription").asString();
diff --git a/xbmc/games/dialogs/osd/DialogGameVideoFilter.h b/xbmc/games/dialogs/osd/DialogGameVideoFilter.h
index 1ba7eebc3904..49903e1e44ac 100644
--- a/xbmc/games/dialogs/osd/DialogGameVideoFilter.h
+++ b/xbmc/games/dialogs/osd/DialogGameVideoFilter.h
@@ -15,30 +15,32 @@ namespace KODI
 {
 namespace GAME
 {
-  class CDialogGameVideoFilter : public CDialogGameVideoSelect
-  {
-  public:
-    CDialogGameVideoFilter();
-    ~CDialogGameVideoFilter() override = default;
-
-  protected:
-    // implementation of CDialogGameVideoSelect
-    std::string GetHeading() override;
-    void PreInit() override;
-    void GetItems(CFileItemList &items) override;
-    void OnItemFocus(unsigned int index) override;
-    unsigned int GetFocusedItem() const override;
-    void PostExit() override;
-
-  private:
-    void InitVideoFilters();
-
-    static void GetProperties(const CFileItem &item, std::string &videoFilter, std::string &description);
-
-    CFileItemList m_items;
-
-    //! \brief Set to true when a description has first been set
-    bool m_bHasDescription = false;
-  };
-}
-}
+class CDialogGameVideoFilter : public CDialogGameVideoSelect
+{
+public:
+  CDialogGameVideoFilter();
+  ~CDialogGameVideoFilter() override = default;
+
+protected:
+  // implementation of CDialogGameVideoSelect
+  std::string GetHeading() override;
+  void PreInit() override;
+  void GetItems(CFileItemList& items) override;
+  void OnItemFocus(unsigned int index) override;
+  unsigned int GetFocusedItem() const override;
+  void PostExit() override;
+
+private:
+  void InitVideoFilters();
+
+  static void GetProperties(const CFileItem& item,
+                            std::string& videoFilter,
+                            std::string& description);
+
+  CFileItemList m_items;
+
+  //! \brief Set to true when a description has first been set
+  bool m_bHasDescription = false;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/osd/DialogGameVideoRotation.cpp b/xbmc/games/dialogs/osd/DialogGameVideoRotation.cpp
index b9e43ab72f12..185d60423faa 100644
--- a/xbmc/games/dialogs/osd/DialogGameVideoRotation.cpp
+++ b/xbmc/games/dialogs/osd/DialogGameVideoRotation.cpp
@@ -18,8 +18,8 @@
 using namespace KODI;
 using namespace GAME;
 
-CDialogGameVideoRotation::CDialogGameVideoRotation() :
-  CDialogGameVideoSelect(WINDOW_DIALOG_GAME_VIDEO_ROTATION)
+CDialogGameVideoRotation::CDialogGameVideoRotation()
+  : CDialogGameVideoSelect(WINDOW_DIALOG_GAME_VIDEO_ROTATION)
 {
 }
 
@@ -39,12 +39,12 @@ void CDialogGameVideoRotation::PreInit()
   m_rotations.push_back(90);
 }
 
-void CDialogGameVideoRotation::GetItems(CFileItemList &items)
+void CDialogGameVideoRotation::GetItems(CFileItemList& items)
 {
   for (unsigned int rotation : m_rotations)
   {
     CFileItemPtr item = std::make_shared<CFileItem>(GetRotationLabel(rotation));
-    item->SetProperty("game.videorotation", CVariant{ rotation });
+    item->SetProperty("game.videorotation", CVariant{rotation});
     items.Add(std::move(item));
   }
 }
@@ -55,7 +55,7 @@ void CDialogGameVideoRotation::OnItemFocus(unsigned int index)
   {
     const unsigned int rotationDegCCW = m_rotations[index];
 
-    CGameSettings &gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
+    CGameSettings& gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
     if (gameSettings.RotationDegCCW() != rotationDegCCW)
     {
       gameSettings.SetRotationDegCCW(rotationDegCCW);
@@ -66,7 +66,7 @@ void CDialogGameVideoRotation::OnItemFocus(unsigned int index)
 
 unsigned int CDialogGameVideoRotation::GetFocusedItem() const
 {
-  CGameSettings &gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
+  CGameSettings& gameSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
 
   for (unsigned int i = 0; i < m_rotations.size(); i++)
   {
@@ -87,16 +87,16 @@ std::string CDialogGameVideoRotation::GetRotationLabel(unsigned int rotationDegC
 {
   switch (rotationDegCCW)
   {
-  case 0:
-    return g_localizeStrings.Get(35228); // 0
-  case 90:
-    return g_localizeStrings.Get(35231); // 270
-  case 180:
-    return g_localizeStrings.Get(35230); // 180
-  case 270:
-    return g_localizeStrings.Get(35229); // 90
-  default:
-    break;
+    case 0:
+      return g_localizeStrings.Get(35228); // 0
+    case 90:
+      return g_localizeStrings.Get(35231); // 270
+    case 180:
+      return g_localizeStrings.Get(35230); // 180
+    case 270:
+      return g_localizeStrings.Get(35229); // 90
+    default:
+      break;
   }
 
   return "";
diff --git a/xbmc/games/dialogs/osd/DialogGameVideoRotation.h b/xbmc/games/dialogs/osd/DialogGameVideoRotation.h
index 19f108d47435..49f461b765c6 100644
--- a/xbmc/games/dialogs/osd/DialogGameVideoRotation.h
+++ b/xbmc/games/dialogs/osd/DialogGameVideoRotation.h
@@ -17,27 +17,27 @@ namespace KODI
 {
 namespace GAME
 {
-  class CDialogGameVideoRotation : public CDialogGameVideoSelect
-  {
-  public:
-    CDialogGameVideoRotation();
-    ~CDialogGameVideoRotation() override = default;
+class CDialogGameVideoRotation : public CDialogGameVideoSelect
+{
+public:
+  CDialogGameVideoRotation();
+  ~CDialogGameVideoRotation() override = default;
 
-  protected:
-    // implementation of CDialogGameVideoSelect
-    std::string GetHeading() override;
-    void PreInit() override;
-    void GetItems(CFileItemList &items) override;
-    void OnItemFocus(unsigned int index) override;
-    unsigned int GetFocusedItem() const override;
-    void PostExit() override;
+protected:
+  // implementation of CDialogGameVideoSelect
+  std::string GetHeading() override;
+  void PreInit() override;
+  void GetItems(CFileItemList& items) override;
+  void OnItemFocus(unsigned int index) override;
+  unsigned int GetFocusedItem() const override;
+  void PostExit() override;
 
-  private:
-    // Helper functions
-    static std::string GetRotationLabel(unsigned int rotationDegCCW);
+private:
+  // Helper functions
+  static std::string GetRotationLabel(unsigned int rotationDegCCW);
 
-    // Dialog parameters
-    std::vector<unsigned int> m_rotations; // Degrees counter-clockwise
-  };
-}
-}
+  // Dialog parameters
+  std::vector<unsigned int> m_rotations; // Degrees counter-clockwise
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/osd/DialogGameVideoSelect.cpp b/xbmc/games/dialogs/osd/DialogGameVideoSelect.cpp
index ece069a1d205..0e08cc69876d 100644
--- a/xbmc/games/dialogs/osd/DialogGameVideoSelect.cpp
+++ b/xbmc/games/dialogs/osd/DialogGameVideoSelect.cpp
@@ -29,14 +29,14 @@
 using namespace KODI;
 using namespace GAME;
 
-#define CONTROL_HEADING               1
-#define CONTROL_THUMBS                11
-#define CONTROL_DESCRIPTION           12
-
-CDialogGameVideoSelect::CDialogGameVideoSelect(int windowId) :
-  CGUIDialog(windowId, "DialogSelect.xml"),
-  m_viewControl(new CGUIViewControl),
-  m_vecItems(new CFileItemList)
+#define CONTROL_HEADING 1
+#define CONTROL_THUMBS 11
+#define CONTROL_DESCRIPTION 12
+
+CDialogGameVideoSelect::CDialogGameVideoSelect(int windowId)
+  : CGUIDialog(windowId, "DialogSelect.xml"),
+    m_viewControl(new CGUIViewControl),
+    m_vecItems(new CFileItemList)
 {
   // Initialize CGUIWindow
   m_loadType = KEEP_IN_MEMORY;
@@ -44,7 +44,7 @@ CDialogGameVideoSelect::CDialogGameVideoSelect(int windowId) :
 
 CDialogGameVideoSelect::~CDialogGameVideoSelect() = default;
 
-bool CDialogGameVideoSelect::OnMessage(CGUIMessage &message)
+bool CDialogGameVideoSelect::OnMessage(CGUIMessage& message)
 {
   switch (message.GetMessage())
   {
@@ -106,7 +106,7 @@ bool CDialogGameVideoSelect::OnMessage(CGUIMessage &message)
 
 void CDialogGameVideoSelect::FrameMove()
 {
-  CGUIBaseContainer *thumbs = dynamic_cast<CGUIBaseContainer*>(GetControl(CONTROL_THUMBS));
+  CGUIBaseContainer* thumbs = dynamic_cast<CGUIBaseContainer*>(GetControl(CONTROL_THUMBS));
   if (thumbs != nullptr)
     OnItemFocus(thumbs->GetSelectedItem());
 
@@ -160,7 +160,7 @@ void CDialogGameVideoSelect::Update()
 {
   //! @todo
   // Lock our display, as this window is rendered from the player thread
-  //CServiceBroker::GetWinSystem()->GetGfxContext().Lock();
+  // CServiceBroker::GetWinSystem()->GetGfxContext().Lock();
 
   m_viewControl->SetCurrentView(DEFAULT_VIEW_ICONS);
 
@@ -169,7 +169,7 @@ void CDialogGameVideoSelect::Update()
 
   OnRefreshList();
 
-  //CServiceBroker::GetWinSystem()->GetGfxContext().Unlock();
+  // CServiceBroker::GetWinSystem()->GetGfxContext().Unlock();
 }
 
 void CDialogGameVideoSelect::Clear()
@@ -193,8 +193,8 @@ void CDialogGameVideoSelect::OnRefreshList()
 
 void CDialogGameVideoSelect::SaveSettings()
 {
-  CGameSettings &defaultSettings = CMediaSettings::GetInstance().GetDefaultGameSettings();
-  CGameSettings &currentSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
+  CGameSettings& defaultSettings = CMediaSettings::GetInstance().GetDefaultGameSettings();
+  CGameSettings& currentSettings = CMediaSettings::GetInstance().GetCurrentGameSettings();
 
   if (defaultSettings != currentSettings)
   {
@@ -203,7 +203,7 @@ void CDialogGameVideoSelect::SaveSettings()
   }
 }
 
-void CDialogGameVideoSelect::OnDescriptionChange(const std::string &description)
+void CDialogGameVideoSelect::OnDescriptionChange(const std::string& description)
 {
   CGUIMessage msg(GUI_MSG_LABEL_SET, GetID(), CONTROL_DESCRIPTION);
   msg.SetLabel(description);
diff --git a/xbmc/games/dialogs/osd/DialogGameVideoSelect.h b/xbmc/games/dialogs/osd/DialogGameVideoSelect.h
index b23b2166094a..dea96b8da43b 100644
--- a/xbmc/games/dialogs/osd/DialogGameVideoSelect.h
+++ b/xbmc/games/dialogs/osd/DialogGameVideoSelect.h
@@ -19,56 +19,56 @@ namespace KODI
 {
 namespace RETRO
 {
-  class CGUIGameVideoHandle;
+class CGUIGameVideoHandle;
 }
 
 namespace GAME
 {
-  class CDialogGameVideoSelect : public CGUIDialog
-  {
-  public:
-    ~CDialogGameVideoSelect() override;
+class CDialogGameVideoSelect : public CGUIDialog
+{
+public:
+  ~CDialogGameVideoSelect() override;
 
-    // implementation of CGUIControl via CGUIDialog
-    bool OnMessage(CGUIMessage &message) override;
+  // implementation of CGUIControl via CGUIDialog
+  bool OnMessage(CGUIMessage& message) override;
 
-    // implementation of CGUIWindow via CGUIDialog
-    void FrameMove() override;
-    void OnDeinitWindow(int nextWindowID) override;
+  // implementation of CGUIWindow via CGUIDialog
+  void FrameMove() override;
+  void OnDeinitWindow(int nextWindowID) override;
 
-  protected:
-    CDialogGameVideoSelect(int windowId);
+protected:
+  CDialogGameVideoSelect(int windowId);
 
-    // implementation of CGUIWindow via CGUIDialog
-    void OnWindowUnload() override;
-    void OnWindowLoaded() override;
-    void OnInitWindow() override;
+  // implementation of CGUIWindow via CGUIDialog
+  void OnWindowUnload() override;
+  void OnWindowLoaded() override;
+  void OnInitWindow() override;
 
-    // Video select interface
-    virtual std::string GetHeading() = 0;
-    virtual void PreInit() = 0;
-    virtual void GetItems(CFileItemList &items) = 0;
-    virtual void OnItemFocus(unsigned int index) = 0;
-    virtual unsigned int GetFocusedItem() const = 0;
-    virtual void PostExit() = 0;
+  // Video select interface
+  virtual std::string GetHeading() = 0;
+  virtual void PreInit() = 0;
+  virtual void GetItems(CFileItemList& items) = 0;
+  virtual void OnItemFocus(unsigned int index) = 0;
+  virtual unsigned int GetFocusedItem() const = 0;
+  virtual void PostExit() = 0;
 
-    void OnDescriptionChange(const std::string &description);
+  void OnDescriptionChange(const std::string& description);
 
-    std::shared_ptr<RETRO::CGUIGameVideoHandle> m_gameVideoHandle;
+  std::shared_ptr<RETRO::CGUIGameVideoHandle> m_gameVideoHandle;
 
-  private:
-    void Update();
-    void Clear();
+private:
+  void Update();
+  void Clear();
 
-    void OnRefreshList();
+  void OnRefreshList();
 
-    void SaveSettings();
+  void SaveSettings();
 
-    void RegisterDialog();
-    void UnregisterDialog();
+  void RegisterDialog();
+  void UnregisterDialog();
 
-    std::unique_ptr<CGUIViewControl> m_viewControl;
-    std::unique_ptr<CFileItemList> m_vecItems;
-  };
-}
-}
+  std::unique_ptr<CGUIViewControl> m_viewControl;
+  std::unique_ptr<CFileItemList> m_vecItems;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/dialogs/osd/DialogGameVolume.cpp b/xbmc/games/dialogs/osd/DialogGameVolume.cpp
index 6b228a3ef160..0d38a6adb24a 100644
--- a/xbmc/games/dialogs/osd/DialogGameVolume.cpp
+++ b/xbmc/games/dialogs/osd/DialogGameVolume.cpp
@@ -26,7 +26,7 @@
 using namespace KODI;
 using namespace GAME;
 
-#define CONTROL_LABEL   12 //! @todo Remove me
+#define CONTROL_LABEL 12 //! @todo Remove me
 
 CDialogGameVolume::CDialogGameVolume()
 {
@@ -35,7 +35,7 @@ CDialogGameVolume::CDialogGameVolume()
   m_loadType = KEEP_IN_MEMORY;
 }
 
-bool CDialogGameVolume::OnMessage(CGUIMessage &message)
+bool CDialogGameVolume::OnMessage(CGUIMessage& message)
 {
   switch (message.GetMessage())
   {
@@ -69,7 +69,8 @@ void CDialogGameVolume::OnInitWindow()
 
   SET_CONTROL_HIDDEN(CONTROL_LABEL);
 
-  CGUIDialogVolumeBar *dialogVolumeBar = dynamic_cast<CGUIDialogVolumeBar*>(CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_VOLUME_BAR));
+  CGUIDialogVolumeBar* dialogVolumeBar = dynamic_cast<CGUIDialogVolumeBar*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_VOLUME_BAR));
   if (dialogVolumeBar != nullptr)
     dialogVolumeBar->RegisterCallback(this);
 
@@ -80,14 +81,15 @@ void CDialogGameVolume::OnDeinitWindow(int nextWindowID)
 {
   CServiceBroker::GetAnnouncementManager()->RemoveAnnouncer(this);
 
-  CGUIDialogVolumeBar *dialogVolumeBar = dynamic_cast<CGUIDialogVolumeBar*>(CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_VOLUME_BAR));
+  CGUIDialogVolumeBar* dialogVolumeBar = dynamic_cast<CGUIDialogVolumeBar*>(
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow(WINDOW_DIALOG_VOLUME_BAR));
   if (dialogVolumeBar != nullptr)
     dialogVolumeBar->UnregisterCallback(this);
 
   CGUIDialogSlider::OnDeinitWindow(nextWindowID);
 }
 
-void CDialogGameVolume::OnSliderChange(void *data, CGUISliderControl *slider)
+void CDialogGameVolume::OnSliderChange(void* data, CGUISliderControl* slider)
 {
   const float volumePercent = slider->GetFloatValue();
 
@@ -103,7 +105,10 @@ bool CDialogGameVolume::IsShown() const
   return m_active;
 }
 
-void CDialogGameVolume::Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data)
+void CDialogGameVolume::Announce(ANNOUNCEMENT::AnnouncementFlag flag,
+                                 const char* sender,
+                                 const char* message,
+                                 const CVariant& data)
 {
   if (flag == ANNOUNCEMENT::Application && strcmp(message, "OnVolumeChanged") == 0)
   {
diff --git a/xbmc/games/dialogs/osd/DialogGameVolume.h b/xbmc/games/dialogs/osd/DialogGameVolume.h
index 89f853360ed8..07d7f5b8f1eb 100644
--- a/xbmc/games/dialogs/osd/DialogGameVolume.h
+++ b/xbmc/games/dialogs/osd/DialogGameVolume.h
@@ -20,58 +20,61 @@ namespace KODI
 
 namespace GAME
 {
-  class CDialogGameVolume : public CGUIDialogSlider, // GUI interface
-                            public ISliderCallback, // GUI callback
-                            public IGUIVolumeBarCallback, // Volume bar dialog callback
-                            public ANNOUNCEMENT::IAnnouncer // Application callback
-  {
-  public:
-    CDialogGameVolume();
-    ~CDialogGameVolume() override = default;
+class CDialogGameVolume : public CGUIDialogSlider, // GUI interface
+                          public ISliderCallback, // GUI callback
+                          public IGUIVolumeBarCallback, // Volume bar dialog callback
+                          public ANNOUNCEMENT::IAnnouncer // Application callback
+{
+public:
+  CDialogGameVolume();
+  ~CDialogGameVolume() override = default;
 
-    // implementation of CGUIControl via CGUIDialogSlider
-    bool OnMessage(CGUIMessage &message) override;
+  // implementation of CGUIControl via CGUIDialogSlider
+  bool OnMessage(CGUIMessage& message) override;
 
-    // implementation of CGUIWindow via CGUIDialogSlider
-    void OnDeinitWindow(int nextWindowID) override;
+  // implementation of CGUIWindow via CGUIDialogSlider
+  void OnDeinitWindow(int nextWindowID) override;
 
-    // implementation of ISliderCallback
-    void OnSliderChange(void *data, CGUISliderControl *slider) override;
+  // implementation of ISliderCallback
+  void OnSliderChange(void* data, CGUISliderControl* slider) override;
 
-    // implementation of IGUIVolumeBarCallback
-    bool IsShown() const override;
+  // implementation of IGUIVolumeBarCallback
+  bool IsShown() const override;
 
-    // implementation of IAnnouncer
-    void Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data) override;
+  // implementation of IAnnouncer
+  void Announce(ANNOUNCEMENT::AnnouncementFlag flag,
+                const char* sender,
+                const char* message,
+                const CVariant& data) override;
 
-  protected:
-    // implementation of CGUIWindow via CGUIDialogSlider
-    void OnInitWindow() override;
+protected:
+  // implementation of CGUIWindow via CGUIDialogSlider
+  void OnInitWindow() override;
 
-  private:
-    /*!
-     * \brief Call when state change message is received
-     */
-    void OnStateChanged();
+private:
+  /*!
+   * \brief Call when state change message is received
+   */
+  void OnStateChanged();
 
-    /*!
-     * \brief Get the volume of the first callback
-     *
-     * \return The volume, as a fraction of maximum volume
-     */
-    float GetVolumePercent() const;
+  /*!
+   * \brief Get the volume of the first callback
+   *
+   * \return The volume, as a fraction of maximum volume
+   */
+  float GetVolumePercent() const;
 
-    /*!
-     * \brief Get the volume bar label
-     */
-    static std::string GetLabel();
+  /*!
+   * \brief Get the volume bar label
+   */
+  static std::string GetLabel();
 
-    // Volume parameters
-    const float VOLUME_MIN = 0.0f;
-    const float VOLUME_DELTA = 10.0f;
-    const float VOLUME_MAX = 100.0f;
-    float m_volumePercent = 100.0f;
-    float m_oldVolumePercent = 100.0f;
-  };
-}
-}
+  // Volume parameters
+  const float VOLUME_MIN = 0.0f;
+  const float VOLUME_DELTA = 10.0f;
+  const float VOLUME_MAX = 100.0f;
+  float m_volumePercent = 100.0f;
+  float m_oldVolumePercent = 100.0f;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/ports/InputSink.cpp b/xbmc/games/ports/InputSink.cpp
index acc921a53749..a48b4b988079 100644
--- a/xbmc/games/ports/InputSink.cpp
+++ b/xbmc/games/ports/InputSink.cpp
@@ -13,8 +13,7 @@
 using namespace KODI;
 using namespace GAME;
 
-CInputSink::CInputSink(JOYSTICK::IInputHandler* gameInput) :
-  m_gameInput(gameInput)
+CInputSink::CInputSink(JOYSTICK::IInputHandler* gameInput) : m_gameInput(gameInput)
 {
 }
 
@@ -33,12 +32,17 @@ bool CInputSink::OnButtonPress(const std::string& feature, bool bPressed)
   return true;
 }
 
-bool CInputSink::OnButtonMotion(const std::string& feature, float magnitude, unsigned int motionTimeMs)
+bool CInputSink::OnButtonMotion(const std::string& feature,
+                                float magnitude,
+                                unsigned int motionTimeMs)
 {
   return true;
 }
 
-bool CInputSink::OnAnalogStickMotion(const std::string& feature, float x, float y, unsigned int motionTimeMs)
+bool CInputSink::OnAnalogStickMotion(const std::string& feature,
+                                     float x,
+                                     float y,
+                                     unsigned int motionTimeMs)
 {
   return true;
 }
@@ -48,12 +52,16 @@ bool CInputSink::OnAccelerometerMotion(const std::string& feature, float x, floa
   return true;
 }
 
-bool CInputSink::OnWheelMotion(const std::string& feature, float position, unsigned int motionTimeMs)
+bool CInputSink::OnWheelMotion(const std::string& feature,
+                               float position,
+                               unsigned int motionTimeMs)
 {
   return true;
 }
 
-bool CInputSink::OnThrottleMotion(const std::string& feature, float position, unsigned int motionTimeMs)
+bool CInputSink::OnThrottleMotion(const std::string& feature,
+                                  float position,
+                                  unsigned int motionTimeMs)
 {
   return true;
 }
diff --git a/xbmc/games/ports/InputSink.h b/xbmc/games/ports/InputSink.h
index fafe62f7ff32..bd2d629dc3c8 100644
--- a/xbmc/games/ports/InputSink.h
+++ b/xbmc/games/ports/InputSink.h
@@ -14,30 +14,39 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameClient;
+class CGameClient;
 
-  class CInputSink : public JOYSTICK::IInputHandler
-  {
-  public:
-    explicit CInputSink(JOYSTICK::IInputHandler* gameInput);
+class CInputSink : public JOYSTICK::IInputHandler
+{
+public:
+  explicit CInputSink(JOYSTICK::IInputHandler* gameInput);
 
-    ~CInputSink() override = default;
+  ~CInputSink() override = default;
 
-    // Implementation of IInputHandler
-    std::string ControllerID() const override;
-    bool HasFeature(const std::string& feature) const override { return true; }
-    bool AcceptsInput(const std::string& feature) const override;
-    bool OnButtonPress(const std::string& feature, bool bPressed) override;
-    void OnButtonHold(const std::string& feature, unsigned int holdTimeMs) override {}
-    bool OnButtonMotion(const std::string& feature, float magnitude, unsigned int motionTimeMs) override;
-    bool OnAnalogStickMotion(const std::string& feature, float x, float y, unsigned int motionTimeMs) override;
-    bool OnAccelerometerMotion(const std::string& feature, float x, float y, float z) override;
-    bool OnWheelMotion(const std::string& feature, float position, unsigned int motionTimeMs) override;
-    bool OnThrottleMotion(const std::string& feature, float position, unsigned int motionTimeMs) override;
+  // Implementation of IInputHandler
+  std::string ControllerID() const override;
+  bool HasFeature(const std::string& feature) const override { return true; }
+  bool AcceptsInput(const std::string& feature) const override;
+  bool OnButtonPress(const std::string& feature, bool bPressed) override;
+  void OnButtonHold(const std::string& feature, unsigned int holdTimeMs) override {}
+  bool OnButtonMotion(const std::string& feature,
+                      float magnitude,
+                      unsigned int motionTimeMs) override;
+  bool OnAnalogStickMotion(const std::string& feature,
+                           float x,
+                           float y,
+                           unsigned int motionTimeMs) override;
+  bool OnAccelerometerMotion(const std::string& feature, float x, float y, float z) override;
+  bool OnWheelMotion(const std::string& feature,
+                     float position,
+                     unsigned int motionTimeMs) override;
+  bool OnThrottleMotion(const std::string& feature,
+                        float position,
+                        unsigned int motionTimeMs) override;
 
-  private:
-    // Construction parameters
-    JOYSTICK::IInputHandler* m_gameInput;
-  };
-}
-}
+private:
+  // Construction parameters
+  JOYSTICK::IInputHandler* m_gameInput;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/ports/Port.cpp b/xbmc/games/ports/Port.cpp
index 289393538a74..855d5d2492a6 100644
--- a/xbmc/games/ports/Port.cpp
+++ b/xbmc/games/ports/Port.cpp
@@ -17,15 +17,14 @@
 using namespace KODI;
 using namespace GAME;
 
-CPort::CPort(JOYSTICK::IInputHandler *gameInput) :
-  m_gameInput(gameInput),
-  m_inputSink(new CInputSink(gameInput))
+CPort::CPort(JOYSTICK::IInputHandler* gameInput)
+  : m_gameInput(gameInput), m_inputSink(new CInputSink(gameInput))
 {
 }
 
 CPort::~CPort() = default;
 
-void CPort::RegisterInput(JOYSTICK::IInputProvider *provider)
+void CPort::RegisterInput(JOYSTICK::IInputProvider* provider)
 {
   // Give input sink the lowest priority by registering it before the other
   // input handlers
@@ -38,7 +37,7 @@ void CPort::RegisterInput(JOYSTICK::IInputProvider *provider)
   m_appInput.reset(new JOYSTICK::CKeymapHandling(provider, false, this));
 }
 
-void CPort::UnregisterInput(JOYSTICK::IInputProvider *provider)
+void CPort::UnregisterInput(JOYSTICK::IInputProvider* provider)
 {
   // Unregister in reverse order
   if (provider == nullptr)
@@ -83,7 +82,10 @@ bool CPort::OnButtonMotion(const std::string& feature, float magnitude, unsigned
   return m_gameInput->OnButtonMotion(feature, magnitude, motionTimeMs);
 }
 
-bool CPort::OnAnalogStickMotion(const std::string& feature, float x, float y, unsigned int motionTimeMs)
+bool CPort::OnAnalogStickMotion(const std::string& feature,
+                                float x,
+                                float y,
+                                unsigned int motionTimeMs)
 {
   if ((x != 0.0f || y != 0.0f) && !m_gameInput->AcceptsInput(feature))
     return false;
diff --git a/xbmc/games/ports/Port.h b/xbmc/games/ports/Port.h
index eea8e2e905cd..a65ce9e28e54 100644
--- a/xbmc/games/ports/Port.h
+++ b/xbmc/games/ports/Port.h
@@ -17,52 +17,60 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class CKeymapHandling;
-  class IInputProvider;
-}
+class CKeymapHandling;
+class IInputProvider;
+} // namespace JOYSTICK
 
 namespace GAME
 {
-  class CPort : public JOYSTICK::IInputHandler,
-                public IKeymapEnvironment
-  {
-  public:
-    CPort(JOYSTICK::IInputHandler* gameInput);
-    ~CPort() override;
+class CPort : public JOYSTICK::IInputHandler, public IKeymapEnvironment
+{
+public:
+  CPort(JOYSTICK::IInputHandler* gameInput);
+  ~CPort() override;
 
-    void RegisterInput(JOYSTICK::IInputProvider *provider);
-    void UnregisterInput(JOYSTICK::IInputProvider *provider);
+  void RegisterInput(JOYSTICK::IInputProvider* provider);
+  void UnregisterInput(JOYSTICK::IInputProvider* provider);
 
-    JOYSTICK::IInputHandler *InputHandler() { return m_gameInput; }
+  JOYSTICK::IInputHandler* InputHandler() { return m_gameInput; }
 
-    // Implementation of IInputHandler
-    std::string ControllerID() const override;
-    bool HasFeature(const std::string& feature) const override { return true; }
-    bool AcceptsInput(const std::string& feature) const override;
-    bool OnButtonPress(const std::string& feature, bool bPressed) override;
-    void OnButtonHold(const std::string& feature, unsigned int holdTimeMs) override;
-    bool OnButtonMotion(const std::string& feature, float magnitude, unsigned int motionTimeMs) override;
-    bool OnAnalogStickMotion(const std::string& feature, float x, float y, unsigned int motionTimeMs) override;
-    bool OnAccelerometerMotion(const std::string& feature, float x, float y, float z) override;
-    bool OnWheelMotion(const std::string& feature, float position, unsigned int motionTimeMs) override;
-    bool OnThrottleMotion(const std::string& feature, float position, unsigned int motionTimeMs) override;
+  // Implementation of IInputHandler
+  std::string ControllerID() const override;
+  bool HasFeature(const std::string& feature) const override { return true; }
+  bool AcceptsInput(const std::string& feature) const override;
+  bool OnButtonPress(const std::string& feature, bool bPressed) override;
+  void OnButtonHold(const std::string& feature, unsigned int holdTimeMs) override;
+  bool OnButtonMotion(const std::string& feature,
+                      float magnitude,
+                      unsigned int motionTimeMs) override;
+  bool OnAnalogStickMotion(const std::string& feature,
+                           float x,
+                           float y,
+                           unsigned int motionTimeMs) override;
+  bool OnAccelerometerMotion(const std::string& feature, float x, float y, float z) override;
+  bool OnWheelMotion(const std::string& feature,
+                     float position,
+                     unsigned int motionTimeMs) override;
+  bool OnThrottleMotion(const std::string& feature,
+                        float position,
+                        unsigned int motionTimeMs) override;
 
-    // Implementation of IKeymapEnvironment
-    int GetWindowID() const override;
-    void SetWindowID(int windowId) override {}
-    int GetFallthrough(int windowId) const override { return -1; }
-    bool UseGlobalFallthrough() const override { return false; }
-    bool UseEasterEgg() const override { return false; }
+  // Implementation of IKeymapEnvironment
+  int GetWindowID() const override;
+  void SetWindowID(int windowId) override {}
+  int GetFallthrough(int windowId) const override { return -1; }
+  bool UseGlobalFallthrough() const override { return false; }
+  bool UseEasterEgg() const override { return false; }
 
-  private:
-    // Construction parameters
-    JOYSTICK::IInputHandler* const m_gameInput;
+private:
+  // Construction parameters
+  JOYSTICK::IInputHandler* const m_gameInput;
 
-    // Handles input to Kodi
-    std::unique_ptr<JOYSTICK::CKeymapHandling> m_appInput;
+  // Handles input to Kodi
+  std::unique_ptr<JOYSTICK::CKeymapHandling> m_appInput;
 
-    // Prevents input falling through to Kodi when not handled by the game
-    std::unique_ptr<JOYSTICK::IInputHandler> m_inputSink;
-  };
-}
-}
+  // Prevents input falling through to Kodi when not handled by the game
+  std::unique_ptr<JOYSTICK::IInputHandler> m_inputSink;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/tags/GameInfoTag.cpp b/xbmc/games/tags/GameInfoTag.cpp
index b3c8239064c3..8a02c2c87c17 100644
--- a/xbmc/games/tags/GameInfoTag.cpp
+++ b/xbmc/games/tags/GameInfoTag.cpp
@@ -38,20 +38,20 @@ CGameInfoTag& CGameInfoTag::operator=(const CGameInfoTag& tag)
 {
   if (this != &tag)
   {
-    m_bLoaded          = tag.m_bLoaded;
-    m_strURL           = tag.m_strURL;
-    m_strTitle         = tag.m_strTitle;
-    m_strPlatform      = tag.m_strPlatform;
-    m_genres           = tag.m_genres;
-    m_strDeveloper     = tag.m_strDeveloper;
-    m_strOverview      = tag.m_strOverview;
-    m_year             = tag.m_year;
-    m_strID            = tag.m_strID;
-    m_strRegion        = tag.m_strRegion;
-    m_strPublisher     = tag.m_strPublisher;
-    m_strFormat        = tag.m_strFormat;
+    m_bLoaded = tag.m_bLoaded;
+    m_strURL = tag.m_strURL;
+    m_strTitle = tag.m_strTitle;
+    m_strPlatform = tag.m_strPlatform;
+    m_genres = tag.m_genres;
+    m_strDeveloper = tag.m_strDeveloper;
+    m_strOverview = tag.m_strOverview;
+    m_year = tag.m_year;
+    m_strID = tag.m_strID;
+    m_strRegion = tag.m_strRegion;
+    m_strPublisher = tag.m_strPublisher;
+    m_strFormat = tag.m_strFormat;
     m_strCartridgeType = tag.m_strCartridgeType;
-    m_strGameClient    = tag.m_strGameClient;
+    m_strGameClient = tag.m_strGameClient;
   }
   return *this;
 }
@@ -65,19 +65,32 @@ bool CGameInfoTag::operator==(const CGameInfoTag& tag) const
 
     if (m_bLoaded)
     {
-      if (m_strURL           != tag.m_strURL)           return false;
-      if (m_strTitle         != tag.m_strTitle)         return false;
-      if (m_strPlatform      != tag.m_strPlatform)      return false;
-      if (m_genres           != tag.m_genres)           return false;
-      if (m_strDeveloper     != tag.m_strDeveloper)     return false;
-      if (m_strOverview      != tag.m_strOverview)      return false;
-      if (m_year             != tag.m_year)             return false;
-      if (m_strID            != tag.m_strID)            return false;
-      if (m_strRegion        != tag.m_strRegion)        return false;
-      if (m_strPublisher     != tag.m_strPublisher)     return false;
-      if (m_strFormat        != tag.m_strFormat)        return false;
-      if (m_strCartridgeType != tag.m_strCartridgeType) return false;
-      if (m_strGameClient    != tag.m_strGameClient)    return false;
+      if (m_strURL != tag.m_strURL)
+        return false;
+      if (m_strTitle != tag.m_strTitle)
+        return false;
+      if (m_strPlatform != tag.m_strPlatform)
+        return false;
+      if (m_genres != tag.m_genres)
+        return false;
+      if (m_strDeveloper != tag.m_strDeveloper)
+        return false;
+      if (m_strOverview != tag.m_strOverview)
+        return false;
+      if (m_year != tag.m_year)
+        return false;
+      if (m_strID != tag.m_strID)
+        return false;
+      if (m_strRegion != tag.m_strRegion)
+        return false;
+      if (m_strPublisher != tag.m_strPublisher)
+        return false;
+      if (m_strFormat != tag.m_strFormat)
+        return false;
+      if (m_strCartridgeType != tag.m_strCartridgeType)
+        return false;
+      if (m_strGameClient != tag.m_strGameClient)
+        return false;
     }
   }
   return true;
@@ -123,20 +136,20 @@ void CGameInfoTag::Archive(CArchive& ar)
 
 void CGameInfoTag::Serialize(CVariant& value) const
 {
-  value["loaded"]        = m_bLoaded;
-  value["url"]           = m_strURL;
-  value["name"]          = m_strTitle;
-  value["platform"]      = m_strPlatform;
-  value["genres"]        = m_genres;
-  value["developer"]     = m_strDeveloper;
-  value["overview"]      = m_strOverview;
-  value["year"]          = m_year;
-  value["id"]            = m_strID;
-  value["region"]        = m_strRegion;
-  value["publisher"]     = m_strPublisher;
-  value["format"]        = m_strFormat;
+  value["loaded"] = m_bLoaded;
+  value["url"] = m_strURL;
+  value["name"] = m_strTitle;
+  value["platform"] = m_strPlatform;
+  value["genres"] = m_genres;
+  value["developer"] = m_strDeveloper;
+  value["overview"] = m_strOverview;
+  value["year"] = m_year;
+  value["id"] = m_strID;
+  value["region"] = m_strRegion;
+  value["publisher"] = m_strPublisher;
+  value["format"] = m_strFormat;
   value["cartridgetype"] = m_strCartridgeType;
-  value["gameclient"]    = m_strGameClient;
+  value["gameclient"] = m_strGameClient;
 }
 
 void CGameInfoTag::ToSortable(SortItem& sortable, Field field) const
diff --git a/xbmc/games/tags/GameInfoTag.h b/xbmc/games/tags/GameInfoTag.h
index d3d45dbf20a4..00287ad18bf5 100644
--- a/xbmc/games/tags/GameInfoTag.h
+++ b/xbmc/games/tags/GameInfoTag.h
@@ -18,94 +18,95 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGameInfoTag : public IArchivable,
-                       public ISerializable,
-                       public ISortable
+class CGameInfoTag : public IArchivable, public ISerializable, public ISortable
+{
+public:
+  CGameInfoTag() { Reset(); }
+  CGameInfoTag(const CGameInfoTag& tag) { *this = tag; }
+  CGameInfoTag& operator=(const CGameInfoTag& tag);
+  virtual ~CGameInfoTag() = default;
+  void Reset();
+
+  bool operator==(const CGameInfoTag& tag) const;
+  bool operator!=(const CGameInfoTag& tag) const { return !(*this == tag); }
+
+  bool IsLoaded() const { return m_bLoaded; }
+  void SetLoaded(bool bOnOff = true) { m_bLoaded = bOnOff; }
+
+  // File path
+  const std::string& GetURL() const { return m_strURL; }
+  void SetURL(const std::string& strURL) { m_strURL = strURL; }
+
+  // Title
+  const std::string& GetTitle() const { return m_strTitle; }
+  void SetTitle(const std::string& strTitle) { m_strTitle = strTitle; }
+
+  // Platform
+  const std::string& GetPlatform() const { return m_strPlatform; }
+  void SetPlatform(const std::string& strPlatform) { m_strPlatform = strPlatform; }
+
+  // Genres
+  const std::vector<std::string>& GetGenres() const { return m_genres; }
+  void SetGenres(const std::vector<std::string>& genres) { m_genres = genres; }
+
+  // Developer
+  const std::string& GetDeveloper() const { return m_strDeveloper; }
+  void SetDeveloper(const std::string& strDeveloper) { m_strDeveloper = strDeveloper; }
+
+  // Overview
+  const std::string& GetOverview() const { return m_strOverview; }
+  void SetOverview(const std::string& strOverview) { m_strOverview = strOverview; }
+
+  // Year
+  unsigned int GetYear() const { return m_year; }
+  void SetYear(unsigned int year) { m_year = year; }
+
+  // Game Code (ID)
+  const std::string& GetID() const { return m_strID; }
+  void SetID(const std::string& strID) { m_strID = strID; }
+
+  // Region
+  const std::string& GetRegion() const { return m_strRegion; }
+  void SetRegion(const std::string& strRegion) { m_strRegion = strRegion; }
+
+  // Publisher / Licensee
+  const std::string& GetPublisher() const { return m_strPublisher; }
+  void SetPublisher(const std::string& strPublisher) { m_strPublisher = strPublisher; }
+
+  // Format (PAL/NTSC)
+  const std::string& GetFormat() const { return m_strFormat; }
+  void SetFormat(const std::string& strFormat) { m_strFormat = strFormat; }
+
+  // Cartridge Type, e.g. "ROM+MBC5+RAM+BATT" or "CD"
+  const std::string& GetCartridgeType() const { return m_strCartridgeType; }
+  void SetCartridgeType(const std::string& strCartridgeType)
   {
-  public:
-    CGameInfoTag() { Reset(); }
-    CGameInfoTag(const CGameInfoTag& tag) { *this = tag; }
-    CGameInfoTag& operator=(const CGameInfoTag& tag);
-    virtual ~CGameInfoTag() = default;
-    void Reset();
-
-    bool operator==(const CGameInfoTag& tag) const;
-    bool operator!=(const CGameInfoTag& tag) const { return !(*this == tag); }
-
-    bool IsLoaded() const { return m_bLoaded; }
-    void SetLoaded(bool bOnOff = true) { m_bLoaded = bOnOff; }
-
-    // File path
-    const std::string& GetURL() const { return m_strURL; }
-    void SetURL(const std::string& strURL) { m_strURL = strURL; }
-
-    // Title
-    const std::string& GetTitle() const { return m_strTitle; }
-    void SetTitle(const std::string& strTitle) { m_strTitle = strTitle; }
-
-    // Platform
-    const std::string& GetPlatform() const { return m_strPlatform; }
-    void SetPlatform(const std::string& strPlatform) { m_strPlatform = strPlatform; }
-
-    // Genres
-    const std::vector<std::string>& GetGenres() const { return m_genres; }
-    void SetGenres(const std::vector<std::string>& genres) { m_genres = genres; }
-
-    // Developer
-    const std::string& GetDeveloper() const { return m_strDeveloper; }
-    void SetDeveloper(const std::string& strDeveloper) { m_strDeveloper = strDeveloper; }
-
-    // Overview
-    const std::string& GetOverview() const { return m_strOverview; }
-    void SetOverview(const std::string& strOverview) { m_strOverview = strOverview; }
-
-    // Year
-    unsigned int GetYear() const { return m_year; }
-    void SetYear(unsigned int year) { m_year = year; }
-
-    // Game Code (ID)
-    const std::string& GetID() const { return m_strID; }
-    void SetID(const std::string& strID) { m_strID = strID; }
-
-    // Region
-    const std::string& GetRegion() const { return m_strRegion; }
-    void SetRegion(const std::string& strRegion) { m_strRegion = strRegion; }
-
-    // Publisher / Licensee
-    const std::string& GetPublisher() const { return m_strPublisher; }
-    void SetPublisher(const std::string& strPublisher) { m_strPublisher = strPublisher; }
-
-    // Format (PAL/NTSC)
-    const std::string& GetFormat() const { return m_strFormat; }
-    void SetFormat(const std::string& strFormat) { m_strFormat = strFormat; }
-
-    // Cartridge Type, e.g. "ROM+MBC5+RAM+BATT" or "CD"
-    const std::string& GetCartridgeType() const { return m_strCartridgeType; }
-    void SetCartridgeType(const std::string& strCartridgeType) { m_strCartridgeType = strCartridgeType; }
-
-    // Game client add-on ID
-    const std::string& GetGameClient() const { return m_strGameClient; }
-    void SetGameClient(const std::string& strGameClient) { m_strGameClient = strGameClient; }
-
-    void Archive(CArchive& ar) override;
-    void Serialize(CVariant& value) const override;
-    void ToSortable(SortItem& sortable, Field field) const override;
-
-  private:
-    bool        m_bLoaded;
-    std::string m_strURL;
-    std::string m_strTitle;
-    std::string m_strPlatform;
-    std::vector<std::string> m_genres;
-    std::string m_strDeveloper;
-    std::string m_strOverview;
-    unsigned int m_year;
-    std::string m_strID;
-    std::string m_strRegion;
-    std::string m_strPublisher;
-    std::string m_strFormat;
-    std::string m_strCartridgeType;
-    std::string m_strGameClient;
-  };
-}
-}
+    m_strCartridgeType = strCartridgeType;
+  }
+
+  // Game client add-on ID
+  const std::string& GetGameClient() const { return m_strGameClient; }
+  void SetGameClient(const std::string& strGameClient) { m_strGameClient = strGameClient; }
+
+  void Archive(CArchive& ar) override;
+  void Serialize(CVariant& value) const override;
+  void ToSortable(SortItem& sortable, Field field) const override;
+
+private:
+  bool m_bLoaded;
+  std::string m_strURL;
+  std::string m_strTitle;
+  std::string m_strPlatform;
+  std::vector<std::string> m_genres;
+  std::string m_strDeveloper;
+  std::string m_strOverview;
+  unsigned int m_year;
+  std::string m_strID;
+  std::string m_strRegion;
+  std::string m_strPublisher;
+  std::string m_strFormat;
+  std::string m_strCartridgeType;
+  std::string m_strGameClient;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/windows/GUIViewStateWindowGames.cpp b/xbmc/games/windows/GUIViewStateWindowGames.cpp
index 5ebd15e5853b..1473542f86e5 100644
--- a/xbmc/games/windows/GUIViewStateWindowGames.cpp
+++ b/xbmc/games/windows/GUIViewStateWindowGames.cpp
@@ -24,8 +24,8 @@
 using namespace KODI;
 using namespace GAME;
 
-CGUIViewStateWindowGames::CGUIViewStateWindowGames(const CFileItemList& items) :
-  CGUIViewState(items)
+CGUIViewStateWindowGames::CGUIViewStateWindowGames(const CFileItemList& items)
+  : CGUIViewState(items)
 {
   if (items.IsVirtualDirectoryRoot())
   {
@@ -37,10 +37,12 @@ CGUIViewStateWindowGames::CGUIViewStateWindowGames(const CFileItemList& items) :
   }
   else
   {
-    AddSortMethod(SortByFile, 561, LABEL_MASKS("%F", "%I", "%L", ""));  // Filename, Size | Label, empty
-    AddSortMethod(SortBySize, 553, LABEL_MASKS("%L", "%I", "%L", "%I"));  // Filename, Size | Label, Size
+    AddSortMethod(SortByFile, 561,
+                  LABEL_MASKS("%F", "%I", "%L", "")); // Filename, Size | Label, empty
+    AddSortMethod(SortBySize, 553,
+                  LABEL_MASKS("%L", "%I", "%L", "%I")); // Filename, Size | Label, Size
 
-    const CViewState *viewState = CViewStateSettings::GetInstance().Get("games");
+    const CViewState* viewState = CViewStateSettings::GetInstance().Get("games");
     if (viewState)
     {
       SetSortMethod(viewState->m_sortDescription);
@@ -72,7 +74,7 @@ std::string CGUIViewStateWindowGames::GetExtensions()
 
 VECSOURCES& CGUIViewStateWindowGames::GetSources()
 {
-  VECSOURCES *pGameSources = CMediaSourceSettings::GetInstance().GetSources("games");
+  VECSOURCES* pGameSources = CMediaSourceSettings::GetInstance().GetSources("games");
 
   // Guard against source type not existing
   if (pGameSources == nullptr)
diff --git a/xbmc/games/windows/GUIViewStateWindowGames.h b/xbmc/games/windows/GUIViewStateWindowGames.h
index 2c2869f45026..90ad8213eccf 100644
--- a/xbmc/games/windows/GUIViewStateWindowGames.h
+++ b/xbmc/games/windows/GUIViewStateWindowGames.h
@@ -14,21 +14,21 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIViewStateWindowGames : public CGUIViewState
-  {
-  public:
-    explicit CGUIViewStateWindowGames(const CFileItemList& items);
+class CGUIViewStateWindowGames : public CGUIViewState
+{
+public:
+  explicit CGUIViewStateWindowGames(const CFileItemList& items);
 
-    ~CGUIViewStateWindowGames() override = default;
+  ~CGUIViewStateWindowGames() override = default;
 
-    // implementation of CGUIViewState
-    std::string GetLockType() override;
-    std::string GetExtensions() override;
-    VECSOURCES& GetSources() override;
+  // implementation of CGUIViewState
+  std::string GetLockType() override;
+  std::string GetExtensions() override;
+  VECSOURCES& GetSources() override;
 
-  protected:
-    // implementation of CGUIViewState
-    void SaveViewState() override;
-  };
-}
-}
+protected:
+  // implementation of CGUIViewState
+  void SaveViewState() override;
+};
+} // namespace GAME
+} // namespace KODI
diff --git a/xbmc/games/windows/GUIWindowGames.cpp b/xbmc/games/windows/GUIWindowGames.cpp
index bef066dfb111..44db1c24018e 100644
--- a/xbmc/games/windows/GUIWindowGames.cpp
+++ b/xbmc/games/windows/GUIWindowGames.cpp
@@ -35,12 +35,11 @@
 using namespace KODI;
 using namespace GAME;
 
-#define CONTROL_BTNVIEWASICONS      2
-#define CONTROL_BTNSORTBY           3
-#define CONTROL_BTNSORTASC          4
+#define CONTROL_BTNVIEWASICONS 2
+#define CONTROL_BTNSORTBY 3
+#define CONTROL_BTNSORTASC 4
 
-CGUIWindowGames::CGUIWindowGames() :
-  CGUIMediaWindow(WINDOW_GAMES, "MyGames.xml")
+CGUIWindowGames::CGUIWindowGames() : CGUIMediaWindow(WINDOW_GAMES, "MyGames.xml")
 {
 }
 
@@ -57,7 +56,8 @@ bool CGUIWindowGames::OnMessage(CGUIMessage& message)
         message.SetStringParam(CMediaSourceSettings::GetInstance().GetDefaultSource("games"));
 
       //! @todo
-      m_dlgProgress = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogProgress>(WINDOW_DIALOG_PROGRESS);
+      m_dlgProgress = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogProgress>(
+          WINDOW_DIALOG_PROGRESS);
 
       break;
     }
@@ -75,7 +75,7 @@ bool CGUIWindowGames::OnMessage(CGUIMessage& message)
 
 bool CGUIWindowGames::OnClickMsg(int controlId, int actionId)
 {
-  if (!m_viewControl.HasControl(controlId))  // list/thumb control
+  if (!m_viewControl.HasControl(controlId)) // list/thumb control
     return false;
 
   const int iItem = m_viewControl.GetSelectedItem();
@@ -86,36 +86,37 @@ bool CGUIWindowGames::OnClickMsg(int controlId, int actionId)
 
   switch (actionId)
   {
-  case ACTION_DELETE_ITEM:
-  {
-    // Is delete allowed?
-    if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_FILELISTS_ALLOWFILEDELETION))
+    case ACTION_DELETE_ITEM:
     {
-      OnDeleteItem(iItem);
-      return true;
+      // Is delete allowed?
+      if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+              CSettings::SETTING_FILELISTS_ALLOWFILEDELETION))
+      {
+        OnDeleteItem(iItem);
+        return true;
+      }
+      break;
     }
-    break;
-  }
-  case ACTION_PLAYER_PLAY:
-  {
-    if (OnClick(iItem))
-      return true;
-    break;
-  }
-  case ACTION_SHOW_INFO:
-  {
-    if (!m_vecItems->IsPlugin())
+    case ACTION_PLAYER_PLAY:
     {
-      if (pItem->HasAddonInfo())
-      {
-        CGUIDialogAddonInfo::ShowForItem(pItem);
+      if (OnClick(iItem))
         return true;
+      break;
+    }
+    case ACTION_SHOW_INFO:
+    {
+      if (!m_vecItems->IsPlugin())
+      {
+        if (pItem->HasAddonInfo())
+        {
+          CGUIDialogAddonInfo::ShowForItem(pItem);
+          return true;
+        }
       }
+      break;
     }
-    break;
-  }
-  default:
-    break;
+    default:
+      break;
   }
 
   return false;
@@ -135,7 +136,7 @@ void CGUIWindowGames::SetupShares()
   m_rootDir.SetFlags(XFILE::DIR_FLAG_NO_FILE_DIRS);
 }
 
-bool CGUIWindowGames::OnClick(int iItem, const std::string &player /* = "" */)
+bool CGUIWindowGames::OnClick(int iItem, const std::string& player /* = "" */)
 {
   CFileItemPtr item = m_vecItems->Get(iItem);
   if (item)
@@ -167,7 +168,7 @@ bool CGUIWindowGames::OnClick(int iItem, const std::string &player /* = "" */)
   return CGUIMediaWindow::OnClick(iItem, player);
 }
 
-void CGUIWindowGames::GetContextButtons(int itemNumber, CContextButtons &buttons)
+void CGUIWindowGames::GetContextButtons(int itemNumber, CContextButtons& buttons)
 {
   CFileItemPtr item = m_vecItems->Get(itemNumber);
 
@@ -185,7 +186,9 @@ void CGUIWindowGames::GetContextButtons(int itemNumber, CContextButtons &buttons
         buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 208); // Play
       }
 
-      if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_FILELISTS_ALLOWFILEDELETION) && !item->IsReadOnly())
+      if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+              CSettings::SETTING_FILELISTS_ALLOWFILEDELETION) &&
+          !item->IsReadOnly())
       {
         buttons.Add(CONTEXT_BUTTON_DELETE, 117);
         buttons.Add(CONTEXT_BUTTON_RENAME, 118);
@@ -211,20 +214,20 @@ bool CGUIWindowGames::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
     }
     switch (button)
     {
-    case CONTEXT_BUTTON_PLAY_ITEM:
-      PlayGame(*item);
-      return true;
-    case CONTEXT_BUTTON_INFO:
-      CGUIDialogAddonInfo::ShowForItem(item);
-      return true;
-    case CONTEXT_BUTTON_DELETE:
-      OnDeleteItem(itemNumber);
-      return true;
-    case CONTEXT_BUTTON_RENAME:
-      OnRenameItem(itemNumber);
-      return true;
-    default:
-      break;
+      case CONTEXT_BUTTON_PLAY_ITEM:
+        PlayGame(*item);
+        return true;
+      case CONTEXT_BUTTON_INFO:
+        CGUIDialogAddonInfo::ShowForItem(item);
+        return true;
+      case CONTEXT_BUTTON_DELETE:
+        OnDeleteItem(itemNumber);
+        return true;
+      case CONTEXT_BUTTON_RENAME:
+        OnRenameItem(itemNumber);
+        return true;
+      default:
+        break;
     }
   }
   return CGUIMediaWindow::OnContextButton(itemNumber, button);
@@ -235,7 +238,7 @@ bool CGUIWindowGames::OnAddMediaSource()
   return CGUIDialogMediaSource::ShowAndAddMediaSource("games");
 }
 
-bool CGUIWindowGames::GetDirectory(const std::string &strDirectory, CFileItemList& items)
+bool CGUIWindowGames::GetDirectory(const std::string& strDirectory, CFileItemList& items)
 {
   if (!CGUIMediaWindow::GetDirectory(strDirectory, items))
     return false;
@@ -245,7 +248,8 @@ bool CGUIWindowGames::GetDirectory(const std::string &strDirectory, CFileItemLis
   if (items.GetLabel().empty())
   {
     std::string source;
-    if (m_rootDir.IsSource(items.GetPath(), CMediaSourceSettings::GetInstance().GetSources("games"), &source))
+    if (m_rootDir.IsSource(items.GetPath(), CMediaSourceSettings::GetInstance().GetSources("games"),
+                           &source))
       label = std::move(source);
   }
 
@@ -257,7 +261,7 @@ bool CGUIWindowGames::GetDirectory(const std::string &strDirectory, CFileItemLis
   if (items.GetContent().empty())
   {
     if (!items.IsVirtualDirectoryRoot() && // Don't set content for root directory
-        !items.IsPlugin())                 // Don't set content for plugins
+        !items.IsPlugin()) // Don't set content for plugins
     {
       content = "games";
     }
@@ -276,12 +280,11 @@ bool CGUIWindowGames::GetDirectory(const std::string &strDirectory, CFileItemLis
   return true;
 }
 
-std::string CGUIWindowGames::GetStartFolder(const std::string &dir)
+std::string CGUIWindowGames::GetStartFolder(const std::string& dir)
 {
   // From CGUIWindowPictures::GetStartFolder()
 
-  if (StringUtils::EqualsNoCase(dir, "plugins") ||
-      StringUtils::EqualsNoCase(dir, "addons"))
+  if (StringUtils::EqualsNoCase(dir, "plugins") || StringUtils::EqualsNoCase(dir, "addons"))
   {
     return "addons://sources/game/";
   }
@@ -320,7 +323,8 @@ void CGUIWindowGames::OnItemInfo(int itemNumber)
 
   //! @todo
   /*
-  CGUIDialogGameInfo* gameInfo = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogGameInfo>(WINDOW_DIALOG_PICTURE_INFO);
+  CGUIDialogGameInfo* gameInfo =
+  CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogGameInfo>(WINDOW_DIALOG_PICTURE_INFO);
   if (gameInfo)
   {
     gameInfo->SetGame(item);
@@ -329,7 +333,7 @@ void CGUIWindowGames::OnItemInfo(int itemNumber)
   */
 }
 
-bool CGUIWindowGames::PlayGame(const CFileItem &item)
+bool CGUIWindowGames::PlayGame(const CFileItem& item)
 {
   CFileItem itemCopy(item);
   return g_application.PlayMedia(itemCopy, "", PLAYLIST_NONE);
diff --git a/xbmc/games/windows/GUIWindowGames.h b/xbmc/games/windows/GUIWindowGames.h
index f2cbb728e0aa..2fbabfa676eb 100644
--- a/xbmc/games/windows/GUIWindowGames.h
+++ b/xbmc/games/windows/GUIWindowGames.h
@@ -16,30 +16,30 @@ namespace KODI
 {
 namespace GAME
 {
-  class CGUIWindowGames : public CGUIMediaWindow
-  {
-  public:
-    CGUIWindowGames();
-    ~CGUIWindowGames() override = default;
-
-    // implementation of CGUIControl via CGUIMediaWindow
-    bool OnMessage(CGUIMessage& message) override;
-
-  protected:
-    // implementation of CGUIMediaWindow
-    void SetupShares() override;
-    bool OnClick(int iItem, const std::string& player = "") override;
-    void GetContextButtons(int itemNumber, CContextButtons& buttons) override;
-    bool OnContextButton(int itemNumber, CONTEXT_BUTTON button) override;
-    bool OnAddMediaSource() override;
-    bool GetDirectory(const std::string& strDirectory, CFileItemList& items) override;
-    std::string GetStartFolder(const std::string& dir) override;
-
-    bool OnClickMsg(int controlId, int actionId);
-    void OnItemInfo(int itemNumber);
-    bool PlayGame(const CFileItem &item);
-
-    CGUIDialogProgress *m_dlgProgress = nullptr;
-  };
-}
-}
+class CGUIWindowGames : public CGUIMediaWindow
+{
+public:
+  CGUIWindowGames();
+  ~CGUIWindowGames() override = default;
+
+  // implementation of CGUIControl via CGUIMediaWindow
+  bool OnMessage(CGUIMessage& message) override;
+
+protected:
+  // implementation of CGUIMediaWindow
+  void SetupShares() override;
+  bool OnClick(int iItem, const std::string& player = "") override;
+  void GetContextButtons(int itemNumber, CContextButtons& buttons) override;
+  bool OnContextButton(int itemNumber, CONTEXT_BUTTON button) override;
+  bool OnAddMediaSource() override;
+  bool GetDirectory(const std::string& strDirectory, CFileItemList& items) override;
+  std::string GetStartFolder(const std::string& dir) override;
+
+  bool OnClickMsg(int controlId, int actionId);
+  void OnItemInfo(int itemNumber);
+  bool PlayGame(const CFileItem& item);
+
+  CGUIDialogProgress* m_dlgProgress = nullptr;
+};
+} // namespace GAME
+} // namespace KODI

From 0b34dc7e6f61424c8cce7249cdcd6060b8eada9e Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Tue, 26 May 2020 17:42:08 -0700
Subject: [PATCH 4/7] Input: Clang-format files

---
 xbmc/input/AppTranslator.cpp                  |  54 +-
 xbmc/input/AppTranslator.h                    |   2 +-
 xbmc/input/ButtonTranslator.cpp               |  75 +-
 xbmc/input/ButtonTranslator.h                 |  23 +-
 xbmc/input/CustomControllerTranslator.cpp     |  24 +-
 xbmc/input/CustomControllerTranslator.h       |  12 +-
 xbmc/input/GamepadTranslator.cpp              |  87 +-
 xbmc/input/IButtonMapper.h                    |   6 +-
 xbmc/input/IKeymap.h                          |  25 +-
 xbmc/input/IRTranslator.cpp                   | 224 +++--
 xbmc/input/IRTranslator.h                     |  10 +-
 xbmc/input/InertialScrollingHandler.cpp       | 123 +--
 xbmc/input/InertialScrollingHandler.h         |  55 +-
 xbmc/input/InputCodingTable.h                 |  10 +-
 xbmc/input/InputCodingTableBaiduPY.cpp        |  26 +-
 xbmc/input/InputCodingTableBaiduPY.h          |   7 +-
 xbmc/input/InputCodingTableBasePY.cpp         | 852 +++++++++---------
 xbmc/input/InputCodingTableBasePY.h           |   1 +
 xbmc/input/InputCodingTableFactory.cpp        |   3 +-
 xbmc/input/InputCodingTableFactory.h          |   3 +-
 xbmc/input/InputCodingTableKorean.cpp         | 112 ++-
 xbmc/input/InputCodingTableKorean.h           |   2 +-
 xbmc/input/InputManager.cpp                   | 370 ++++----
 xbmc/input/InputManager.h                     |  42 +-
 xbmc/input/InputTranslator.cpp                |  40 +-
 xbmc/input/InputTranslator.h                  |  76 +-
 xbmc/input/InputTypes.h                       |  56 +-
 xbmc/input/JoystickMapper.cpp                 |  45 +-
 xbmc/input/JoystickMapper.h                   |   9 +-
 xbmc/input/Key.cpp                            |  51 +-
 xbmc/input/Key.h                              | 182 ++--
 xbmc/input/KeyboardLayout.cpp                 |  16 +-
 xbmc/input/KeyboardLayout.h                   |   8 +-
 xbmc/input/KeyboardLayoutManager.cpp          |  44 +-
 xbmc/input/KeyboardLayoutManager.h            |   5 +-
 xbmc/input/KeyboardStat.cpp                   |  46 +-
 xbmc/input/KeyboardStat.h                     |  19 +-
 xbmc/input/KeyboardTranslator.cpp             |  13 +-
 xbmc/input/KeyboardTranslator.h               |   4 +-
 xbmc/input/Keymap.cpp                         |  13 +-
 xbmc/input/Keymap.h                           |   6 +-
 xbmc/input/TouchTranslator.cpp                |  59 +-
 xbmc/input/TouchTranslator.h                  |  15 +-
 xbmc/input/WindowKeymap.cpp                   |  12 +-
 xbmc/input/WindowKeymap.h                     |   9 +-
 xbmc/input/WindowTranslator.cpp               | 308 ++++---
 xbmc/input/WindowTranslator.h                 |  10 +-
 xbmc/input/XBMC_keyboard.h                    |  26 +-
 xbmc/input/XBMC_keysym.h                      | 405 ++++-----
 xbmc/input/XBMC_keytable.cpp                  | 486 +++++-----
 xbmc/input/XBMC_keytable.h                    |   5 +-
 xbmc/input/XBMC_vkeys.h                       | 454 +++++-----
 xbmc/input/actions/Action.cpp                 |  27 +-
 xbmc/input/actions/Action.h                   |  46 +-
 xbmc/input/actions/ActionIDs.h                | 602 +++++++------
 xbmc/input/actions/ActionTranslator.cpp       | 470 +++++-----
 xbmc/input/actions/ActionTranslator.h         |   4 +-
 xbmc/input/hardware/IHardwareInput.h          |  28 +-
 xbmc/input/joysticks/DeadzoneFilter.cpp       |  34 +-
 xbmc/input/joysticks/DeadzoneFilter.h         | 113 +--
 xbmc/input/joysticks/DriverPrimitive.cpp      | 172 ++--
 xbmc/input/joysticks/DriverPrimitive.h        | 335 +++----
 xbmc/input/joysticks/JoystickEasterEgg.cpp    |  62 +-
 xbmc/input/joysticks/JoystickEasterEgg.h      |  50 +-
 xbmc/input/joysticks/JoystickIDs.h            |   6 +-
 xbmc/input/joysticks/JoystickMonitor.cpp      |  19 +-
 xbmc/input/joysticks/JoystickMonitor.h        |  66 +-
 xbmc/input/joysticks/JoystickTranslator.cpp   | 103 ++-
 xbmc/input/joysticks/JoystickTranslator.h     | 192 ++--
 xbmc/input/joysticks/JoystickTypes.h          | 327 ++++---
 xbmc/input/joysticks/JoystickUtils.cpp        |  30 +-
 xbmc/input/joysticks/JoystickUtils.h          |  22 +-
 xbmc/input/joysticks/RumbleGenerator.cpp      |  71 +-
 xbmc/input/joysticks/RumbleGenerator.h        |  58 +-
 .../dialogs/GUIDialogNewJoystick.cpp          |  17 +-
 .../joysticks/dialogs/GUIDialogNewJoystick.h  |  24 +-
 .../input/joysticks/generic/ButtonMapping.cpp | 116 +--
 xbmc/input/joysticks/generic/ButtonMapping.h  | 598 ++++++------
 .../joysticks/generic/DriverReceiving.cpp     |   3 +-
 .../input/joysticks/generic/DriverReceiving.h |  54 +-
 .../joysticks/generic/FeatureHandling.cpp     | 134 +--
 .../input/joysticks/generic/FeatureHandling.h | 504 +++++------
 .../input/joysticks/generic/InputHandling.cpp |  20 +-
 xbmc/input/joysticks/generic/InputHandling.h  |  79 +-
 xbmc/input/joysticks/interfaces/IButtonMap.h  | 589 ++++++------
 .../joysticks/interfaces/IButtonMapCallback.h |  58 +-
 .../joysticks/interfaces/IButtonMapper.h      | 179 ++--
 .../joysticks/interfaces/IButtonSequence.h    |  26 +-
 .../joysticks/interfaces/IDriverHandler.h     | 109 +--
 .../joysticks/interfaces/IDriverReceiver.h    |  38 +-
 .../joysticks/interfaces/IInputHandler.h      | 272 +++---
 .../joysticks/interfaces/IInputProvider.h     |  50 +-
 .../joysticks/interfaces/IInputReceiver.h     |  38 +-
 xbmc/input/joysticks/interfaces/IKeyHandler.h |  74 +-
 .../joysticks/interfaces/IKeymapHandler.h     |  62 +-
 xbmc/input/joysticks/keymaps/KeyHandler.cpp   |  56 +-
 xbmc/input/joysticks/keymaps/KeyHandler.h     | 161 ++--
 .../input/joysticks/keymaps/KeymapHandler.cpp |  67 +-
 xbmc/input/joysticks/keymaps/KeymapHandler.h  | 145 +--
 .../joysticks/keymaps/KeymapHandling.cpp      |  32 +-
 xbmc/input/joysticks/keymaps/KeymapHandling.h |  86 +-
 xbmc/input/keyboard/KeyboardEasterEgg.cpp     |  12 +-
 xbmc/input/keyboard/KeyboardEasterEgg.h       |  32 +-
 xbmc/input/keyboard/KeyboardTypes.h           |  38 +-
 xbmc/input/keyboard/KeymapActionMap.cpp       |   3 +-
 xbmc/input/keyboard/KeymapActionMap.h         |  20 +-
 .../generic/KeyboardInputHandling.cpp         |   6 +-
 .../keyboard/generic/KeyboardInputHandling.h  |  62 +-
 xbmc/input/keyboard/interfaces/IActionMap.h   |  36 +-
 .../interfaces/IKeyboardDriverHandler.h       |  48 +-
 .../interfaces/IKeyboardInputHandler.h        |  88 +-
 .../interfaces/IKeyboardInputProvider.h       |  50 +-
 xbmc/input/mouse/MouseStat.cpp                | 159 ++--
 xbmc/input/mouse/MouseStat.h                  | 113 ++-
 xbmc/input/mouse/MouseTranslator.cpp          | 131 ++-
 xbmc/input/mouse/MouseTranslator.h            |   4 +-
 xbmc/input/mouse/MouseTypes.h                 |  68 +-
 .../mouse/generic/MouseInputHandling.cpp      | 318 +++----
 xbmc/input/mouse/generic/MouseInputHandling.h |  86 +-
 .../mouse/interfaces/IMouseDriverHandler.h    |  72 +-
 .../mouse/interfaces/IMouseInputHandler.h     |  86 +-
 .../mouse/interfaces/IMouseInputProvider.h    |  50 +-
 xbmc/input/remote/IRRemote.h                  | 152 ++--
 xbmc/input/touch/ITouchActionHandler.h        |  66 +-
 xbmc/input/touch/ITouchInputHandler.h         |  22 +-
 xbmc/input/touch/ITouchInputHandling.cpp      |  28 +-
 xbmc/input/touch/ITouchInputHandling.h        |  34 +-
 xbmc/input/touch/TouchTypes.h                 |  17 +-
 .../generic/GenericTouchActionHandler.cpp     |  46 +-
 .../touch/generic/GenericTouchActionHandler.h |  37 +-
 .../generic/GenericTouchInputHandler.cpp      |  69 +-
 .../touch/generic/GenericTouchInputHandler.h  |  21 +-
 .../generic/GenericTouchPinchDetector.cpp     |   8 +-
 .../touch/generic/GenericTouchPinchDetector.h |  11 +-
 .../generic/GenericTouchRotateDetector.cpp    |  18 +-
 .../generic/GenericTouchRotateDetector.h      |  10 +-
 .../generic/GenericTouchSwipeDetector.cpp     |  37 +-
 .../touch/generic/GenericTouchSwipeDetector.h |  10 +-
 .../generic/IGenericTouchGestureDetector.h    |  12 +-
 139 files changed, 6915 insertions(+), 6163 deletions(-)

diff --git a/xbmc/input/AppTranslator.cpp b/xbmc/input/AppTranslator.cpp
index ce52a8c7c422..7882791d42c2 100644
--- a/xbmc/input/AppTranslator.cpp
+++ b/xbmc/input/AppTranslator.cpp
@@ -21,38 +21,36 @@ using ActionName = std::string;
 using CommandID = uint32_t;
 
 #ifdef TARGET_WINDOWS
-static const std::map<ActionName, CommandID> AppCommands =
-{
-    { "browser_back"             , APPCOMMAND_BROWSER_BACKWARD },
-    { "browser_forward"          , APPCOMMAND_BROWSER_FORWARD },
-    { "browser_refresh"          , APPCOMMAND_BROWSER_REFRESH },
-    { "browser_stop"             , APPCOMMAND_BROWSER_STOP },
-    { "browser_search"           , APPCOMMAND_BROWSER_SEARCH },
-    { "browser_favorites"        , APPCOMMAND_BROWSER_FAVORITES },
-    { "browser_home"             , APPCOMMAND_BROWSER_HOME },
-    { "volume_mute"              , APPCOMMAND_VOLUME_MUTE },
-    { "volume_down"              , APPCOMMAND_VOLUME_DOWN },
-    { "volume_up"                , APPCOMMAND_VOLUME_UP },
-    { "next_track"               , APPCOMMAND_MEDIA_NEXTTRACK },
-    { "prev_track"               , APPCOMMAND_MEDIA_PREVIOUSTRACK },
-    { "stop"                     , APPCOMMAND_MEDIA_STOP },
-    { "play_pause"               , APPCOMMAND_MEDIA_PLAY_PAUSE },
-    { "launch_mail"              , APPCOMMAND_LAUNCH_MAIL },
-    { "launch_media_select"      , APPCOMMAND_LAUNCH_MEDIA_SELECT },
-    { "launch_app1"              , APPCOMMAND_LAUNCH_APP1 },
-    { "launch_app2"              , APPCOMMAND_LAUNCH_APP2 },
-    { "play"                     , APPCOMMAND_MEDIA_PLAY },
-    { "pause"                    , APPCOMMAND_MEDIA_PAUSE },
-    { "fastforward"              , APPCOMMAND_MEDIA_FAST_FORWARD },
-    { "rewind"                   , APPCOMMAND_MEDIA_REWIND },
-    { "channelup"                , APPCOMMAND_MEDIA_CHANNEL_UP },
-    { "channeldown"              , APPCOMMAND_MEDIA_CHANNEL_DOWN }
-};
+static const std::map<ActionName, CommandID> AppCommands = {
+    {"browser_back", APPCOMMAND_BROWSER_BACKWARD},
+    {"browser_forward", APPCOMMAND_BROWSER_FORWARD},
+    {"browser_refresh", APPCOMMAND_BROWSER_REFRESH},
+    {"browser_stop", APPCOMMAND_BROWSER_STOP},
+    {"browser_search", APPCOMMAND_BROWSER_SEARCH},
+    {"browser_favorites", APPCOMMAND_BROWSER_FAVORITES},
+    {"browser_home", APPCOMMAND_BROWSER_HOME},
+    {"volume_mute", APPCOMMAND_VOLUME_MUTE},
+    {"volume_down", APPCOMMAND_VOLUME_DOWN},
+    {"volume_up", APPCOMMAND_VOLUME_UP},
+    {"next_track", APPCOMMAND_MEDIA_NEXTTRACK},
+    {"prev_track", APPCOMMAND_MEDIA_PREVIOUSTRACK},
+    {"stop", APPCOMMAND_MEDIA_STOP},
+    {"play_pause", APPCOMMAND_MEDIA_PLAY_PAUSE},
+    {"launch_mail", APPCOMMAND_LAUNCH_MAIL},
+    {"launch_media_select", APPCOMMAND_LAUNCH_MEDIA_SELECT},
+    {"launch_app1", APPCOMMAND_LAUNCH_APP1},
+    {"launch_app2", APPCOMMAND_LAUNCH_APP2},
+    {"play", APPCOMMAND_MEDIA_PLAY},
+    {"pause", APPCOMMAND_MEDIA_PAUSE},
+    {"fastforward", APPCOMMAND_MEDIA_FAST_FORWARD},
+    {"rewind", APPCOMMAND_MEDIA_REWIND},
+    {"channelup", APPCOMMAND_MEDIA_CHANNEL_UP},
+    {"channeldown", APPCOMMAND_MEDIA_CHANNEL_DOWN}};
 #endif
 
 } // anonymous namespace
 
-uint32_t CAppTranslator::TranslateAppCommand(const std::string &szButton)
+uint32_t CAppTranslator::TranslateAppCommand(const std::string& szButton)
 {
 #ifdef TARGET_WINDOWS
   std::string strAppCommand = szButton;
diff --git a/xbmc/input/AppTranslator.h b/xbmc/input/AppTranslator.h
index 363bba2273e7..3b331e180830 100644
--- a/xbmc/input/AppTranslator.h
+++ b/xbmc/input/AppTranslator.h
@@ -14,5 +14,5 @@
 class CAppTranslator
 {
 public:
-  static uint32_t TranslateAppCommand(const std::string &szButton);
+  static uint32_t TranslateAppCommand(const std::string& szButton);
 };
diff --git a/xbmc/input/ButtonTranslator.cpp b/xbmc/input/ButtonTranslator.cpp
index 104df13d0c35..66241bd82cb3 100644
--- a/xbmc/input/ButtonTranslator.cpp
+++ b/xbmc/input/ButtonTranslator.cpp
@@ -69,11 +69,9 @@ bool CButtonTranslator::Load()
 
   // Directories to search for keymaps. They're applied in this order,
   // so keymaps in profile/keymaps/ override e.g. system/keymaps
-  static std::vector<std::string> DIRS_TO_CHECK = {
-    "special://xbmc/system/keymaps/",
-    "special://masterprofile/keymaps/",
-    "special://profile/keymaps/"
-  };
+  static std::vector<std::string> DIRS_TO_CHECK = {"special://xbmc/system/keymaps/",
+                                                   "special://masterprofile/keymaps/",
+                                                   "special://profile/keymaps/"};
 
   bool success = false;
 
@@ -85,7 +83,7 @@ bool CButtonTranslator::Load()
       XFILE::CDirectory::GetDirectory(dir, files, ".xml", XFILE::DIR_FLAG_DEFAULTS);
       // Sort the list for filesystem based priorities, e.g. 01-keymap.xml, 02-keymap-overrides.xml
       files.Sort(SortByFile, SortOrderAscending);
-      for(int fileIndex = 0; fileIndex<files.Size(); ++fileIndex)
+      for (int fileIndex = 0; fileIndex < files.Size(); ++fileIndex)
       {
         if (!files[fileIndex]->m_bIsFolder)
           success |= LoadKeymap(files[fileIndex]->GetPath());
@@ -101,9 +99,10 @@ bool CButtonTranslator::Load()
         {
           CFileItemList files;
           XFILE::CDirectory::GetDirectory(devicedir, files, ".xml", XFILE::DIR_FLAG_DEFAULTS);
-          // Sort the list for filesystem based priorities, e.g. 01-keymap.xml, 02-keymap-overrides.xml
+          // Sort the list for filesystem based priorities, e.g. 01-keymap.xml,
+          // 02-keymap-overrides.xml
           files.Sort(SortByFile, SortOrderAscending);
-          for(int fileIndex = 0; fileIndex<files.Size(); ++fileIndex)
+          for (int fileIndex = 0; fileIndex < files.Size(); ++fileIndex)
           {
             if (!files[fileIndex]->m_bIsFolder)
               success |= LoadKeymap(files[fileIndex]->GetPath());
@@ -115,8 +114,8 @@ bool CButtonTranslator::Load()
 
   if (!success)
   {
-    CLog::Log(LOGERROR, "Error loading keymaps from: %s or %s or %s",
-      DIRS_TO_CHECK[0].c_str(), DIRS_TO_CHECK[1].c_str(), DIRS_TO_CHECK[2].c_str());
+    CLog::Log(LOGERROR, "Error loading keymaps from: %s or %s or %s", DIRS_TO_CHECK[0].c_str(),
+              DIRS_TO_CHECK[1].c_str(), DIRS_TO_CHECK[2].c_str());
     return false;
   }
 
@@ -124,14 +123,15 @@ bool CButtonTranslator::Load()
   return true;
 }
 
-bool CButtonTranslator::LoadKeymap(const std::string &keymapPath)
+bool CButtonTranslator::LoadKeymap(const std::string& keymapPath)
 {
   CXBMCTinyXML xmlDoc;
 
   CLog::Log(LOGINFO, "Loading %s", keymapPath.c_str());
   if (!xmlDoc.LoadFile(keymapPath))
   {
-    CLog::Log(LOGERROR, "Error loading keymap: %s, Line %d\n%s", keymapPath.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+    CLog::Log(LOGERROR, "Error loading keymap: %s, Line %d\n%s", keymapPath.c_str(),
+              xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
     return false;
   }
 
@@ -156,7 +156,7 @@ bool CButtonTranslator::LoadKeymap(const std::string &keymapPath)
     if (pWindow->Type() == TiXmlNode::TINYXML_ELEMENT)
     {
       int windowID = WINDOW_INVALID;
-      const char *szWindow = pWindow->Value();
+      const char* szWindow = pWindow->Value();
       if (szWindow != nullptr)
       {
         if (StringUtils::CompareNoCase(szWindow, "global") == 0)
@@ -172,7 +172,7 @@ bool CButtonTranslator::LoadKeymap(const std::string &keymapPath)
   return true;
 }
 
-CAction CButtonTranslator::GetAction(int window, const CKey &key, bool fallback)
+CAction CButtonTranslator::GetAction(int window, const CKey& key, bool fallback)
 {
   std::string strAction;
 
@@ -195,14 +195,14 @@ CAction CButtonTranslator::GetAction(int window, const CKey &key, bool fallback)
   return CAction(actionID, strAction, key);
 }
 
-bool CButtonTranslator::HasLongpressMapping(int window, const CKey &key)
+bool CButtonTranslator::HasLongpressMapping(int window, const CKey& key)
 {
   // handle virtual windows
   window = CWindowTranslator::GetVirtualWindow(window);
   return HasLongpressMapping_Internal(window, key);
 }
 
-bool CButtonTranslator::HasLongpressMapping_Internal(int window, const CKey &key)
+bool CButtonTranslator::HasLongpressMapping_Internal(int window, const CKey& key)
 {
   std::map<int, buttonMap>::const_iterator it = m_translatorMap.find(window);
   if (it != m_translatorMap.end())
@@ -241,7 +241,9 @@ bool CButtonTranslator::HasLongpressMapping_Internal(int window, const CKey &key
   return false;
 }
 
-unsigned int CButtonTranslator::GetActionCode(int window, const CKey &key, std::string &strAction) const
+unsigned int CButtonTranslator::GetActionCode(int window,
+                                              const CKey& key,
+                                              std::string& strAction) const
 {
   uint32_t code = key.GetButtonCode();
 
@@ -251,7 +253,8 @@ unsigned int CButtonTranslator::GetActionCode(int window, const CKey &key, std::
 
   buttonMap::const_iterator it2 = (*it).second.find(code);
   unsigned int action = ACTION_NONE;
-  if (it2 == (*it).second.end() && code & CKey::MODIFIER_LONG) // If long action not found, try short one
+  if (it2 == (*it).second.end() &&
+      code & CKey::MODIFIER_LONG) // If long action not found, try short one
   {
     code &= ~CKey::MODIFIER_LONG;
     it2 = (*it).second.find(code);
@@ -281,11 +284,11 @@ unsigned int CButtonTranslator::GetActionCode(int window, const CKey &key, std::
   return action;
 }
 
-void CButtonTranslator::MapAction(uint32_t buttonCode, const std::string &szAction, buttonMap &map)
+void CButtonTranslator::MapAction(uint32_t buttonCode, const std::string& szAction, buttonMap& map)
 {
   unsigned int action = ACTION_NONE;
   if (!CActionTranslator::TranslateString(szAction, action) || buttonCode == 0)
-    return;   // no valid action, or an invalid buttoncode
+    return; // no valid action, or an invalid buttoncode
 
   // have a valid action, and a valid button - map it.
   // check to see if we've already got this (button,action) pair defined
@@ -303,19 +306,19 @@ void CButtonTranslator::MapAction(uint32_t buttonCode, const std::string &szActi
   }
 }
 
-void CButtonTranslator::MapWindowActions(const TiXmlNode *pWindow, int windowID)
+void CButtonTranslator::MapWindowActions(const TiXmlNode* pWindow, int windowID)
 {
   if (pWindow == nullptr || windowID == WINDOW_INVALID)
     return;
 
-  const TiXmlNode *pDevice;
+  const TiXmlNode* pDevice;
 
-  static const std::vector<std::string> types = {"gamepad", "remote", "universalremote", "keyboard", "mouse", "appcommand"};
+  static const std::vector<std::string> types = {"gamepad",  "remote", "universalremote",
+                                                 "keyboard", "mouse",  "appcommand"};
 
   for (const auto& type : types)
   {
-    for (pDevice = pWindow->FirstChild(type);
-         pDevice != nullptr;
+    for (pDevice = pWindow->FirstChild(type); pDevice != nullptr;
          pDevice = pDevice->NextSiblingElement(type))
     {
       buttonMap map;
@@ -326,24 +329,24 @@ void CButtonTranslator::MapWindowActions(const TiXmlNode *pWindow, int windowID)
         m_translatorMap.erase(it);
       }
 
-      const TiXmlElement *pButton = pDevice->FirstChildElement();
+      const TiXmlElement* pButton = pDevice->FirstChildElement();
 
       while (pButton != nullptr)
       {
         uint32_t buttonCode = 0;
 
         if (type == "gamepad")
-            buttonCode = CGamepadTranslator::TranslateString(pButton->Value());
+          buttonCode = CGamepadTranslator::TranslateString(pButton->Value());
         else if (type == "remote")
-            buttonCode = CIRTranslator::TranslateString(pButton->Value());
+          buttonCode = CIRTranslator::TranslateString(pButton->Value());
         else if (type == "universalremote")
-            buttonCode = CIRTranslator::TranslateUniversalRemoteString(pButton->Value());
+          buttonCode = CIRTranslator::TranslateUniversalRemoteString(pButton->Value());
         else if (type == "keyboard")
-            buttonCode = CKeyboardTranslator::TranslateButton(pButton);
+          buttonCode = CKeyboardTranslator::TranslateButton(pButton);
         else if (type == "mouse")
-            buttonCode = CMouseTranslator::TranslateCommand(pButton);
+          buttonCode = CMouseTranslator::TranslateCommand(pButton);
         else if (type == "appcommand")
-            buttonCode = CAppTranslator::TranslateAppCommand(pButton->Value());
+          buttonCode = CAppTranslator::TranslateAppCommand(pButton->Value());
 
         if (buttonCode != 0)
         {
@@ -370,8 +373,8 @@ void CButtonTranslator::MapWindowActions(const TiXmlNode *pWindow, int windowID)
 
   for (auto it : m_buttonMappers)
   {
-    const std::string &device = it.first;
-    IButtonMapper *mapper = it.second;
+    const std::string& device = it.first;
+    IButtonMapper* mapper = it.second;
 
     // Map device actions
     pDevice = pWindow->FirstChild(device);
@@ -391,12 +394,12 @@ void CButtonTranslator::Clear()
     it.second->Clear();
 }
 
-void CButtonTranslator::RegisterMapper(const std::string &device, IButtonMapper *mapper)
+void CButtonTranslator::RegisterMapper(const std::string& device, IButtonMapper* mapper)
 {
   m_buttonMappers[device] = mapper;
 }
 
-void CButtonTranslator::UnregisterMapper(IButtonMapper *mapper)
+void CButtonTranslator::UnregisterMapper(IButtonMapper* mapper)
 {
   for (auto it = m_buttonMappers.begin(); it != m_buttonMappers.end(); ++it)
   {
diff --git a/xbmc/input/ButtonTranslator.h b/xbmc/input/ButtonTranslator.h
index 9124d1460f0a..2aeb6629ac37 100644
--- a/xbmc/input/ButtonTranslator.h
+++ b/xbmc/input/ButtonTranslator.h
@@ -49,18 +49,19 @@ class CButtonTranslator
    \param key to search a mapping for
    \return true if a longpress mapping exists
    */
-  bool HasLongpressMapping(int window, const CKey &key);
+  bool HasLongpressMapping(int window, const CKey& key);
 
   /*! \brief Obtain the action configured for a given window and key
    \param window the window id
    \param key the key to query the action for
-   \param fallback if no action is directly configured for the given window, obtain the action from fallback window, if exists or from global config as last resort
-   \return the action matching the key
+   \param fallback if no action is directly configured for the given window, obtain the action from
+   fallback window, if exists or from global config as last resort \return the action matching the
+   key
    */
-  CAction GetAction(int window, const CKey &key, bool fallback = true);
+  CAction GetAction(int window, const CKey& key, bool fallback = true);
 
-  void RegisterMapper(const std::string &device, IButtonMapper *mapper);
-  void UnregisterMapper(IButtonMapper *mapper);
+  void RegisterMapper(const std::string& device, IButtonMapper* mapper);
+  void UnregisterMapper(IButtonMapper* mapper);
 
   static uint32_t TranslateString(std::string strMap, std::string strButton);
 
@@ -79,14 +80,14 @@ class CButtonTranslator
   // m_deviceList contains the list of connected HID devices
   std::set<std::string> m_deviceList;
 
-  unsigned int GetActionCode(int window, const CKey &key, std::string &strAction) const;
+  unsigned int GetActionCode(int window, const CKey& key, std::string& strAction) const;
 
-  void MapWindowActions(const TiXmlNode *pWindow, int wWindowID);
-  void MapAction(uint32_t buttonCode, const std::string &szAction, buttonMap &map);
+  void MapWindowActions(const TiXmlNode* pWindow, int wWindowID);
+  void MapAction(uint32_t buttonCode, const std::string& szAction, buttonMap& map);
 
-  bool LoadKeymap(const std::string &keymapPath);
+  bool LoadKeymap(const std::string& keymapPath);
 
-  bool HasLongpressMapping_Internal(int window, const CKey &key);
+  bool HasLongpressMapping_Internal(int window, const CKey& key);
 
   std::map<std::string, IButtonMapper*> m_buttonMappers;
 };
diff --git a/xbmc/input/CustomControllerTranslator.cpp b/xbmc/input/CustomControllerTranslator.cpp
index db8052d95482..beb9bd4513f1 100644
--- a/xbmc/input/CustomControllerTranslator.cpp
+++ b/xbmc/input/CustomControllerTranslator.cpp
@@ -14,16 +14,16 @@
 #include "utils/XBMCTinyXML.h"
 #include "utils/log.h"
 
-void CCustomControllerTranslator::MapActions(int windowID, const TiXmlNode *pCustomController)
+void CCustomControllerTranslator::MapActions(int windowID, const TiXmlNode* pCustomController)
 {
   CustomControllerButtonMap buttonMap;
   std::string controllerName;
 
-  const TiXmlElement *pController = pCustomController->ToElement();
+  const TiXmlElement* pController = pCustomController->ToElement();
   if (pController != nullptr)
   {
     // Transform loose name to new family, including altnames
-    const char *name = pController->Attribute("name");
+    const char* name = pController->Attribute("name");
     if (name != nullptr)
       controllerName = name;
   }
@@ -35,7 +35,7 @@ void CCustomControllerTranslator::MapActions(int windowID, const TiXmlNode *pCus
   }
 
   // Parse map
-  const TiXmlElement *pButton = pCustomController->FirstChildElement();
+  const TiXmlElement* pButton = pCustomController->FirstChildElement();
   int id = 0;
   while (pButton != nullptr)
   {
@@ -63,7 +63,11 @@ void CCustomControllerTranslator::Clear()
   m_customControllersMap.clear();
 }
 
-bool CCustomControllerTranslator::TranslateCustomControllerString(int windowId, const std::string& controllerName, int buttonId, int& action, std::string& strAction)
+bool CCustomControllerTranslator::TranslateCustomControllerString(int windowId,
+                                                                  const std::string& controllerName,
+                                                                  int buttonId,
+                                                                  int& action,
+                                                                  std::string& strAction)
 {
   unsigned int actionId = ACTION_NONE;
 
@@ -85,18 +89,22 @@ bool CCustomControllerTranslator::TranslateCustomControllerString(int windowId,
   return actionId != ACTION_NONE;
 }
 
-bool CCustomControllerTranslator::TranslateString(int windowId, const std::string& controllerName, int buttonId, unsigned int& actionId, std::string& strAction)
+bool CCustomControllerTranslator::TranslateString(int windowId,
+                                                  const std::string& controllerName,
+                                                  int buttonId,
+                                                  unsigned int& actionId,
+                                                  std::string& strAction)
 {
   // Resolve the correct custom controller
   auto it = m_customControllersMap.find(controllerName);
   if (it == m_customControllersMap.end())
     return false;
 
-  const CustomControllerWindowMap &windowMap = it->second;
+  const CustomControllerWindowMap& windowMap = it->second;
   auto it2 = windowMap.find(windowId);
   if (it2 != windowMap.end())
   {
-    const CustomControllerButtonMap &buttonMap = it2->second;
+    const CustomControllerButtonMap& buttonMap = it2->second;
     auto it3 = buttonMap.find(buttonId);
     if (it3 != buttonMap.end())
     {
diff --git a/xbmc/input/CustomControllerTranslator.h b/xbmc/input/CustomControllerTranslator.h
index 85f106555248..5c06fe716627 100644
--- a/xbmc/input/CustomControllerTranslator.h
+++ b/xbmc/input/CustomControllerTranslator.h
@@ -24,10 +24,18 @@ class CCustomControllerTranslator : public IButtonMapper
   void MapActions(int windowID, const TiXmlNode* pDevice) override;
   void Clear() override;
 
-  bool TranslateCustomControllerString(int windowId, const std::string& controllerName, int buttonId, int& action, std::string& strAction);
+  bool TranslateCustomControllerString(int windowId,
+                                       const std::string& controllerName,
+                                       int buttonId,
+                                       int& action,
+                                       std::string& strAction);
 
 private:
-  bool TranslateString(int windowId, const std::string& controllerName, int buttonId, unsigned int& actionId, std::string& strAction);
+  bool TranslateString(int windowId,
+                       const std::string& controllerName,
+                       int buttonId,
+                       unsigned int& actionId,
+                       std::string& strAction);
 
   // Maps button id to action
   using CustomControllerButtonMap = std::map<int, std::string>;
diff --git a/xbmc/input/GamepadTranslator.cpp b/xbmc/input/GamepadTranslator.cpp
index f8820cd7c2f7..c7e5ae63399c 100644
--- a/xbmc/input/GamepadTranslator.cpp
+++ b/xbmc/input/GamepadTranslator.cpp
@@ -22,35 +22,64 @@ uint32_t CGamepadTranslator::TranslateString(std::string strButton)
   StringUtils::ToLower(strButton);
 
   uint32_t buttonCode = 0;
-  if (strButton == "a") buttonCode = KEY_BUTTON_A;
-  else if (strButton == "b") buttonCode = KEY_BUTTON_B;
-  else if (strButton == "x") buttonCode = KEY_BUTTON_X;
-  else if (strButton == "y") buttonCode = KEY_BUTTON_Y;
-  else if (strButton == "white") buttonCode = KEY_BUTTON_WHITE;
-  else if (strButton == "black") buttonCode = KEY_BUTTON_BLACK;
-  else if (strButton == "start") buttonCode = KEY_BUTTON_START;
-  else if (strButton == "back") buttonCode = KEY_BUTTON_BACK;
-  else if (strButton == "leftthumbbutton") buttonCode = KEY_BUTTON_LEFT_THUMB_BUTTON;
-  else if (strButton == "rightthumbbutton") buttonCode = KEY_BUTTON_RIGHT_THUMB_BUTTON;
-  else if (strButton == "leftthumbstick") buttonCode = KEY_BUTTON_LEFT_THUMB_STICK;
-  else if (strButton == "leftthumbstickup") buttonCode = KEY_BUTTON_LEFT_THUMB_STICK_UP;
-  else if (strButton == "leftthumbstickdown") buttonCode = KEY_BUTTON_LEFT_THUMB_STICK_DOWN;
-  else if (strButton == "leftthumbstickleft") buttonCode = KEY_BUTTON_LEFT_THUMB_STICK_LEFT;
-  else if (strButton == "leftthumbstickright") buttonCode = KEY_BUTTON_LEFT_THUMB_STICK_RIGHT;
-  else if (strButton == "rightthumbstick") buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK;
-  else if (strButton == "rightthumbstickup") buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK_UP;
-  else if (strButton == "rightthumbstickdown") buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK_DOWN;
-  else if (strButton == "rightthumbstickleft") buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK_LEFT;
-  else if (strButton == "rightthumbstickright") buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT;
-  else if (strButton == "lefttrigger") buttonCode = KEY_BUTTON_LEFT_TRIGGER;
-  else if (strButton == "righttrigger") buttonCode = KEY_BUTTON_RIGHT_TRIGGER;
-  else if (strButton == "leftanalogtrigger") buttonCode = KEY_BUTTON_LEFT_ANALOG_TRIGGER;
-  else if (strButton == "rightanalogtrigger") buttonCode = KEY_BUTTON_RIGHT_ANALOG_TRIGGER;
-  else if (strButton == "dpadleft") buttonCode = KEY_BUTTON_DPAD_LEFT;
-  else if (strButton == "dpadright") buttonCode = KEY_BUTTON_DPAD_RIGHT;
-  else if (strButton == "dpadup") buttonCode = KEY_BUTTON_DPAD_UP;
-  else if (strButton == "dpaddown") buttonCode = KEY_BUTTON_DPAD_DOWN;
-  else CLog::Log(LOGERROR, "Gamepad Translator: Can't find button %s", strButton.c_str());
+  if (strButton == "a")
+    buttonCode = KEY_BUTTON_A;
+  else if (strButton == "b")
+    buttonCode = KEY_BUTTON_B;
+  else if (strButton == "x")
+    buttonCode = KEY_BUTTON_X;
+  else if (strButton == "y")
+    buttonCode = KEY_BUTTON_Y;
+  else if (strButton == "white")
+    buttonCode = KEY_BUTTON_WHITE;
+  else if (strButton == "black")
+    buttonCode = KEY_BUTTON_BLACK;
+  else if (strButton == "start")
+    buttonCode = KEY_BUTTON_START;
+  else if (strButton == "back")
+    buttonCode = KEY_BUTTON_BACK;
+  else if (strButton == "leftthumbbutton")
+    buttonCode = KEY_BUTTON_LEFT_THUMB_BUTTON;
+  else if (strButton == "rightthumbbutton")
+    buttonCode = KEY_BUTTON_RIGHT_THUMB_BUTTON;
+  else if (strButton == "leftthumbstick")
+    buttonCode = KEY_BUTTON_LEFT_THUMB_STICK;
+  else if (strButton == "leftthumbstickup")
+    buttonCode = KEY_BUTTON_LEFT_THUMB_STICK_UP;
+  else if (strButton == "leftthumbstickdown")
+    buttonCode = KEY_BUTTON_LEFT_THUMB_STICK_DOWN;
+  else if (strButton == "leftthumbstickleft")
+    buttonCode = KEY_BUTTON_LEFT_THUMB_STICK_LEFT;
+  else if (strButton == "leftthumbstickright")
+    buttonCode = KEY_BUTTON_LEFT_THUMB_STICK_RIGHT;
+  else if (strButton == "rightthumbstick")
+    buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK;
+  else if (strButton == "rightthumbstickup")
+    buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK_UP;
+  else if (strButton == "rightthumbstickdown")
+    buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK_DOWN;
+  else if (strButton == "rightthumbstickleft")
+    buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK_LEFT;
+  else if (strButton == "rightthumbstickright")
+    buttonCode = KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT;
+  else if (strButton == "lefttrigger")
+    buttonCode = KEY_BUTTON_LEFT_TRIGGER;
+  else if (strButton == "righttrigger")
+    buttonCode = KEY_BUTTON_RIGHT_TRIGGER;
+  else if (strButton == "leftanalogtrigger")
+    buttonCode = KEY_BUTTON_LEFT_ANALOG_TRIGGER;
+  else if (strButton == "rightanalogtrigger")
+    buttonCode = KEY_BUTTON_RIGHT_ANALOG_TRIGGER;
+  else if (strButton == "dpadleft")
+    buttonCode = KEY_BUTTON_DPAD_LEFT;
+  else if (strButton == "dpadright")
+    buttonCode = KEY_BUTTON_DPAD_RIGHT;
+  else if (strButton == "dpadup")
+    buttonCode = KEY_BUTTON_DPAD_UP;
+  else if (strButton == "dpaddown")
+    buttonCode = KEY_BUTTON_DPAD_DOWN;
+  else
+    CLog::Log(LOGERROR, "Gamepad Translator: Can't find button %s", strButton.c_str());
 
   return buttonCode;
 }
diff --git a/xbmc/input/IButtonMapper.h b/xbmc/input/IButtonMapper.h
index 39d4ab5cdbf5..e535df1c90a9 100644
--- a/xbmc/input/IButtonMapper.h
+++ b/xbmc/input/IButtonMapper.h
@@ -11,14 +11,14 @@
 class TiXmlNode;
 
 /*!
-  * \brief Interface for classes that can map buttons to Kodi actions
-  */
+ * \brief Interface for classes that can map buttons to Kodi actions
+ */
 class IButtonMapper
 {
 public:
   virtual ~IButtonMapper() = default;
 
-  virtual void MapActions(int windowId, const TiXmlNode *pDevice) = 0;
+  virtual void MapActions(int windowId, const TiXmlNode* pDevice) = 0;
 
   virtual void Clear() = 0;
 };
diff --git a/xbmc/input/IKeymap.h b/xbmc/input/IKeymap.h
index 99072b38f763..22c0b6e0c919 100644
--- a/xbmc/input/IKeymap.h
+++ b/xbmc/input/IKeymap.h
@@ -15,10 +15,10 @@
 class IKeymapEnvironment;
 
 /*!
-  * \brief Interface for mapping buttons to Kodi actions
-  *
-  * \sa CJoystickUtils::MakeKeyName
-  */
+ * \brief Interface for mapping buttons to Kodi actions
+ *
+ * \sa CJoystickUtils::MakeKeyName
+ */
 class IKeymap
 {
 public:
@@ -34,7 +34,7 @@ class IKeymap
   /*!
    * \brief Access properties of the keymapping environment
    */
-  virtual const IKeymapEnvironment *Environment() const = 0;
+  virtual const IKeymapEnvironment* Environment() const = 0;
 
   /*!
    * \brief Get the actions for a given key name
@@ -47,10 +47,10 @@ class IKeymap
 };
 
 /*!
-  * \brief Interface for mapping buttons to Kodi actions for specific windows
-  *
-  * \sa CJoystickUtils::MakeKeyName
-  */
+ * \brief Interface for mapping buttons to Kodi actions for specific windows
+ *
+ * \sa CJoystickUtils::MakeKeyName
+ */
 class IWindowKeymap
 {
 public:
@@ -70,7 +70,9 @@ class IWindowKeymap
    * \param keyName   The key name created by CJoystickUtils::MakeKeyName()
    * \param action    The action to map
    */
-  virtual void MapAction(int windowId, const std::string &keyName, KODI::JOYSTICK::KeymapAction action) = 0;
+  virtual void MapAction(int windowId,
+                         const std::string& keyName,
+                         KODI::JOYSTICK::KeymapAction action) = 0;
 
   /*!
    * \brief Get the actions for a given key name and window ID
@@ -80,5 +82,6 @@ class IWindowKeymap
    *
    * \return A list of actions associated with the given key for the given window
    */
-  virtual const KODI::JOYSTICK::KeymapActionGroup& GetActions(int windowId, const std::string& keyName) const = 0;
+  virtual const KODI::JOYSTICK::KeymapActionGroup& GetActions(int windowId,
+                                                              const std::string& keyName) const = 0;
 };
diff --git a/xbmc/input/IRTranslator.cpp b/xbmc/input/IRTranslator.cpp
index 900134eb0c04..86ac53adaa86 100644
--- a/xbmc/input/IRTranslator.cpp
+++ b/xbmc/input/IRTranslator.cpp
@@ -21,7 +21,7 @@
 #include <stdlib.h>
 #include <vector>
 
-void CIRTranslator::Load(const std::string &irMapName)
+void CIRTranslator::Load(const std::string& irMapName)
 {
   if (irMapName.empty())
     return;
@@ -36,7 +36,8 @@ void CIRTranslator::Load(const std::string &irMapName)
   else
     CLog::Log(LOGDEBUG, "CIRTranslator::Load - no system %s found, skipping", irMapName.c_str());
 
-  irMapPath = CServiceBroker::GetSettingsComponent()->GetProfileManager()->GetUserDataItem(irMapName);
+  irMapPath =
+      CServiceBroker::GetSettingsComponent()->GetProfileManager()->GetUserDataItem(irMapName);
   if (XFILE::CFile::Exists(irMapPath))
     success |= LoadIRMap(irMapPath);
   else
@@ -46,7 +47,7 @@ void CIRTranslator::Load(const std::string &irMapName)
     CLog::Log(LOGERROR, "CIRTranslator::Load - unable to load remote map %s", irMapName.c_str());
 }
 
-bool CIRTranslator::LoadIRMap(const std::string &irMapPath)
+bool CIRTranslator::LoadIRMap(const std::string& irMapPath)
 {
   std::string remoteMapTag = URIUtils::GetFileName(irMapPath);
   size_t lastindex = remoteMapTag.find_last_of(".");
@@ -61,7 +62,8 @@ bool CIRTranslator::LoadIRMap(const std::string &irMapPath)
   CLog::Log(LOGINFO, "Loading %s", irMapPath.c_str());
   if (!xmlDoc.LoadFile(irMapPath))
   {
-    CLog::Log(LOGERROR, "%s, Line %d\n%s", irMapPath.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+    CLog::Log(LOGERROR, "%s, Line %d\n%s", irMapPath.c_str(), xmlDoc.ErrorRow(),
+              xmlDoc.ErrorDesc());
     return false;
   }
 
@@ -79,7 +81,7 @@ bool CIRTranslator::LoadIRMap(const std::string &irMapPath)
   {
     if (pRemote->Type() == TiXmlNode::TINYXML_ELEMENT)
     {
-      const char *szRemote = pRemote->Value();
+      const char* szRemote = pRemote->Value();
       if (szRemote != nullptr)
       {
         TiXmlAttribute* pAttr = pRemote->ToElement()->FirstAttribute();
@@ -93,7 +95,7 @@ bool CIRTranslator::LoadIRMap(const std::string &irMapPath)
   return true;
 }
 
-void CIRTranslator::MapRemote(TiXmlNode *pRemote, const std::string &szDevice)
+void CIRTranslator::MapRemote(TiXmlNode* pRemote, const std::string& szDevice)
 {
   CLog::Log(LOGINFO, "* Adding remote mapping for device '%s'", szDevice.c_str());
 
@@ -105,7 +107,7 @@ void CIRTranslator::MapRemote(TiXmlNode *pRemote, const std::string &szDevice)
 
   std::shared_ptr<IRButtonMap>& buttons = m_irRemotesMap[szDevice];
 
-  TiXmlElement *pButton = pRemote->FirstChildElement();
+  TiXmlElement* pButton = pRemote->FirstChildElement();
   while (pButton != nullptr)
   {
     if (!pButton->NoChildren())
@@ -120,7 +122,8 @@ void CIRTranslator::MapRemote(TiXmlNode *pRemote, const std::string &szDevice)
 
   for (const auto& remoteName : remoteNames)
   {
-    CLog::Log(LOGINFO, "* Linking remote mapping for '%s' to '%s'", szDevice.c_str(), remoteName.c_str());
+    CLog::Log(LOGINFO, "* Linking remote mapping for '%s' to '%s'", szDevice.c_str(),
+              remoteName.c_str());
     m_irRemotesMap[remoteName] = buttons;
   }
 }
@@ -130,7 +133,8 @@ void CIRTranslator::Clear()
   m_irRemotesMap.clear();
 }
 
-unsigned int CIRTranslator::TranslateButton(const std::string &szDevice, const std::string &szButton)
+unsigned int CIRTranslator::TranslateButton(const std::string& szDevice,
+                                            const std::string& szButton)
 {
   // Find the device
   auto it = m_irRemotesMap.find(szDevice);
@@ -158,82 +162,148 @@ uint32_t CIRTranslator::TranslateString(std::string strButton)
 
   StringUtils::ToLower(strButton);
 
-  if (strButton == "left") buttonCode = XINPUT_IR_REMOTE_LEFT;
-  else if (strButton == "right") buttonCode = XINPUT_IR_REMOTE_RIGHT;
-  else if (strButton == "up") buttonCode = XINPUT_IR_REMOTE_UP;
-  else if (strButton == "down") buttonCode = XINPUT_IR_REMOTE_DOWN;
-  else if (strButton == "select") buttonCode = XINPUT_IR_REMOTE_SELECT;
-  else if (strButton == "back") buttonCode = XINPUT_IR_REMOTE_BACK;
-  else if (strButton == "menu") buttonCode = XINPUT_IR_REMOTE_MENU;
-  else if (strButton == "info") buttonCode = XINPUT_IR_REMOTE_INFO;
-  else if (strButton == "display") buttonCode = XINPUT_IR_REMOTE_DISPLAY;
-  else if (strButton == "title") buttonCode = XINPUT_IR_REMOTE_TITLE;
-  else if (strButton == "play") buttonCode = XINPUT_IR_REMOTE_PLAY;
-  else if (strButton == "pause") buttonCode = XINPUT_IR_REMOTE_PAUSE;
-  else if (strButton == "reverse") buttonCode = XINPUT_IR_REMOTE_REVERSE;
-  else if (strButton == "forward") buttonCode = XINPUT_IR_REMOTE_FORWARD;
-  else if (strButton == "skipplus") buttonCode = XINPUT_IR_REMOTE_SKIP_PLUS;
-  else if (strButton == "skipminus") buttonCode = XINPUT_IR_REMOTE_SKIP_MINUS;
-  else if (strButton == "stop") buttonCode = XINPUT_IR_REMOTE_STOP;
-  else if (strButton == "zero") buttonCode = XINPUT_IR_REMOTE_0;
-  else if (strButton == "one") buttonCode = XINPUT_IR_REMOTE_1;
-  else if (strButton == "two") buttonCode = XINPUT_IR_REMOTE_2;
-  else if (strButton == "three") buttonCode = XINPUT_IR_REMOTE_3;
-  else if (strButton == "four") buttonCode = XINPUT_IR_REMOTE_4;
-  else if (strButton == "five") buttonCode = XINPUT_IR_REMOTE_5;
-  else if (strButton == "six") buttonCode = XINPUT_IR_REMOTE_6;
-  else if (strButton == "seven") buttonCode = XINPUT_IR_REMOTE_7;
-  else if (strButton == "eight") buttonCode = XINPUT_IR_REMOTE_8;
-  else if (strButton == "nine") buttonCode = XINPUT_IR_REMOTE_9;
+  if (strButton == "left")
+    buttonCode = XINPUT_IR_REMOTE_LEFT;
+  else if (strButton == "right")
+    buttonCode = XINPUT_IR_REMOTE_RIGHT;
+  else if (strButton == "up")
+    buttonCode = XINPUT_IR_REMOTE_UP;
+  else if (strButton == "down")
+    buttonCode = XINPUT_IR_REMOTE_DOWN;
+  else if (strButton == "select")
+    buttonCode = XINPUT_IR_REMOTE_SELECT;
+  else if (strButton == "back")
+    buttonCode = XINPUT_IR_REMOTE_BACK;
+  else if (strButton == "menu")
+    buttonCode = XINPUT_IR_REMOTE_MENU;
+  else if (strButton == "info")
+    buttonCode = XINPUT_IR_REMOTE_INFO;
+  else if (strButton == "display")
+    buttonCode = XINPUT_IR_REMOTE_DISPLAY;
+  else if (strButton == "title")
+    buttonCode = XINPUT_IR_REMOTE_TITLE;
+  else if (strButton == "play")
+    buttonCode = XINPUT_IR_REMOTE_PLAY;
+  else if (strButton == "pause")
+    buttonCode = XINPUT_IR_REMOTE_PAUSE;
+  else if (strButton == "reverse")
+    buttonCode = XINPUT_IR_REMOTE_REVERSE;
+  else if (strButton == "forward")
+    buttonCode = XINPUT_IR_REMOTE_FORWARD;
+  else if (strButton == "skipplus")
+    buttonCode = XINPUT_IR_REMOTE_SKIP_PLUS;
+  else if (strButton == "skipminus")
+    buttonCode = XINPUT_IR_REMOTE_SKIP_MINUS;
+  else if (strButton == "stop")
+    buttonCode = XINPUT_IR_REMOTE_STOP;
+  else if (strButton == "zero")
+    buttonCode = XINPUT_IR_REMOTE_0;
+  else if (strButton == "one")
+    buttonCode = XINPUT_IR_REMOTE_1;
+  else if (strButton == "two")
+    buttonCode = XINPUT_IR_REMOTE_2;
+  else if (strButton == "three")
+    buttonCode = XINPUT_IR_REMOTE_3;
+  else if (strButton == "four")
+    buttonCode = XINPUT_IR_REMOTE_4;
+  else if (strButton == "five")
+    buttonCode = XINPUT_IR_REMOTE_5;
+  else if (strButton == "six")
+    buttonCode = XINPUT_IR_REMOTE_6;
+  else if (strButton == "seven")
+    buttonCode = XINPUT_IR_REMOTE_7;
+  else if (strButton == "eight")
+    buttonCode = XINPUT_IR_REMOTE_8;
+  else if (strButton == "nine")
+    buttonCode = XINPUT_IR_REMOTE_9;
   // Additional keys from the media center extender for xbox remote
-  else if (strButton == "power") buttonCode = XINPUT_IR_REMOTE_POWER;
-  else if (strButton == "mytv") buttonCode = XINPUT_IR_REMOTE_MY_TV;
-  else if (strButton == "mymusic") buttonCode = XINPUT_IR_REMOTE_MY_MUSIC;
-  else if (strButton == "mypictures") buttonCode = XINPUT_IR_REMOTE_MY_PICTURES;
-  else if (strButton == "myvideo") buttonCode = XINPUT_IR_REMOTE_MY_VIDEOS;
-  else if (strButton == "record") buttonCode = XINPUT_IR_REMOTE_RECORD;
-  else if (strButton == "start") buttonCode = XINPUT_IR_REMOTE_START;
-  else if (strButton == "volumeplus") buttonCode = XINPUT_IR_REMOTE_VOLUME_PLUS;
-  else if (strButton == "volumeminus") buttonCode = XINPUT_IR_REMOTE_VOLUME_MINUS;
-  else if (strButton == "channelplus") buttonCode = XINPUT_IR_REMOTE_CHANNEL_PLUS;
-  else if (strButton == "channelminus") buttonCode = XINPUT_IR_REMOTE_CHANNEL_MINUS;
-  else if (strButton == "pageplus") buttonCode = XINPUT_IR_REMOTE_CHANNEL_PLUS;
-  else if (strButton == "pageminus") buttonCode = XINPUT_IR_REMOTE_CHANNEL_MINUS;
-  else if (strButton == "mute") buttonCode = XINPUT_IR_REMOTE_MUTE;
-  else if (strButton == "recordedtv") buttonCode = XINPUT_IR_REMOTE_RECORDED_TV;
-  else if (strButton == "guide") buttonCode = XINPUT_IR_REMOTE_GUIDE;
-  else if (strButton == "livetv") buttonCode = XINPUT_IR_REMOTE_LIVE_TV;
-  else if (strButton == "liveradio") buttonCode = XINPUT_IR_REMOTE_LIVE_RADIO;
-  else if (strButton == "epgsearch") buttonCode = XINPUT_IR_REMOTE_EPG_SEARCH;
-  else if (strButton == "star") buttonCode = XINPUT_IR_REMOTE_STAR;
-  else if (strButton == "hash") buttonCode = XINPUT_IR_REMOTE_HASH;
-  else if (strButton == "clear") buttonCode = XINPUT_IR_REMOTE_CLEAR;
-  else if (strButton == "enter") buttonCode = XINPUT_IR_REMOTE_ENTER;
-  else if (strButton == "xbox") buttonCode = XINPUT_IR_REMOTE_DISPLAY; // Same as display
-  else if (strButton == "playlist") buttonCode = XINPUT_IR_REMOTE_PLAYLIST;
-  else if (strButton == "teletext") buttonCode = XINPUT_IR_REMOTE_TELETEXT;
-  else if (strButton == "red") buttonCode = XINPUT_IR_REMOTE_RED;
-  else if (strButton == "green") buttonCode = XINPUT_IR_REMOTE_GREEN;
-  else if (strButton == "yellow") buttonCode = XINPUT_IR_REMOTE_YELLOW;
-  else if (strButton == "blue") buttonCode = XINPUT_IR_REMOTE_BLUE;
-  else if (strButton == "subtitle") buttonCode = XINPUT_IR_REMOTE_SUBTITLE;
-  else if (strButton == "language") buttonCode = XINPUT_IR_REMOTE_LANGUAGE;
-  else if (strButton == "eject") buttonCode = XINPUT_IR_REMOTE_EJECT;
-  else if (strButton == "contentsmenu") buttonCode = XINPUT_IR_REMOTE_CONTENTS_MENU;
-  else if (strButton == "rootmenu") buttonCode = XINPUT_IR_REMOTE_ROOT_MENU;
-  else if (strButton == "topmenu") buttonCode = XINPUT_IR_REMOTE_TOP_MENU;
-  else if (strButton == "dvdmenu") buttonCode = XINPUT_IR_REMOTE_DVD_MENU;
-  else if (strButton == "print") buttonCode = XINPUT_IR_REMOTE_PRINT;
-  else CLog::Log(LOGERROR, "Remote Translator: Can't find button %s", strButton.c_str());
+  else if (strButton == "power")
+    buttonCode = XINPUT_IR_REMOTE_POWER;
+  else if (strButton == "mytv")
+    buttonCode = XINPUT_IR_REMOTE_MY_TV;
+  else if (strButton == "mymusic")
+    buttonCode = XINPUT_IR_REMOTE_MY_MUSIC;
+  else if (strButton == "mypictures")
+    buttonCode = XINPUT_IR_REMOTE_MY_PICTURES;
+  else if (strButton == "myvideo")
+    buttonCode = XINPUT_IR_REMOTE_MY_VIDEOS;
+  else if (strButton == "record")
+    buttonCode = XINPUT_IR_REMOTE_RECORD;
+  else if (strButton == "start")
+    buttonCode = XINPUT_IR_REMOTE_START;
+  else if (strButton == "volumeplus")
+    buttonCode = XINPUT_IR_REMOTE_VOLUME_PLUS;
+  else if (strButton == "volumeminus")
+    buttonCode = XINPUT_IR_REMOTE_VOLUME_MINUS;
+  else if (strButton == "channelplus")
+    buttonCode = XINPUT_IR_REMOTE_CHANNEL_PLUS;
+  else if (strButton == "channelminus")
+    buttonCode = XINPUT_IR_REMOTE_CHANNEL_MINUS;
+  else if (strButton == "pageplus")
+    buttonCode = XINPUT_IR_REMOTE_CHANNEL_PLUS;
+  else if (strButton == "pageminus")
+    buttonCode = XINPUT_IR_REMOTE_CHANNEL_MINUS;
+  else if (strButton == "mute")
+    buttonCode = XINPUT_IR_REMOTE_MUTE;
+  else if (strButton == "recordedtv")
+    buttonCode = XINPUT_IR_REMOTE_RECORDED_TV;
+  else if (strButton == "guide")
+    buttonCode = XINPUT_IR_REMOTE_GUIDE;
+  else if (strButton == "livetv")
+    buttonCode = XINPUT_IR_REMOTE_LIVE_TV;
+  else if (strButton == "liveradio")
+    buttonCode = XINPUT_IR_REMOTE_LIVE_RADIO;
+  else if (strButton == "epgsearch")
+    buttonCode = XINPUT_IR_REMOTE_EPG_SEARCH;
+  else if (strButton == "star")
+    buttonCode = XINPUT_IR_REMOTE_STAR;
+  else if (strButton == "hash")
+    buttonCode = XINPUT_IR_REMOTE_HASH;
+  else if (strButton == "clear")
+    buttonCode = XINPUT_IR_REMOTE_CLEAR;
+  else if (strButton == "enter")
+    buttonCode = XINPUT_IR_REMOTE_ENTER;
+  else if (strButton == "xbox")
+    buttonCode = XINPUT_IR_REMOTE_DISPLAY; // Same as display
+  else if (strButton == "playlist")
+    buttonCode = XINPUT_IR_REMOTE_PLAYLIST;
+  else if (strButton == "teletext")
+    buttonCode = XINPUT_IR_REMOTE_TELETEXT;
+  else if (strButton == "red")
+    buttonCode = XINPUT_IR_REMOTE_RED;
+  else if (strButton == "green")
+    buttonCode = XINPUT_IR_REMOTE_GREEN;
+  else if (strButton == "yellow")
+    buttonCode = XINPUT_IR_REMOTE_YELLOW;
+  else if (strButton == "blue")
+    buttonCode = XINPUT_IR_REMOTE_BLUE;
+  else if (strButton == "subtitle")
+    buttonCode = XINPUT_IR_REMOTE_SUBTITLE;
+  else if (strButton == "language")
+    buttonCode = XINPUT_IR_REMOTE_LANGUAGE;
+  else if (strButton == "eject")
+    buttonCode = XINPUT_IR_REMOTE_EJECT;
+  else if (strButton == "contentsmenu")
+    buttonCode = XINPUT_IR_REMOTE_CONTENTS_MENU;
+  else if (strButton == "rootmenu")
+    buttonCode = XINPUT_IR_REMOTE_ROOT_MENU;
+  else if (strButton == "topmenu")
+    buttonCode = XINPUT_IR_REMOTE_TOP_MENU;
+  else if (strButton == "dvdmenu")
+    buttonCode = XINPUT_IR_REMOTE_DVD_MENU;
+  else if (strButton == "print")
+    buttonCode = XINPUT_IR_REMOTE_PRINT;
+  else
+    CLog::Log(LOGERROR, "Remote Translator: Can't find button %s", strButton.c_str());
   return buttonCode;
 }
 
-uint32_t CIRTranslator::TranslateUniversalRemoteString(const std::string &szButton)
+uint32_t CIRTranslator::TranslateUniversalRemoteString(const std::string& szButton)
 {
   if (szButton.empty() || szButton.length() < 4 || StringUtils::CompareNoCase(szButton, "obc", 3))
     return 0;
 
-  const char *szCode = szButton.c_str() + 3;
+  const char* szCode = szButton.c_str() + 3;
 
   // Button Code is 255 - OBC (Original Button Code) of the button
   uint32_t buttonCode = 255 - atol(szCode);
diff --git a/xbmc/input/IRTranslator.h b/xbmc/input/IRTranslator.h
index b0406f952b4d..d32363e617e1 100644
--- a/xbmc/input/IRTranslator.h
+++ b/xbmc/input/IRTranslator.h
@@ -22,21 +22,21 @@ class CIRTranslator
   /*!
    * \brief Loads Lircmap.xml/IRSSmap.xml
    */
-  void Load(const std::string &irMapName);
+  void Load(const std::string& irMapName);
 
   /*!
    * \brief Clears the map
    */
   void Clear();
 
-  unsigned int TranslateButton(const std::string &szDevice, const std::string &szButton);
+  unsigned int TranslateButton(const std::string& szDevice, const std::string& szButton);
 
   static uint32_t TranslateString(std::string strButton);
-  static uint32_t TranslateUniversalRemoteString(const std::string &szButton);
+  static uint32_t TranslateUniversalRemoteString(const std::string& szButton);
 
 private:
-  bool LoadIRMap(const std::string &irMapPath);
-  void MapRemote(TiXmlNode *pRemote, const std::string &szDevice);
+  bool LoadIRMap(const std::string& irMapPath);
+  void MapRemote(TiXmlNode* pRemote, const std::string& szDevice);
 
   using IRButtonMap = std::map<std::string, std::string>;
 
diff --git a/xbmc/input/InertialScrollingHandler.cpp b/xbmc/input/InertialScrollingHandler.cpp
index 80e5ca3b124f..9585550b431e 100644
--- a/xbmc/input/InertialScrollingHandler.cpp
+++ b/xbmc/input/InertialScrollingHandler.cpp
@@ -31,8 +31,7 @@
 // maximum time between last movement and gesture end in ms to consider as moving
 #define MAXIMUM_DELAY_FOR_INERTIA 200
 
-CInertialScrollingHandler::CInertialScrollingHandler()
-: m_iLastGesturePoint(CPoint(0,0))
+CInertialScrollingHandler::CInertialScrollingHandler() : m_iLastGesturePoint(CPoint(0, 0))
 {
 }
 
@@ -43,58 +42,60 @@ unsigned int CInertialScrollingHandler::PanPoint::TimeElapsed() const
 
 bool CInertialScrollingHandler::CheckForInertialScrolling(const CAction* action)
 {
-  bool ret = false;//return value - false no inertial scrolling - true - inertial scrolling
+  bool ret = false; // return value - false no inertial scrolling - true - inertial scrolling
 
-  if(CServiceBroker::GetWinSystem()->HasInertialGestures())
+  if (CServiceBroker::GetWinSystem()->HasInertialGestures())
   {
-    return ret;//no need for emulating inertial scrolling - windowing does support it natively.
+    return ret; // no need for emulating inertial scrolling - windowing does support it natively.
   }
 
-  //reset screensaver during pan
-  if( action->GetID() == ACTION_GESTURE_PAN )
+  // reset screensaver during pan
+  if (action->GetID() == ACTION_GESTURE_PAN)
   {
     g_application.ResetScreenSaver();
     if (!m_bScrolling)
     {
-      m_panPoints.emplace_back(CTimeUtils::GetFrameTime(), CVector{action->GetAmount(4), action->GetAmount(5)});
+      m_panPoints.emplace_back(CTimeUtils::GetFrameTime(),
+                               CVector{action->GetAmount(4), action->GetAmount(5)});
     }
     return false;
   }
 
-  //mouse click aborts scrolling
-  if( m_bScrolling && action->GetID() == ACTION_MOUSE_LEFT_CLICK )
+  // mouse click aborts scrolling
+  if (m_bScrolling && action->GetID() == ACTION_MOUSE_LEFT_CLICK)
   {
     ret = true;
-    m_bAborting = true;//lets abort
+    m_bAborting = true; // lets abort
   }
 
-  //trim saved pan points to time range that qualifies for inertial scrolling
+  // trim saved pan points to time range that qualifies for inertial scrolling
   while (!m_panPoints.empty() && m_panPoints.front().TimeElapsed() > MAXIMUM_DELAY_FOR_INERTIA)
     m_panPoints.pop_front();
 
-  //on begin/tap stop all inertial scrolling
-  if ( action->GetID() == ACTION_GESTURE_BEGIN )
+  // on begin/tap stop all inertial scrolling
+  if (action->GetID() == ACTION_GESTURE_BEGIN)
   {
-    //release any former exclusive mouse mode
-    //for making switching between multiple lists
-    //possible
+    // release any former exclusive mouse mode
+    // for making switching between multiple lists
+    // possible
     CGUIMessage message(GUI_MSG_EXCLUSIVE_MOUSE, 0, 0);
     CServiceBroker::GetGUI()->GetWindowManager().SendMessage(message);
     m_bScrolling = false;
-    //wakeup screensaver on pan begin
+    // wakeup screensaver on pan begin
     g_application.ResetScreenSaver();
     g_application.WakeUpScreenSaverAndDPMS();
   }
-  else if(action->GetID() == ACTION_GESTURE_END && !m_panPoints.empty()) //do we need to animate inertial scrolling?
+  else if (action->GetID() == ACTION_GESTURE_END &&
+           !m_panPoints.empty()) // do we need to animate inertial scrolling?
   {
     // Calculate velocity in the last MAXIMUM_DELAY_FOR_INERTIA milliseconds.
     // Do not use the velocity given by the ACTION_GESTURE_END data - it is calculated
     // for the whole duration of the touch and thus useless for inertia. The user
     // may scroll around for a few seconds and then only at the end flick in one
     // direction. Only the last flick should be relevant here.
-    auto velocitySum = std::accumulate(m_panPoints.cbegin(), m_panPoints.cend(), CVector{}, [](CVector val, PanPoint const& p) {
-      return val + p.velocity;
-    });
+    auto velocitySum =
+        std::accumulate(m_panPoints.cbegin(), m_panPoints.cend(), CVector{},
+                        [](CVector val, PanPoint const& p) { return val + p.velocity; });
     auto velocityX = velocitySum.x / m_panPoints.size();
     auto velocityY = velocitySum.y / m_panPoints.size();
 
@@ -111,47 +112,48 @@ bool CInertialScrollingHandler::CheckForInertialScrolling(const CAction* action)
         m_timeToZero = (m_timeToZero * velocityMax) / (MAXIMUM_SPEED_FOR_REDUCTION * dpiScale);
 
       bool inertialRequested = false;
-      CGUIMessage message(GUI_MSG_GESTURE_NOTIFY, 0, 0, static_cast<int> (velocityX), static_cast<int> (velocityY));
+      CGUIMessage message(GUI_MSG_GESTURE_NOTIFY, 0, 0, static_cast<int>(velocityX),
+                          static_cast<int>(velocityY));
 
-      //ask if the control wants inertial scrolling
-      if(CServiceBroker::GetGUI()->GetWindowManager().SendMessage(message))
+      // ask if the control wants inertial scrolling
+      if (CServiceBroker::GetGUI()->GetWindowManager().SendMessage(message))
       {
         int result = 0;
         if (message.GetPointer())
         {
-          int *p = static_cast<int*>(message.GetPointer());
+          int* p = static_cast<int*>(message.GetPointer());
           message.SetPointer(nullptr);
           result = *p;
           delete p;
         }
-        if( result == EVENT_RESULT_PAN_HORIZONTAL ||
-            result == EVENT_RESULT_PAN_VERTICAL)
+        if (result == EVENT_RESULT_PAN_HORIZONTAL || result == EVENT_RESULT_PAN_VERTICAL)
         {
           inertialRequested = true;
         }
       }
 
-      if( inertialRequested )
+      if (inertialRequested)
       {
-        m_iFlickVelocity.x = velocityX;//in pixels per sec
-        m_iFlickVelocity.y = velocityY;//in pixels per sec
-        m_iLastGesturePoint.x = action->GetAmount(2);//last gesture point x
-        m_iLastGesturePoint.y = action->GetAmount(3);//last gesture point y
-
-        //calc deacceleration for fullstop in TIME_TO_ZERO_SPEED secs
-        //v = a*t + v0 -> set v = 0 because we want to stop scrolling
-        //a = -v0 / t
+        m_iFlickVelocity.x = velocityX; // in pixels per sec
+        m_iFlickVelocity.y = velocityY; // in pixels per sec
+        m_iLastGesturePoint.x = action->GetAmount(2); // last gesture point x
+        m_iLastGesturePoint.y = action->GetAmount(3); // last gesture point y
+
+        // calc deacceleration for fullstop in TIME_TO_ZERO_SPEED secs
+        // v = a*t + v0 -> set v = 0 because we want to stop scrolling
+        // a = -v0 / t
         m_inertialDeacceleration.x = -1 * m_iFlickVelocity.x / m_timeToZero;
         m_inertialDeacceleration.y = -1 * m_iFlickVelocity.y / m_timeToZero;
 
-        m_inertialStartTime = CTimeUtils::GetFrameTime();//start time of inertial scrolling
+        m_inertialStartTime = CTimeUtils::GetFrameTime(); // start time of inertial scrolling
         ret = true;
-        m_bScrolling = true;//activate the inertial scrolling animation
+        m_bScrolling = true; // activate the inertial scrolling animation
       }
     }
   }
 
-  if(action->GetID() == ACTION_GESTURE_BEGIN || action->GetID() == ACTION_GESTURE_END || action->GetID() == ACTION_GESTURE_ABORT)
+  if (action->GetID() == ACTION_GESTURE_BEGIN || action->GetID() == ACTION_GESTURE_END ||
+      action->GetID() == ACTION_GESTURE_ABORT)
   {
     m_panPoints.clear();
   }
@@ -161,28 +163,28 @@ bool CInertialScrollingHandler::CheckForInertialScrolling(const CAction* action)
 
 bool CInertialScrollingHandler::ProcessInertialScroll(float frameTime)
 {
-  //do inertial scroll animation by sending gesture_pan
-  if( m_bScrolling)
+  // do inertial scroll animation by sending gesture_pan
+  if (m_bScrolling)
   {
     float xMovement = 0.0;
     float yMovement = 0.0;
 
-    //decrease based on negative acceleration
-    //calc the overall inertial scrolling time in secs
-    float absoluteInertialTime = (CTimeUtils::GetFrameTime() - m_inertialStartTime)/(float)1000;
+    // decrease based on negative acceleration
+    // calc the overall inertial scrolling time in secs
+    float absoluteInertialTime = (CTimeUtils::GetFrameTime() - m_inertialStartTime) / (float)1000;
 
-    //as long as we aren't over the overall inertial scroll time - do the deacceleration
+    // as long as we aren't over the overall inertial scroll time - do the deacceleration
     if (absoluteInertialTime < m_timeToZero)
     {
-      //v = s/t -> s = t * v
+      // v = s/t -> s = t * v
       xMovement = frameTime * m_iFlickVelocity.x;
       yMovement = frameTime * m_iFlickVelocity.y;
 
-      //save new gesture point
+      // save new gesture point
       m_iLastGesturePoint.x += xMovement;
       m_iLastGesturePoint.y += yMovement;
 
-      //fire the pan action
+      // fire the pan action
       if (!g_application.OnAction(CAction(ACTION_GESTURE_PAN, 0, m_iLastGesturePoint.x,
                                           m_iLastGesturePoint.y, xMovement, yMovement,
                                           m_iFlickVelocity.x, m_iFlickVelocity.y)))
@@ -190,34 +192,35 @@ bool CInertialScrollingHandler::ProcessInertialScroll(float frameTime)
         m_bAborting = true; // we are done
       }
 
-      //calc new velocity based on deacceleration
-      //v = a*t + v0
+      // calc new velocity based on deacceleration
+      // v = a*t + v0
       m_iFlickVelocity.x = m_inertialDeacceleration.x * frameTime + m_iFlickVelocity.x;
       m_iFlickVelocity.y = m_inertialDeacceleration.y * frameTime + m_iFlickVelocity.y;
 
-      //check if the signs are equal - which would mean we deaccelerated to long and reversed the direction
-      if( (m_inertialDeacceleration.x < 0) == (m_iFlickVelocity.x < 0) )
+      // check if the signs are equal - which would mean we deaccelerated to long and reversed the
+      // direction
+      if ((m_inertialDeacceleration.x < 0) == (m_iFlickVelocity.x < 0))
       {
         m_iFlickVelocity.x = 0;
       }
-      if( (m_inertialDeacceleration.y < 0) == (m_iFlickVelocity.y < 0) )
+      if ((m_inertialDeacceleration.y < 0) == (m_iFlickVelocity.y < 0))
       {
         m_iFlickVelocity.y = 0;
       }
     }
-    else//no movement -> done
+    else // no movement -> done
     {
-      m_bAborting = true;//we are done
+      m_bAborting = true; // we are done
     }
   }
 
-  //if we are done - or we where aborted
-  if( m_bAborting )
+  // if we are done - or we where aborted
+  if (m_bAborting)
   {
-    //fire gesture end action
+    // fire gesture end action
     g_application.OnAction(CAction(ACTION_GESTURE_END, 0, 0.0f, 0.0f, 0.0f, 0.0f));
     m_bAborting = false;
-    m_bScrolling = false; //stop scrolling
+    m_bScrolling = false; // stop scrolling
     m_iFlickVelocity.x = 0;
     m_iFlickVelocity.y = 0;
   }
diff --git a/xbmc/input/InertialScrollingHandler.h b/xbmc/input/InertialScrollingHandler.h
index 4d79b53a8089..154ea08c2da8 100644
--- a/xbmc/input/InertialScrollingHandler.h
+++ b/xbmc/input/InertialScrollingHandler.h
@@ -19,31 +19,32 @@ class CAction;
 class CInertialScrollingHandler
 {
   friend class CApplication;
-  public:
-    CInertialScrollingHandler();
-
-    bool IsScrolling(){return m_bScrolling;}
-
-  private:
-    bool CheckForInertialScrolling(const CAction* action);
-    bool ProcessInertialScroll(float frameTime);
-
-    //-------------------------------------------vars for inertial scrolling animation with gestures
-    bool          m_bScrolling = false;        //flag indicating that we currently do the inertial scrolling emulation
-    bool          m_bAborting = false;         //flag indicating an abort of scrolling
-    CVector       m_iFlickVelocity;
-
-    struct PanPoint
-    {
-      unsigned int time;
-      CVector velocity;
-      PanPoint(unsigned int time, CVector velocity)
-        : time(time), velocity(velocity) {}
-      unsigned int TimeElapsed() const;
-    };
-    std::deque<PanPoint> m_panPoints;
-    CPoint        m_iLastGesturePoint;
-    CVector       m_inertialDeacceleration;
-    unsigned int  m_inertialStartTime = 0;
-    float m_timeToZero = 0.0f;
+
+public:
+  CInertialScrollingHandler();
+
+  bool IsScrolling() { return m_bScrolling; }
+
+private:
+  bool CheckForInertialScrolling(const CAction* action);
+  bool ProcessInertialScroll(float frameTime);
+
+  //-------------------------------------------vars for inertial scrolling animation with gestures
+  bool m_bScrolling = false; // flag indicating that we currently do the inertial scrolling
+                             // emulation
+  bool m_bAborting = false; // flag indicating an abort of scrolling
+  CVector m_iFlickVelocity;
+
+  struct PanPoint
+  {
+    unsigned int time;
+    CVector velocity;
+    PanPoint(unsigned int time, CVector velocity) : time(time), velocity(velocity) {}
+    unsigned int TimeElapsed() const;
+  };
+  std::deque<PanPoint> m_panPoints;
+  CPoint m_iLastGesturePoint;
+  CVector m_inertialDeacceleration;
+  unsigned int m_inertialStartTime = 0;
+  float m_timeToZero = 0.0f;
 };
diff --git a/xbmc/input/InputCodingTable.h b/xbmc/input/InputCodingTable.h
index 53d5241d5ad2..8e72a7fa4b0a 100644
--- a/xbmc/input/InputCodingTable.h
+++ b/xbmc/input/InputCodingTable.h
@@ -15,7 +15,11 @@
 class IInputCodingTable
 {
 public:
-  enum { TYPE_WORD_LIST, TYPE_CONVERT_STRING };
+  enum
+  {
+    TYPE_WORD_LIST,
+    TYPE_CONVERT_STRING
+  };
   virtual int GetType() { return TYPE_WORD_LIST; }
 
   virtual ~IInputCodingTable() = default;
@@ -33,8 +37,8 @@ class IInputCodingTable
   */
   virtual void Deinitialize() {}
 
-  /*! \brief Can be overridden if initialization is expensive to avoid calling initialize more than needed
-      \return true if initialization has been done and was successful, false otherwise.
+  /*! \brief Can be overridden if initialization is expensive to avoid calling initialize more than
+     needed \return true if initialization has been done and was successful, false otherwise.
   */
   virtual bool IsInitialized() const { return true; }
   virtual bool GetWordListPage(const std::string& strCode, bool isFirstPage) = 0;
diff --git a/xbmc/input/InputCodingTableBaiduPY.cpp b/xbmc/input/InputCodingTableBaiduPY.cpp
index 84bc671f7145..3506369f5e02 100644
--- a/xbmc/input/InputCodingTableBaiduPY.cpp
+++ b/xbmc/input/InputCodingTableBaiduPY.cpp
@@ -19,13 +19,13 @@
 #include <stdlib.h>
 #include <utility>
 
-CInputCodingTableBaiduPY::CInputCodingTableBaiduPY(const std::string& strUrl) :
-  CThread("BaiduPYApi"),
-  m_messageCounter{ 0 },
-  m_api_begin{ 0 },
-  m_api_end{ 20 },
-  m_api_nomore{ false },
-  m_initialized{ false }
+CInputCodingTableBaiduPY::CInputCodingTableBaiduPY(const std::string& strUrl)
+  : CThread("BaiduPYApi"),
+    m_messageCounter{0},
+    m_api_begin{0},
+    m_api_end{20},
+    m_api_nomore{false},
+    m_initialized{false}
 {
   m_url = strUrl;
   m_codechars = "abcdefghijklmnopqrstuvwxyz";
@@ -35,10 +35,10 @@ CInputCodingTableBaiduPY::CInputCodingTableBaiduPY(const std::string& strUrl) :
 void CInputCodingTableBaiduPY::Process()
 {
   m_initialized = true;
-  while (!m_bStop) //Make sure we don't exit the thread
+  while (!m_bStop) // Make sure we don't exit the thread
   {
-    AbortableWait(m_Event, -1); //Wait for work to appear
-    while (!m_bStop) //Process all queued work before going back to wait on the event
+    AbortableWait(m_Event, -1); // Wait for work to appear
+    while (!m_bStop) // Process all queued work before going back to wait on the event
     {
       CSingleLock lock(m_CS);
       if (m_work.empty())
@@ -59,7 +59,8 @@ void CInputCodingTableBaiduPY::Process()
   }
 }
 
-void CInputCodingTableBaiduPY::HandleResponse(const std::string& strCode, const std::string& response)
+void CInputCodingTableBaiduPY::HandleResponse(const std::string& strCode,
+                                              const std::string& response)
 {
   if (strCode != m_code) // don't handle obsolete response
     return;
@@ -89,7 +90,8 @@ void CInputCodingTableBaiduPY::HandleResponse(const std::string& strCode, const
   CGUIMessage msg(GUI_MSG_CODINGTABLE_LOOKUP_COMPLETED, 0, 0, m_messageCounter);
   msg.SetStringParam(strCode);
   lock.Leave();
-  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msg, CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog());
+  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(
+      msg, CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog());
 }
 
 std::wstring CInputCodingTableBaiduPY::UnicodeToWString(const std::string& unicode)
diff --git a/xbmc/input/InputCodingTableBaiduPY.h b/xbmc/input/InputCodingTableBaiduPY.h
index 3fe43e497134..0b78cf4ba82c 100644
--- a/xbmc/input/InputCodingTableBaiduPY.h
+++ b/xbmc/input/InputCodingTableBaiduPY.h
@@ -29,6 +29,7 @@ class CInputCodingTableBaiduPY : public IInputCodingTable, public CThread
   void Process() override;
 
   std::vector<std::wstring> GetResponse(int response) override;
+
 private:
   std::wstring UnicodeToWString(const std::string& unicode);
   void HandleResponse(const std::string& strCode, const std::string& response);
@@ -37,12 +38,12 @@ class CInputCodingTableBaiduPY : public IInputCodingTable, public CThread
   std::string m_code;
   int m_messageCounter;
   int m_api_begin; // baidu api begin num
-  int m_api_end;   // baidu api end num
+  int m_api_end; // baidu api end num
   bool m_api_nomore;
   bool m_initialized;
 
   std::deque<std::string> m_work;
   std::map<int, std::vector<std::wstring>> m_responses;
-  CEvent            m_Event;
-  CCriticalSection  m_CS;
+  CEvent m_Event;
+  CCriticalSection m_CS;
 };
diff --git a/xbmc/input/InputCodingTableBasePY.cpp b/xbmc/input/InputCodingTableBasePY.cpp
index 948e60a922f5..b1ab319965b9 100644
--- a/xbmc/input/InputCodingTableBasePY.cpp
+++ b/xbmc/input/InputCodingTableBasePY.cpp
@@ -16,416 +16,445 @@
 
 #include <stdlib.h>
 
-static std::map<std::string, std::wstring> codemap =
-{
-  { "a", L"" },
-  { "ai", L"" },
-  { "an", L"" },
-  { "ang", L"" },
-  { "ao", L"" },
-  { "ba", L"" },
-  { "bai", L"" },
-  { "ban", L"" },
-  { "bang", L"" },
-  { "bao", L"" },
-  { "bei", L"" },
-  { "ben", L"" },
-  { "beng", L"" },
-  { "bi", L"" },
-  { "bian", L"" },
-  { "biao", L"" },
-  { "bie", L"" },
-  { "bin", L"" },
-  { "bing", L"" },
-  { "bo", L"" },
-  { "bu", L"" },
-  { "ca", L"" },
-  { "cai", L"" },
-  { "can", L"" },
-  { "cang", L"" },
-  { "cao", L"" },
-  { "ce", L"" },
-  { "cen", L"" },
-  { "ceng", L"" },
-  { "cha", L"" },
-  { "chai", L"" },
-  { "chan", L"" },
-  { "chang", L"" },
-  { "chao", L"" },
-  { "che", L"" },
-  { "chen", L"" },
-  { "cheng", L"" },
-  { "chi", L"" },
-  { "chong", L"" },
-  { "chou", L"" },
-  { "chu", L"" },
-  { "chuai", L"" },
-  { "chuan", L"" },
-  { "chuang", L"" },
-  { "chui", L"" },
-  { "chun", L"" },
-  { "chuo", L"" },
-  { "ci", L"" },
-  { "cong", L"" },
-  { "cou", L"" },
-  { "cu", L"" },
-  { "cuan", L"" },
-  { "cui", L"" },
-  { "cun", L"" },
-  { "cuo", L"" },
-  { "da", L"" },
-  { "dai", L"" },
-  { "dan", L"" },
-  { "dang", L"" },
-  { "dao", L"" },
-  { "de", L"" },
-  { "dei", L"" },
-  { "deng", L"" },
-  { "di", L"" },
-  { "dia", L"" },
-  { "dian", L"" },
-  { "diao", L"" },
-  { "die", L"" },
-  { "ding", L"" },
-  { "diu", L"" },
-  { "dong", L"" },
-  { "dou", L"" },
-  { "du", L"" },
-  { "duan", L"" },
-  { "dui", L"" },
-  { "dun", L"" },
-  { "duo", L"" },
-  { "e", L"" },
-  { "ei", L"" },
-  { "en", L"" },
-  { "er", L"" },
-  { "fa", L"" },
-  { "fan", L"" },
-  { "fang", L"" },
-  { "fei", L"" },
-  { "fen", L"" },
-  { "feng", L"" },
-  { "fo", L"" },
-  { "fou", L"" },
-  { "fu", L"" },
-  { "ga", L"" },
-  { "gai", L"" },
-  { "gan", L"" },
-  { "gang", L"" },
-  { "gao", L"" },
-  { "ge", L"" },
-  { "gei", L"" },
-  { "gen", L"" },
-  { "geng", L"" },
-  { "gong", L"" },
-  { "gou", L"" },
-  { "gu", L"" },
-  { "gua", L"" },
-  { "guai", L"" },
-  { "guan", L"" },
-  { "guang", L"" },
-  { "gui", L"" },
-  { "gun", L"" },
-  { "guo", L"" },
-  { "ha", L"" },
-  { "hai", L"" },
-  { "han", L"" },
-  { "hang", L"" },
-  { "hao", L"" },
-  { "he", L"" },
-  { "hei", L"" },
-  { "hen", L"" },
-  { "heng", L"" },
-  { "hong", L"" },
-  { "hou", L"" },
-  { "hu", L"" },
-  { "hua", L"" },
-  { "huai", L"" },
-  { "huan", L"" },
-  { "huang", L"" },
-  { "hui", L"" },
-  { "hun", L"" },
-  { "huo", L"" },
-  { "ji", L"" },
-  { "jia", L"" },
-  { "jian", L"" },
-  { "jiang", L"" },
-  { "jiao", L"" },
-  { "jie", L"" },
-  { "jin", L"" },
-  { "jing", L"" },
-  { "jiong", L"" },
-  { "jiu", L"" },
-  { "ju", L"" },
-  { "juan", L"" },
-  { "jue", L"" },
-  { "jun", L"" },
-  { "ka", L"" },
-  { "kai", L"" },
-  { "kan", L"" },
-  { "kang", L"" },
-  { "kao", L"" },
-  { "ke", L"" },
-  { "ken", L"" },
-  { "keng", L"" },
-  { "kong", L"" },
-  { "kou", L"" },
-  { "ku", L"" },
-  { "kua", L"" },
-  { "kuai", L"" },
-  { "kuan", L"" },
-  { "kuang", L"" },
-  { "kui", L"" },
-  { "kun", L"" },
-  { "kuo", L"" },
-  { "la", L"" },
-  { "lai", L"" },
-  { "lan", L"" },
-  { "lang", L"" },
-  { "lao", L"" },
-  { "le", L"" },
-  { "lei", L"" },
-  { "leng", L"" },
-  { "li", L"" },
-  { "lia", L"" },
-  { "lian", L"" },
-  { "liang", L"" },
-  { "liao", L"" },
-  { "lie", L"" },
-  { "lin", L"" },
-  { "ling", L"" },
-  { "liu", L"" },
-  { "lo", L"" },
-  { "long", L"" },
-  { "lou", L"" },
-  { "lu", L"" },
-  { "luan", L"" },
-  { "lue", L"" },
-  { "lun", L"" },
-  { "luo", L"" },
-  { "lv", L"" },
-  { "lve", L"" },
-  { "m", L"" },
-  { "ma", L"" },
-  { "mai", L"" },
-  { "man", L"" },
-  { "mang", L"" },
-  { "mao", L"" },
-  { "me", L"" },
-  { "mei", L"" },
-  { "men", L"" },
-  { "meng", L"" },
-  { "mi", L"" },
-  { "mian", L"" },
-  { "miao", L"" },
-  { "mie", L"" },
-  { "min", L"" },
-  { "ming", L"" },
-  { "miu", L"" },
-  { "mo", L"" },
-  { "mou", L"" },
-  { "mu", L"" },
-  { "na", L"" },
-  { "nai", L"" },
-  { "nan", L"" },
-  { "nang", L"" },
-  { "nao", L"" },
-  { "ne", L"" },
-  { "nei", L"" },
-  { "nen", L"" },
-  { "neng", L"" },
-  { "ng", L"" },
-  { "ni", L"" },
-  { "nian", L"" },
-  { "niang", L"" },
-  { "niao", L"" },
-  { "nie", L"" },
-  { "nin", L"" },
-  { "ning", L"" },
-  { "niu", L"" },
-  { "nong", L"" },
-  { "nou", L"" },
-  { "nu", L"" },
-  { "nuan", L"" },
-  { "nue", L"" },
-  { "nuo", L"" },
-  { "nv", L"" },
-  { "nve", L"" },
-  { "o", L"" },
-  { "ou", L"" },
-  { "pa", L"" },
-  { "pai", L"" },
-  { "pan", L"" },
-  { "pang", L"" },
-  { "pao", L"" },
-  { "pei", L"" },
-  { "pen", L"" },
-  { "peng", L"" },
-  { "pi", L"" },
-  { "pian", L"" },
-  { "piao", L"" },
-  { "pie", L"" },
-  { "pin", L"" },
-  { "ping", L"" },
-  { "po", L"" },
-  { "pou", L"" },
-  { "pu", L"" },
-  { "qi", L"" },
-  { "qia", L"" },
-  { "qian", L"" },
-  { "qiang", L"" },
-  { "qiao", L"" },
-  { "qie", L"" },
-  { "qin", L"" },
-  { "qing", L"" },
-  { "qiong", L"" },
-  { "qiu", L"" },
-  { "qu", L"" },
-  { "quan", L"" },
-  { "que", L"" },
-  { "qun", L"" },
-  { "ran", L"" },
-  { "rang", L"" },
-  { "rao", L"" },
-  { "re", L"" },
-  { "ren", L"" },
-  { "reng", L"" },
-  { "ri", L"" },
-  { "rong", L"" },
-  { "rou", L"" },
-  { "ru", L"" },
-  { "ruan", L"" },
-  { "rui", L"" },
-  { "run", L"" },
-  { "ruo", L"" },
-  { "sa", L"" },
-  { "sai", L"" },
-  { "san", L"" },
-  { "sang", L"" },
-  { "sao", L"" },
-  { "se", L"" },
-  { "sen", L"" },
-  { "seng", L"" },
-  { "sha", L"" },
-  { "shai", L"" },
-  { "shan", L"" },
-  { "shang", L"" },
-  { "shao", L"" },
-  { "she", L"" },
-  { "shei", L"" },
-  { "shen", L"" },
-  { "sheng", L"" },
-  { "shi", L"" },
-  { "shou", L"" },
-  { "shu", L"" },
-  { "shua", L"" },
-  { "shuai", L"" },
-  { "shuan", L"" },
-  { "shuang", L"" },
-  { "shui", L"" },
-  { "shun", L"" },
-  { "shuo", L"" },
-  { "si", L"" },
-  { "song", L"" },
-  { "sou", L"" },
-  { "su", L"" },
-  { "suan", L"" },
-  { "sui", L"" },
-  { "sun", L"" },
-  { "suo", L"" },
-  { "ta", L"" },
-  { "tai", L"" },
-  { "tan", L"" },
-  { "tang", L"" },
-  { "tao", L"" },
-  { "te", L"" },
-  { "teng", L"" },
-  { "ti", L"" },
-  { "tian", L"" },
-  { "tiao", L"" },
-  { "tie", L"" },
-  { "ting", L"" },
-  { "tong", L"" },
-  { "tou", L"" },
-  { "tu", L"" },
-  { "tuan", L"" },
-  { "tui", L"" },
-  { "tun", L"" },
-  { "tuo", L"" },
-  { "wa", L"" },
-  { "wai", L"" },
-  { "wan", L"" },
-  { "wang", L"" },
-  { "wei", L"" },
-  { "wen", L"" },
-  { "weng", L"" },
-  { "wo", L"" },
-  { "wu", L"" },
-  { "xi", L"" },
-  { "xia", L"" },
-  { "xian", L"" },
-  { "xiang", L"" },
-  { "xiao", L"" },
-  { "xie", L"" },
-  { "xin", L"" },
-  { "xing", L"" },
-  { "xiong", L"" },
-  { "xiu", L"" },
-  { "xu", L"" },
-  { "xuan", L"" },
-  { "xue", L"" },
-  { "xun", L"" },
-  { "ya", L"" },
-  { "yan", L"" },
-  { "yang", L"" },
-  { "yao", L"" },
-  { "ye", L"" },
-  { "yi", L"" },
-  { "yin", L"" },
-  { "ying", L"" },
-  { "yo", L"" },
-  { "yong", L"" },
-  { "you", L"" },
-  { "yu", L"" },
-  { "yuan", L"" },
-  { "yue", L"" },
-  { "yun", L"" },
-  { "za", L"" },
-  { "zai", L"" },
-  { "zan", L"" },
-  { "zang", L"" },
-  { "zao", L"" },
-  { "ze", L"" },
-  { "zei", L"" },
-  { "zen", L"" },
-  { "zeng", L"" },
-  { "zha", L"" },
-  { "zhai", L"" },
-  { "zhan", L"" },
-  { "zhang", L"" },
-  { "zhao", L"" },
-  { "zhe", L"" },
-  { "zhen", L"" },
-  { "zheng", L"" },
-  { "zhi", L"" },
-  { "zhong", L"" },
-  { "zhou", L"" },
-  { "zhu", L"" },
-  { "zhua", L"" },
-  { "zhuai", L"" },
-  { "zhuan", L"" },
-  { "zhuang", L"" },
-  { "zhui", L"" },
-  { "zhun", L"" },
-  { "zhuo", L"" },
-  { "zi", L"" },
-  { "zong", L"" },
-  { "zou", L"" },
-  { "zu", L"" },
-  { "zuan", L"" },
-  { "zui", L"" },
-  { "zun", L"" },
-  { "zuo", L"" },
+static std::map<std::string, std::wstring> codemap = {
+    {"a", L""},
+    {"ai", L""},
+    {"an", L""},
+    {"ang", L""},
+    {"ao", L""},
+    {"ba", L""},
+    {"bai", L""},
+    {"ban", L""},
+    {"bang", L""},
+    {"bao", L""},
+    {"bei", L""},
+    {"ben", L""},
+    {"beng", L""},
+    {"bi", L""
+           L""},
+    {"bian", L""},
+    {"biao", L""},
+    {"bie", L""},
+    {"bin", L""},
+    {"bing", L""},
+    {"bo", L""},
+    {"bu", L""},
+    {"ca", L""},
+    {"cai", L""},
+    {"can", L""},
+    {"cang", L""},
+    {"cao", L""},
+    {"ce", L""},
+    {"cen", L""},
+    {"ceng", L""},
+    {"cha", L""},
+    {"chai", L""},
+    {"chan", L""},
+    {"chang", L""},
+    {"chao", L""},
+    {"che", L""},
+    {"chen", L""},
+    {"cheng", L""},
+    {"chi", L""},
+    {"chong", L""},
+    {"chou", L""},
+    {"chu", L""},
+    {"chuai", L""},
+    {"chuan", L""},
+    {"chuang", L""},
+    {"chui", L""},
+    {"chun", L""},
+    {"chuo", L""},
+    {"ci", L""},
+    {"cong", L""},
+    {"cou", L""},
+    {"cu", L""},
+    {"cuan", L""},
+    {"cui", L""},
+    {"cun", L""},
+    {"cuo", L""},
+    {"da", L""},
+    {"dai", L""},
+    {"dan", L""},
+    {"dang", L""},
+    {"dao", L""},
+    {"de", L""},
+    {"dei", L""},
+    {"deng", L""},
+    {"di", L""},
+    {"dia", L""},
+    {"dian", L""},
+    {"diao", L""},
+    {"die", L""},
+    {"ding", L""},
+    {"diu", L""},
+    {"dong", L""},
+    {"dou", L""},
+    {"du", L""},
+    {"duan", L""},
+    {"dui", L""},
+    {"dun", L""},
+    {"duo", L""},
+    {"e", L""},
+    {"ei", L""},
+    {"en", L""},
+    {"er", L""},
+    {"fa", L""},
+    {"fan", L""},
+    {"fang", L""},
+    {"fei", L""},
+    {"fen", L""},
+    {"feng", L""},
+    {"fo", L""},
+    {"fou", L""},
+    {"fu", L""
+           L""},
+    {"ga", L""},
+    {"gai", L""},
+    {"gan", L""},
+    {"gang", L""},
+    {"gao", L""},
+    {"ge", L""},
+    {"gei", L""},
+    {"gen", L""},
+    {"geng", L""},
+    {"gong", L""},
+    {"gou", L""},
+    {"gu", L""},
+    {"gua", L""},
+    {"guai", L""},
+    {"guan", L""},
+    {"guang", L""},
+    {"gui", L""},
+    {"gun", L""},
+    {"guo", L""},
+    {"ha", L""},
+    {"hai", L""},
+    {"han", L""},
+    {"hang", L""},
+    {"hao", L""},
+    {"he", L""},
+    {"hei", L""},
+    {"hen", L""},
+    {"heng", L""},
+    {"hong", L""},
+    {"hou", L""},
+    {"hu", L""
+           L""},
+    {"hua", L""},
+    {"huai", L""},
+    {"huan", L""},
+    {"huang", L""},
+    {"hui", L""},
+    {"hun", L""},
+    {"huo", L""},
+    {"ji", L""
+           L""
+           L""},
+    {"jia", L""},
+    {"jian", L""
+             L""},
+    {"jiang", L""},
+    {"jiao", L""
+             L""},
+    {"jie",
+     L""},
+    {"jin", L""},
+    {"jing",
+     L""},
+    {"jiong", L""},
+    {"jiu", L""},
+    {"ju", L""
+           L""},
+    {"juan", L""},
+    {"jue", L""},
+    {"jun", L""},
+    {"ka", L""},
+    {"kai", L""},
+    {"kan", L""},
+    {"kang", L""},
+    {"kao", L""},
+    {"ke", L""},
+    {"ken", L""},
+    {"keng", L""},
+    {"kong", L""},
+    {"kou", L""},
+    {"ku", L""},
+    {"kua", L""},
+    {"kuai", L""},
+    {"kuan", L""},
+    {"kuang", L""},
+    {"kui", L""},
+    {"kun", L""},
+    {"kuo", L""},
+    {"la", L""},
+    {"lai", L""},
+    {"lan", L""},
+    {"lang", L""},
+    {"lao", L""},
+    {"le", L""},
+    {"lei", L""},
+    {"leng", L""},
+    {"li", L""
+           L""},
+    {"lia", L""},
+    {"lian", L""},
+    {"liang", L""},
+    {"liao", L""},
+    {"lie", L""},
+    {"lin", L""},
+    {"ling", L""},
+    {"liu", L""},
+    {"lo", L""},
+    {"long", L""},
+    {"lou", L""},
+    {"lu",
+     L""},
+    {"luan", L""},
+    {"lue", L""},
+    {"lun", L""},
+    {"luo", L""},
+    {"lv", L""},
+    {"lve", L""},
+    {"m", L""},
+    {"ma", L""},
+    {"mai", L""},
+    {"man", L""},
+    {"mang", L""},
+    {"mao", L""},
+    {"me", L""},
+    {"mei", L""},
+    {"men", L""},
+    {"meng", L""},
+    {"mi", L""},
+    {"mian", L""},
+    {"miao", L""},
+    {"mie", L""},
+    {"min", L""},
+    {"ming", L""},
+    {"miu", L""},
+    {"mo", L""},
+    {"mou", L""},
+    {"mu", L""},
+    {"na", L""},
+    {"nai", L""},
+    {"nan", L""},
+    {"nang", L""},
+    {"nao", L""},
+    {"ne", L""},
+    {"nei", L""},
+    {"nen", L""},
+    {"neng", L""},
+    {"ng", L""},
+    {"ni", L""},
+    {"nian", L""},
+    {"niang", L""},
+    {"niao", L""},
+    {"nie", L""},
+    {"nin", L""},
+    {"ning", L""},
+    {"niu", L""},
+    {"nong", L""},
+    {"nou", L""},
+    {"nu", L""},
+    {"nuan", L""},
+    {"nue", L""},
+    {"nuo", L""},
+    {"nv", L""},
+    {"nve", L""},
+    {"o", L""},
+    {"ou", L""},
+    {"pa", L""},
+    {"pai", L""},
+    {"pan", L""},
+    {"pang", L""},
+    {"pao", L""},
+    {"pei", L""},
+    {"pen", L""},
+    {"peng", L""},
+    {"pi", L""
+           L""},
+    {"pian", L""},
+    {"piao", L""},
+    {"pie", L""},
+    {"pin", L""},
+    {"ping", L""},
+    {"po", L""},
+    {"pou", L""},
+    {"pu", L""},
+    {"qi", L""
+           L""},
+    {"qia", L""},
+    {"qian", L""
+             L""},
+    {"qiang", L""},
+    {"qiao", L""},
+    {"qie", L""},
+    {"qin", L""},
+    {"qing", L""},
+    {"qiong", L""},
+    {"qiu", L""},
+    {"qu", L""},
+    {"quan", L""},
+    {"que", L""},
+    {"qun", L""},
+    {"ran", L""},
+    {"rang", L""},
+    {"rao", L""},
+    {"re", L""},
+    {"ren", L""},
+    {"reng", L""},
+    {"ri", L""},
+    {"rong", L""},
+    {"rou", L""},
+    {"ru", L""},
+    {"ruan", L""},
+    {"rui", L""},
+    {"run", L""},
+    {"ruo", L""},
+    {"sa", L""},
+    {"sai", L""},
+    {"san", L""},
+    {"sang", L""},
+    {"sao", L""},
+    {"se", L""},
+    {"sen", L""},
+    {"seng", L""},
+    {"sha", L""},
+    {"shai", L""},
+    {"shan", L""},
+    {"shang", L""},
+    {"shao", L""},
+    {"she", L""},
+    {"shei", L""},
+    {"shen", L""},
+    {"sheng", L""},
+    {"shi", L""
+            L""},
+    {"shou", L""},
+    {"shu", L""
+            L""},
+    {"shua", L""},
+    {"shuai", L""},
+    {"shuan", L""},
+    {"shuang", L""},
+    {"shui", L""},
+    {"shun", L""},
+    {"shuo", L""},
+    {"si", L""},
+    {"song", L""},
+    {"sou", L""},
+    {"su", L""},
+    {"suan", L""},
+    {"sui", L""},
+    {"sun", L""},
+    {"suo", L""},
+    {"ta", L""},
+    {"tai", L""},
+    {"tan", L""},
+    {"tang", L""},
+    {"tao", L""},
+    {"te", L""},
+    {"teng", L""},
+    {"ti", L""},
+    {"tian", L""},
+    {"tiao", L""},
+    {"tie", L""},
+    {"ting", L""},
+    {"tong", L""},
+    {"tou", L""},
+    {"tu", L""},
+    {"tuan", L""},
+    {"tui", L""},
+    {"tun", L""},
+    {"tuo", L""},
+    {"wa", L""},
+    {"wai", L""},
+    {"wan", L""},
+    {"wang", L""},
+    {"wei", L""
+            L""},
+    {"wen", L""},
+    {"weng", L""},
+    {"wo", L""},
+    {"wu", L""
+           L""},
+    {"xi", L""
+           L""},
+    {"xia", L""},
+    {"xian", L""
+             L""},
+    {"xiang", L""},
+    {"xiao", L""},
+    {"xie",
+     L""},
+    {"xin", L""},
+    {"xing", L""},
+    {"xiong", L""},
+    {"xiu", L""},
+    {"xu", L""},
+    {"xuan", L""},
+    {"xue", L""},
+    {"xun", L""},
+    {"ya", L""},
+    {"yan", L""
+            L""},
+    {"yang", L""},
+    {"yao", L""},
+    {"ye", L""},
+    {"yi", L""
+           L""
+           L""},
+    {"yin", L""},
+    {"ying", L""},
+    {"yo", L""},
+    {"yong", L""},
+    {"you",
+     L""},
+    {"yu", L""
+           L""
+           L""},
+    {"yuan", L""},
+    {"yue", L""},
+    {"yun", L""},
+    {"za", L""},
+    {"zai", L""},
+    {"zan", L""},
+    {"zang", L""},
+    {"zao", L""},
+    {"ze", L""},
+    {"zei", L""},
+    {"zen", L""},
+    {"zeng", L""},
+    {"zha", L""},
+    {"zhai", L""},
+    {"zhan", L""},
+    {"zhang", L""},
+    {"zhao", L""},
+    {"zhe", L""},
+    {"zhen", L""},
+    {"zheng", L""},
+    {"zhi", L""
+            L""},
+    {"zhong", L""},
+    {"zhou", L""},
+    {"zhu", L""
+            L""},
+    {"zhua", L""},
+    {"zhuai", L""},
+    {"zhuan", L""},
+    {"zhuang", L""},
+    {"zhui", L""},
+    {"zhun", L""},
+    {"zhuo", L""},
+    {"zi", L""},
+    {"zong", L""},
+    {"zou", L""},
+    {"zu", L""},
+    {"zuan", L""},
+    {"zui", L""},
+    {"zun", L""},
+    {"zuo", L""},
 };
 
 CInputCodingTableBasePY::CInputCodingTableBasePY()
@@ -454,6 +483,7 @@ bool CInputCodingTableBasePY::GetWordListPage(const std::string& strCode, bool i
   }
   CGUIMessage msg(GUI_MSG_CODINGTABLE_LOOKUP_COMPLETED, 0, 0, 0);
   msg.SetStringParam(strCode);
-  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msg, CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog());
+  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(
+      msg, CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog());
   return true;
 }
diff --git a/xbmc/input/InputCodingTableBasePY.h b/xbmc/input/InputCodingTableBasePY.h
index 0ea060d05c4e..243b4de275ce 100644
--- a/xbmc/input/InputCodingTableBasePY.h
+++ b/xbmc/input/InputCodingTableBasePY.h
@@ -22,6 +22,7 @@ class CInputCodingTableBasePY : public IInputCodingTable
 
   bool GetWordListPage(const std::string& strCode, bool isFirstPage) override;
   std::vector<std::wstring> GetResponse(int) override;
+
 private:
   std::vector<std::wstring> m_words;
 };
diff --git a/xbmc/input/InputCodingTableFactory.cpp b/xbmc/input/InputCodingTableFactory.cpp
index c4bed07242fe..e43616cbd255 100644
--- a/xbmc/input/InputCodingTableFactory.cpp
+++ b/xbmc/input/InputCodingTableFactory.cpp
@@ -14,7 +14,8 @@
 #include "utils/XBMCTinyXML.h"
 #include "utils/log.h"
 
-IInputCodingTable* CInputCodingTableFactory::CreateCodingTable(const std::string& strTableName, const TiXmlElement* element)
+IInputCodingTable* CInputCodingTableFactory::CreateCodingTable(const std::string& strTableName,
+                                                               const TiXmlElement* element)
 {
   if (strTableName == "BaiduPY")
   {
diff --git a/xbmc/input/InputCodingTableFactory.h b/xbmc/input/InputCodingTableFactory.h
index da58beeef42a..a2dc247aa134 100644
--- a/xbmc/input/InputCodingTableFactory.h
+++ b/xbmc/input/InputCodingTableFactory.h
@@ -16,5 +16,6 @@ class IInputCodingTable;
 class CInputCodingTableFactory
 {
 public:
-  static IInputCodingTable* CreateCodingTable(const std::string& strTableName, const TiXmlElement* element);
+  static IInputCodingTable* CreateCodingTable(const std::string& strTableName,
+                                              const TiXmlElement* element);
 };
diff --git a/xbmc/input/InputCodingTableKorean.cpp b/xbmc/input/InputCodingTableKorean.cpp
index 28aa4c4cce9d..a0ec1ecd22c6 100644
--- a/xbmc/input/InputCodingTableKorean.cpp
+++ b/xbmc/input/InputCodingTableKorean.cpp
@@ -31,7 +31,7 @@ void CInputCodingTableKorean::SetTextPrev(const std::string& strTextPrev)
 
 int CInputCodingTableKorean::MergeCode(int choseong, int jungseong, int jongseong)
 {
-  return (unsigned short) 0xAC00 + choseong * 21 * 28 + jungseong * 28 + jongseong + 1;
+  return (unsigned short)0xAC00 + choseong * 21 * 28 + jungseong * 28 + jongseong + 1;
 }
 
 // Reference
@@ -40,16 +40,24 @@ int CInputCodingTableKorean::MergeCode(int choseong, int jungseong, int jongseon
 
 std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
 {
-  std::wstring dicEnglish = //L"rRseEfaqQtTdwWczxvgkoiOjpuPhynbml";
-  { 0x72, 0x52, 0x73, 0x65, 0x45, 0x66, 0x61, 0x71, 0x51, 0x74, 0x54, 0x64, 0x77, 0x57, 0x63, 0x7A, 0x78, 0x76, 0x67, 0x6B, 0x6F, 0x69, 0x4F, 0x6A, 0x70, 0x75, 0x50, 0x68, 0x79, 0x6E, 0x62, 0x6D, 0x6C };
-  std::wstring dicKorean = //L"";
-  { 0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139, 0x3141, 0x3142, 0x3143, 0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e, 0x314f, 0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157, 0x315b, 0x315c, 0x3160, 0x3161, 0x3163 };
-  std::wstring dicChoseong = //L"";
-  { 0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139, 0x3141, 0x3142, 0x3143, 0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e };
-  std::wstring dicJungseong = //L"";
-  { 0x314f, 0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157, 0x3158, 0x3159, 0x315a, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160, 0x3161, 0x3162, 0x3163 };
-  std::wstring dicJongseong = //L"";
-  { 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d, 0x313e, 0x313f, 0x3140, 0x3141, 0x3142, 0x3144, 0x3145, 0x3146, 0x3147, 0x3148, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e };
+  std::wstring dicEnglish = // L"rRseEfaqQtTdwWczxvgkoiOjpuPhynbml";
+      {0x72, 0x52, 0x73, 0x65, 0x45, 0x66, 0x61, 0x71, 0x51, 0x74, 0x54,
+       0x64, 0x77, 0x57, 0x63, 0x7A, 0x78, 0x76, 0x67, 0x6B, 0x6F, 0x69,
+       0x4F, 0x6A, 0x70, 0x75, 0x50, 0x68, 0x79, 0x6E, 0x62, 0x6D, 0x6C};
+  std::wstring dicKorean = // L"";
+      {0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139, 0x3141, 0x3142, 0x3143, 0x3145, 0x3146,
+       0x3147, 0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e, 0x314f, 0x3150, 0x3151,
+       0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157, 0x315b, 0x315c, 0x3160, 0x3161, 0x3163};
+  std::wstring dicChoseong = // L"";
+      {0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139, 0x3141, 0x3142, 0x3143, 0x3145,
+       0x3146, 0x3147, 0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e};
+  std::wstring dicJungseong = // L"";
+      {0x314f, 0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157, 0x3158, 0x3159,
+       0x315a, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160, 0x3161, 0x3162, 0x3163};
+  std::wstring dicJongseong = // L"";
+      {0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137, 0x3139, 0x313a,
+       0x313b, 0x313c, 0x313d, 0x313e, 0x313f, 0x3140, 0x3141, 0x3142, 0x3144,
+       0x3145, 0x3146, 0x3147, 0x3148, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e};
 
   std::wstring korean;
 
@@ -64,7 +72,7 @@ std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
     int key = dicKorean.find(ch);
 
     // H/W Keyboard input with English will be changed to Korean
-	// because H/W input in Korean is not supported.
+    // because H/W input in Korean is not supported.
     if (key == -1)
       key = dicEnglish.find(ch);
 
@@ -96,7 +104,7 @@ std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
       if (jungseong != -1)
       {
         if (choseong == -1) // Jungseong without choseong cannot have jongseong.
-		                    // So inputted key is jungseong character, new character is begun.
+                            // So inputted key is jungseong character, new character is begun.
         {
           korean += dicJungseong.at(jungseong);
           jungseong = -1;
@@ -104,29 +112,30 @@ std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
         }
         else // Jungseong with choseong can have jongseong.
         {
-          if (jongseong == -1) // Chongseong can have two consonant. So this is first consonant of chongseong.
+          if (jongseong ==
+              -1) // Chongseong can have two consonant. So this is first consonant of chongseong.
           {
             jongseong = dicJongseong.find(dicKorean.at(key));
             if (jongseong == -1) // This consonant cannot be jongseong. ex) "", "", ""
-			{
+            {
               korean += MergeCode(choseong, jungseong, jongseong);
               choseong = dicChoseong.find(dicKorean.at(key));
               jungseong = -1;
             }
           }
-          else if (jongseong == 0 && key == 9)  // ""
+          else if (jongseong == 0 && key == 9) // ""
             jongseong = 2;
           else if (jongseong == 3 && key == 12) // ""
             jongseong = 4;
           else if (jongseong == 3 && key == 18) // ""
             jongseong = 5;
-          else if (jongseong == 7 && key == 0)  // ""
+          else if (jongseong == 7 && key == 0) // ""
             jongseong = 8;
-          else if (jongseong == 7 && key == 6)  // ""
+          else if (jongseong == 7 && key == 6) // ""
             jongseong = 9;
-          else if (jongseong == 7 && key == 7)  // ""
+          else if (jongseong == 7 && key == 7) // ""
             jongseong = 10;
-          else if (jongseong == 7 && key == 9)  // ""
+          else if (jongseong == 7 && key == 9) // ""
             jongseong = 11;
           else if (jongseong == 7 && key == 16) // ""
             jongseong = 12;
@@ -145,12 +154,14 @@ std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
           }
         }
       }
-      else // If there is no jungseong, new consonant can be choseong or second part of double consonant.
+      else // If there is no jungseong, new consonant can be choseong or second part of double
+           // consonant.
       {
-        if (choseong == -1) // New consonant is choseong. Also it could be first part of double consonant.
+        if (choseong ==
+            -1) // New consonant is choseong. Also it could be first part of double consonant.
         {
-          if (jongseong != -1) // If choseong is already completed, new consonant is another choseong.
-                               // So previous character has only jongseong.
+          if (jongseong != -1) // If choseong is already completed, new consonant is another
+                               // choseong. So previous character has only jongseong.
           {
             korean += dicJongseong.at(jongseong);
             jongseong = -1;
@@ -158,37 +169,37 @@ std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
           choseong = dicChoseong.find(dicKorean.at(key));
         }
         // Find double consonant of chongseong
-        else if (choseong == 0 && key == 9)   // ""
+        else if (choseong == 0 && key == 9) // ""
         {
           choseong = -1;
           jongseong = 2;
         }
-        else if (choseong == 2 && key == 12)  // ""
+        else if (choseong == 2 && key == 12) // ""
         {
           choseong = -1;
           jongseong = 4;
         }
-        else if (choseong == 2 && key == 18)  // ""
+        else if (choseong == 2 && key == 18) // ""
         {
           choseong = -1;
           jongseong = 5;
         }
-        else if (choseong == 5 && key == 0)   // ""
+        else if (choseong == 5 && key == 0) // ""
         {
           choseong = -1;
           jongseong = 8;
         }
-        else if (choseong == 5 && key == 6)   // ""
+        else if (choseong == 5 && key == 6) // ""
         {
           choseong = -1;
           jongseong = 9;
         }
-        else if (choseong == 5 && key == 7)   // ""
+        else if (choseong == 5 && key == 7) // ""
         {
           choseong = -1;
           jongseong = 10;
         }
-        else if (choseong == 5 && key == 9)   // ""
+        else if (choseong == 5 && key == 9) // ""
         {
           choseong = -1;
           jongseong = 11;
@@ -222,34 +233,35 @@ std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
     }
     else // If key is vowel, key is jungseong.
     {
-      if (jongseong != -1) // If previous character has jongseong and this key is jungseong,
-                           // actually latest vowel is not jongseong. It's choseong of new character.
+      if (jongseong !=
+          -1) // If previous character has jongseong and this key is jungseong,
+              // actually latest vowel is not jongseong. It's choseong of new character.
       {
-        // If jongseong of previous character is double consonant, we will separate it to two vowel again.
-        // First part of double consonant is jongseong of previous character.
-        // Second part of double consonant is choseong of current character.
+        // If jongseong of previous character is double consonant, we will separate it to two vowel
+        // again. First part of double consonant is jongseong of previous character. Second part of
+        // double consonant is choseong of current character.
         int newCho;
-        if (jongseong == 2)       // ", "
+        if (jongseong == 2) // ", "
         {
           jongseong = 0;
           newCho = 9;
         }
-        else if (jongseong == 4)  // ", "
+        else if (jongseong == 4) // ", "
         {
           jongseong = 3;
           newCho = 12;
         }
-        else if (jongseong == 5)  // ", "
+        else if (jongseong == 5) // ", "
         {
           jongseong = 3;
           newCho = 18;
         }
-        else if (jongseong == 8)  // ", "
+        else if (jongseong == 8) // ", "
         {
           jongseong = 7;
           newCho = 0;
         }
-        else if (jongseong == 9)  // ", "
+        else if (jongseong == 9) // ", "
         {
           jongseong = 7;
           newCho = 6;
@@ -304,19 +316,19 @@ std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
         jungseong = dicJungseong.find(dicKorean.at(key));
       }
       // If there is jungseong already, jungseong is double vowel.
-      else if (jungseong == 8 && key == 19)   // ""
+      else if (jungseong == 8 && key == 19) // ""
         jungseong = 9;
-      else if (jungseong == 8 && key == 20)   // ""
+      else if (jungseong == 8 && key == 20) // ""
         jungseong = 10;
-      else if (jungseong == 8 && key == 32)   // ""
+      else if (jungseong == 8 && key == 32) // ""
         jungseong = 11;
-      else if (jungseong == 13 && key == 23)  // ""
+      else if (jungseong == 13 && key == 23) // ""
         jungseong = 14;
-      else if (jungseong == 13 && key == 24)  // ""
+      else if (jungseong == 13 && key == 24) // ""
         jungseong = 15;
-      else if (jungseong == 13 && key == 32)  // ""
+      else if (jungseong == 13 && key == 32) // ""
         jungseong = 16;
-      else if (jungseong == 18 && key == 32)  // ""
+      else if (jungseong == 18 && key == 32) // ""
         jungseong = 19;
       else // If two vowel cannot be double vowel.
       {
@@ -344,9 +356,9 @@ std::wstring CInputCodingTableKorean::InputToKorean(const std::wstring& input)
   }
   else
   {
-    if (jungseong != -1)  // Current character has jungseong only
+    if (jungseong != -1) // Current character has jungseong only
       korean += dicJungseong.at(jungseong);
-    else if (jongseong != -1)  // Current character has jongseong only
+    else if (jongseong != -1) // Current character has jongseong only
       korean += dicJongseong.at(jongseong);
   }
 
diff --git a/xbmc/input/InputCodingTableKorean.h b/xbmc/input/InputCodingTableKorean.h
index 3bdb68eb1e69..55a64d6c4760 100644
--- a/xbmc/input/InputCodingTableKorean.h
+++ b/xbmc/input/InputCodingTableKorean.h
@@ -25,7 +25,7 @@ class CInputCodingTableKorean : public IInputCodingTable
 
   void SetTextPrev(const std::string& strTextPrev) override;
   std::string ConvertString(const std::string& strCode) override;
-  int GetType() override { return TYPE_CONVERT_STRING;  }
+  int GetType() override { return TYPE_CONVERT_STRING; }
 
 protected:
   int MergeCode(int choseong, int jungseong, int jongseong);
diff --git a/xbmc/input/InputManager.cpp b/xbmc/input/InputManager.cpp
index ec2585ba6215..49c9b9f7c9f5 100644
--- a/xbmc/input/InputManager.cpp
+++ b/xbmc/input/InputManager.cpp
@@ -51,13 +51,13 @@ using namespace MESSAGING;
 
 const std::string CInputManager::SETTING_INPUT_ENABLE_CONTROLLER = "input.enablejoystick";
 
-CInputManager::CInputManager(const CAppParamParser &params) :
-  m_keymapEnvironment(new CKeymapEnvironment),
-  m_buttonTranslator(new CButtonTranslator),
-  m_customControllerTranslator(new CCustomControllerTranslator),
-  m_touchTranslator(new CTouchTranslator),
-  m_joystickTranslator(new CJoystickMapper),
-  m_keyboardEasterEgg(new KEYBOARD::CKeyboardEasterEgg)
+CInputManager::CInputManager(const CAppParamParser& params)
+  : m_keymapEnvironment(new CKeymapEnvironment),
+    m_buttonTranslator(new CButtonTranslator),
+    m_customControllerTranslator(new CCustomControllerTranslator),
+    m_touchTranslator(new CTouchTranslator),
+    m_joystickTranslator(new CJoystickMapper),
+    m_keyboardEasterEgg(new KEYBOARD::CKeyboardEasterEgg)
 {
   m_buttonTranslator->RegisterMapper("touch", m_touchTranslator.get());
   m_buttonTranslator->RegisterMapper("customcontroller", m_customControllerTranslator.get());
@@ -91,7 +91,8 @@ void CInputManager::InitializeInputs()
   m_Keyboard.Initialize();
 
   m_Mouse.Initialize();
-  m_Mouse.SetEnabled(CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_INPUT_ENABLEMOUSE));
+  m_Mouse.SetEnabled(CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+      CSettings::SETTING_INPUT_ENABLEMOUSE));
 
   m_enableController = CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
       SETTING_INPUT_ENABLE_CONTROLLER);
@@ -159,14 +160,10 @@ bool CInputManager::ProcessMouse(int windowId)
     return g_application.OnAction(mouseaction);
 
   // This is a mouse action so we need to record the mouse position
-  return g_application.OnAction(CAction(mouseaction.GetID(),
-    m_Mouse.GetHold(MOUSE_LEFT_BUTTON),
-    (float)m_Mouse.GetX(),
-    (float)m_Mouse.GetY(),
-    (float)m_Mouse.GetDX(),
-    (float)m_Mouse.GetDY(),
-    0.0f, 0.0f,
-    mouseaction.GetName()));
+  return g_application.OnAction(CAction(mouseaction.GetID(), m_Mouse.GetHold(MOUSE_LEFT_BUTTON),
+                                        (float)m_Mouse.GetX(), (float)m_Mouse.GetY(),
+                                        (float)m_Mouse.GetDX(), (float)m_Mouse.GetDY(), 0.0f, 0.0f,
+                                        mouseaction.GetName()));
 }
 
 bool CInputManager::ProcessEventServer(int windowId, float frameTime)
@@ -212,7 +209,8 @@ bool CInputManager::ProcessEventServer(int windowId, float frameTime)
         std::string actionName;
 
         // Translate using custom controller translator.
-        if (m_customControllerTranslator->TranslateCustomControllerString(windowId, strMapName, wKeyID, actionID, actionName))
+        if (m_customControllerTranslator->TranslateCustomControllerString(
+                windowId, strMapName, wKeyID, actionID, actionName))
         {
           // break screensaver
           g_application.ResetSystemIdleTimer();
@@ -230,7 +228,8 @@ bool CInputManager::ProcessEventServer(int windowId, float frameTime)
         }
         else
         {
-          CLog::Log(LOGDEBUG, "ERROR mapping customcontroller action. CustomController: %s %i", strMapName.c_str(), wKeyID);
+          CLog::Log(LOGDEBUG, "ERROR mapping customcontroller action. CustomController: %s %i",
+                    strMapName.c_str(), wKeyID);
         }
       }
     }
@@ -279,7 +278,8 @@ bool CInputManager::ProcessEventServer(int windowId, float frameTime)
       newEvent.type = XBMC_MOUSEMOTION;
       newEvent.motion.x = (uint16_t)pos.x;
       newEvent.motion.y = (uint16_t)pos.y;
-      CServiceBroker::GetAppPort()->OnEvent(newEvent);  // had to call this to update g_Mouse position
+      CServiceBroker::GetAppPort()->OnEvent(
+          newEvent); // had to call this to update g_Mouse position
       return g_application.OnAction(CAction(ACTION_MOUSE_MOVE, pos.x, pos.y));
     }
   }
@@ -307,10 +307,10 @@ void CInputManager::QueueAction(const CAction& action)
   if (action.IsAnalog())
   {
     m_queuedActions.erase(std::remove_if(m_queuedActions.begin(), m_queuedActions.end(),
-      [&action](const CAction& queuedAction)
-      {
-        return action.GetID() == queuedAction.GetID();
-      }), m_queuedActions.end());
+                                         [&action](const CAction& queuedAction) {
+                                           return action.GetID() == queuedAction.GetID();
+                                         }),
+                          m_queuedActions.end());
   }
 
   m_queuedActions.push_back(action);
@@ -333,107 +333,117 @@ bool CInputManager::OnEvent(XBMC_Event& newEvent)
 {
   switch (newEvent.type)
   {
-  case XBMC_KEYDOWN:
-  {
-    m_Keyboard.ProcessKeyDown(newEvent.key.keysym);
-    CKey key = m_Keyboard.TranslateKey(newEvent.key.keysym);
-    OnKey(key);
-    break;
-  }
-  case XBMC_KEYUP:
-    m_Keyboard.ProcessKeyUp();
-    OnKeyUp(m_Keyboard.TranslateKey(newEvent.key.keysym));
-    break;
-  case XBMC_MOUSEBUTTONDOWN:
-  case XBMC_MOUSEBUTTONUP:
-  case XBMC_MOUSEMOTION:
-  {
-    bool handled = false;
-
-    for (auto driverHandler : m_mouseHandlers)
+    case XBMC_KEYDOWN:
     {
-      switch (newEvent.type)
-      {
-      case XBMC_MOUSEMOTION:
-      {
-        if (driverHandler->OnPosition(newEvent.motion.x, newEvent.motion.y))
-          handled = true;
-        break;
-      }
-      case XBMC_MOUSEBUTTONDOWN:
+      m_Keyboard.ProcessKeyDown(newEvent.key.keysym);
+      CKey key = m_Keyboard.TranslateKey(newEvent.key.keysym);
+      OnKey(key);
+      break;
+    }
+    case XBMC_KEYUP:
+      m_Keyboard.ProcessKeyUp();
+      OnKeyUp(m_Keyboard.TranslateKey(newEvent.key.keysym));
+      break;
+    case XBMC_MOUSEBUTTONDOWN:
+    case XBMC_MOUSEBUTTONUP:
+    case XBMC_MOUSEMOTION:
+    {
+      bool handled = false;
+
+      for (auto driverHandler : m_mouseHandlers)
       {
-        MOUSE::BUTTON_ID buttonId;
-        if (CMouseTranslator::TranslateEventID(newEvent.button.button, buttonId))
+        switch (newEvent.type)
         {
-          if (driverHandler->OnButtonPress(buttonId))
-            handled = true;
+          case XBMC_MOUSEMOTION:
+          {
+            if (driverHandler->OnPosition(newEvent.motion.x, newEvent.motion.y))
+              handled = true;
+            break;
+          }
+          case XBMC_MOUSEBUTTONDOWN:
+          {
+            MOUSE::BUTTON_ID buttonId;
+            if (CMouseTranslator::TranslateEventID(newEvent.button.button, buttonId))
+            {
+              if (driverHandler->OnButtonPress(buttonId))
+                handled = true;
+            }
+            break;
+          }
+          case XBMC_MOUSEBUTTONUP:
+          {
+            MOUSE::BUTTON_ID buttonId;
+            if (CMouseTranslator::TranslateEventID(newEvent.button.button, buttonId))
+              driverHandler->OnButtonRelease(buttonId);
+            break;
+          }
+          default:
+            break;
         }
-        break;
+
+        if (handled)
+          break;
       }
-      case XBMC_MOUSEBUTTONUP:
+
+      if (!handled)
       {
-        MOUSE::BUTTON_ID buttonId;
-        if (CMouseTranslator::TranslateEventID(newEvent.button.button, buttonId))
-          driverHandler->OnButtonRelease(buttonId);
-        break;
-      }
-      default:
-        break;
+        m_Mouse.HandleEvent(newEvent);
+        ProcessMouse(CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog());
       }
-
-      if (handled)
-        break;
-    }
-
-    if (!handled)
-    {
-      m_Mouse.HandleEvent(newEvent);
-      ProcessMouse(CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog());
-    }
-    break;
-  }
-  case XBMC_TOUCH:
-  {
-    if (newEvent.touch.action == ACTION_TOUCH_TAP)
-    { // Send a mouse motion event with no dx,dy for getting the current guiitem selected
-      g_application.OnAction(CAction(ACTION_MOUSE_MOVE, 0, newEvent.touch.x, newEvent.touch.y, 0, 0));
+      break;
     }
-    int actionId = 0;
-    std::string actionString;
-    if (newEvent.touch.action == ACTION_GESTURE_BEGIN || newEvent.touch.action == ACTION_GESTURE_END || newEvent.touch.action == ACTION_GESTURE_ABORT)
-      actionId = newEvent.touch.action;
-    else
+    case XBMC_TOUCH:
     {
-      int iWin = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog();
-      m_touchTranslator->TranslateTouchAction(iWin, newEvent.touch.action, newEvent.touch.pointers, actionId, actionString);
-    }
+      if (newEvent.touch.action == ACTION_TOUCH_TAP)
+      { // Send a mouse motion event with no dx,dy for getting the current guiitem selected
+        g_application.OnAction(
+            CAction(ACTION_MOUSE_MOVE, 0, newEvent.touch.x, newEvent.touch.y, 0, 0));
+      }
+      int actionId = 0;
+      std::string actionString;
+      if (newEvent.touch.action == ACTION_GESTURE_BEGIN ||
+          newEvent.touch.action == ACTION_GESTURE_END ||
+          newEvent.touch.action == ACTION_GESTURE_ABORT)
+        actionId = newEvent.touch.action;
+      else
+      {
+        int iWin = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog();
+        m_touchTranslator->TranslateTouchAction(iWin, newEvent.touch.action,
+                                                newEvent.touch.pointers, actionId, actionString);
+      }
 
-    if (actionId <= 0)
-      return false;
+      if (actionId <= 0)
+        return false;
 
-    if ((actionId >= ACTION_TOUCH_TAP && actionId <= ACTION_GESTURE_END)
-        || (actionId >= ACTION_MOUSE_START && actionId <= ACTION_MOUSE_END))
-    {
-      auto action = new CAction(actionId, 0, newEvent.touch.x, newEvent.touch.y, newEvent.touch.x2, newEvent.touch.y2, newEvent.touch.x3, newEvent.touch.y3);
-      CApplicationMessenger::GetInstance().PostMsg(TMSG_GUI_ACTION, WINDOW_INVALID, -1, static_cast<void*>(action));
-    }
-    else
-    {
-      if (actionId == ACTION_BUILT_IN_FUNCTION && !actionString.empty())
-        CApplicationMessenger::GetInstance().PostMsg(TMSG_GUI_ACTION, WINDOW_INVALID, -1, static_cast<void*>(new CAction(actionId, actionString)));
+      if ((actionId >= ACTION_TOUCH_TAP && actionId <= ACTION_GESTURE_END) ||
+          (actionId >= ACTION_MOUSE_START && actionId <= ACTION_MOUSE_END))
+      {
+        auto action =
+            new CAction(actionId, 0, newEvent.touch.x, newEvent.touch.y, newEvent.touch.x2,
+                        newEvent.touch.y2, newEvent.touch.x3, newEvent.touch.y3);
+        CApplicationMessenger::GetInstance().PostMsg(TMSG_GUI_ACTION, WINDOW_INVALID, -1,
+                                                     static_cast<void*>(action));
+      }
       else
-        CApplicationMessenger::GetInstance().PostMsg(TMSG_GUI_ACTION, WINDOW_INVALID, -1, static_cast<void*>(new CAction(actionId)));
-    }
+      {
+        if (actionId == ACTION_BUILT_IN_FUNCTION && !actionString.empty())
+          CApplicationMessenger::GetInstance().PostMsg(
+              TMSG_GUI_ACTION, WINDOW_INVALID, -1,
+              static_cast<void*>(new CAction(actionId, actionString)));
+        else
+          CApplicationMessenger::GetInstance().PostMsg(TMSG_GUI_ACTION, WINDOW_INVALID, -1,
+                                                       static_cast<void*>(new CAction(actionId)));
+      }
 
-    break;
-  } //case
-  case XBMC_BUTTON:
-  {
-    CKey key(newEvent.keybutton.button, newEvent.keybutton.holdtime);
-    OnKey(key);
-    break;
-  }
-  }//switch
+      break;
+    } // case
+    case XBMC_BUTTON:
+    {
+      CKey key(newEvent.keybutton.button, newEvent.keybutton.holdtime);
+      OnKey(key);
+      break;
+    }
+  } // switch
 
   return true;
 }
@@ -462,7 +472,8 @@ bool CInputManager::OnKey(const CKey& key)
   }
   else
   {
-    if (key.GetButtonCode() == m_LastKey.GetButtonCode() && (m_LastKey.GetButtonCode() & CKey::MODIFIER_LONG))
+    if (key.GetButtonCode() == m_LastKey.GetButtonCode() &&
+        (m_LastKey.GetButtonCode() & CKey::MODIFIER_LONG))
     {
       // Do not repeat long presses
     }
@@ -479,9 +490,10 @@ bool CInputManager::OnKey(const CKey& key)
       }
       else
       {
-        if (key.GetButtonCode() != m_LastKey.GetButtonCode() && (key.GetButtonCode() & CKey::MODIFIER_LONG))
+        if (key.GetButtonCode() != m_LastKey.GetButtonCode() &&
+            (key.GetButtonCode() & CKey::MODIFIER_LONG))
         {
-          m_LastKey = key;  // OnKey is reentrant; need to do this before entering
+          m_LastKey = key; // OnKey is reentrant; need to do this before entering
           bHandled = HandleKey(key);
         }
 
@@ -510,14 +522,17 @@ bool CInputManager::HandleKey(const CKey& key)
   g_application.ResetSystemIdleTimer();
   bool processKey = AlwaysProcess(action);
 
-  if (StringUtils::StartsWithNoCase(action.GetName(), "CECToggleState") || StringUtils::StartsWithNoCase(action.GetName(), "CECStandby"))
+  if (StringUtils::StartsWithNoCase(action.GetName(), "CECToggleState") ||
+      StringUtils::StartsWithNoCase(action.GetName(), "CECStandby"))
   {
     // do not wake up the screensaver right after switching off the playing device
     if (StringUtils::StartsWithNoCase(action.GetName(), "CECToggleState"))
     {
-      CLog::LogF(LOGDEBUG, "action %s [%d], toggling state of playing device", action.GetName().c_str(), action.GetID());
+      CLog::LogF(LOGDEBUG, "action %s [%d], toggling state of playing device",
+                 action.GetName().c_str(), action.GetID());
       bool result;
-      CApplicationMessenger::GetInstance().SendMsg(TMSG_CECTOGGLESTATE, 0, 0, static_cast<void*>(&result));
+      CApplicationMessenger::GetInstance().SendMsg(TMSG_CECTOGGLESTATE, 0, 0,
+                                                   static_cast<void*>(&result));
       if (!result)
         return true;
     }
@@ -533,23 +548,24 @@ bool CInputManager::HandleKey(const CKey& key)
   // allow some keys to be processed while the screensaver is active
   if (g_application.WakeUpScreenSaverAndDPMS(processKey) && !processKey)
   {
-    CLog::LogF(LOGDEBUG, "%s pressed, screen saver/dpms woken up", m_Keyboard.GetKeyName((int)key.GetButtonCode()).c_str());
+    CLog::LogF(LOGDEBUG, "%s pressed, screen saver/dpms woken up",
+               m_Keyboard.GetKeyName((int)key.GetButtonCode()).c_str());
     return true;
   }
 
-  if (iWin != WINDOW_FULLSCREEN_VIDEO &&
-      iWin != WINDOW_FULLSCREEN_GAME)
+  if (iWin != WINDOW_FULLSCREEN_VIDEO && iWin != WINDOW_FULLSCREEN_GAME)
   {
     // current active window isnt the fullscreen window
     // just use corresponding section from keymap.xml
     // to map key->action
 
     // first determine if we should use keyboard input directly
-    bool useKeyboard = key.FromKeyboard() && (iWin == WINDOW_DIALOG_KEYBOARD || iWin == WINDOW_DIALOG_NUMERIC);
-    CGUIWindow *window = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(iWin);
+    bool useKeyboard =
+        key.FromKeyboard() && (iWin == WINDOW_DIALOG_KEYBOARD || iWin == WINDOW_DIALOG_NUMERIC);
+    CGUIWindow* window = CServiceBroker::GetGUI()->GetWindowManager().GetWindow(iWin);
     if (window)
     {
-      CGUIControl *control = window->GetFocusedControl();
+      CGUIControl* control = window->GetFocusedControl();
       if (control)
       {
         // If this is an edit control set usekeyboard to true. This causes the
@@ -569,31 +585,26 @@ bool CInputManager::HandleKey(const CKey& key)
       // use the virtualkeyboard section of the keymap, and send keyboard-specific or navigation
       // actions through if that's what they are
       CAction action = m_buttonTranslator->GetAction(WINDOW_DIALOG_KEYBOARD, key);
-      if (!(action.GetID() == ACTION_MOVE_LEFT ||
-        action.GetID() == ACTION_MOVE_RIGHT ||
-        action.GetID() == ACTION_MOVE_UP ||
-        action.GetID() == ACTION_MOVE_DOWN ||
-        action.GetID() == ACTION_SELECT_ITEM ||
-        action.GetID() == ACTION_ENTER ||
-        action.GetID() == ACTION_PREVIOUS_MENU ||
-        action.GetID() == ACTION_NAV_BACK ||
-        action.GetID() == ACTION_VOICE_RECOGNIZE))
+      if (!(action.GetID() == ACTION_MOVE_LEFT || action.GetID() == ACTION_MOVE_RIGHT ||
+            action.GetID() == ACTION_MOVE_UP || action.GetID() == ACTION_MOVE_DOWN ||
+            action.GetID() == ACTION_SELECT_ITEM || action.GetID() == ACTION_ENTER ||
+            action.GetID() == ACTION_PREVIOUS_MENU || action.GetID() == ACTION_NAV_BACK ||
+            action.GetID() == ACTION_VOICE_RECOGNIZE))
       {
         // the action isn't plain navigation - check for a keyboard-specific keymap
         action = m_buttonTranslator->GetAction(WINDOW_DIALOG_KEYBOARD, key, false);
         if (!(action.GetID() >= REMOTE_0 && action.GetID() <= REMOTE_9) ||
-            action.GetID() == ACTION_BACKSPACE ||
-            action.GetID() == ACTION_SHIFT ||
-            action.GetID() == ACTION_SYMBOLS ||
-            action.GetID() == ACTION_CURSOR_LEFT ||
+            action.GetID() == ACTION_BACKSPACE || action.GetID() == ACTION_SHIFT ||
+            action.GetID() == ACTION_SYMBOLS || action.GetID() == ACTION_CURSOR_LEFT ||
             action.GetID() == ACTION_CURSOR_RIGHT)
-            action = CAction(0); // don't bother with this action
+          action = CAction(0); // don't bother with this action
       }
       // else pass the keys through directly
       if (!action.GetID())
       {
         if (key.GetFromService())
-          action = CAction(key.GetButtonCode() != KEY_INVALID ? key.GetButtonCode() : 0, key.GetUnicode());
+          action = CAction(key.GetButtonCode() != KEY_INVALID ? key.GetButtonCode() : 0,
+                           key.GetUnicode());
         else
         {
           // Check for paste keypress
@@ -620,7 +631,8 @@ bool CInputManager::HandleKey(const CKey& key)
         }
       }
 
-      CLog::LogF(LOGDEBUG, "%s pressed, trying keyboard action %x", m_Keyboard.GetKeyName((int)key.GetButtonCode()).c_str(), action.GetID());
+      CLog::LogF(LOGDEBUG, "%s pressed, trying keyboard action %x",
+                 m_Keyboard.GetKeyName((int)key.GetButtonCode()).c_str(), action.GetID());
 
       if (g_application.OnAction(action))
         return true;
@@ -635,7 +647,8 @@ bool CInputManager::HandleKey(const CKey& key)
       action = m_buttonTranslator->GetAction(iWin, key);
   }
   if (!key.IsAnalogButton())
-    CLog::LogF(LOGDEBUG, "%s pressed, action is %s", m_Keyboard.GetKeyName((int)key.GetButtonCode()).c_str(), action.GetName().c_str());
+    CLog::LogF(LOGDEBUG, "%s pressed, action is %s",
+               m_Keyboard.GetKeyName((int)key.GetButtonCode()).c_str(), action.GetName().c_str());
 
   return ExecuteInputAction(action);
 }
@@ -645,10 +658,11 @@ void CInputManager::OnKeyUp(const CKey& key)
   for (auto handler : m_keyboardHandlers)
     handler->OnKeyRelease(key);
 
-  if (m_LastKey.GetButtonCode() != KEY_INVALID && !(m_LastKey.GetButtonCode() & CKey::MODIFIER_LONG))
+  if (m_LastKey.GetButtonCode() != KEY_INVALID &&
+      !(m_LastKey.GetButtonCode() & CKey::MODIFIER_LONG))
   {
     CKey key = m_LastKey;
-    m_LastKey.Reset();  // OnKey is reentrant; need to do this before entering
+    m_LastKey.Reset(); // OnKey is reentrant; need to do this before entering
     HandleKey(key);
   }
   else
@@ -666,14 +680,10 @@ bool CInputManager::AlwaysProcess(const CAction& action)
     StringUtils::ToLower(builtInFunction);
 
     // should this button be handled normally or just cancel the screensaver?
-    if (builtInFunction == "powerdown"
-        || builtInFunction == "reboot"
-        || builtInFunction == "restart"
-        || builtInFunction == "restartapp"
-        || builtInFunction == "suspend"
-        || builtInFunction == "hibernate"
-        || builtInFunction == "quit"
-        || builtInFunction == "shutdown")
+    if (builtInFunction == "powerdown" || builtInFunction == "reboot" ||
+        builtInFunction == "restart" || builtInFunction == "restartapp" ||
+        builtInFunction == "suspend" || builtInFunction == "hibernate" ||
+        builtInFunction == "quit" || builtInFunction == "shutdown")
     {
       return true;
     }
@@ -682,7 +692,7 @@ bool CInputManager::AlwaysProcess(const CAction& action)
   return false;
 }
 
-bool CInputManager::ExecuteInputAction(const CAction &action)
+bool CInputManager::ExecuteInputAction(const CAction& action)
 {
   bool bResult = false;
   CGUIComponent* gui = CServiceBroker::GetGUI();
@@ -710,7 +720,8 @@ bool CInputManager::HasBuiltin(const std::string& command)
   return false;
 }
 
-int CInputManager::ExecuteBuiltin(const std::string& execute, const std::vector<std::string>& params)
+int CInputManager::ExecuteBuiltin(const std::string& execute,
+                                  const std::vector<std::string>& params)
 {
   return 0;
 }
@@ -760,7 +771,7 @@ void CInputManager::OnSettingChanged(std::shared_ptr<const CSetting> setting)
   if (setting == nullptr)
     return;
 
-  const std::string &settingId = setting->GetId();
+  const std::string& settingId = setting->GetId();
   if (settingId == CSettings::SETTING_INPUT_ENABLEMOUSE)
     m_Mouse.SetEnabled(std::dynamic_pointer_cast<const CSettingBool>(setting)->GetValue());
 
@@ -790,17 +801,17 @@ bool CInputManager::OnAction(const CAction& action)
 
         switch (action.GetID())
         {
-        case ACTION_MOVE_LEFT:
-        case ACTION_MOVE_RIGHT:
-        case ACTION_MOVE_UP:
-        case ACTION_MOVE_DOWN:
-        case ACTION_PAGE_UP:
-        case ACTION_PAGE_DOWN:
-          bIsNavigation = true;
-          break;
-
-        default:
-          break;
+          case ACTION_MOVE_LEFT:
+          case ACTION_MOVE_RIGHT:
+          case ACTION_MOVE_UP:
+          case ACTION_MOVE_DOWN:
+          case ACTION_PAGE_UP:
+          case ACTION_PAGE_DOWN:
+            bIsNavigation = true;
+            break;
+
+          default:
+            break;
         }
 
         if (bIsNavigation)
@@ -842,7 +853,7 @@ void CInputManager::ClearKeymaps()
   NotifyObservers(ObservableMessageButtonMapsChanged);
 }
 
-void CInputManager::AddKeymap(const std::string &keymap)
+void CInputManager::AddKeymap(const std::string& keymap)
 {
   if (m_buttonTranslator->AddDevice(keymap))
   {
@@ -851,7 +862,7 @@ void CInputManager::AddKeymap(const std::string &keymap)
   }
 }
 
-void CInputManager::RemoveKeymap(const std::string &keymap)
+void CInputManager::RemoveKeymap(const std::string& keymap)
 {
   if (m_buttonTranslator->RemoveDevice(keymap))
   {
@@ -860,19 +871,26 @@ void CInputManager::RemoveKeymap(const std::string &keymap)
   }
 }
 
-CAction CInputManager::GetAction(int window, const CKey &key, bool fallback /* = true */)
+CAction CInputManager::GetAction(int window, const CKey& key, bool fallback /* = true */)
 {
   return m_buttonTranslator->GetAction(window, key, fallback);
 }
 
-bool CInputManager::TranslateCustomControllerString(int windowId, const std::string& controllerName, int buttonId, int& action, std::string& strAction)
+bool CInputManager::TranslateCustomControllerString(int windowId,
+                                                    const std::string& controllerName,
+                                                    int buttonId,
+                                                    int& action,
+                                                    std::string& strAction)
 {
-  return m_customControllerTranslator->TranslateCustomControllerString(windowId, controllerName, buttonId, action, strAction);
+  return m_customControllerTranslator->TranslateCustomControllerString(windowId, controllerName,
+                                                                       buttonId, action, strAction);
 }
 
-bool CInputManager::TranslateTouchAction(int windowId, int touchAction, int touchPointers, int &action, std::string &actionString)
+bool CInputManager::TranslateTouchAction(
+    int windowId, int touchAction, int touchPointers, int& action, std::string& actionString)
 {
-  return m_touchTranslator->TranslateTouchAction(windowId, touchAction, touchPointers, action, actionString);
+  return m_touchTranslator->TranslateTouchAction(windowId, touchAction, touchPointers, action,
+                                                 actionString);
 }
 
 std::vector<std::shared_ptr<const IWindowKeymap>> CInputManager::GetJoystickKeymaps() const
@@ -882,13 +900,16 @@ std::vector<std::shared_ptr<const IWindowKeymap>> CInputManager::GetJoystickKeym
 
 void CInputManager::RegisterKeyboardDriverHandler(KEYBOARD::IKeyboardDriverHandler* handler)
 {
-  if (std::find(m_keyboardHandlers.begin(), m_keyboardHandlers.end(), handler) == m_keyboardHandlers.end())
+  if (std::find(m_keyboardHandlers.begin(), m_keyboardHandlers.end(), handler) ==
+      m_keyboardHandlers.end())
     m_keyboardHandlers.insert(m_keyboardHandlers.begin(), handler);
 }
 
 void CInputManager::UnregisterKeyboardDriverHandler(KEYBOARD::IKeyboardDriverHandler* handler)
 {
-  m_keyboardHandlers.erase(std::remove(m_keyboardHandlers.begin(), m_keyboardHandlers.end(), handler), m_keyboardHandlers.end());
+  m_keyboardHandlers.erase(
+      std::remove(m_keyboardHandlers.begin(), m_keyboardHandlers.end(), handler),
+      m_keyboardHandlers.end());
 }
 
 void CInputManager::RegisterMouseDriverHandler(MOUSE::IMouseDriverHandler* handler)
@@ -899,5 +920,6 @@ void CInputManager::RegisterMouseDriverHandler(MOUSE::IMouseDriverHandler* handl
 
 void CInputManager::UnregisterMouseDriverHandler(MOUSE::IMouseDriverHandler* handler)
 {
-  m_mouseHandlers.erase(std::remove(m_mouseHandlers.begin(), m_mouseHandlers.end(), handler), m_mouseHandlers.end());
+  m_mouseHandlers.erase(std::remove(m_mouseHandlers.begin(), m_mouseHandlers.end(), handler),
+                        m_mouseHandlers.end());
 }
diff --git a/xbmc/input/InputManager.h b/xbmc/input/InputManager.h
index ba6f1dec5b53..564bd70ed5b7 100644
--- a/xbmc/input/InputManager.h
+++ b/xbmc/input/InputManager.h
@@ -38,14 +38,14 @@ namespace KODI
 
 namespace KEYBOARD
 {
-  class IKeyboardDriverHandler;
+class IKeyboardDriverHandler;
 }
 
 namespace MOUSE
 {
-  class IMouseDriverHandler;
-}
+class IMouseDriverHandler;
 }
+} // namespace KODI
 
 /// \addtogroup input
 /// \{
@@ -60,12 +60,10 @@ namespace MOUSE
  * \copydoc keyboard
  * \copydoc mouse
  */
-class CInputManager : public ISettingCallback,
-                      public IActionListener,
-                      public Observable
+class CInputManager : public ISettingCallback, public IActionListener, public Observable
 {
 public:
-  explicit CInputManager(const CAppParamParser &params);
+  explicit CInputManager(const CAppParamParser& params);
   CInputManager(const CInputManager&) = delete;
   CInputManager const& operator=(CInputManager const&) = delete;
   ~CInputManager() override;
@@ -77,7 +75,8 @@ class CInputManager : public ISettingCallback,
    */
   bool ProcessMouse(int windowId);
 
-  /*! \brief decode an event from the event service, this can be mouse, key, joystick, reset idle timers.
+  /*! \brief decode an event from the event service, this can be mouse, key, joystick, reset idle
+   * timers.
    *
    * \param windowId Currently active window
    * \param frameTime Time in seconds since last call
@@ -190,24 +189,30 @@ class CInputManager : public ISettingCallback,
   bool LoadKeymaps();
   bool ReloadKeymaps();
   void ClearKeymaps();
-  void AddKeymap(const std::string &keymap);
-  void RemoveKeymap(const std::string &keymap);
+  void AddKeymap(const std::string& keymap);
+  void RemoveKeymap(const std::string& keymap);
 
-  const IKeymapEnvironment *KeymapEnvironment() const { return m_keymapEnvironment.get(); }
+  const IKeymapEnvironment* KeymapEnvironment() const { return m_keymapEnvironment.get(); }
 
   /*! \brief Obtain the action configured for a given window and key
    *
    * \param window the window id
    * \param key the key to query the action for
-   * \param fallback if no action is directly configured for the given window, obtain the action from fallback window, if exists or from global config as last resort
+   * \param fallback if no action is directly configured for the given window, obtain the action
+   * from fallback window, if exists or from global config as last resort
    *
    * \return the action matching the key
    */
-  CAction GetAction(int window, const CKey &key, bool fallback = true);
+  CAction GetAction(int window, const CKey& key, bool fallback = true);
 
-  bool TranslateCustomControllerString(int windowId, const std::string& controllerName, int buttonId, int& action, std::string& strAction);
+  bool TranslateCustomControllerString(int windowId,
+                                       const std::string& controllerName,
+                                       int buttonId,
+                                       int& action,
+                                       std::string& strAction);
 
-  bool TranslateTouchAction(int windowId, int touchAction, int touchPointers, int &action, std::string &actionString);
+  bool TranslateTouchAction(
+      int windowId, int touchAction, int touchPointers, int& action, std::string& actionString);
 
   std::vector<std::shared_ptr<const IWindowKeymap>> GetJoystickKeymaps() const;
 
@@ -229,7 +234,6 @@ class CInputManager : public ISettingCallback,
   virtual void UnregisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler);
 
 private:
-
   /*! \brief Process keyboard event and translate into an action
    *
    * \param key keypress details
@@ -268,7 +272,7 @@ class CInputManager : public ISettingCallback,
    * \return result from CApplication::OnAction
    * \sa CAction
    */
-  bool ExecuteInputAction(const CAction &action);
+  bool ExecuteInputAction(const CAction& action);
 
   /*! \brief Dispatch actions queued since the last call to Process()
    */
@@ -278,10 +282,10 @@ class CInputManager : public ISettingCallback,
   CMouseStat m_Mouse;
   CKey m_LastKey;
 
-  std::map<std::string, std::map<int, float> > m_lastAxisMap;
+  std::map<std::string, std::map<int, float>> m_lastAxisMap;
 
   std::vector<CAction> m_queuedActions;
-  CCriticalSection     m_actionMutex;
+  CCriticalSection m_actionMutex;
 
   // Button translation
   std::unique_ptr<IKeymapEnvironment> m_keymapEnvironment;
diff --git a/xbmc/input/InputTranslator.cpp b/xbmc/input/InputTranslator.cpp
index dc24d3eaac03..6e3786d18213 100644
--- a/xbmc/input/InputTranslator.cpp
+++ b/xbmc/input/InputTranslator.cpp
@@ -11,29 +11,41 @@
 using namespace KODI;
 using namespace INPUT;
 
-#define TAN_1_8_PI  0.4142136f // tan(1/8*PI)
-#define TAN_3_8_PI  2.4142136f // tan(3/8*PI)
+#define TAN_1_8_PI 0.4142136f // tan(1/8*PI)
+#define TAN_3_8_PI 2.4142136f // tan(3/8*PI)
 
 CARDINAL_DIRECTION CInputTranslator::VectorToCardinalDirection(float x, float y)
 {
-  if      (y >= -x && y >  x) return CARDINAL_DIRECTION::UP;
-  else if (y <=  x && y > -x) return CARDINAL_DIRECTION::RIGHT;
-  else if (y <= -x && y <  x) return CARDINAL_DIRECTION::DOWN;
-  else if (y >=  x && y < -x) return CARDINAL_DIRECTION::LEFT;
+  if (y >= -x && y > x)
+    return CARDINAL_DIRECTION::UP;
+  else if (y <= x && y > -x)
+    return CARDINAL_DIRECTION::RIGHT;
+  else if (y <= -x && y < x)
+    return CARDINAL_DIRECTION::DOWN;
+  else if (y >= x && y < -x)
+    return CARDINAL_DIRECTION::LEFT;
 
   return CARDINAL_DIRECTION::NONE;
 }
 
 INTERCARDINAL_DIRECTION CInputTranslator::VectorToIntercardinalDirection(float x, float y)
 {
-  if      (y >= TAN_3_8_PI * -x && y > TAN_3_8_PI *  x) return INTERCARDINAL_DIRECTION::UP;
-  else if (y <= TAN_3_8_PI *  x && y > TAN_1_8_PI *  x) return INTERCARDINAL_DIRECTION::RIGHTUP;
-  else if (y <= TAN_1_8_PI *  x && y > TAN_1_8_PI * -x) return INTERCARDINAL_DIRECTION::RIGHT;
-  else if (y <= TAN_1_8_PI * -x && y > TAN_3_8_PI * -x) return INTERCARDINAL_DIRECTION::RIGHTDOWN;
-  else if (y <= TAN_3_8_PI * -x && y < TAN_3_8_PI *  x) return INTERCARDINAL_DIRECTION::DOWN;
-  else if (y >= TAN_3_8_PI *  x && y < TAN_1_8_PI *  x) return INTERCARDINAL_DIRECTION::LEFTDOWN;
-  else if (y >= TAN_1_8_PI *  x && y < TAN_1_8_PI * -x) return INTERCARDINAL_DIRECTION::LEFT;
-  else if (y >= TAN_1_8_PI * -x && y < TAN_3_8_PI * -x) return INTERCARDINAL_DIRECTION::LEFTUP;
+  if (y >= TAN_3_8_PI * -x && y > TAN_3_8_PI * x)
+    return INTERCARDINAL_DIRECTION::UP;
+  else if (y <= TAN_3_8_PI * x && y > TAN_1_8_PI * x)
+    return INTERCARDINAL_DIRECTION::RIGHTUP;
+  else if (y <= TAN_1_8_PI * x && y > TAN_1_8_PI * -x)
+    return INTERCARDINAL_DIRECTION::RIGHT;
+  else if (y <= TAN_1_8_PI * -x && y > TAN_3_8_PI * -x)
+    return INTERCARDINAL_DIRECTION::RIGHTDOWN;
+  else if (y <= TAN_3_8_PI * -x && y < TAN_3_8_PI * x)
+    return INTERCARDINAL_DIRECTION::DOWN;
+  else if (y >= TAN_3_8_PI * x && y < TAN_1_8_PI * x)
+    return INTERCARDINAL_DIRECTION::LEFTDOWN;
+  else if (y >= TAN_1_8_PI * x && y < TAN_1_8_PI * -x)
+    return INTERCARDINAL_DIRECTION::LEFT;
+  else if (y >= TAN_1_8_PI * -x && y < TAN_3_8_PI * -x)
+    return INTERCARDINAL_DIRECTION::LEFTUP;
 
   return INTERCARDINAL_DIRECTION::NONE;
 }
diff --git a/xbmc/input/InputTranslator.h b/xbmc/input/InputTranslator.h
index bcf446d0c692..19975ac328de 100644
--- a/xbmc/input/InputTranslator.h
+++ b/xbmc/input/InputTranslator.h
@@ -14,42 +14,42 @@ namespace KODI
 {
 namespace INPUT
 {
-  class CInputTranslator
-  {
-  public:
-    /*!
-     * \brief Get the closest cardinal direction to the given vector
-     *
-     * This function assumes a right-handed cartesian coordinate system; postive
-     * X is right, positive Y is up.
-     *
-     * Ties are resolved in the clockwise direction: (0.5, 0.5) will resolve to
-     * RIGHT.
-     *
-     * \param x  The x component of the vector
-     * \param y  The y component of the vector
-     *
-     * \return The closest cardinal direction (up, down, right or left), or
-     *         CARDINAL_DIRECTION::NONE if x and y are both 0
-     */
-    static CARDINAL_DIRECTION VectorToCardinalDirection(float x, float y);
+class CInputTranslator
+{
+public:
+  /*!
+   * \brief Get the closest cardinal direction to the given vector
+   *
+   * This function assumes a right-handed cartesian coordinate system; postive
+   * X is right, positive Y is up.
+   *
+   * Ties are resolved in the clockwise direction: (0.5, 0.5) will resolve to
+   * RIGHT.
+   *
+   * \param x  The x component of the vector
+   * \param y  The y component of the vector
+   *
+   * \return The closest cardinal direction (up, down, right or left), or
+   *         CARDINAL_DIRECTION::NONE if x and y are both 0
+   */
+  static CARDINAL_DIRECTION VectorToCardinalDirection(float x, float y);
 
-    /*!
-     * \brief Get the closest cardinal or intercardinal direction to the given
-     *        vector
-     *
-     * This function assumes a right-handed cartesian coordinate system; postive
-     * X is right, positive Y is up.
-     *
-     * Ties are resolved in the clockwise direction.
-     *
-     * \param x  The x component of the vector
-     * \param y  The y component of the vector
-     *
-     * \return The closest intercardinal direction, or
-     *         INTERCARDINAL_DIRECTION::NONE if x and y are both 0
-     */
-    static INTERCARDINAL_DIRECTION VectorToIntercardinalDirection(float x, float y);
-  };
-}
-}
+  /*!
+   * \brief Get the closest cardinal or intercardinal direction to the given
+   *        vector
+   *
+   * This function assumes a right-handed cartesian coordinate system; postive
+   * X is right, positive Y is up.
+   *
+   * Ties are resolved in the clockwise direction.
+   *
+   * \param x  The x component of the vector
+   * \param y  The y component of the vector
+   *
+   * \return The closest intercardinal direction, or
+   *         INTERCARDINAL_DIRECTION::NONE if x and y are both 0
+   */
+  static INTERCARDINAL_DIRECTION VectorToIntercardinalDirection(float x, float y);
+};
+} // namespace INPUT
+} // namespace KODI
diff --git a/xbmc/input/InputTypes.h b/xbmc/input/InputTypes.h
index af31efb90ea9..29da9aa31a39 100644
--- a/xbmc/input/InputTypes.h
+++ b/xbmc/input/InputTypes.h
@@ -12,32 +12,32 @@ namespace KODI
 {
 namespace INPUT
 {
-  /*!
-   * \brief Cardinal directions, used for input device motions
-   */
-  enum class CARDINAL_DIRECTION
-  {
-    NONE    = 0x0,
-    UP      = 0x1,
-    DOWN    = 0x2,
-    RIGHT   = 0x4,
-    LEFT    = 0x8,
-  };
+/*!
+ * \brief Cardinal directions, used for input device motions
+ */
+enum class CARDINAL_DIRECTION
+{
+  NONE = 0x0,
+  UP = 0x1,
+  DOWN = 0x2,
+  RIGHT = 0x4,
+  LEFT = 0x8,
+};
 
-  /*!
-   * \brief Cardinal and intercardinal directions, used for input device motions
-   */
-  enum class INTERCARDINAL_DIRECTION
-  {
-    NONE      = static_cast<unsigned int>(CARDINAL_DIRECTION::NONE),
-    UP        = static_cast<unsigned int>(CARDINAL_DIRECTION::UP),
-    DOWN      = static_cast<unsigned int>(CARDINAL_DIRECTION::DOWN),
-    RIGHT     = static_cast<unsigned int>(CARDINAL_DIRECTION::RIGHT),
-    LEFT      = static_cast<unsigned int>(CARDINAL_DIRECTION::LEFT),
-    RIGHTUP   = RIGHT | UP,
-    RIGHTDOWN = RIGHT | DOWN,
-    LEFTUP    = LEFT  | UP,
-    LEFTDOWN  = LEFT  | DOWN,
-  };
-}
-}
+/*!
+ * \brief Cardinal and intercardinal directions, used for input device motions
+ */
+enum class INTERCARDINAL_DIRECTION
+{
+  NONE = static_cast<unsigned int>(CARDINAL_DIRECTION::NONE),
+  UP = static_cast<unsigned int>(CARDINAL_DIRECTION::UP),
+  DOWN = static_cast<unsigned int>(CARDINAL_DIRECTION::DOWN),
+  RIGHT = static_cast<unsigned int>(CARDINAL_DIRECTION::RIGHT),
+  LEFT = static_cast<unsigned int>(CARDINAL_DIRECTION::LEFT),
+  RIGHTUP = RIGHT | UP,
+  RIGHTDOWN = RIGHT | DOWN,
+  LEFTUP = LEFT | UP,
+  LEFTDOWN = LEFT | DOWN,
+};
+} // namespace INPUT
+} // namespace KODI
diff --git a/xbmc/input/JoystickMapper.cpp b/xbmc/input/JoystickMapper.cpp
index 4e4121a56e98..631f68062db2 100644
--- a/xbmc/input/JoystickMapper.cpp
+++ b/xbmc/input/JoystickMapper.cpp
@@ -22,12 +22,12 @@
 
 using namespace KODI;
 
-#define JOYSTICK_XML_NODE_PROFILE    "profile"
-#define JOYSTICK_XML_ATTR_DIRECTION  "direction"
-#define JOYSTICK_XML_ATTR_HOLDTIME   "holdtime"
-#define JOYSTICK_XML_ATTR_HOTKEY     "hotkey"
+#define JOYSTICK_XML_NODE_PROFILE "profile"
+#define JOYSTICK_XML_ATTR_DIRECTION "direction"
+#define JOYSTICK_XML_ATTR_HOLDTIME "holdtime"
+#define JOYSTICK_XML_ATTR_HOTKEY "hotkey"
 
-void CJoystickMapper::MapActions(int windowID, const TiXmlNode *pDevice)
+void CJoystickMapper::MapActions(int windowID, const TiXmlNode* pDevice)
 {
   std::string controllerId;
   DeserializeJoystickNode(pDevice, controllerId);
@@ -35,7 +35,8 @@ void CJoystickMapper::MapActions(int windowID, const TiXmlNode *pDevice)
     return;
 
   // Update Controller IDs
-  if (std::find(m_controllerIds.begin(), m_controllerIds.end(), controllerId) == m_controllerIds.end())
+  if (std::find(m_controllerIds.begin(), m_controllerIds.end(), controllerId) ==
+      m_controllerIds.end())
     m_controllerIds.emplace_back(controllerId);
 
   // Create/overwrite keymap
@@ -43,7 +44,7 @@ void CJoystickMapper::MapActions(int windowID, const TiXmlNode *pDevice)
   if (!keymap)
     keymap.reset(new CWindowKeymap(controllerId));
 
-  const TiXmlElement *pButton = pDevice->FirstChildElement();
+  const TiXmlElement* pButton = pDevice->FirstChildElement();
   while (pButton != nullptr)
   {
     std::string feature;
@@ -58,12 +59,13 @@ void CJoystickMapper::MapActions(int windowID, const TiXmlNode *pDevice)
       if (CActionTranslator::TranslateString(actionString, actionId))
       {
         JOYSTICK::KeymapAction action = {
-          actionId,
-          std::move(actionString),
-          holdtimeMs,
-          std::move(hotkeys),
+            actionId,
+            std::move(actionString),
+            holdtimeMs,
+            std::move(hotkeys),
         };
-        keymap->MapAction(windowID, JOYSTICK::CJoystickUtils::MakeKeyName(feature, dir), std::move(action));
+        keymap->MapAction(windowID, JOYSTICK::CJoystickUtils::MakeKeyName(feature, dir),
+                          std::move(action));
       }
     }
     pButton = pButton->NextSiblingElement();
@@ -80,7 +82,7 @@ std::vector<std::shared_ptr<const IWindowKeymap>> CJoystickMapper::GetJoystickKe
 {
   std::vector<std::shared_ptr<const IWindowKeymap>> keymaps;
 
-  for (const auto &controllerId : m_controllerIds)
+  for (const auto& controllerId : m_controllerIds)
   {
     auto it = m_joystickKeymaps.find(controllerId);
     if (it != m_joystickKeymaps.end())
@@ -90,21 +92,26 @@ std::vector<std::shared_ptr<const IWindowKeymap>> CJoystickMapper::GetJoystickKe
   return keymaps;
 }
 
-void CJoystickMapper::DeserializeJoystickNode(const TiXmlNode* pDevice, std::string &controllerId)
+void CJoystickMapper::DeserializeJoystickNode(const TiXmlNode* pDevice, std::string& controllerId)
 {
   const TiXmlElement* deviceElem = pDevice->ToElement();
   if (deviceElem != nullptr)
     deviceElem->QueryValueAttribute(JOYSTICK_XML_NODE_PROFILE, &controllerId);
 }
 
-bool CJoystickMapper::DeserializeButton(const TiXmlElement *pButton, std::string &feature, JOYSTICK::ANALOG_STICK_DIRECTION &dir, unsigned int& holdtimeMs, std::set<std::string>& hotkeys, std::string &actionStr)
+bool CJoystickMapper::DeserializeButton(const TiXmlElement* pButton,
+                                        std::string& feature,
+                                        JOYSTICK::ANALOG_STICK_DIRECTION& dir,
+                                        unsigned int& holdtimeMs,
+                                        std::set<std::string>& hotkeys,
+                                        std::string& actionStr)
 {
-  const char *szButton = pButton->Value();
+  const char* szButton = pButton->Value();
   if (szButton != nullptr)
   {
-    const char *szAction = nullptr;
+    const char* szAction = nullptr;
 
-    const TiXmlNode *actionNode = pButton->FirstChild();
+    const TiXmlNode* actionNode = pButton->FirstChild();
     if (actionNode != nullptr)
       szAction = actionNode->Value();
 
@@ -120,7 +127,7 @@ bool CJoystickMapper::DeserializeButton(const TiXmlElement *pButton, std::string
   {
     // Handle direction
     dir = JOYSTICK::ANALOG_STICK_DIRECTION::NONE;
-    const char *szDirection = pButton->Attribute(JOYSTICK_XML_ATTR_DIRECTION);
+    const char* szDirection = pButton->Attribute(JOYSTICK_XML_ATTR_DIRECTION);
     if (szDirection != nullptr)
       dir = JOYSTICK::CJoystickTranslator::TranslateAnalogStickDirection(szDirection);
 
diff --git a/xbmc/input/JoystickMapper.h b/xbmc/input/JoystickMapper.h
index 27f1c2892afe..ed5e61a9415c 100644
--- a/xbmc/input/JoystickMapper.h
+++ b/xbmc/input/JoystickMapper.h
@@ -34,8 +34,13 @@ class CJoystickMapper : public IButtonMapper
   std::vector<std::shared_ptr<const IWindowKeymap>> GetJoystickKeymaps() const;
 
 private:
-  void DeserializeJoystickNode(const TiXmlNode* pDevice, std::string &controllerId);
-  bool DeserializeButton(const TiXmlElement *pButton, std::string &feature, KODI::JOYSTICK::ANALOG_STICK_DIRECTION &dir, unsigned int& holdtimeMs, std::set<std::string>& hotkeys, std::string &actionStr);
+  void DeserializeJoystickNode(const TiXmlNode* pDevice, std::string& controllerId);
+  bool DeserializeButton(const TiXmlElement* pButton,
+                         std::string& feature,
+                         KODI::JOYSTICK::ANALOG_STICK_DIRECTION& dir,
+                         unsigned int& holdtimeMs,
+                         std::set<std::string>& hotkeys,
+                         std::string& actionStr);
 
   using ControllerID = std::string;
   std::map<ControllerID, std::shared_ptr<IWindowKeymap>> m_joystickKeymaps;
diff --git a/xbmc/input/Key.cpp b/xbmc/input/Key.cpp
index 04fad7d90f89..b4e2653be2af 100644
--- a/xbmc/input/Key.cpp
+++ b/xbmc/input/Key.cpp
@@ -15,7 +15,14 @@ CKey::CKey(void)
 
 CKey::~CKey(void) = default;
 
-CKey::CKey(uint32_t buttonCode, uint8_t leftTrigger, uint8_t rightTrigger, float leftThumbX, float leftThumbY, float rightThumbX, float rightThumbY, float repeat)
+CKey::CKey(uint32_t buttonCode,
+           uint8_t leftTrigger,
+           uint8_t rightTrigger,
+           float leftThumbX,
+           float leftThumbY,
+           float rightThumbX,
+           float rightThumbY,
+           float repeat)
 {
   Reset();
   m_buttonCode = buttonCode;
@@ -35,7 +42,13 @@ CKey::CKey(uint32_t buttonCode, unsigned int held)
   m_held = held;
 }
 
-CKey::CKey(uint32_t keycode, uint8_t vkey, wchar_t unicode, char ascii, uint32_t modifiers, uint32_t lockingModifiers, unsigned int held)
+CKey::CKey(uint32_t keycode,
+           uint8_t vkey,
+           wchar_t unicode,
+           char ascii,
+           uint32_t modifiers,
+           uint32_t lockingModifiers,
+           unsigned int held)
 {
   Reset();
   if (vkey) // FIXME: This needs cleaning up - should we always use the unicode key where available?
@@ -79,23 +92,24 @@ void CKey::Reset()
 
 CKey& CKey::operator=(const CKey& key)
 {
-  if (&key == this) return * this;
-  m_leftTrigger  = key.m_leftTrigger;
+  if (&key == this)
+    return *this;
+  m_leftTrigger = key.m_leftTrigger;
   m_rightTrigger = key.m_rightTrigger;
-  m_leftThumbX   = key.m_leftThumbX;
-  m_leftThumbY   = key.m_leftThumbY;
-  m_rightThumbX  = key.m_rightThumbX;
-  m_rightThumbY  = key.m_rightThumbY;
-  m_repeat       = key.m_repeat;
-  m_fromService  = key.m_fromService;
-  m_buttonCode   = key.m_buttonCode;
-  m_keycode      = key.m_keycode;
-  m_vkey         = key.m_vkey;
-  m_unicode     = key.m_unicode;
-  m_ascii       = key.m_ascii;
-  m_modifiers    = key.m_modifiers;
+  m_leftThumbX = key.m_leftThumbX;
+  m_leftThumbY = key.m_leftThumbY;
+  m_rightThumbX = key.m_rightThumbX;
+  m_rightThumbY = key.m_rightThumbY;
+  m_repeat = key.m_repeat;
+  m_fromService = key.m_fromService;
+  m_buttonCode = key.m_buttonCode;
+  m_keycode = key.m_keycode;
+  m_vkey = key.m_vkey;
+  m_unicode = key.m_unicode;
+  m_ascii = key.m_ascii;
+  m_modifiers = key.m_modifiers;
   m_lockingModifiers = key.m_lockingModifiers;
-  m_held         = key.m_held;
+  m_held = key.m_held;
   return *this;
 }
 
@@ -137,7 +151,8 @@ bool CKey::FromKeyboard() const
 
 bool CKey::IsAnalogButton() const
 {
-  if ((GetButtonCode() > 261 && GetButtonCode() < 270) || (GetButtonCode() > 279 && GetButtonCode() < 284))
+  if ((GetButtonCode() > 261 && GetButtonCode() < 270) ||
+      (GetButtonCode() > 279 && GetButtonCode() < 284))
     return true;
 
   return false;
diff --git a/xbmc/input/Key.h b/xbmc/input/Key.h
index 8a488ce22223..40ef07c12cd4 100644
--- a/xbmc/input/Key.h
+++ b/xbmc/input/Key.h
@@ -28,81 +28,82 @@
  * EventServer "gamepad" keys based on original Xbox controller
  */
 // Analogue - don't change order
-#define KEY_BUTTON_A                        256
-#define KEY_BUTTON_B                        257
-#define KEY_BUTTON_X                        258
-#define KEY_BUTTON_Y                        259
-#define KEY_BUTTON_BLACK                    260
-#define KEY_BUTTON_WHITE                    261
-#define KEY_BUTTON_LEFT_TRIGGER             262
-#define KEY_BUTTON_RIGHT_TRIGGER            263
-
-#define KEY_BUTTON_LEFT_THUMB_STICK         264
-#define KEY_BUTTON_RIGHT_THUMB_STICK        265
-
-#define KEY_BUTTON_RIGHT_THUMB_STICK_UP     266 // right thumb stick directions
-#define KEY_BUTTON_RIGHT_THUMB_STICK_DOWN   267 // for defining different actions per direction
-#define KEY_BUTTON_RIGHT_THUMB_STICK_LEFT   268
-#define KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT  269
+#define KEY_BUTTON_A 256
+#define KEY_BUTTON_B 257
+#define KEY_BUTTON_X 258
+#define KEY_BUTTON_Y 259
+#define KEY_BUTTON_BLACK 260
+#define KEY_BUTTON_WHITE 261
+#define KEY_BUTTON_LEFT_TRIGGER 262
+#define KEY_BUTTON_RIGHT_TRIGGER 263
+
+#define KEY_BUTTON_LEFT_THUMB_STICK 264
+#define KEY_BUTTON_RIGHT_THUMB_STICK 265
+
+#define KEY_BUTTON_RIGHT_THUMB_STICK_UP 266 // right thumb stick directions
+#define KEY_BUTTON_RIGHT_THUMB_STICK_DOWN 267 // for defining different actions per direction
+#define KEY_BUTTON_RIGHT_THUMB_STICK_LEFT 268
+#define KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT 269
 
 // Digital - don't change order
-#define KEY_BUTTON_DPAD_UP                  270
-#define KEY_BUTTON_DPAD_DOWN                271
-#define KEY_BUTTON_DPAD_LEFT                272
-#define KEY_BUTTON_DPAD_RIGHT               273
+#define KEY_BUTTON_DPAD_UP 270
+#define KEY_BUTTON_DPAD_DOWN 271
+#define KEY_BUTTON_DPAD_LEFT 272
+#define KEY_BUTTON_DPAD_RIGHT 273
 
-#define KEY_BUTTON_START                    274
-#define KEY_BUTTON_BACK                     275
+#define KEY_BUTTON_START 274
+#define KEY_BUTTON_BACK 275
 
-#define KEY_BUTTON_LEFT_THUMB_BUTTON        276
-#define KEY_BUTTON_RIGHT_THUMB_BUTTON       277
+#define KEY_BUTTON_LEFT_THUMB_BUTTON 276
+#define KEY_BUTTON_RIGHT_THUMB_BUTTON 277
 
-#define KEY_BUTTON_LEFT_ANALOG_TRIGGER      278
-#define KEY_BUTTON_RIGHT_ANALOG_TRIGGER     279
+#define KEY_BUTTON_LEFT_ANALOG_TRIGGER 278
+#define KEY_BUTTON_RIGHT_ANALOG_TRIGGER 279
 
-#define KEY_BUTTON_LEFT_THUMB_STICK_UP      280 // left thumb stick directions
-#define KEY_BUTTON_LEFT_THUMB_STICK_DOWN    281 // for defining different actions per direction
-#define KEY_BUTTON_LEFT_THUMB_STICK_LEFT    282
-#define KEY_BUTTON_LEFT_THUMB_STICK_RIGHT   283
+#define KEY_BUTTON_LEFT_THUMB_STICK_UP 280 // left thumb stick directions
+#define KEY_BUTTON_LEFT_THUMB_STICK_DOWN 281 // for defining different actions per direction
+#define KEY_BUTTON_LEFT_THUMB_STICK_LEFT 282
+#define KEY_BUTTON_LEFT_THUMB_STICK_RIGHT 283
 
 // 0xF000 -> 0xF200 is reserved for the keyboard; a keyboard press is either
-#define KEY_VKEY            0xF000 // a virtual key/functional key e.g. cursor left
-#define KEY_UNICODE         0xF200 // another printable character whose range is not included in this KEY code
+#define KEY_VKEY 0xF000 // a virtual key/functional key e.g. cursor left
+#define KEY_UNICODE \
+  0xF200 // another printable character whose range is not included in this KEY code
 
 // 0xE000 -> 0xEFFF is reserved for mouse actions
-#define KEY_VMOUSE          0xEFFF
-
-#define KEY_MOUSE_START            0xE000
-#define KEY_MOUSE_CLICK            0xE000
-#define KEY_MOUSE_RIGHTCLICK       0xE001
-#define KEY_MOUSE_MIDDLECLICK      0xE002
-#define KEY_MOUSE_DOUBLE_CLICK     0xE010
-#define KEY_MOUSE_LONG_CLICK       0xE020
-#define KEY_MOUSE_WHEEL_UP         0xE101
-#define KEY_MOUSE_WHEEL_DOWN       0xE102
-#define KEY_MOUSE_MOVE             0xE103
-#define KEY_MOUSE_DRAG             0xE104
-#define KEY_MOUSE_DRAG_START       0xE105
-#define KEY_MOUSE_DRAG_END         0xE106
-#define KEY_MOUSE_RDRAG            0xE107
-#define KEY_MOUSE_RDRAG_START      0xE108
-#define KEY_MOUSE_RDRAG_END        0xE109
-#define KEY_MOUSE_NOOP             0xEFFF
-#define KEY_MOUSE_END              0xEFFF
+#define KEY_VMOUSE 0xEFFF
+
+#define KEY_MOUSE_START 0xE000
+#define KEY_MOUSE_CLICK 0xE000
+#define KEY_MOUSE_RIGHTCLICK 0xE001
+#define KEY_MOUSE_MIDDLECLICK 0xE002
+#define KEY_MOUSE_DOUBLE_CLICK 0xE010
+#define KEY_MOUSE_LONG_CLICK 0xE020
+#define KEY_MOUSE_WHEEL_UP 0xE101
+#define KEY_MOUSE_WHEEL_DOWN 0xE102
+#define KEY_MOUSE_MOVE 0xE103
+#define KEY_MOUSE_DRAG 0xE104
+#define KEY_MOUSE_DRAG_START 0xE105
+#define KEY_MOUSE_DRAG_END 0xE106
+#define KEY_MOUSE_RDRAG 0xE107
+#define KEY_MOUSE_RDRAG_START 0xE108
+#define KEY_MOUSE_RDRAG_END 0xE109
+#define KEY_MOUSE_NOOP 0xEFFF
+#define KEY_MOUSE_END 0xEFFF
 
 // 0xD000 -> 0xD0FF is reserved for WM_APPCOMMAND messages
-#define KEY_APPCOMMAND      0xD000
+#define KEY_APPCOMMAND 0xD000
 
-#define KEY_INVALID         0xFFFF
+#define KEY_INVALID 0xFFFF
 
-#define ICON_TYPE_NONE          101
-#define ICON_TYPE_PROGRAMS      102
-#define ICON_TYPE_MUSIC         103
-#define ICON_TYPE_PICTURES      104
-#define ICON_TYPE_VIDEOS        105
-#define ICON_TYPE_FILES         106
-#define ICON_TYPE_WEATHER       107
-#define ICON_TYPE_SETTINGS      109
+#define ICON_TYPE_NONE 101
+#define ICON_TYPE_PROGRAMS 102
+#define ICON_TYPE_MUSIC 103
+#define ICON_TYPE_PICTURES 104
+#define ICON_TYPE_VIDEOS 105
+#define ICON_TYPE_FILES 106
+#define ICON_TYPE_WEATHER 107
+#define ICON_TYPE_SETTINGS 109
 
 #ifndef SWIG
 
@@ -121,10 +122,10 @@ class CMouseEvent
     m_offsetY = offsetY;
   };
 
-  int    m_id;
-  int    m_state;
-  float  m_offsetX;
-  float  m_offsetY;
+  int m_id;
+  int m_state;
+  float m_offsetX;
+  float m_offsetY;
 };
 
 /*!
@@ -135,9 +136,22 @@ class CKey
 {
 public:
   CKey(void);
-  CKey(uint32_t buttonCode, uint8_t leftTrigger = 0, uint8_t rightTrigger = 0, float leftThumbX = 0.0f, float leftThumbY = 0.0f, float rightThumbX = 0.0f, float rightThumbY = 0.0f, float repeat = 0.0f);
+  CKey(uint32_t buttonCode,
+       uint8_t leftTrigger = 0,
+       uint8_t rightTrigger = 0,
+       float leftThumbX = 0.0f,
+       float leftThumbY = 0.0f,
+       float rightThumbX = 0.0f,
+       float rightThumbY = 0.0f,
+       float repeat = 0.0f);
   CKey(uint32_t buttonCode, unsigned int held);
-  CKey(uint32_t keycode, uint8_t vkey, wchar_t unicode, char ascii, uint32_t modifiers, uint32_t lockingModifiers, unsigned int held);
+  CKey(uint32_t keycode,
+       uint8_t vkey,
+       wchar_t unicode,
+       char ascii,
+       uint32_t modifiers,
+       uint32_t lockingModifiers,
+       unsigned int held);
   CKey(const CKey& key);
   void Reset();
 
@@ -157,22 +171,23 @@ class CKey
   bool GetFromService() const { return m_fromService; }
 
   inline uint32_t GetButtonCode() const { return m_buttonCode; }
-  inline uint32_t GetKeycode() const    { return m_keycode; } // XBMCKey enum in XBMC_keysym.h
-  inline uint8_t  GetVKey() const       { return m_vkey; }
-  inline wchar_t  GetUnicode() const    { return m_unicode; }
-  inline char     GetAscii() const      { return m_ascii; }
-  inline uint32_t GetModifiers() const  { return m_modifiers; };
+  inline uint32_t GetKeycode() const { return m_keycode; } // XBMCKey enum in XBMC_keysym.h
+  inline uint8_t GetVKey() const { return m_vkey; }
+  inline wchar_t GetUnicode() const { return m_unicode; }
+  inline char GetAscii() const { return m_ascii; }
+  inline uint32_t GetModifiers() const { return m_modifiers; };
   inline uint32_t GetLockingModifiers() const { return m_lockingModifiers; };
-  inline unsigned int GetHeld() const   { return m_held; }
+  inline unsigned int GetHeld() const { return m_held; }
 
-  enum Modifier {
-    MODIFIER_CTRL  = 0x00010000,
+  enum Modifier
+  {
+    MODIFIER_CTRL = 0x00010000,
     MODIFIER_SHIFT = 0x00020000,
-    MODIFIER_ALT   = 0x00040000,
-    MODIFIER_RALT  = 0x00080000,
+    MODIFIER_ALT = 0x00040000,
+    MODIFIER_RALT = 0x00080000,
     MODIFIER_SUPER = 0x00100000,
-    MODIFIER_META  = 0X00200000,
-    MODIFIER_LONG  = 0X01000000,
+    MODIFIER_META = 0X00200000,
+    MODIFIER_LONG = 0X01000000,
     MODIFIER_NUMLOCK = 0X02000000,
     MODIFIER_CAPSLOCK = 0X04000000,
     MODIFIER_SCROLLLOCK = 0X08000000,
@@ -181,9 +196,9 @@ class CKey
 private:
   uint32_t m_buttonCode;
   uint32_t m_keycode;
-  uint8_t  m_vkey;
-  wchar_t  m_unicode;
-  char     m_ascii;
+  uint8_t m_vkey;
+  wchar_t m_unicode;
+  char m_ascii;
   uint32_t m_modifiers;
   uint32_t m_lockingModifiers;
   unsigned int m_held;
@@ -197,5 +212,4 @@ class CKey
   float m_repeat; // time since last keypress
   bool m_fromService;
 };
-#endif //undef SWIG
-
+#endif // undef SWIG
diff --git a/xbmc/input/KeyboardLayout.cpp b/xbmc/input/KeyboardLayout.cpp
index 29dfbb65aa2a..f6d8828566b7 100644
--- a/xbmc/input/KeyboardLayout.cpp
+++ b/xbmc/input/KeyboardLayout.cpp
@@ -55,9 +55,10 @@ bool CKeyboardLayout::Load(const TiXmlElement* element)
     return false;
   }
 
-  const TiXmlElement *keyboard = element->FirstChildElement("keyboard");
+  const TiXmlElement* keyboard = element->FirstChildElement("keyboard");
   if (element->Attribute("codingtable"))
-    m_codingtable = IInputCodingTablePtr(CInputCodingTableFactory::CreateCodingTable(element->Attribute("codingtable"), element));
+    m_codingtable = IInputCodingTablePtr(
+        CInputCodingTableFactory::CreateCodingTable(element->Attribute("codingtable"), element));
   else
     m_codingtable = NULL;
   while (keyboard != NULL)
@@ -89,7 +90,7 @@ bool CKeyboardLayout::Load(const TiXmlElement* element)
     }
 
     // parse keyboard rows
-    const TiXmlNode *row = keyboard->FirstChild("row");
+    const TiXmlNode* row = keyboard->FirstChild("row");
     while (row != NULL)
     {
       if (!row->NoChildren())
@@ -127,10 +128,13 @@ std::string CKeyboardLayout::GetIdentifier() const
 
 std::string CKeyboardLayout::GetName() const
 {
-  return StringUtils::Format(g_localizeStrings.Get(311).c_str(), m_language.c_str(), m_layout.c_str());
+  return StringUtils::Format(g_localizeStrings.Get(311).c_str(), m_language.c_str(),
+                             m_layout.c_str());
 }
 
-std::string CKeyboardLayout::GetCharAt(unsigned int row, unsigned int column, unsigned int modifiers) const
+std::string CKeyboardLayout::GetCharAt(unsigned int row,
+                                       unsigned int column,
+                                       unsigned int modifiers) const
 {
   Keyboards::const_iterator mod = m_keyboards.find(modifiers);
   if (modifiers != ModifierKeyNone && mod != m_keyboards.end() && mod->second.empty())
@@ -152,7 +156,7 @@ std::string CKeyboardLayout::GetCharAt(unsigned int row, unsigned int column, un
   return "";
 }
 
-std::vector<std::string> CKeyboardLayout::BreakCharacters(const std::string &chars)
+std::vector<std::string> CKeyboardLayout::BreakCharacters(const std::string& chars)
 {
   std::vector<std::string> result;
   // break into utf8 characters
diff --git a/xbmc/input/KeyboardLayout.h b/xbmc/input/KeyboardLayout.h
index 264f282548dd..683ae5390794 100644
--- a/xbmc/input/KeyboardLayout.h
+++ b/xbmc/input/KeyboardLayout.h
@@ -32,17 +32,17 @@ class CKeyboardLayout
 
   enum ModifierKey
   {
-    ModifierKeyNone   = 0x00,
-    ModifierKeyShift  = 0x01,
+    ModifierKeyNone = 0x00,
+    ModifierKeyShift = 0x01,
     ModifierKeySymbol = 0x02
   };
 
   std::string GetCharAt(unsigned int row, unsigned int column, unsigned int modifiers = 0) const;
 
 private:
-  static std::vector<std::string> BreakCharacters(const std::string &chars);
+  static std::vector<std::string> BreakCharacters(const std::string& chars);
 
-  typedef std::vector< std::vector<std::string> > KeyboardRows;
+  typedef std::vector<std::vector<std::string>> KeyboardRows;
   typedef std::map<unsigned int, KeyboardRows> Keyboards;
 
   std::string m_language;
diff --git a/xbmc/input/KeyboardLayoutManager.cpp b/xbmc/input/KeyboardLayoutManager.cpp
index 931b955d16fa..afbec2815903 100644
--- a/xbmc/input/KeyboardLayoutManager.cpp
+++ b/xbmc/input/KeyboardLayoutManager.cpp
@@ -18,7 +18,7 @@
 
 #include <algorithm>
 
-#define KEYBOARD_LAYOUTS_PATH   "special://xbmc/system/keyboardlayouts"
+#define KEYBOARD_LAYOUTS_PATH "special://xbmc/system/keyboardlayouts"
 
 CKeyboardLayoutManager::~CKeyboardLayoutManager()
 {
@@ -39,18 +39,25 @@ bool CKeyboardLayoutManager::Load(const std::string& path /* = "" */)
 
   if (!XFILE::CDirectory::Exists(layoutDirectory))
   {
-    CLog::Log(LOGWARNING, "CKeyboardLayoutManager: unable to load keyboard layouts from non-existing directory \"%s\"", layoutDirectory.c_str());
+    CLog::Log(LOGWARNING,
+              "CKeyboardLayoutManager: unable to load keyboard layouts from non-existing directory "
+              "\"%s\"",
+              layoutDirectory.c_str());
     return false;
   }
 
   CFileItemList layouts;
-  if (!XFILE::CDirectory::GetDirectory(CURL(layoutDirectory), layouts, ".xml", XFILE::DIR_FLAG_DEFAULTS) || layouts.IsEmpty())
+  if (!XFILE::CDirectory::GetDirectory(CURL(layoutDirectory), layouts, ".xml",
+                                       XFILE::DIR_FLAG_DEFAULTS) ||
+      layouts.IsEmpty())
   {
-    CLog::Log(LOGWARNING, "CKeyboardLayoutManager: no keyboard layouts found in %s", layoutDirectory.c_str());
+    CLog::Log(LOGWARNING, "CKeyboardLayoutManager: no keyboard layouts found in %s",
+              layoutDirectory.c_str());
     return false;
   }
 
-  CLog::Log(LOGINFO, "CKeyboardLayoutManager: loading keyboard layouts from %s...", layoutDirectory.c_str());
+  CLog::Log(LOGINFO, "CKeyboardLayoutManager: loading keyboard layouts from %s...",
+            layoutDirectory.c_str());
   size_t oldLayoutCount = m_layouts.size();
   for (int i = 0; i < layouts.Size(); i++)
   {
@@ -68,13 +75,15 @@ bool CKeyboardLayoutManager::Load(const std::string& path /* = "" */)
     const TiXmlElement* rootElement = xmlDoc.RootElement();
     if (rootElement == NULL)
     {
-      CLog::Log(LOGWARNING, "CKeyboardLayoutManager: missing or invalid XML root element in %s", layoutPath.c_str());
+      CLog::Log(LOGWARNING, "CKeyboardLayoutManager: missing or invalid XML root element in %s",
+                layoutPath.c_str());
       continue;
     }
 
     if (rootElement->ValueStr() != "keyboardlayouts")
     {
-      CLog::Log(LOGWARNING, "CKeyboardLayoutManager: unexpected XML root element \"%s\" in %s", rootElement->Value(), layoutPath.c_str());
+      CLog::Log(LOGWARNING, "CKeyboardLayoutManager: unexpected XML root element \"%s\" in %s",
+                rootElement->Value(), layoutPath.c_str());
       continue;
     }
 
@@ -85,10 +94,13 @@ bool CKeyboardLayoutManager::Load(const std::string& path /* = "" */)
       if (!layout.Load(layoutElement))
         CLog::Log(LOGWARNING, "CKeyboardLayoutManager: failed to load %s", layoutPath.c_str());
       else if (m_layouts.find(layout.GetIdentifier()) != m_layouts.end())
-        CLog::Log(LOGWARNING, "CKeyboardLayoutManager: duplicate layout with identifier \"%s\" in %s", layout.GetIdentifier().c_str(), layoutPath.c_str());
+        CLog::Log(LOGWARNING,
+                  "CKeyboardLayoutManager: duplicate layout with identifier \"%s\" in %s",
+                  layout.GetIdentifier().c_str(), layoutPath.c_str());
       else
       {
-        CLog::Log(LOGDEBUG, "CKeyboardLayoutManager: keyboard layout \"%s\" successfully loaded", layout.GetIdentifier().c_str());
+        CLog::Log(LOGDEBUG, "CKeyboardLayoutManager: keyboard layout \"%s\" successfully loaded",
+                  layout.GetIdentifier().c_str());
         m_layouts.insert(std::make_pair(layout.GetIdentifier(), layout));
       }
 
@@ -119,13 +131,17 @@ bool CKeyboardLayoutManager::GetLayout(const std::string& name, CKeyboardLayout&
 
 namespace
 {
-  inline bool LayoutSort(const StringSettingOption& i, const StringSettingOption& j)
-  {
-    return (i.value < j.value);
-  }
+inline bool LayoutSort(const StringSettingOption& i, const StringSettingOption& j)
+{
+  return (i.value < j.value);
 }
+} // namespace
 
-void CKeyboardLayoutManager::SettingOptionsKeyboardLayoutsFiller(SettingConstPtr setting, std::vector<StringSettingOption> &list, std::string &current, void* data)
+void CKeyboardLayoutManager::SettingOptionsKeyboardLayoutsFiller(
+    SettingConstPtr setting,
+    std::vector<StringSettingOption>& list,
+    std::string& current,
+    void* data)
 {
   for (const auto& it : CKeyboardLayoutManager::GetInstance().m_layouts)
   {
diff --git a/xbmc/input/KeyboardLayoutManager.h b/xbmc/input/KeyboardLayoutManager.h
index a5ea4b6880b3..b493155e38b6 100644
--- a/xbmc/input/KeyboardLayoutManager.h
+++ b/xbmc/input/KeyboardLayoutManager.h
@@ -33,7 +33,10 @@ class CKeyboardLayoutManager
   const KeyboardLayouts& GetLayouts() const { return m_layouts; }
   bool GetLayout(const std::string& name, CKeyboardLayout& layout) const;
 
-  static void SettingOptionsKeyboardLayoutsFiller(std::shared_ptr<const CSetting> setting, std::vector<StringSettingOption> &list, std::string &current, void* data);
+  static void SettingOptionsKeyboardLayoutsFiller(std::shared_ptr<const CSetting> setting,
+                                                  std::vector<StringSettingOption>& list,
+                                                  std::string& current,
+                                                  void* data);
 
 private:
   CKeyboardLayoutManager() = default;
diff --git a/xbmc/input/KeyboardStat.cpp b/xbmc/input/KeyboardStat.cpp
index 3e669f97290a..9d5ce3e4926c 100644
--- a/xbmc/input/KeyboardStat.cpp
+++ b/xbmc/input/KeyboardStat.cpp
@@ -26,10 +26,8 @@
 
 bool operator==(const XBMC_keysym& lhs, const XBMC_keysym& rhs)
 {
-  return lhs.mod      == rhs.mod      &&
-         lhs.scancode == rhs.scancode &&
-         lhs.sym      == rhs.sym      &&
-         lhs.unicode  == rhs.unicode;
+  return lhs.mod == rhs.mod && lhs.scancode == rhs.scancode && lhs.sym == rhs.sym &&
+         lhs.unicode == rhs.unicode;
 }
 
 CKeyboardStat::CKeyboardStat()
@@ -44,7 +42,7 @@ void CKeyboardStat::Initialize()
 {
 }
 
-bool CKeyboardStat::LookupSymAndUnicodePeripherals(XBMC_keysym &keysym, uint8_t *key, char *unicode)
+bool CKeyboardStat::LookupSymAndUnicodePeripherals(XBMC_keysym& keysym, uint8_t* key, char* unicode)
 {
   using namespace PERIPHERALS;
 
@@ -53,7 +51,8 @@ bool CKeyboardStat::LookupSymAndUnicodePeripherals(XBMC_keysym &keysym, uint8_t
   {
     for (auto& peripheral : hidDevices)
     {
-      std::shared_ptr<CPeripheralHID> hidDevice = std::static_pointer_cast<CPeripheralHID>(peripheral);
+      std::shared_ptr<CPeripheralHID> hidDevice =
+          std::static_pointer_cast<CPeripheralHID>(peripheral);
       if (hidDevice->LookupSymAndUnicode(keysym, key, unicode))
         return true;
     }
@@ -92,7 +91,8 @@ CKey CKeyboardStat::TranslateKey(XBMC_keysym& keysym) const
   if (keysym.mod & XBMCKMOD_MODE)
     lockingModifiers |= CKey::MODIFIER_SCROLLLOCK;
 
-  CLog::Log(LOGDEBUG, "Keyboard: scancode: 0x%02x, sym: 0x%04x, unicode: 0x%04x, modifier: 0x%x", keysym.scancode, keysym.sym, keysym.unicode, keysym.mod);
+  CLog::Log(LOGDEBUG, "Keyboard: scancode: 0x%02x, sym: 0x%04x, unicode: 0x%04x, modifier: 0x%x",
+            keysym.scancode, keysym.sym, keysym.unicode, keysym.mod);
 
   // The keysym.unicode is usually valid, even if it is zero. A zero
   // unicode just means this is a non-printing keypress. The ascii and
@@ -146,12 +146,18 @@ CKey CKeyboardStat::TranslateKey(XBMC_keysym& keysym) const
   {
     if (!vkey && !ascii)
     {
-      if (keysym.mod & XBMCKMOD_LSHIFT) vkey = 0xa0;
-      else if (keysym.mod & XBMCKMOD_RSHIFT) vkey = 0xa1;
-      else if (keysym.mod & XBMCKMOD_LALT) vkey = 0xa4;
-      else if (keysym.mod & XBMCKMOD_RALT) vkey = 0xa5;
-      else if (keysym.mod & XBMCKMOD_LCTRL) vkey = 0xa2;
-      else if (keysym.mod & XBMCKMOD_RCTRL) vkey = 0xa3;
+      if (keysym.mod & XBMCKMOD_LSHIFT)
+        vkey = 0xa0;
+      else if (keysym.mod & XBMCKMOD_RSHIFT)
+        vkey = 0xa1;
+      else if (keysym.mod & XBMCKMOD_LALT)
+        vkey = 0xa4;
+      else if (keysym.mod & XBMCKMOD_RALT)
+        vkey = 0xa5;
+      else if (keysym.mod & XBMCKMOD_LCTRL)
+        vkey = 0xa2;
+      else if (keysym.mod & XBMCKMOD_RCTRL)
+        vkey = 0xa3;
       else if (keysym.unicode > 32 && keysym.unicode < 128)
         // only TRUE ASCII! (Otherwise XBMC crashes! No unicode not even latin 1!)
         ascii = (char)(keysym.unicode & 0xff);
@@ -172,7 +178,8 @@ CKey CKeyboardStat::TranslateKey(XBMC_keysym& keysym) const
   // The function keys are exempted because function keys have no shifted value and
   // the Nyxboard remote uses keys like Shift-F3 for some buttons.
   if (modifiers == CKey::MODIFIER_SHIFT)
-    if ((unicode < 'A' || unicode > 'Z') && (unicode < 'a' || unicode > 'z') && (vkey < XBMCVK_F1 || vkey > XBMCVK_F24))
+    if ((unicode < 'A' || unicode > 'Z') && (unicode < 'a' || unicode > 'z') &&
+        (vkey < XBMCVK_F1 || vkey > XBMCVK_F24))
       modifiers = 0;
 
   // Create and return a CKey
@@ -202,13 +209,14 @@ void CKeyboardStat::ProcessKeyUp(void)
 // The KeyID includes the flags for ctrl, alt etc
 
 std::string CKeyboardStat::GetKeyName(int KeyID)
-{ int keyid;
+{
+  int keyid;
   std::string keyname;
   XBMCKEYTABLE keytable;
 
   keyname.clear();
 
-// Get modifiers
+  // Get modifiers
 
   if (KeyID & CKey::MODIFIER_CTRL)
     keyname.append("ctrl-");
@@ -223,7 +231,7 @@ std::string CKeyboardStat::GetKeyName(int KeyID)
   if (KeyID & CKey::MODIFIER_LONG)
     keyname.append("long-");
 
-// Now get the key name
+  // Now get the key name
 
   keyid = KeyID & 0xFF;
   bool VKeyFound = KeyTableLookupVKeyName(keyid, &keytable);
@@ -238,10 +246,8 @@ std::string CKeyboardStat::GetKeyName(int KeyID)
   // map xml
   if (VKeyFound || keyid > 255)
     keyname += StringUtils::Format(" (0x%02x)", KeyID);
-  else// obc keys are 255 -rawid
+  else // obc keys are 255 -rawid
     keyname += StringUtils::Format(" (0x%02x, obc%i)", KeyID, 255 - KeyID);
 
   return keyname;
 }
-
-
diff --git a/xbmc/input/KeyboardStat.h b/xbmc/input/KeyboardStat.h
index 5e575d50a78f..8eed0b2d25cf 100644
--- a/xbmc/input/KeyboardStat.h
+++ b/xbmc/input/KeyboardStat.h
@@ -13,14 +13,16 @@
 //
 // Description: Adds features like international keyboard layout mapping on top of the
 // platform specific low level keyboard classes.
-// Here it must be done only once. Within the other mentioned classes it would have to be done several times.
+// Here it must be done only once. Within the other mentioned classes it would have to be done
+// several times.
 //
-// Keyboards always deliver printable characters, logical keys for functional behaviour, modifiers ... alongside
-// Based on the same hardware with the same scancodes (also alongside) but delivered with different labels to customers
-// the software must solve the mapping to the real labels. This is done here.
-// The mapping must be specified by an xml configuration that should be able to access everything available,
-// but this allows for double/redundant or ambiguous mapping definition, e.g.
-// ASCII/unicode could be derived from scancodes, virtual keys, modifiers and/or other ASCII/unicode.
+// Keyboards always deliver printable characters, logical keys for functional behaviour, modifiers
+// ... alongside Based on the same hardware with the same scancodes (also alongside) but delivered
+// with different labels to customers the software must solve the mapping to the real labels. This
+// is done here. The mapping must be specified by an xml configuration that should be able to access
+// everything available, but this allows for double/redundant or ambiguous mapping definition, e.g.
+// ASCII/unicode could be derived from scancodes, virtual keys, modifiers and/or other
+// ASCII/unicode.
 
 #include "input/Key.h"
 #include "input/XBMC_keyboard.h"
@@ -43,9 +45,8 @@ class CKeyboardStat
   std::string GetKeyName(int KeyID);
 
 private:
-  static bool LookupSymAndUnicodePeripherals(XBMC_keysym &keysym, uint8_t *key, char *unicode);
+  static bool LookupSymAndUnicodePeripherals(XBMC_keysym& keysym, uint8_t* key, char* unicode);
 
   XBMC_keysym m_lastKeysym;
   unsigned int m_lastKeyTime;
 };
-
diff --git a/xbmc/input/KeyboardTranslator.cpp b/xbmc/input/KeyboardTranslator.cpp
index 78996c79b9db..074be43aa3b8 100644
--- a/xbmc/input/KeyboardTranslator.cpp
+++ b/xbmc/input/KeyboardTranslator.cpp
@@ -17,10 +17,10 @@
 #include <string>
 #include <vector>
 
-uint32_t CKeyboardTranslator::TranslateButton(const TiXmlElement *pButton)
+uint32_t CKeyboardTranslator::TranslateButton(const TiXmlElement* pButton)
 {
   uint32_t button_id = 0;
-  const char *szButton = pButton->Value();
+  const char* szButton = pButton->Value();
 
   if (szButton == nullptr)
     return 0;
@@ -31,8 +31,8 @@ uint32_t CKeyboardTranslator::TranslateButton(const TiXmlElement *pButton)
     std::string strID;
     if (pButton->QueryValueAttribute("id", &strID) == TIXML_SUCCESS)
     {
-      const char *str = strID.c_str();
-      char *endptr;
+      const char* str = strID.c_str();
+      char* endptr;
       long int id = strtol(str, &endptr, 0);
       if (endptr - str != (int)strlen(str) || id <= 0 || id > 0x00FFFFFF)
         CLog::Log(LOGDEBUG, "%s - invalid key id %s", __FUNCTION__, strID.c_str());
@@ -69,14 +69,15 @@ uint32_t CKeyboardTranslator::TranslateButton(const TiXmlElement *pButton)
       else if (substr == "longpress")
         button_id |= CKey::MODIFIER_LONG;
       else
-        CLog::Log(LOGERROR, "Keyboard Translator: Unknown key modifier %s in %s", substr.c_str(), strMod.c_str());
+        CLog::Log(LOGERROR, "Keyboard Translator: Unknown key modifier %s in %s", substr.c_str(),
+                  strMod.c_str());
     }
   }
 
   return button_id;
 }
 
-uint32_t CKeyboardTranslator::TranslateString(const std::string &szButton)
+uint32_t CKeyboardTranslator::TranslateString(const std::string& szButton)
 {
   uint32_t buttonCode = 0;
   XBMCKEYTABLE keytable;
diff --git a/xbmc/input/KeyboardTranslator.h b/xbmc/input/KeyboardTranslator.h
index 2499ed8aadb2..7432037e88e0 100644
--- a/xbmc/input/KeyboardTranslator.h
+++ b/xbmc/input/KeyboardTranslator.h
@@ -16,6 +16,6 @@ class TiXmlElement;
 class CKeyboardTranslator
 {
 public:
-  static uint32_t TranslateButton(const TiXmlElement *pButton);
-  static uint32_t TranslateString(const std::string &szButton);
+  static uint32_t TranslateButton(const TiXmlElement* pButton);
+  static uint32_t TranslateString(const std::string& szButton);
 };
diff --git a/xbmc/input/Keymap.cpp b/xbmc/input/Keymap.cpp
index 0bfc9829d346..a2b431d0866e 100644
--- a/xbmc/input/Keymap.cpp
+++ b/xbmc/input/Keymap.cpp
@@ -12,9 +12,8 @@
 
 using namespace KODI;
 
-CKeymap::CKeymap(std::shared_ptr<const IWindowKeymap> keymap, const IKeymapEnvironment *environment) :
-  m_keymap(std::move(keymap)),
-  m_environment(environment)
+CKeymap::CKeymap(std::shared_ptr<const IWindowKeymap> keymap, const IKeymapEnvironment* environment)
+  : m_keymap(std::move(keymap)), m_environment(environment)
 {
 }
 
@@ -23,24 +22,24 @@ std::string CKeymap::ControllerID() const
   return m_keymap->ControllerID();
 }
 
-const JOYSTICK::KeymapActionGroup &CKeymap::GetActions(const std::string& keyName) const
+const JOYSTICK::KeymapActionGroup& CKeymap::GetActions(const std::string& keyName) const
 {
   const int windowId = m_environment->GetWindowID();
-  const auto &actions = m_keymap->GetActions(windowId, keyName);
+  const auto& actions = m_keymap->GetActions(windowId, keyName);
   if (!actions.actions.empty())
     return actions;
 
   const int fallbackWindowId = m_environment->GetFallthrough(windowId);
   if (fallbackWindowId >= 0)
   {
-    const auto &fallbackActions = m_keymap->GetActions(fallbackWindowId, keyName);
+    const auto& fallbackActions = m_keymap->GetActions(fallbackWindowId, keyName);
     if (!fallbackActions.actions.empty())
       return fallbackActions;
   }
 
   if (m_environment->UseGlobalFallthrough())
   {
-    const auto &globalActions = m_keymap->GetActions(-1, keyName);
+    const auto& globalActions = m_keymap->GetActions(-1, keyName);
     if (!globalActions.actions.empty())
       return globalActions;
   }
diff --git a/xbmc/input/Keymap.h b/xbmc/input/Keymap.h
index 11f997d20367..822ed67d3d94 100644
--- a/xbmc/input/Keymap.h
+++ b/xbmc/input/Keymap.h
@@ -17,15 +17,15 @@ class IKeymapEnvironment;
 class CKeymap : public IKeymap
 {
 public:
-  CKeymap(std::shared_ptr<const IWindowKeymap> keymap, const IKeymapEnvironment *environment);
+  CKeymap(std::shared_ptr<const IWindowKeymap> keymap, const IKeymapEnvironment* environment);
 
   // implementation of IKeymap
   std::string ControllerID() const override;
   const IKeymapEnvironment* Environment() const override { return m_environment; }
-  const KODI::JOYSTICK::KeymapActionGroup &GetActions(const std::string& keyName) const override;
+  const KODI::JOYSTICK::KeymapActionGroup& GetActions(const std::string& keyName) const override;
 
 private:
   // Construction parameters
   const std::shared_ptr<const IWindowKeymap> m_keymap;
-  const IKeymapEnvironment *const m_environment;
+  const IKeymapEnvironment* const m_environment;
 };
diff --git a/xbmc/input/TouchTranslator.cpp b/xbmc/input/TouchTranslator.cpp
index 3a3e5dd74ac4..4ba722ec284b 100644
--- a/xbmc/input/TouchTranslator.cpp
+++ b/xbmc/input/TouchTranslator.cpp
@@ -20,22 +20,20 @@
 using ActionName = std::string;
 using TouchCommandID = unsigned int;
 
-#define TOUCH_COMMAND_NONE  0
-
-static const std::map<ActionName, TouchCommandID> TouchCommands =
-{
-    { "tap"                      , ACTION_TOUCH_TAP },
-    { "longpress"                , ACTION_TOUCH_LONGPRESS },
-    { "pan"                      , ACTION_GESTURE_PAN },
-    { "zoom"                     , ACTION_GESTURE_ZOOM },
-    { "rotate"                   , ACTION_GESTURE_ROTATE },
-    { "swipeleft"                , ACTION_GESTURE_SWIPE_LEFT },
-    { "swiperight"               , ACTION_GESTURE_SWIPE_RIGHT },
-    { "swipeup"                  , ACTION_GESTURE_SWIPE_UP },
-    { "swipedown"                , ACTION_GESTURE_SWIPE_DOWN }
-};
-
-void CTouchTranslator::MapActions(int windowID, const TiXmlNode *pTouch)
+#define TOUCH_COMMAND_NONE 0
+
+static const std::map<ActionName, TouchCommandID> TouchCommands = {
+    {"tap", ACTION_TOUCH_TAP},
+    {"longpress", ACTION_TOUCH_LONGPRESS},
+    {"pan", ACTION_GESTURE_PAN},
+    {"zoom", ACTION_GESTURE_ZOOM},
+    {"rotate", ACTION_GESTURE_ROTATE},
+    {"swipeleft", ACTION_GESTURE_SWIPE_LEFT},
+    {"swiperight", ACTION_GESTURE_SWIPE_RIGHT},
+    {"swipeup", ACTION_GESTURE_SWIPE_UP},
+    {"swipedown", ACTION_GESTURE_SWIPE_DOWN}};
+
+void CTouchTranslator::MapActions(int windowID, const TiXmlNode* pTouch)
 {
   if (pTouch == nullptr)
     return;
@@ -52,11 +50,11 @@ void CTouchTranslator::MapActions(int windowID, const TiXmlNode *pTouch)
     m_touchMap.erase(it);
   }
 
-  const TiXmlElement *pTouchElem = pTouch->ToElement();
+  const TiXmlElement* pTouchElem = pTouch->ToElement();
   if (pTouchElem == nullptr)
     return;
 
-  const TiXmlElement *pButton = pTouchElem->FirstChildElement();
+  const TiXmlElement* pButton = pTouchElem->FirstChildElement();
   while (pButton != nullptr)
   {
     CTouchAction action;
@@ -85,7 +83,8 @@ void CTouchTranslator::Clear()
   m_touchMap.clear();
 }
 
-bool CTouchTranslator::TranslateTouchAction(int window, int touchAction, int touchPointers, int &action, std::string &actionString)
+bool CTouchTranslator::TranslateTouchAction(
+    int window, int touchAction, int touchPointers, int& action, std::string& actionString)
 {
   if (touchAction < 0)
     return false;
@@ -109,7 +108,11 @@ bool CTouchTranslator::TranslateTouchAction(int window, int touchAction, int tou
   return actionId != ACTION_NONE;
 }
 
-bool CTouchTranslator::TranslateAction(int window, unsigned int touchCommand, int touchPointers, unsigned int &actionId, std::string &actionString)
+bool CTouchTranslator::TranslateAction(int window,
+                                       unsigned int touchCommand,
+                                       int touchPointers,
+                                       unsigned int& actionId,
+                                       std::string& actionString)
 {
   unsigned int touchActionKey = GetTouchActionKey(touchCommand, touchPointers);
 
@@ -118,7 +121,9 @@ bool CTouchTranslator::TranslateAction(int window, unsigned int touchCommand, in
   return actionId != ACTION_NONE;
 }
 
-unsigned int CTouchTranslator::GetActionID(WindowID window, TouchActionKey touchActionKey, std::string &actionString)
+unsigned int CTouchTranslator::GetActionID(WindowID window,
+                                           TouchActionKey touchActionKey,
+                                           std::string& actionString)
 {
   auto windowIt = m_touchMap.find(window);
   if (windowIt == m_touchMap.end())
@@ -132,13 +137,14 @@ unsigned int CTouchTranslator::GetActionID(WindowID window, TouchActionKey touch
   return touchIt->second.actionId;
 }
 
-unsigned int CTouchTranslator::TranslateTouchCommand(const TiXmlElement *pButton, CTouchAction &action)
+unsigned int CTouchTranslator::TranslateTouchCommand(const TiXmlElement* pButton,
+                                                     CTouchAction& action)
 {
-  const char *szButton = pButton->Value();
+  const char* szButton = pButton->Value();
   if (szButton == nullptr || pButton->FirstChild() == nullptr)
     return ACTION_NONE;
 
-  const char *szAction = pButton->FirstChild()->Value();
+  const char* szAction = pButton->FirstChild()->Value();
   if (szAction == nullptr)
     return ACTION_NONE;
 
@@ -146,7 +152,7 @@ unsigned int CTouchTranslator::TranslateTouchCommand(const TiXmlElement *pButton
   StringUtils::ToLower(strTouchCommand);
 
   // Handle direction
-  const char *attrVal = pButton->Attribute("direction");
+  const char* attrVal = pButton->Attribute("direction");
   if (attrVal != nullptr)
     strTouchCommand += attrVal;
 
@@ -171,7 +177,8 @@ unsigned int CTouchTranslator::TranslateTouchCommand(const TiXmlElement *pButton
   unsigned int touchActionKey = GetTouchActionKey(touchCommandId, pointers);
 
   action.strAction = szAction;
-  if (!CActionTranslator::TranslateString(action.strAction, action.actionId) || action.actionId == ACTION_NONE)
+  if (!CActionTranslator::TranslateString(action.strAction, action.actionId) ||
+      action.actionId == ACTION_NONE)
     return ACTION_NONE;
 
   return touchActionKey;
diff --git a/xbmc/input/TouchTranslator.h b/xbmc/input/TouchTranslator.h
index 3926e9632dc9..989857edcd26 100644
--- a/xbmc/input/TouchTranslator.h
+++ b/xbmc/input/TouchTranslator.h
@@ -24,10 +24,15 @@ class CTouchTranslator : public IButtonMapper
   void MapActions(int windowID, const TiXmlNode* bDevice) override;
   void Clear() override;
 
-  bool TranslateTouchAction(int window, int touchAction, int touchPointers, int &action, std::string &actionString);
+  bool TranslateTouchAction(
+      int window, int touchAction, int touchPointers, int& action, std::string& actionString);
 
 private:
-  bool TranslateAction(int window, unsigned int touchCommand, int touchPointers, unsigned int &actionId, std::string &actionString);
+  bool TranslateAction(int window,
+                       unsigned int touchCommand,
+                       int touchPointers,
+                       unsigned int& actionId,
+                       std::string& actionString);
 
   struct CTouchAction
   {
@@ -41,9 +46,11 @@ class CTouchTranslator : public IButtonMapper
   using WindowID = int;
   using TouchMap = std::map<WindowID, TouchActionMap>;
 
-  unsigned int GetActionID(WindowID window, TouchActionKey touchActionKey, std::string &actionString);
+  unsigned int GetActionID(WindowID window,
+                           TouchActionKey touchActionKey,
+                           std::string& actionString);
 
-  static unsigned int TranslateTouchCommand(const TiXmlElement *pButton, CTouchAction &action);
+  static unsigned int TranslateTouchCommand(const TiXmlElement* pButton, CTouchAction& action);
 
   static unsigned int GetTouchActionKey(unsigned int touchCommandId, int touchPointers);
 
diff --git a/xbmc/input/WindowKeymap.cpp b/xbmc/input/WindowKeymap.cpp
index 3250a5eb68b9..4fd2ae027254 100644
--- a/xbmc/input/WindowKeymap.cpp
+++ b/xbmc/input/WindowKeymap.cpp
@@ -12,14 +12,15 @@
 
 using namespace KODI;
 
-CWindowKeymap::CWindowKeymap(const std::string &controllerId) :
-  m_controllerId(controllerId)
+CWindowKeymap::CWindowKeymap(const std::string& controllerId) : m_controllerId(controllerId)
 {
 }
 
-void CWindowKeymap::MapAction(int windowId, const std::string &keyName, JOYSTICK::KeymapAction action)
+void CWindowKeymap::MapAction(int windowId,
+                              const std::string& keyName,
+                              JOYSTICK::KeymapAction action)
 {
-  auto &actionGroup = m_windowKeymap[windowId][keyName];
+  auto& actionGroup = m_windowKeymap[windowId][keyName];
 
   actionGroup.windowId = windowId;
   auto it = actionGroup.actions.begin();
@@ -33,7 +34,8 @@ void CWindowKeymap::MapAction(int windowId, const std::string &keyName, JOYSTICK
   actionGroup.actions.insert(std::move(action));
 }
 
-const JOYSTICK::KeymapActionGroup &CWindowKeymap::GetActions(int windowId, const std::string& keyName) const
+const JOYSTICK::KeymapActionGroup& CWindowKeymap::GetActions(int windowId,
+                                                             const std::string& keyName) const
 {
   // handle virtual windows
   windowId = CWindowTranslator::GetVirtualWindow(windowId);
diff --git a/xbmc/input/WindowKeymap.h b/xbmc/input/WindowKeymap.h
index 6a105036b463..f6c0612ba59c 100644
--- a/xbmc/input/WindowKeymap.h
+++ b/xbmc/input/WindowKeymap.h
@@ -17,12 +17,15 @@
 class CWindowKeymap : public IWindowKeymap
 {
 public:
-  explicit CWindowKeymap(const std::string &controllerId);
+  explicit CWindowKeymap(const std::string& controllerId);
 
   // implementation of IWindowKeymap
   std::string ControllerID() const override { return m_controllerId; }
-  void MapAction(int windowId, const std::string& keyName, KODI::JOYSTICK::KeymapAction action) override;
-  const KODI::JOYSTICK::KeymapActionGroup& GetActions(int windowId, const std::string& keyName) const override;
+  void MapAction(int windowId,
+                 const std::string& keyName,
+                 KODI::JOYSTICK::KeymapAction action) override;
+  const KODI::JOYSTICK::KeymapActionGroup& GetActions(int windowId,
+                                                      const std::string& keyName) const override;
 
 private:
   // Construction parameter
diff --git a/xbmc/input/WindowTranslator.cpp b/xbmc/input/WindowTranslator.cpp
index b035bd2f834e..564582371a64 100644
--- a/xbmc/input/WindowTranslator.cpp
+++ b/xbmc/input/WindowTranslator.cpp
@@ -20,135 +20,138 @@
 #include <cstring>
 #include <stdlib.h>
 
-const CWindowTranslator::WindowMapByName CWindowTranslator::WindowMappingByName =
-{
-    { "home"                     , WINDOW_HOME },
-    { "programs"                 , WINDOW_PROGRAMS },
-    { "pictures"                 , WINDOW_PICTURES },
-    { "filemanager"              , WINDOW_FILES },
-    { "settings"                 , WINDOW_SETTINGS_MENU },
-    { "music"                    , WINDOW_MUSIC_NAV },
-    { "videos"                   , WINDOW_VIDEO_NAV },
-    { "tvchannels"               , WINDOW_TV_CHANNELS },
-    { "tvrecordings"             , WINDOW_TV_RECORDINGS },
-    { "tvguide"                  , WINDOW_TV_GUIDE },
-    { "tvtimers"                 , WINDOW_TV_TIMERS },
-    { "tvsearch"                 , WINDOW_TV_SEARCH },
-    { "radiochannels"            , WINDOW_RADIO_CHANNELS },
-    { "radiorecordings"          , WINDOW_RADIO_RECORDINGS },
-    { "radioguide"               , WINDOW_RADIO_GUIDE },
-    { "radiotimers"              , WINDOW_RADIO_TIMERS },
-    { "radiosearch"              , WINDOW_RADIO_SEARCH },
-    { "gamecontrollers"          , WINDOW_DIALOG_GAME_CONTROLLERS },
-    { "games"                    , WINDOW_GAMES },
-    { "pvrguidecontrols"         , WINDOW_DIALOG_PVR_GUIDE_CONTROLS },
-    { "pvrguideinfo"             , WINDOW_DIALOG_PVR_GUIDE_INFO },
-    { "pvrrecordinginfo"         , WINDOW_DIALOG_PVR_RECORDING_INFO },
-    { "pvrradiordsinfo"          , WINDOW_DIALOG_PVR_RADIO_RDS_INFO },
-    { "pvrtimersetting"          , WINDOW_DIALOG_PVR_TIMER_SETTING },
-    { "pvrgroupmanager"          , WINDOW_DIALOG_PVR_GROUP_MANAGER },
-    { "pvrchannelmanager"        , WINDOW_DIALOG_PVR_CHANNEL_MANAGER },
-    { "pvrguidesearch"           , WINDOW_DIALOG_PVR_GUIDE_SEARCH },
-    { "pvrchannelscan"           , WINDOW_DIALOG_PVR_CHANNEL_SCAN },
-    { "pvrupdateprogress"        , WINDOW_DIALOG_PVR_UPDATE_PROGRESS },
-    { "pvrosdchannels"           , WINDOW_DIALOG_PVR_OSD_CHANNELS },
-    { "pvrchannelguide"          , WINDOW_DIALOG_PVR_CHANNEL_GUIDE },
-    { "pvrosdguide"              , WINDOW_DIALOG_PVR_CHANNEL_GUIDE }, // backward compatibility to v17
-    { "pvrosdteletext"           , WINDOW_DIALOG_OSD_TELETEXT },
-    { "systeminfo"               , WINDOW_SYSTEM_INFORMATION },
-    { "screencalibration"        , WINDOW_SCREEN_CALIBRATION },
-    { "systemsettings"           , WINDOW_SETTINGS_SYSTEM },
-    { "servicesettings"          , WINDOW_SETTINGS_SERVICE },
-    { "pvrsettings"              , WINDOW_SETTINGS_MYPVR },
-    { "playersettings"           , WINDOW_SETTINGS_PLAYER },
-    { "mediasettings"            , WINDOW_SETTINGS_MEDIA },
-    { "interfacesettings"        , WINDOW_SETTINGS_INTERFACE },
-    { "appearancesettings"       , WINDOW_SETTINGS_INTERFACE },	// backward compatibility to v16
-    { "gamesettings"             , WINDOW_SETTINGS_MYGAMES },
-    { "videoplaylist"            , WINDOW_VIDEO_PLAYLIST },
-    { "loginscreen"              , WINDOW_LOGIN_SCREEN },
-    { "profiles"                 , WINDOW_SETTINGS_PROFILES },
-    { "skinsettings"             , WINDOW_SKIN_SETTINGS },
-    { "addonbrowser"             , WINDOW_ADDON_BROWSER },
-    { "yesnodialog"              , WINDOW_DIALOG_YES_NO },
-    { "progressdialog"           , WINDOW_DIALOG_PROGRESS },
-    { "virtualkeyboard"          , WINDOW_DIALOG_KEYBOARD },
-    { "volumebar"                , WINDOW_DIALOG_VOLUME_BAR },
-    { "submenu"                  , WINDOW_DIALOG_SUB_MENU },
-    { "favourites"               , WINDOW_DIALOG_FAVOURITES },
-    { "contextmenu"              , WINDOW_DIALOG_CONTEXT_MENU },
-    { "notification"             , WINDOW_DIALOG_KAI_TOAST },
-    { "numericinput"             , WINDOW_DIALOG_NUMERIC },
-    { "gamepadinput"             , WINDOW_DIALOG_GAMEPAD },
-    { "shutdownmenu"             , WINDOW_DIALOG_BUTTON_MENU },
-    { "playercontrols"           , WINDOW_DIALOG_PLAYER_CONTROLS },
-    { "playerprocessinfo"        , WINDOW_DIALOG_PLAYER_PROCESS_INFO },
-    { "seekbar"                  , WINDOW_DIALOG_SEEK_BAR },
-    { "musicosd"                 , WINDOW_DIALOG_MUSIC_OSD },
-    { "addonsettings"            , WINDOW_DIALOG_ADDON_SETTINGS },
-    { "visualisationpresetlist"  , WINDOW_DIALOG_VIS_PRESET_LIST },
-    { "osdcmssettings"           , WINDOW_DIALOG_CMS_OSD_SETTINGS },
-    { "osdvideosettings"         , WINDOW_DIALOG_VIDEO_OSD_SETTINGS },
-    { "osdaudiosettings"         , WINDOW_DIALOG_AUDIO_OSD_SETTINGS },
-    { "osdsubtitlesettings"      , WINDOW_DIALOG_SUBTITLE_OSD_SETTINGS },
-    { "videobookmarks"           , WINDOW_DIALOG_VIDEO_BOOKMARKS },
-    { "filebrowser"              , WINDOW_DIALOG_FILE_BROWSER },
-    { "networksetup"             , WINDOW_DIALOG_NETWORK_SETUP },
-    { "mediasource"              , WINDOW_DIALOG_MEDIA_SOURCE },
-    { "profilesettings"          , WINDOW_DIALOG_PROFILE_SETTINGS },
-    { "locksettings"             , WINDOW_DIALOG_LOCK_SETTINGS },
-    { "contentsettings"          , WINDOW_DIALOG_CONTENT_SETTINGS },
-    { "libexportsettings"        , WINDOW_DIALOG_LIBEXPORT_SETTINGS },
-    { "songinformation"          , WINDOW_DIALOG_SONG_INFO },
-    { "smartplaylisteditor"      , WINDOW_DIALOG_SMART_PLAYLIST_EDITOR },
-    { "smartplaylistrule"        , WINDOW_DIALOG_SMART_PLAYLIST_RULE },
-    { "busydialog"               , WINDOW_DIALOG_BUSY },
-    { "busydialognocancel"       , WINDOW_DIALOG_BUSY_NOCANCEL },
-    { "pictureinfo"              , WINDOW_DIALOG_PICTURE_INFO },
-    { "fullscreeninfo"           , WINDOW_DIALOG_FULLSCREEN_INFO },
-    { "sliderdialog"             , WINDOW_DIALOG_SLIDER },
-    { "addoninformation"         , WINDOW_DIALOG_ADDON_INFO },
-    { "subtitlesearch"           , WINDOW_DIALOG_SUBTITLES },
-    { "musicplaylist"            , WINDOW_MUSIC_PLAYLIST },
-    { "musicplaylisteditor"      , WINDOW_MUSIC_PLAYLIST_EDITOR },
-    { "infoprovidersettings"     , WINDOW_DIALOG_INFOPROVIDER_SETTINGS },
-    { "teletext"                 , WINDOW_DIALOG_OSD_TELETEXT },
-    { "selectdialog"             , WINDOW_DIALOG_SELECT },
-    { "musicinformation"         , WINDOW_DIALOG_MUSIC_INFO },
-    { "okdialog"                 , WINDOW_DIALOG_OK },
-    { "movieinformation"         , WINDOW_DIALOG_VIDEO_INFO },
-    { "textviewer"               , WINDOW_DIALOG_TEXT_VIEWER },
-    { "fullscreenvideo"          , WINDOW_FULLSCREEN_VIDEO },
-    { "fullscreenlivetv"         , WINDOW_FULLSCREEN_LIVETV }, // virtual window for fullscreen radio, uses WINDOW_FULLSCREEN_VIDEO as fallback
-    { "fullscreenlivetvpreview"  , WINDOW_FULLSCREEN_LIVETV_PREVIEW }, // Live TV channel preview
-    { "fullscreenlivetvinput"    , WINDOW_FULLSCREEN_LIVETV_INPUT }, // Livr TV direct channel number input
-    { "fullscreenradio"          , WINDOW_FULLSCREEN_RADIO }, // virtual window for fullscreen radio, uses WINDOW_VISUALISATION as fallback
-    { "fullscreenradiopreview"   , WINDOW_FULLSCREEN_RADIO_PREVIEW }, // PVR Radio channel preview
-    { "fullscreenradioinput"     , WINDOW_FULLSCREEN_RADIO_INPUT }, // PVR radio direct channel number input
-    { "fullscreengame"           , WINDOW_FULLSCREEN_GAME },
-    { "visualisation"            , WINDOW_VISUALISATION },
-    { "slideshow"                , WINDOW_SLIDESHOW },
-    { "weather"                  , WINDOW_WEATHER },
-    { "screensaver"              , WINDOW_SCREENSAVER },
-    { "videoosd"                 , WINDOW_DIALOG_VIDEO_OSD },
-    { "videomenu"                , WINDOW_VIDEO_MENU },
-    { "videotimeseek"            , WINDOW_VIDEO_TIME_SEEK },
-    { "splash"                   , WINDOW_SPLASH },
-    { "startwindow"              , WINDOW_START },
-    { "startup"                  , WINDOW_STARTUP_ANIM },
-    { "peripheralsettings"       , WINDOW_DIALOG_PERIPHERAL_SETTINGS },
-    { "extendedprogressdialog"   , WINDOW_DIALOG_EXT_PROGRESS },
-    { "mediafilter"              , WINDOW_DIALOG_MEDIA_FILTER },
-    { "addon"                    , WINDOW_ADDON_START },
-    { "eventlog"                 , WINDOW_EVENT_LOG},
-    { "tvtimerrules"             , WINDOW_TV_TIMER_RULES},
-    { "radiotimerrules"          , WINDOW_RADIO_TIMER_RULES},
-    { "gameosd"                  , WINDOW_DIALOG_GAME_OSD },
-    { "gamevideofilter"          , WINDOW_DIALOG_GAME_VIDEO_FILTER },
-    { "gamestretchmode"          , WINDOW_DIALOG_GAME_STRETCH_MODE },
-    { "gamevolume"               , WINDOW_DIALOG_GAME_VOLUME },
-    { "gameadvancedsettings"     , WINDOW_DIALOG_GAME_ADVANCED_SETTINGS },
-    { "gamevideorotation"        , WINDOW_DIALOG_GAME_VIDEO_ROTATION },
+const CWindowTranslator::WindowMapByName CWindowTranslator::WindowMappingByName = {
+    {"home", WINDOW_HOME},
+    {"programs", WINDOW_PROGRAMS},
+    {"pictures", WINDOW_PICTURES},
+    {"filemanager", WINDOW_FILES},
+    {"settings", WINDOW_SETTINGS_MENU},
+    {"music", WINDOW_MUSIC_NAV},
+    {"videos", WINDOW_VIDEO_NAV},
+    {"tvchannels", WINDOW_TV_CHANNELS},
+    {"tvrecordings", WINDOW_TV_RECORDINGS},
+    {"tvguide", WINDOW_TV_GUIDE},
+    {"tvtimers", WINDOW_TV_TIMERS},
+    {"tvsearch", WINDOW_TV_SEARCH},
+    {"radiochannels", WINDOW_RADIO_CHANNELS},
+    {"radiorecordings", WINDOW_RADIO_RECORDINGS},
+    {"radioguide", WINDOW_RADIO_GUIDE},
+    {"radiotimers", WINDOW_RADIO_TIMERS},
+    {"radiosearch", WINDOW_RADIO_SEARCH},
+    {"gamecontrollers", WINDOW_DIALOG_GAME_CONTROLLERS},
+    {"games", WINDOW_GAMES},
+    {"pvrguidecontrols", WINDOW_DIALOG_PVR_GUIDE_CONTROLS},
+    {"pvrguideinfo", WINDOW_DIALOG_PVR_GUIDE_INFO},
+    {"pvrrecordinginfo", WINDOW_DIALOG_PVR_RECORDING_INFO},
+    {"pvrradiordsinfo", WINDOW_DIALOG_PVR_RADIO_RDS_INFO},
+    {"pvrtimersetting", WINDOW_DIALOG_PVR_TIMER_SETTING},
+    {"pvrgroupmanager", WINDOW_DIALOG_PVR_GROUP_MANAGER},
+    {"pvrchannelmanager", WINDOW_DIALOG_PVR_CHANNEL_MANAGER},
+    {"pvrguidesearch", WINDOW_DIALOG_PVR_GUIDE_SEARCH},
+    {"pvrchannelscan", WINDOW_DIALOG_PVR_CHANNEL_SCAN},
+    {"pvrupdateprogress", WINDOW_DIALOG_PVR_UPDATE_PROGRESS},
+    {"pvrosdchannels", WINDOW_DIALOG_PVR_OSD_CHANNELS},
+    {"pvrchannelguide", WINDOW_DIALOG_PVR_CHANNEL_GUIDE},
+    {"pvrosdguide", WINDOW_DIALOG_PVR_CHANNEL_GUIDE}, // backward compatibility to v17
+    {"pvrosdteletext", WINDOW_DIALOG_OSD_TELETEXT},
+    {"systeminfo", WINDOW_SYSTEM_INFORMATION},
+    {"screencalibration", WINDOW_SCREEN_CALIBRATION},
+    {"systemsettings", WINDOW_SETTINGS_SYSTEM},
+    {"servicesettings", WINDOW_SETTINGS_SERVICE},
+    {"pvrsettings", WINDOW_SETTINGS_MYPVR},
+    {"playersettings", WINDOW_SETTINGS_PLAYER},
+    {"mediasettings", WINDOW_SETTINGS_MEDIA},
+    {"interfacesettings", WINDOW_SETTINGS_INTERFACE},
+    {"appearancesettings", WINDOW_SETTINGS_INTERFACE}, // backward compatibility to v16
+    {"gamesettings", WINDOW_SETTINGS_MYGAMES},
+    {"videoplaylist", WINDOW_VIDEO_PLAYLIST},
+    {"loginscreen", WINDOW_LOGIN_SCREEN},
+    {"profiles", WINDOW_SETTINGS_PROFILES},
+    {"skinsettings", WINDOW_SKIN_SETTINGS},
+    {"addonbrowser", WINDOW_ADDON_BROWSER},
+    {"yesnodialog", WINDOW_DIALOG_YES_NO},
+    {"progressdialog", WINDOW_DIALOG_PROGRESS},
+    {"virtualkeyboard", WINDOW_DIALOG_KEYBOARD},
+    {"volumebar", WINDOW_DIALOG_VOLUME_BAR},
+    {"submenu", WINDOW_DIALOG_SUB_MENU},
+    {"favourites", WINDOW_DIALOG_FAVOURITES},
+    {"contextmenu", WINDOW_DIALOG_CONTEXT_MENU},
+    {"notification", WINDOW_DIALOG_KAI_TOAST},
+    {"numericinput", WINDOW_DIALOG_NUMERIC},
+    {"gamepadinput", WINDOW_DIALOG_GAMEPAD},
+    {"shutdownmenu", WINDOW_DIALOG_BUTTON_MENU},
+    {"playercontrols", WINDOW_DIALOG_PLAYER_CONTROLS},
+    {"playerprocessinfo", WINDOW_DIALOG_PLAYER_PROCESS_INFO},
+    {"seekbar", WINDOW_DIALOG_SEEK_BAR},
+    {"musicosd", WINDOW_DIALOG_MUSIC_OSD},
+    {"addonsettings", WINDOW_DIALOG_ADDON_SETTINGS},
+    {"visualisationpresetlist", WINDOW_DIALOG_VIS_PRESET_LIST},
+    {"osdcmssettings", WINDOW_DIALOG_CMS_OSD_SETTINGS},
+    {"osdvideosettings", WINDOW_DIALOG_VIDEO_OSD_SETTINGS},
+    {"osdaudiosettings", WINDOW_DIALOG_AUDIO_OSD_SETTINGS},
+    {"osdsubtitlesettings", WINDOW_DIALOG_SUBTITLE_OSD_SETTINGS},
+    {"videobookmarks", WINDOW_DIALOG_VIDEO_BOOKMARKS},
+    {"filebrowser", WINDOW_DIALOG_FILE_BROWSER},
+    {"networksetup", WINDOW_DIALOG_NETWORK_SETUP},
+    {"mediasource", WINDOW_DIALOG_MEDIA_SOURCE},
+    {"profilesettings", WINDOW_DIALOG_PROFILE_SETTINGS},
+    {"locksettings", WINDOW_DIALOG_LOCK_SETTINGS},
+    {"contentsettings", WINDOW_DIALOG_CONTENT_SETTINGS},
+    {"libexportsettings", WINDOW_DIALOG_LIBEXPORT_SETTINGS},
+    {"songinformation", WINDOW_DIALOG_SONG_INFO},
+    {"smartplaylisteditor", WINDOW_DIALOG_SMART_PLAYLIST_EDITOR},
+    {"smartplaylistrule", WINDOW_DIALOG_SMART_PLAYLIST_RULE},
+    {"busydialog", WINDOW_DIALOG_BUSY},
+    {"busydialognocancel", WINDOW_DIALOG_BUSY_NOCANCEL},
+    {"pictureinfo", WINDOW_DIALOG_PICTURE_INFO},
+    {"fullscreeninfo", WINDOW_DIALOG_FULLSCREEN_INFO},
+    {"sliderdialog", WINDOW_DIALOG_SLIDER},
+    {"addoninformation", WINDOW_DIALOG_ADDON_INFO},
+    {"subtitlesearch", WINDOW_DIALOG_SUBTITLES},
+    {"musicplaylist", WINDOW_MUSIC_PLAYLIST},
+    {"musicplaylisteditor", WINDOW_MUSIC_PLAYLIST_EDITOR},
+    {"infoprovidersettings", WINDOW_DIALOG_INFOPROVIDER_SETTINGS},
+    {"teletext", WINDOW_DIALOG_OSD_TELETEXT},
+    {"selectdialog", WINDOW_DIALOG_SELECT},
+    {"musicinformation", WINDOW_DIALOG_MUSIC_INFO},
+    {"okdialog", WINDOW_DIALOG_OK},
+    {"movieinformation", WINDOW_DIALOG_VIDEO_INFO},
+    {"textviewer", WINDOW_DIALOG_TEXT_VIEWER},
+    {"fullscreenvideo", WINDOW_FULLSCREEN_VIDEO},
+    {"fullscreenlivetv", WINDOW_FULLSCREEN_LIVETV}, // virtual window for fullscreen radio, uses
+                                                    // WINDOW_FULLSCREEN_VIDEO as fallback
+    {"fullscreenlivetvpreview", WINDOW_FULLSCREEN_LIVETV_PREVIEW}, // Live TV channel preview
+    {"fullscreenlivetvinput",
+     WINDOW_FULLSCREEN_LIVETV_INPUT}, // Livr TV direct channel number input
+    {"fullscreenradio", WINDOW_FULLSCREEN_RADIO}, // virtual window for fullscreen radio, uses
+                                                  // WINDOW_VISUALISATION as fallback
+    {"fullscreenradiopreview", WINDOW_FULLSCREEN_RADIO_PREVIEW}, // PVR Radio channel preview
+    {"fullscreenradioinput",
+     WINDOW_FULLSCREEN_RADIO_INPUT}, // PVR radio direct channel number input
+    {"fullscreengame", WINDOW_FULLSCREEN_GAME},
+    {"visualisation", WINDOW_VISUALISATION},
+    {"slideshow", WINDOW_SLIDESHOW},
+    {"weather", WINDOW_WEATHER},
+    {"screensaver", WINDOW_SCREENSAVER},
+    {"videoosd", WINDOW_DIALOG_VIDEO_OSD},
+    {"videomenu", WINDOW_VIDEO_MENU},
+    {"videotimeseek", WINDOW_VIDEO_TIME_SEEK},
+    {"splash", WINDOW_SPLASH},
+    {"startwindow", WINDOW_START},
+    {"startup", WINDOW_STARTUP_ANIM},
+    {"peripheralsettings", WINDOW_DIALOG_PERIPHERAL_SETTINGS},
+    {"extendedprogressdialog", WINDOW_DIALOG_EXT_PROGRESS},
+    {"mediafilter", WINDOW_DIALOG_MEDIA_FILTER},
+    {"addon", WINDOW_ADDON_START},
+    {"eventlog", WINDOW_EVENT_LOG},
+    {"tvtimerrules", WINDOW_TV_TIMER_RULES},
+    {"radiotimerrules", WINDOW_RADIO_TIMER_RULES},
+    {"gameosd", WINDOW_DIALOG_GAME_OSD},
+    {"gamevideofilter", WINDOW_DIALOG_GAME_VIDEO_FILTER},
+    {"gamestretchmode", WINDOW_DIALOG_GAME_STRETCH_MODE},
+    {"gamevolume", WINDOW_DIALOG_GAME_VOLUME},
+    {"gameadvancedsettings", WINDOW_DIALOG_GAME_ADVANCED_SETTINGS},
+    {"gamevideorotation", WINDOW_DIALOG_GAME_VIDEO_ROTATION},
 };
 
 namespace
@@ -159,29 +162,30 @@ struct FallbackWindowMapping
   int target;
 };
 
-static const std::vector<FallbackWindowMapping> FallbackWindows =
-{
-    { WINDOW_FULLSCREEN_LIVETV,         WINDOW_FULLSCREEN_VIDEO },
-    { WINDOW_FULLSCREEN_LIVETV_INPUT,   WINDOW_FULLSCREEN_LIVETV },
-    { WINDOW_FULLSCREEN_LIVETV_PREVIEW, WINDOW_FULLSCREEN_LIVETV },
-    { WINDOW_FULLSCREEN_RADIO,          WINDOW_VISUALISATION },
-    { WINDOW_FULLSCREEN_RADIO_INPUT,    WINDOW_FULLSCREEN_RADIO },
-    { WINDOW_FULLSCREEN_RADIO_PREVIEW,  WINDOW_FULLSCREEN_RADIO },
+static const std::vector<FallbackWindowMapping> FallbackWindows = {
+    {WINDOW_FULLSCREEN_LIVETV, WINDOW_FULLSCREEN_VIDEO},
+    {WINDOW_FULLSCREEN_LIVETV_INPUT, WINDOW_FULLSCREEN_LIVETV},
+    {WINDOW_FULLSCREEN_LIVETV_PREVIEW, WINDOW_FULLSCREEN_LIVETV},
+    {WINDOW_FULLSCREEN_RADIO, WINDOW_VISUALISATION},
+    {WINDOW_FULLSCREEN_RADIO_INPUT, WINDOW_FULLSCREEN_RADIO},
+    {WINDOW_FULLSCREEN_RADIO_PREVIEW, WINDOW_FULLSCREEN_RADIO},
 };
 } // anonymous namespace
 
 
-bool CWindowTranslator::WindowNameCompare::operator()(const WindowMapItem &lhs, const WindowMapItem &rhs) const
+bool CWindowTranslator::WindowNameCompare::operator()(const WindowMapItem& lhs,
+                                                      const WindowMapItem& rhs) const
 {
   return std::strcmp(lhs.windowName, rhs.windowName) < 0;
 }
 
-bool CWindowTranslator::WindowIDCompare::operator()(const WindowMapItem &lhs, const WindowMapItem &rhs) const
+bool CWindowTranslator::WindowIDCompare::operator()(const WindowMapItem& lhs,
+                                                    const WindowMapItem& rhs) const
 {
   return lhs.windowId < rhs.windowId;
 }
 
-void CWindowTranslator::GetWindows(std::vector<std::string> &windowList)
+void CWindowTranslator::GetWindows(std::vector<std::string>& windowList)
 {
   windowList.clear();
   windowList.reserve(WindowMappingByName.size());
@@ -189,7 +193,7 @@ void CWindowTranslator::GetWindows(std::vector<std::string> &windowList)
     windowList.emplace_back(itMapping.windowName);
 }
 
-int CWindowTranslator::TranslateWindow(const std::string &window)
+int CWindowTranslator::TranslateWindow(const std::string& window)
 {
   std::string strWindow(window);
   if (strWindow.empty())
@@ -220,7 +224,7 @@ int CWindowTranslator::TranslateWindow(const std::string &window)
   }
 
   // Run through the window structure
-  auto it = WindowMappingByName.find(WindowMapItem{ strWindow.c_str() });
+  auto it = WindowMappingByName.find(WindowMapItem{strWindow.c_str()});
   if (it != WindowMappingByName.end())
     return it->windowId;
 
@@ -235,7 +239,7 @@ std::string CWindowTranslator::TranslateWindow(int windowId)
 
   windowId = GetVirtualWindow(windowId);
 
-  auto it = reverseWindowMapping.find(WindowMapItem{ "", windowId });
+  auto it = reverseWindowMapping.find(WindowMapItem{"", windowId});
   if (it != reverseWindowMapping.end())
     return it->windowName;
 
@@ -244,11 +248,9 @@ std::string CWindowTranslator::TranslateWindow(int windowId)
 
 int CWindowTranslator::GetFallbackWindow(int windowId)
 {
-  auto it = std::find_if(FallbackWindows.begin(), FallbackWindows.end(),
-    [windowId](const FallbackWindowMapping& mapping)
-    {
-      return mapping.origin == windowId;
-    });
+  auto it = std::find_if(
+      FallbackWindows.begin(), FallbackWindows.end(),
+      [windowId](const FallbackWindowMapping& mapping) { return mapping.origin == windowId; });
 
   if (it != FallbackWindows.end())
     return it->target;
@@ -279,7 +281,10 @@ int CWindowTranslator::GetVirtualWindow(int windowId)
     // special casing for Live TV
     else if (g_application.CurrentFileItem().HasPVRChannelInfoTag())
     {
-      if (CServiceBroker::GetPVRManager().GUIActions()->GetChannelNumberInputHandler().HasChannelNumber())
+      if (CServiceBroker::GetPVRManager()
+              .GUIActions()
+              ->GetChannelNumberInputHandler()
+              .HasChannelNumber())
         return WINDOW_FULLSCREEN_LIVETV_INPUT;
       else if (CServiceBroker::GetPVRManager().GUIActions()->GetChannelNavigator().IsPreview())
         return WINDOW_FULLSCREEN_LIVETV_PREVIEW;
@@ -295,7 +300,10 @@ int CWindowTranslator::GetVirtualWindow(int windowId)
     // special casing for PVR radio
     if (g_application.CurrentFileItem().HasPVRChannelInfoTag())
     {
-      if (CServiceBroker::GetPVRManager().GUIActions()->GetChannelNumberInputHandler().HasChannelNumber())
+      if (CServiceBroker::GetPVRManager()
+              .GUIActions()
+              ->GetChannelNumberInputHandler()
+              .HasChannelNumber())
         return WINDOW_FULLSCREEN_RADIO_INPUT;
       else if (CServiceBroker::GetPVRManager().GUIActions()->GetChannelNavigator().IsPreview())
         return WINDOW_FULLSCREEN_RADIO_PREVIEW;
diff --git a/xbmc/input/WindowTranslator.h b/xbmc/input/WindowTranslator.h
index 43b2f968891e..9d99c156fdfe 100644
--- a/xbmc/input/WindowTranslator.h
+++ b/xbmc/input/WindowTranslator.h
@@ -18,14 +18,14 @@ class CWindowTranslator
   /*!
    * \brief Get a list of all known window names
    */
-  static void GetWindows(std::vector<std::string> &windowList);
+  static void GetWindows(std::vector<std::string>& windowList);
 
   /*!
    * \brief Translate between a window name and its ID
    * \param window The name of the window
    * \return ID of the window, or WINDOW_INVALID if not found
    */
-  static int TranslateWindow(const std::string &window);
+  static int TranslateWindow(const std::string& window);
 
   /*!
    * \brief Translate between a window id and it's name
@@ -49,18 +49,18 @@ class CWindowTranslator
 private:
   struct WindowMapItem
   {
-    const char *windowName;
+    const char* windowName;
     int windowId;
   };
 
   struct WindowNameCompare
   {
-    bool operator()(const WindowMapItem &lhs, const WindowMapItem &rhs) const;
+    bool operator()(const WindowMapItem& lhs, const WindowMapItem& rhs) const;
   };
 
   struct WindowIDCompare
   {
-    bool operator()(const WindowMapItem &lhs, const WindowMapItem &rhs) const;
+    bool operator()(const WindowMapItem& lhs, const WindowMapItem& rhs) const;
   };
 
   using WindowMapByName = std::set<WindowMapItem, WindowNameCompare>;
diff --git a/xbmc/input/XBMC_keyboard.h b/xbmc/input/XBMC_keyboard.h
index dfd936c26bd1..09f2af76d6f4 100644
--- a/xbmc/input/XBMC_keyboard.h
+++ b/xbmc/input/XBMC_keyboard.h
@@ -26,20 +26,20 @@
      this is a UNICODE character corresponding to the keypress.  If the
      high 9 bits of the character are 0, then this maps to the equivalent
      ASCII character:
-	char ch;
-	if ( (keysym.unicode & 0xFF80) == 0 ) {
-		ch = keysym.unicode & 0x7F;
-	} else {
-		An international character..
-	}
+        char ch;
+        if ( (keysym.unicode & 0xFF80) == 0 ) {
+                ch = keysym.unicode & 0x7F;
+        } else {
+                An international character..
+        }
  */
-typedef struct XBMC_keysym {
-	unsigned char scancode;			/* hardware specific scancode */
-	XBMCKey sym;			/* SDL virtual keysym */
-	XBMCMod mod;			/* current key modifiers */
-	uint16_t unicode;			/* translated character */
+typedef struct XBMC_keysym
+{
+  unsigned char scancode; /* hardware specific scancode */
+  XBMCKey sym; /* SDL virtual keysym */
+  XBMCMod mod; /* current key modifiers */
+  uint16_t unicode; /* translated character */
 } XBMC_keysym;
 
 /* This is the mask which refers to all hotkey bindings */
-#define XBMC_ALL_HOTKEYS		0xFFFFFFFF
-
+#define XBMC_ALL_HOTKEYS 0xFFFFFFFF
diff --git a/xbmc/input/XBMC_keysym.h b/xbmc/input/XBMC_keysym.h
index af48a1526228..65d80bab020f 100644
--- a/xbmc/input/XBMC_keysym.h
+++ b/xbmc/input/XBMC_keysym.h
@@ -22,240 +22,241 @@
 // On OSs that don't support SDL (i.e. Windows) the OS dependant key
 // handling code converts keypresses to an XBMC_keysym value.
 
-typedef enum {
+typedef enum
+{
   // The keyboard syms have been cleverly chosen to map to ASCII
-  XBMCK_UNKNOWN     = 0x00,
-  XBMCK_FIRST       = 0x00,
-  XBMCK_BACKSPACE   = 0x08,
-  XBMCK_TAB         = 0x09,
-  XBMCK_CLEAR       = 0x0C,
-  XBMCK_RETURN      = 0x0D,
-  XBMCK_PAUSE       = 0x13,
-  XBMCK_ESCAPE      = 0x1B,
-  XBMCK_SPACE       = 0x20,
-  XBMCK_EXCLAIM     = 0x21,
-  XBMCK_QUOTEDBL    = 0x22,
-  XBMCK_HASH        = 0x23,
-  XBMCK_DOLLAR      = 0x24,
-  XBMCK_PERCENT     = 0x25,
-  XBMCK_AMPERSAND   = 0x26,
-  XBMCK_QUOTE       = 0x27,
-  XBMCK_LEFTPAREN   = 0x28,
-  XBMCK_RIGHTPAREN  = 0x29,
-  XBMCK_ASTERISK    = 0x2A,
-  XBMCK_PLUS        = 0x2B,
-  XBMCK_COMMA       = 0x2C,
-  XBMCK_MINUS       = 0x2D,
-  XBMCK_PERIOD      = 0x2E,
-  XBMCK_SLASH       = 0x2F,
-  XBMCK_0           = 0x30,
-  XBMCK_1           = 0x31,
-  XBMCK_2           = 0x32,
-  XBMCK_3           = 0x33,
-  XBMCK_4           = 0x34,
-  XBMCK_5           = 0x35,
-  XBMCK_6           = 0x36,
-  XBMCK_7           = 0x37,
-  XBMCK_8           = 0x38,
-  XBMCK_9           = 0x39,
-  XBMCK_COLON       = 0x3A,
-  XBMCK_SEMICOLON   = 0x3B,
-  XBMCK_LESS        = 0x3C,
-  XBMCK_EQUALS      = 0x3D,
-  XBMCK_GREATER     = 0x3E,
-  XBMCK_QUESTION    = 0x3F,
-  XBMCK_AT          = 0x40,
+  XBMCK_UNKNOWN = 0x00,
+  XBMCK_FIRST = 0x00,
+  XBMCK_BACKSPACE = 0x08,
+  XBMCK_TAB = 0x09,
+  XBMCK_CLEAR = 0x0C,
+  XBMCK_RETURN = 0x0D,
+  XBMCK_PAUSE = 0x13,
+  XBMCK_ESCAPE = 0x1B,
+  XBMCK_SPACE = 0x20,
+  XBMCK_EXCLAIM = 0x21,
+  XBMCK_QUOTEDBL = 0x22,
+  XBMCK_HASH = 0x23,
+  XBMCK_DOLLAR = 0x24,
+  XBMCK_PERCENT = 0x25,
+  XBMCK_AMPERSAND = 0x26,
+  XBMCK_QUOTE = 0x27,
+  XBMCK_LEFTPAREN = 0x28,
+  XBMCK_RIGHTPAREN = 0x29,
+  XBMCK_ASTERISK = 0x2A,
+  XBMCK_PLUS = 0x2B,
+  XBMCK_COMMA = 0x2C,
+  XBMCK_MINUS = 0x2D,
+  XBMCK_PERIOD = 0x2E,
+  XBMCK_SLASH = 0x2F,
+  XBMCK_0 = 0x30,
+  XBMCK_1 = 0x31,
+  XBMCK_2 = 0x32,
+  XBMCK_3 = 0x33,
+  XBMCK_4 = 0x34,
+  XBMCK_5 = 0x35,
+  XBMCK_6 = 0x36,
+  XBMCK_7 = 0x37,
+  XBMCK_8 = 0x38,
+  XBMCK_9 = 0x39,
+  XBMCK_COLON = 0x3A,
+  XBMCK_SEMICOLON = 0x3B,
+  XBMCK_LESS = 0x3C,
+  XBMCK_EQUALS = 0x3D,
+  XBMCK_GREATER = 0x3E,
+  XBMCK_QUESTION = 0x3F,
+  XBMCK_AT = 0x40,
   // Skip uppercase letters
   XBMCK_LEFTBRACKET = 0x5B,
-  XBMCK_BACKSLASH   = 0x5C,
+  XBMCK_BACKSLASH = 0x5C,
   XBMCK_RIGHTBRACKET = 0x5D,
-  XBMCK_CARET       = 0x5E,
-  XBMCK_UNDERSCORE  = 0x5F,
-  XBMCK_BACKQUOTE   = 0x60,
-  XBMCK_a           = 0x61,
-  XBMCK_b           = 0x62,
-  XBMCK_c           = 0x63,
-  XBMCK_d           = 0x64,
-  XBMCK_e           = 0x65,
-  XBMCK_f           = 0x66,
-  XBMCK_g           = 0x67,
-  XBMCK_h           = 0x68,
-  XBMCK_i           = 0x69,
-  XBMCK_j           = 0x6A,
-  XBMCK_k           = 0x6B,
-  XBMCK_l           = 0x6C,
-  XBMCK_m           = 0x6D,
-  XBMCK_n           = 0x6E,
-  XBMCK_o           = 0x6F,
-  XBMCK_p           = 0x70,
-  XBMCK_q           = 0x71,
-  XBMCK_r           = 0x72,
-  XBMCK_s           = 0x73,
-  XBMCK_t           = 0x74,
-  XBMCK_u           = 0x75,
-  XBMCK_v           = 0x76,
-  XBMCK_w           = 0x77,
-  XBMCK_x           = 0x78,
-  XBMCK_y           = 0x79,
-  XBMCK_z           = 0x7A,
-  XBMCK_LEFTBRACE   = 0x7b,
-  XBMCK_PIPE        = 0x7C,
-  XBMCK_RIGHTBRACE  = 0x7D,
-  XBMCK_TILDE       = 0x7E,
+  XBMCK_CARET = 0x5E,
+  XBMCK_UNDERSCORE = 0x5F,
+  XBMCK_BACKQUOTE = 0x60,
+  XBMCK_a = 0x61,
+  XBMCK_b = 0x62,
+  XBMCK_c = 0x63,
+  XBMCK_d = 0x64,
+  XBMCK_e = 0x65,
+  XBMCK_f = 0x66,
+  XBMCK_g = 0x67,
+  XBMCK_h = 0x68,
+  XBMCK_i = 0x69,
+  XBMCK_j = 0x6A,
+  XBMCK_k = 0x6B,
+  XBMCK_l = 0x6C,
+  XBMCK_m = 0x6D,
+  XBMCK_n = 0x6E,
+  XBMCK_o = 0x6F,
+  XBMCK_p = 0x70,
+  XBMCK_q = 0x71,
+  XBMCK_r = 0x72,
+  XBMCK_s = 0x73,
+  XBMCK_t = 0x74,
+  XBMCK_u = 0x75,
+  XBMCK_v = 0x76,
+  XBMCK_w = 0x77,
+  XBMCK_x = 0x78,
+  XBMCK_y = 0x79,
+  XBMCK_z = 0x7A,
+  XBMCK_LEFTBRACE = 0x7b,
+  XBMCK_PIPE = 0x7C,
+  XBMCK_RIGHTBRACE = 0x7D,
+  XBMCK_TILDE = 0x7E,
   XBMCK_DELETE = 0x7F,
   // End of ASCII mapped keysyms
 
   // Multimedia keys
   // These are the Windows VK_ codes. SDL doesn't define codes for
   // these keys.
-  XBMCK_BROWSER_BACK         = 0xA6,
-  XBMCK_BROWSER_FORWARD      = 0xA7,
-  XBMCK_BROWSER_REFRESH      = 0xA8,
-  XBMCK_BROWSER_STOP         = 0xA9,
-  XBMCK_BROWSER_SEARCH       = 0xAA,
-  XBMCK_BROWSER_FAVORITES    = 0xAB,
-  XBMCK_BROWSER_HOME         = 0xAC,
-  XBMCK_VOLUME_MUTE          = 0xAD,
-  XBMCK_VOLUME_DOWN          = 0xAE,
-  XBMCK_VOLUME_UP            = 0xAF,
-  XBMCK_MEDIA_NEXT_TRACK     = 0xB0,
-  XBMCK_MEDIA_PREV_TRACK     = 0xB1,
-  XBMCK_MEDIA_STOP           = 0xB2,
-  XBMCK_MEDIA_PLAY_PAUSE     = 0xB3,
-  XBMCK_LAUNCH_MAIL          = 0xB4,
-  XBMCK_LAUNCH_MEDIA_SELECT  = 0xB5,
-  XBMCK_LAUNCH_APP1          = 0xB6,
-  XBMCK_LAUNCH_APP2          = 0xB7,
-  XBMCK_LAUNCH_FILE_BROWSER  = 0xB8,
-  XBMCK_LAUNCH_MEDIA_CENTER  = 0xB9,
-  XBMCK_MEDIA_REWIND         = 0xBA,
-  XBMCK_MEDIA_FASTFORWARD    = 0xBB,
+  XBMCK_BROWSER_BACK = 0xA6,
+  XBMCK_BROWSER_FORWARD = 0xA7,
+  XBMCK_BROWSER_REFRESH = 0xA8,
+  XBMCK_BROWSER_STOP = 0xA9,
+  XBMCK_BROWSER_SEARCH = 0xAA,
+  XBMCK_BROWSER_FAVORITES = 0xAB,
+  XBMCK_BROWSER_HOME = 0xAC,
+  XBMCK_VOLUME_MUTE = 0xAD,
+  XBMCK_VOLUME_DOWN = 0xAE,
+  XBMCK_VOLUME_UP = 0xAF,
+  XBMCK_MEDIA_NEXT_TRACK = 0xB0,
+  XBMCK_MEDIA_PREV_TRACK = 0xB1,
+  XBMCK_MEDIA_STOP = 0xB2,
+  XBMCK_MEDIA_PLAY_PAUSE = 0xB3,
+  XBMCK_LAUNCH_MAIL = 0xB4,
+  XBMCK_LAUNCH_MEDIA_SELECT = 0xB5,
+  XBMCK_LAUNCH_APP1 = 0xB6,
+  XBMCK_LAUNCH_APP2 = 0xB7,
+  XBMCK_LAUNCH_FILE_BROWSER = 0xB8,
+  XBMCK_LAUNCH_MEDIA_CENTER = 0xB9,
+  XBMCK_MEDIA_REWIND = 0xBA,
+  XBMCK_MEDIA_FASTFORWARD = 0xBB,
 
   // Numeric keypad
-  XBMCK_KP0         = 0x100,
-  XBMCK_KP1         = 0x101,
-  XBMCK_KP2         = 0x102,
-  XBMCK_KP3         = 0x103,
-  XBMCK_KP4         = 0x104,
-  XBMCK_KP5         = 0x105,
-  XBMCK_KP6         = 0x106,
-  XBMCK_KP7         = 0x107,
-  XBMCK_KP8         = 0x108,
-  XBMCK_KP9         = 0x109,
-  XBMCK_KP_PERIOD   = 0x10A,
-  XBMCK_KP_DIVIDE   = 0x10B,
+  XBMCK_KP0 = 0x100,
+  XBMCK_KP1 = 0x101,
+  XBMCK_KP2 = 0x102,
+  XBMCK_KP3 = 0x103,
+  XBMCK_KP4 = 0x104,
+  XBMCK_KP5 = 0x105,
+  XBMCK_KP6 = 0x106,
+  XBMCK_KP7 = 0x107,
+  XBMCK_KP8 = 0x108,
+  XBMCK_KP9 = 0x109,
+  XBMCK_KP_PERIOD = 0x10A,
+  XBMCK_KP_DIVIDE = 0x10B,
   XBMCK_KP_MULTIPLY = 0x10C,
-  XBMCK_KP_MINUS    = 0x10D,
-  XBMCK_KP_PLUS     = 0x10E,
-  XBMCK_KP_ENTER    = 0x10F,
-  XBMCK_KP_EQUALS   = 0x110,
+  XBMCK_KP_MINUS = 0x10D,
+  XBMCK_KP_PLUS = 0x10E,
+  XBMCK_KP_ENTER = 0x10F,
+  XBMCK_KP_EQUALS = 0x110,
 
   // Arrows + Home/End pad
-  XBMCK_UP          = 0x111,
-  XBMCK_DOWN        = 0x112,
-  XBMCK_RIGHT       = 0x113,
-  XBMCK_LEFT        = 0x114,
-  XBMCK_INSERT      = 0x115,
-  XBMCK_HOME        = 0x116,
-  XBMCK_END         = 0x117,
-  XBMCK_PAGEUP      = 0x118,
-  XBMCK_PAGEDOWN    = 0x119,
+  XBMCK_UP = 0x111,
+  XBMCK_DOWN = 0x112,
+  XBMCK_RIGHT = 0x113,
+  XBMCK_LEFT = 0x114,
+  XBMCK_INSERT = 0x115,
+  XBMCK_HOME = 0x116,
+  XBMCK_END = 0x117,
+  XBMCK_PAGEUP = 0x118,
+  XBMCK_PAGEDOWN = 0x119,
 
   // Function keys
-  XBMCK_F1          = 0x11A,
-  XBMCK_F2          = 0x11B,
-  XBMCK_F3          = 0x11C,
-  XBMCK_F4          = 0x11D,
-  XBMCK_F5          = 0x11E,
-  XBMCK_F6          = 0x11F,
-  XBMCK_F7          = 0x120,
-  XBMCK_F8          = 0x121,
-  XBMCK_F9          = 0x122,
-  XBMCK_F10         = 0x123,
-  XBMCK_F11         = 0x124,
-  XBMCK_F12         = 0x125,
-  XBMCK_F13         = 0x126,
-  XBMCK_F14         = 0x127,
-  XBMCK_F15         = 0x128,
+  XBMCK_F1 = 0x11A,
+  XBMCK_F2 = 0x11B,
+  XBMCK_F3 = 0x11C,
+  XBMCK_F4 = 0x11D,
+  XBMCK_F5 = 0x11E,
+  XBMCK_F6 = 0x11F,
+  XBMCK_F7 = 0x120,
+  XBMCK_F8 = 0x121,
+  XBMCK_F9 = 0x122,
+  XBMCK_F10 = 0x123,
+  XBMCK_F11 = 0x124,
+  XBMCK_F12 = 0x125,
+  XBMCK_F13 = 0x126,
+  XBMCK_F14 = 0x127,
+  XBMCK_F15 = 0x128,
 
   // Key state modifier keys
-  XBMCK_NUMLOCK     = 0x12C,
-  XBMCK_CAPSLOCK    = 0x12D,
-  XBMCK_SCROLLOCK   = 0x12E,
-  XBMCK_RSHIFT      = 0x12F,
-  XBMCK_LSHIFT      = 0x130,
-  XBMCK_RCTRL       = 0x131,
-  XBMCK_LCTRL       = 0x132,
-  XBMCK_RALT        = 0x133,
-  XBMCK_LALT        = 0x134,
-  XBMCK_RMETA       = 0x135,
-  XBMCK_LMETA       = 0x136,
-  XBMCK_LSUPER      = 0x137,    // Left "Windows" key
-  XBMCK_RSUPER      = 0x138,    // Right "Windows" key
-  XBMCK_MODE        = 0x139,    // "Alt Gr" key
-  XBMCK_COMPOSE     = 0x13A,    // Multi-key compose key
+  XBMCK_NUMLOCK = 0x12C,
+  XBMCK_CAPSLOCK = 0x12D,
+  XBMCK_SCROLLOCK = 0x12E,
+  XBMCK_RSHIFT = 0x12F,
+  XBMCK_LSHIFT = 0x130,
+  XBMCK_RCTRL = 0x131,
+  XBMCK_LCTRL = 0x132,
+  XBMCK_RALT = 0x133,
+  XBMCK_LALT = 0x134,
+  XBMCK_RMETA = 0x135,
+  XBMCK_LMETA = 0x136,
+  XBMCK_LSUPER = 0x137, // Left "Windows" key
+  XBMCK_RSUPER = 0x138, // Right "Windows" key
+  XBMCK_MODE = 0x139, // "Alt Gr" key
+  XBMCK_COMPOSE = 0x13A, // Multi-key compose key
 
   // Miscellaneous function keys
-  XBMCK_HELP        = 0x13B,
-  XBMCK_PRINT       = 0x13C,
-  XBMCK_SYSREQ      = 0x13D,
-  XBMCK_BREAK       = 0x13E,
-  XBMCK_MENU        = 0x13F,
-  XBMCK_POWER       = 0x140,    // Power Macintosh power key
-  XBMCK_EURO        = 0x141,    // Some european keyboards
-  XBMCK_UNDO        = 0x142,    // Atari keyboard has Undo
-  XBMCK_SLEEP       = 0x143,    // Sleep button on Nyxboard remote (and others?)
-  XBMCK_GUIDE       = 0x144,
-  XBMCK_SETTINGS    = 0x145,
-  XBMCK_INFO        = 0x146,
-  XBMCK_RED         = 0x147,
-  XBMCK_GREEN       = 0x148,
-  XBMCK_YELLOW      = 0x149,
-  XBMCK_BLUE        = 0x14a,
-  XBMCK_ZOOM        = 0x14b,
-  XBMCK_TEXT        = 0x14c,
-  XBMCK_FAVORITES   = 0x14d,
-  XBMCK_HOMEPAGE    = 0x14e,
-  XBMCK_CONFIG      = 0x14f,
-  XBMCK_EPG         = 0x150,
+  XBMCK_HELP = 0x13B,
+  XBMCK_PRINT = 0x13C,
+  XBMCK_SYSREQ = 0x13D,
+  XBMCK_BREAK = 0x13E,
+  XBMCK_MENU = 0x13F,
+  XBMCK_POWER = 0x140, // Power Macintosh power key
+  XBMCK_EURO = 0x141, // Some european keyboards
+  XBMCK_UNDO = 0x142, // Atari keyboard has Undo
+  XBMCK_SLEEP = 0x143, // Sleep button on Nyxboard remote (and others?)
+  XBMCK_GUIDE = 0x144,
+  XBMCK_SETTINGS = 0x145,
+  XBMCK_INFO = 0x146,
+  XBMCK_RED = 0x147,
+  XBMCK_GREEN = 0x148,
+  XBMCK_YELLOW = 0x149,
+  XBMCK_BLUE = 0x14a,
+  XBMCK_ZOOM = 0x14b,
+  XBMCK_TEXT = 0x14c,
+  XBMCK_FAVORITES = 0x14d,
+  XBMCK_HOMEPAGE = 0x14e,
+  XBMCK_CONFIG = 0x14f,
+  XBMCK_EPG = 0x150,
 
   // Add any other keys here
 
-	/* Media keys */
-  XBMCK_STOP              = 337,
-  XBMCK_RECORD            = 338,
-  XBMCK_REWIND            = 339,
-  XBMCK_PHONE             = 340,
-  XBMCK_PLAY              = 341,
-  XBMCK_SHUFFLE           = 342,
-  XBMCK_FASTFORWARD       = 343,
+  /* Media keys */
+  XBMCK_STOP = 337,
+  XBMCK_RECORD = 338,
+  XBMCK_REWIND = 339,
+  XBMCK_PHONE = 340,
+  XBMCK_PLAY = 341,
+  XBMCK_SHUFFLE = 342,
+  XBMCK_FASTFORWARD = 343,
   XBMCK_EJECT = 344,
 
   XBMCK_LAST
 } XBMCKey;
 
 // Enumeration of valid key mods (possibly OR'd together)
-typedef enum {
-  XBMCKMOD_NONE     = 0x0000,
-  XBMCKMOD_LSHIFT   = 0x0001,
-  XBMCKMOD_RSHIFT   = 0x0002,
-  XBMCKMOD_LSUPER   = 0x0010,
-  XBMCKMOD_RSUPER   = 0x0020,
-  XBMCKMOD_LCTRL    = 0x0040,
-  XBMCKMOD_RCTRL    = 0x0080,
-  XBMCKMOD_LALT     = 0x0100,
-  XBMCKMOD_RALT     = 0x0200,
-  XBMCKMOD_LMETA    = 0x0400,
-  XBMCKMOD_RMETA    = 0x0800,
-  XBMCKMOD_NUM      = 0x1000,
-  XBMCKMOD_CAPS     = 0x2000,
-  XBMCKMOD_MODE     = 0x4000,
+typedef enum
+{
+  XBMCKMOD_NONE = 0x0000,
+  XBMCKMOD_LSHIFT = 0x0001,
+  XBMCKMOD_RSHIFT = 0x0002,
+  XBMCKMOD_LSUPER = 0x0010,
+  XBMCKMOD_RSUPER = 0x0020,
+  XBMCKMOD_LCTRL = 0x0040,
+  XBMCKMOD_RCTRL = 0x0080,
+  XBMCKMOD_LALT = 0x0100,
+  XBMCKMOD_RALT = 0x0200,
+  XBMCKMOD_LMETA = 0x0400,
+  XBMCKMOD_RMETA = 0x0800,
+  XBMCKMOD_NUM = 0x1000,
+  XBMCKMOD_CAPS = 0x2000,
+  XBMCKMOD_MODE = 0x4000,
   XBMCKMOD_RESERVED = 0x8000
 } XBMCMod;
 
-#define XBMCKMOD_CTRL  (XBMCKMOD_LCTRL  | XBMCKMOD_RCTRL)
+#define XBMCKMOD_CTRL (XBMCKMOD_LCTRL | XBMCKMOD_RCTRL)
 #define XBMCKMOD_SHIFT (XBMCKMOD_LSHIFT | XBMCKMOD_RSHIFT)
-#define XBMCKMOD_ALT   (XBMCKMOD_LALT   | XBMCKMOD_RALT)
-#define XBMCKMOD_META  (XBMCKMOD_LMETA  | XBMCKMOD_RMETA)
+#define XBMCKMOD_ALT (XBMCKMOD_LALT | XBMCKMOD_RALT)
+#define XBMCKMOD_META (XBMCKMOD_LMETA | XBMCKMOD_RMETA)
 #define XBMCKMOD_SUPER (XBMCKMOD_LSUPER | XBMCKMOD_RSUPER)
-
diff --git a/xbmc/input/XBMC_keytable.cpp b/xbmc/input/XBMC_keytable.cpp
index a9e4339505e2..2ea9d9ac69d1 100644
--- a/xbmc/input/XBMC_keytable.cpp
+++ b/xbmc/input/XBMC_keytable.cpp
@@ -14,227 +14,238 @@
 
 // The array of XBMCKEYTABLEs used in XBMC.
 // scancode, sym, unicode, ascii, vkey, keyname
-static const XBMCKEYTABLE XBMCKeyTable[] =
-{ { XBMCK_BACKSPACE, 0,    0, XBMCVK_BACK,   "backspace" }
-, { XBMCK_TAB,       0,    0, XBMCVK_TAB,    "tab" }
-, { XBMCK_RETURN,    0,    0, XBMCVK_RETURN, "return" }
-, { XBMCK_ESCAPE,    0,    0, XBMCVK_ESCAPE, "escape" }
-, { 0,               0,    0, XBMCVK_ESCAPE, "esc" } // Allowed abbreviation for "escape"
-
-// Number keys on the main keyboard
-, { XBMCK_0,    '0',  '0', XBMCVK_0, "zero" }
-, { XBMCK_1,    '1',  '1', XBMCVK_1, "one" }
-, { XBMCK_2,    '2',  '2', XBMCVK_2, "two" }
-, { XBMCK_3,    '3',  '3', XBMCVK_3, "three" }
-, { XBMCK_4,    '4',  '4', XBMCVK_4, "four" }
-, { XBMCK_5,    '5',  '5', XBMCVK_5, "five" }
-, { XBMCK_6,    '6',  '6', XBMCVK_6, "six" }
-, { XBMCK_7,    '7',  '7', XBMCVK_7, "seven" }
-, { XBMCK_8,    '8',  '8', XBMCVK_8, "eight" }
-, { XBMCK_9,    '9',  '9', XBMCVK_9, "nine" }
-
-// A to Z - note that upper case A-Z don't have a matching name or
-// vkey. Only the lower case a-z are used in key mappings.
-, { XBMCK_a,    'A',  'A', XBMCVK_A, NULL }
-, { XBMCK_b,    'B',  'B', XBMCVK_B, NULL }
-, { XBMCK_c,    'C',  'C', XBMCVK_C, NULL }
-, { XBMCK_d,    'D',  'D', XBMCVK_D, NULL }
-, { XBMCK_e,    'E',  'E', XBMCVK_E, NULL }
-, { XBMCK_f,    'F',  'F', XBMCVK_F, NULL }
-, { XBMCK_g,    'G',  'G', XBMCVK_G, NULL }
-, { XBMCK_h,    'H',  'H', XBMCVK_H, NULL }
-, { XBMCK_i,    'I',  'I', XBMCVK_I, NULL }
-, { XBMCK_j,    'J',  'J', XBMCVK_J, NULL }
-, { XBMCK_k,    'K',  'K', XBMCVK_K, NULL }
-, { XBMCK_l,    'L',  'L', XBMCVK_L, NULL }
-, { XBMCK_m,    'M',  'M', XBMCVK_M, NULL }
-, { XBMCK_n,    'N',  'N', XBMCVK_N, NULL }
-, { XBMCK_o,    'O',  'O', XBMCVK_O, NULL }
-, { XBMCK_p,    'P',  'P', XBMCVK_P, NULL }
-, { XBMCK_q,    'Q',  'Q', XBMCVK_Q, NULL }
-, { XBMCK_r,    'R',  'R', XBMCVK_R, NULL }
-, { XBMCK_s,    'S',  'S', XBMCVK_S, NULL }
-, { XBMCK_t,    'T',  'T', XBMCVK_T, NULL }
-, { XBMCK_u,    'U',  'U', XBMCVK_U, NULL }
-, { XBMCK_v,    'V',  'V', XBMCVK_V, NULL }
-, { XBMCK_w,    'W',  'W', XBMCVK_W, NULL }
-, { XBMCK_x,    'X',  'X', XBMCVK_X, NULL }
-, { XBMCK_y,    'Y',  'Y', XBMCVK_Y, NULL }
-, { XBMCK_z,    'Z',  'Z', XBMCVK_Z, NULL }
-
-, { XBMCK_a,    'a',  'a', XBMCVK_A, "a" }
-, { XBMCK_b,    'b',  'b', XBMCVK_B, "b" }
-, { XBMCK_c,    'c',  'c', XBMCVK_C, "c" }
-, { XBMCK_d,    'd',  'd', XBMCVK_D, "d" }
-, { XBMCK_e,    'e',  'e', XBMCVK_E, "e" }
-, { XBMCK_f,    'f',  'f', XBMCVK_F, "f" }
-, { XBMCK_g,    'g',  'g', XBMCVK_G, "g" }
-, { XBMCK_h,    'h',  'h', XBMCVK_H, "h" }
-, { XBMCK_i,    'i',  'i', XBMCVK_I, "i" }
-, { XBMCK_j,    'j',  'j', XBMCVK_J, "j" }
-, { XBMCK_k,    'k',  'k', XBMCVK_K, "k" }
-, { XBMCK_l,    'l',  'l', XBMCVK_L, "l" }
-, { XBMCK_m,    'm',  'm', XBMCVK_M, "m" }
-, { XBMCK_n,    'n',  'n', XBMCVK_N, "n" }
-, { XBMCK_o,    'o',  'o', XBMCVK_O, "o" }
-, { XBMCK_p,    'p',  'p', XBMCVK_P, "p" }
-, { XBMCK_q,    'q',  'q', XBMCVK_Q, "q" }
-, { XBMCK_r,    'r',  'r', XBMCVK_R, "r" }
-, { XBMCK_s,    's',  's', XBMCVK_S, "s" }
-, { XBMCK_t,    't',  't', XBMCVK_T, "t" }
-, { XBMCK_u,    'u',  'u', XBMCVK_U, "u" }
-, { XBMCK_v,    'v',  'v', XBMCVK_V, "v" }
-, { XBMCK_w,    'w',  'w', XBMCVK_W, "w" }
-, { XBMCK_x,    'x',  'x', XBMCVK_X, "x" }
-, { XBMCK_y,    'y',  'y', XBMCVK_Y, "y" }
-, { XBMCK_z,    'z',  'z', XBMCVK_Z, "z" }
-
-// Misc printing characters
-, { XBMCK_SPACE,                ' ',  ' ', XBMCVK_SPACE,         "space" }
-, { XBMCK_EXCLAIM,              '!',  '!', XBMCVK_EXCLAIM,       "exclaim" }
-, { XBMCK_QUOTEDBL,             '"',  '"', XBMCVK_QUOTEDBL,      "doublequote" }
-, { XBMCK_HASH,                 '#',  '#', XBMCVK_HASH,          "hash" }
-, { XBMCK_DOLLAR,               '$',  '$', XBMCVK_DOLLAR,        "dollar" }
-, { XBMCK_PERCENT,              '%',  '%', XBMCVK_PERCENT,       "percent" }
-, { XBMCK_AMPERSAND,            '&',  '&', XBMCVK_AMPERSAND,     "ampersand" }
-, { XBMCK_QUOTE,                '\'', '\'', XBMCVK_QUOTE,         "quote" }
-, { XBMCK_LEFTPAREN,            '(',  '(', XBMCVK_LEFTPAREN,     "leftbracket" }
-, { XBMCK_RIGHTPAREN,           ')',  ')', XBMCVK_RIGHTPAREN,    "rightbracket" }
-, { XBMCK_ASTERISK,             '*',  '*', XBMCVK_ASTERISK,      "asterisk" }
-, { XBMCK_PLUS,                 '+',  '+', XBMCVK_PLUS,          "plus" }
-, { XBMCK_COMMA,                ',',  ',', XBMCVK_COMMA,         "comma" }
-, { XBMCK_MINUS,                '-',  '-', XBMCVK_MINUS,         "minus" }
-, { XBMCK_PERIOD,               '.',  '.', XBMCVK_PERIOD,        "period" }
-, { XBMCK_SLASH,                '/',  '/', XBMCVK_SLASH,         "forwardslash" }
-
-, { XBMCK_COLON,                ':',  ':', XBMCVK_COLON,         "colon" }
-, { XBMCK_SEMICOLON,            ';',  ';', XBMCVK_SEMICOLON,     "semicolon" }
-, { XBMCK_LESS,                 '<',  '<', XBMCVK_LESS,          "lessthan" }
-, { XBMCK_EQUALS,               '=',  '=', XBMCVK_EQUALS,        "equals" }
-, { XBMCK_GREATER,              '>',  '>', XBMCVK_GREATER,       "greaterthan" }
-, { XBMCK_QUESTION,             '?',  '?', XBMCVK_QUESTION,      "questionmark" }
-, { XBMCK_AT,                   '@',  '@', XBMCVK_AT,            "at" }
-
-, { XBMCK_LEFTBRACKET,          '[',  '[', XBMCVK_LEFTBRACKET,   "opensquarebracket" }
-, { XBMCK_BACKSLASH,            '\\', '\\', XBMCVK_BACKSLASH,     "backslash" }
-, { XBMCK_RIGHTBRACKET,         ']',  ']', XBMCVK_RIGHTBRACKET,  "closesquarebracket" }
-, { XBMCK_CARET,                '^',  '^', XBMCVK_CARET,         "caret" }
-, { XBMCK_UNDERSCORE,           '_',  '_', XBMCVK_UNDERSCORE,    "underline" }
-, { XBMCK_BACKQUOTE,            '`',  '`', XBMCVK_BACKQUOTE,     "leftquote" }
-
-, { XBMCK_LEFTBRACE,            '{',  '{', XBMCVK_LEFTBRACE,     "openbrace" }
-, { XBMCK_PIPE,                 '|',  '|', XBMCVK_PIPE,          "pipe" }
-, { XBMCK_RIGHTBRACE,           '}',  '}', XBMCVK_RIGHTBRACE,    "closebrace" }
-, { XBMCK_TILDE,                '~',  '~', XBMCVK_TILDE,         "tilde" }
-
-// Numeric keypad
-, { XBMCK_KP0,                  '0',  '0', XBMCVK_NUMPAD0,       "numpadzero"}
-, { XBMCK_KP1,                  '1',  '1', XBMCVK_NUMPAD1,       "numpadone"}
-, { XBMCK_KP2,                  '2',  '2', XBMCVK_NUMPAD2,       "numpadtwo"}
-, { XBMCK_KP3,                  '3',  '3', XBMCVK_NUMPAD3,       "numpadthree"}
-, { XBMCK_KP4,                  '4',  '4', XBMCVK_NUMPAD4,       "numpadfour"}
-, { XBMCK_KP5,                  '5',  '5', XBMCVK_NUMPAD5,       "numpadfive"}
-, { XBMCK_KP6,                  '6',  '6', XBMCVK_NUMPAD6,       "numpadsix"}
-, { XBMCK_KP7,                  '7',  '7', XBMCVK_NUMPAD7,       "numpadseven"}
-, { XBMCK_KP8,                  '8',  '8', XBMCVK_NUMPAD8,       "numpadeight"}
-, { XBMCK_KP9,                  '9',  '9', XBMCVK_NUMPAD9,       "numpadnine"}
-
-, { XBMCK_KP_DIVIDE,            '/',  '/', XBMCVK_NUMPADDIVIDE,  "numpaddivide"}
-, { XBMCK_KP_MULTIPLY,          '*',  '*', XBMCVK_NUMPADTIMES,   "numpadtimes"}
-, { XBMCK_KP_MINUS,             '-',  '-', XBMCVK_NUMPADMINUS,   "numpadminus"}
-, { XBMCK_KP_PLUS,              '+',  '+', XBMCVK_NUMPADPLUS,    "numpadplus"}
-, { XBMCK_KP_ENTER,               0,    0, XBMCVK_NUMPADENTER,   "enter"}
-, { XBMCK_KP_PERIOD,            '.',  '.', XBMCVK_NUMPADPERIOD,  "numpadperiod"}
-
-// Multimedia keys
-, { XBMCK_BROWSER_BACK,           0,    0, XBMCVK_BROWSER_BACK,        "browser_back" }
-, { XBMCK_BROWSER_FORWARD,        0,    0, XBMCVK_BROWSER_FORWARD,     "browser_forward" }
-, { XBMCK_BROWSER_REFRESH,        0,    0, XBMCVK_BROWSER_REFRESH,     "browser_refresh" }
-, { XBMCK_BROWSER_STOP,           0,    0, XBMCVK_BROWSER_STOP,        "browser_stop" }
-, { XBMCK_BROWSER_SEARCH,         0,    0, XBMCVK_BROWSER_SEARCH,      "browser_search" }
-, { XBMCK_BROWSER_FAVORITES,      0,    0, XBMCVK_BROWSER_FAVORITES,   "browser_favorites" }
-, { XBMCK_BROWSER_HOME,           0,    0, XBMCVK_BROWSER_HOME,        "browser_home" }
-, { XBMCK_VOLUME_MUTE,            0,    0, XBMCVK_VOLUME_MUTE,         "volume_mute" }
-, { XBMCK_VOLUME_DOWN,            0,    0, XBMCVK_VOLUME_DOWN,         "volume_down" }
-, { XBMCK_VOLUME_UP,              0,    0, XBMCVK_VOLUME_UP,           "volume_up" }
-, { XBMCK_MEDIA_NEXT_TRACK,       0,    0, XBMCVK_MEDIA_NEXT_TRACK,    "next_track" }
-, { XBMCK_MEDIA_PREV_TRACK,       0,    0, XBMCVK_MEDIA_PREV_TRACK,    "prev_track" }
-, { XBMCK_MEDIA_STOP,             0,    0, XBMCVK_MEDIA_STOP,          "stop" }
-, { XBMCK_MEDIA_PLAY_PAUSE,       0,    0, XBMCVK_MEDIA_PLAY_PAUSE,    "play_pause" }
-, { XBMCK_MEDIA_REWIND,           0,    0, XBMCVK_MEDIA_REWIND,        "rewind" }
-, { XBMCK_MEDIA_FASTFORWARD,      0,    0, XBMCVK_MEDIA_FASTFORWARD,   "fastforward" }
-, { XBMCK_LAUNCH_MAIL,            0,    0, XBMCVK_LAUNCH_MAIL,         "launch_mail" }
-, { XBMCK_LAUNCH_MEDIA_SELECT,    0,    0, XBMCVK_LAUNCH_MEDIA_SELECT, "launch_media_select" }
-, { XBMCK_LAUNCH_APP1,            0,    0, XBMCVK_LAUNCH_APP1,         "launch_app1_pc_icon" }
-, { XBMCK_LAUNCH_APP2,            0,    0, XBMCVK_LAUNCH_APP2,         "launch_app2_pc_icon" }
-, { XBMCK_LAUNCH_FILE_BROWSER,    0,    0, XBMCVK_LAUNCH_FILE_BROWSER, "launch_file_browser" }
-, { XBMCK_LAUNCH_MEDIA_CENTER,    0,    0, XBMCVK_LAUNCH_MEDIA_CENTER, "launch_media_center" }
-, { XBMCK_PLAY,                   0,    0, XBMCVK_MEDIA_PLAY_PAUSE,    "play_pause" }
-, { XBMCK_STOP,                   0,    0, XBMCVK_MEDIA_STOP,          "stop" }
-, { XBMCK_REWIND,                 0,    0, XBMCVK_MEDIA_REWIND,        "rewind" }
-, { XBMCK_FASTFORWARD,            0,    0, XBMCVK_MEDIA_FASTFORWARD,   "fastforward" }
-, { XBMCK_RECORD,                 0,    0, XBMCVK_MEDIA_RECORD,        "record" }
-
-
-// Function keys
-, { XBMCK_F1,                     0,    0, XBMCVK_F1,            "f1"}
-, { XBMCK_F2,                     0,    0, XBMCVK_F2,            "f2"}
-, { XBMCK_F3,                     0,    0, XBMCVK_F3,            "f3"}
-, { XBMCK_F4,                     0,    0, XBMCVK_F4,            "f4"}
-, { XBMCK_F5,                     0,    0, XBMCVK_F5,            "f5"}
-, { XBMCK_F6,                     0,    0, XBMCVK_F6,            "f6"}
-, { XBMCK_F7,                     0,    0, XBMCVK_F7,            "f7"}
-, { XBMCK_F8,                     0,    0, XBMCVK_F8,            "f8"}
-, { XBMCK_F9,                     0,    0, XBMCVK_F9,            "f9"}
-, { XBMCK_F10,                    0,    0, XBMCVK_F10,           "f10"}
-, { XBMCK_F11,                    0,    0, XBMCVK_F11,           "f11"}
-, { XBMCK_F12,                    0,    0, XBMCVK_F12,           "f12"}
-, { XBMCK_F13,                    0,    0, XBMCVK_F13,           "f13"}
-, { XBMCK_F14,                    0,    0, XBMCVK_F14,           "f14"}
-, { XBMCK_F15,                    0,    0, XBMCVK_F15,           "f15"}
-
-// Misc non-printing keys
-, { XBMCK_UP,                     0,    0, XBMCVK_UP,            "up" }
-, { XBMCK_DOWN,                   0,    0, XBMCVK_DOWN,          "down" }
-, { XBMCK_RIGHT,                  0,    0, XBMCVK_RIGHT,         "right" }
-, { XBMCK_LEFT,                   0,    0, XBMCVK_LEFT,          "left" }
-, { XBMCK_INSERT,                 0,    0, XBMCVK_INSERT,        "insert" }
-, { XBMCK_DELETE,                 0,    0, XBMCVK_DELETE,        "delete" }
-, { XBMCK_HOME,                   0,    0, XBMCVK_HOME,          "home" }
-, { XBMCK_END,                    0,    0, XBMCVK_END,           "end" }
-, { XBMCK_PAGEUP,                 0,    0, XBMCVK_PAGEUP,        "pageup" }
-, { XBMCK_PAGEDOWN,               0,    0, XBMCVK_PAGEDOWN,      "pagedown" }
-, { XBMCK_NUMLOCK,                0,    0, XBMCVK_NUMLOCK,       "numlock" }
-, { XBMCK_CAPSLOCK,               0,    0, XBMCVK_CAPSLOCK,      "capslock" }
-, { XBMCK_RSHIFT,                 0,    0, XBMCVK_RSHIFT,        "rightshift" }
-, { XBMCK_LSHIFT,                 0,    0, XBMCVK_LSHIFT,        "leftshift" }
-, { XBMCK_RCTRL,                  0,    0, XBMCVK_RCONTROL,      "rightctrl" }
-, { XBMCK_LCTRL,                  0,    0, XBMCVK_LCONTROL,      "leftctrl" }
-, { XBMCK_LALT,                   0,    0, XBMCVK_LMENU,         "leftalt" }
-, { XBMCK_LSUPER,                 0,    0, XBMCVK_LWIN,          "leftwindows" }
-, { XBMCK_RSUPER,                 0,    0, XBMCVK_RWIN,          "rightwindows" }
-, { XBMCK_MENU,                   0,    0, XBMCVK_MENU,          "menu" }
-, { XBMCK_PAUSE,                  0,    0, XBMCVK_PAUSE,         "pause" }
-, { XBMCK_SCROLLOCK,              0,    0, XBMCVK_SCROLLLOCK,    "scrolllock" }
-, { XBMCK_PRINT,                  0,    0, XBMCVK_PRINTSCREEN,   "printscreen" }
-, { XBMCK_POWER,                  0,    0, XBMCVK_POWER,         "power" }
-, { XBMCK_SLEEP,                  0,    0, XBMCVK_SLEEP,         "sleep" }
-, { XBMCK_GUIDE,                  0,    0, XBMCVK_GUIDE,         "guide" }
-, { XBMCK_SETTINGS,               0,    0, XBMCVK_SETTINGS,      "settings" }
-, { XBMCK_INFO,                   0,    0, XBMCVK_INFO,          "info" }
-, { XBMCK_RED,                    0,    0, XBMCVK_RED,           "red" }
-, { XBMCK_GREEN,                  0,    0, XBMCVK_GREEN,         "green" }
-, { XBMCK_YELLOW,                 0,    0, XBMCVK_YELLOW,        "yellow" }
-, { XBMCK_BLUE,                   0,    0, XBMCVK_BLUE,          "blue" }
-, { XBMCK_ZOOM,                   0,    0, XBMCVK_ZOOM,          "zoom" }
-, { XBMCK_TEXT,                   0,    0, XBMCVK_TEXT,          "text" }
-, { XBMCK_FAVORITES,              0,    0, XBMCVK_FAVORITES,     "favorites" }
-, { XBMCK_HOMEPAGE ,              0,    0, XBMCVK_HOMEPAGE,      "homepage" }
-, { XBMCK_CONFIG,                 0,    0, XBMCVK_CONFIG,        "config" }
-, { XBMCK_EPG   ,                 0,    0, XBMCVK_EPG,           "epg" }
-};
-
-static int XBMCKeyTableSize = sizeof(XBMCKeyTable)/sizeof(XBMCKEYTABLE);
+static const XBMCKEYTABLE XBMCKeyTable[] = {
+    {XBMCK_BACKSPACE, 0, 0, XBMCVK_BACK, "backspace"},
+    {XBMCK_TAB, 0, 0, XBMCVK_TAB, "tab"},
+    {XBMCK_RETURN, 0, 0, XBMCVK_RETURN, "return"},
+    {XBMCK_ESCAPE, 0, 0, XBMCVK_ESCAPE, "escape"},
+    {0, 0, 0, XBMCVK_ESCAPE, "esc"} // Allowed abbreviation for "escape"
+
+    // Number keys on the main keyboard
+    ,
+    {XBMCK_0, '0', '0', XBMCVK_0, "zero"},
+    {XBMCK_1, '1', '1', XBMCVK_1, "one"},
+    {XBMCK_2, '2', '2', XBMCVK_2, "two"},
+    {XBMCK_3, '3', '3', XBMCVK_3, "three"},
+    {XBMCK_4, '4', '4', XBMCVK_4, "four"},
+    {XBMCK_5, '5', '5', XBMCVK_5, "five"},
+    {XBMCK_6, '6', '6', XBMCVK_6, "six"},
+    {XBMCK_7, '7', '7', XBMCVK_7, "seven"},
+    {XBMCK_8, '8', '8', XBMCVK_8, "eight"},
+    {XBMCK_9, '9', '9', XBMCVK_9, "nine"}
+
+    // A to Z - note that upper case A-Z don't have a matching name or
+    // vkey. Only the lower case a-z are used in key mappings.
+    ,
+    {XBMCK_a, 'A', 'A', XBMCVK_A, NULL},
+    {XBMCK_b, 'B', 'B', XBMCVK_B, NULL},
+    {XBMCK_c, 'C', 'C', XBMCVK_C, NULL},
+    {XBMCK_d, 'D', 'D', XBMCVK_D, NULL},
+    {XBMCK_e, 'E', 'E', XBMCVK_E, NULL},
+    {XBMCK_f, 'F', 'F', XBMCVK_F, NULL},
+    {XBMCK_g, 'G', 'G', XBMCVK_G, NULL},
+    {XBMCK_h, 'H', 'H', XBMCVK_H, NULL},
+    {XBMCK_i, 'I', 'I', XBMCVK_I, NULL},
+    {XBMCK_j, 'J', 'J', XBMCVK_J, NULL},
+    {XBMCK_k, 'K', 'K', XBMCVK_K, NULL},
+    {XBMCK_l, 'L', 'L', XBMCVK_L, NULL},
+    {XBMCK_m, 'M', 'M', XBMCVK_M, NULL},
+    {XBMCK_n, 'N', 'N', XBMCVK_N, NULL},
+    {XBMCK_o, 'O', 'O', XBMCVK_O, NULL},
+    {XBMCK_p, 'P', 'P', XBMCVK_P, NULL},
+    {XBMCK_q, 'Q', 'Q', XBMCVK_Q, NULL},
+    {XBMCK_r, 'R', 'R', XBMCVK_R, NULL},
+    {XBMCK_s, 'S', 'S', XBMCVK_S, NULL},
+    {XBMCK_t, 'T', 'T', XBMCVK_T, NULL},
+    {XBMCK_u, 'U', 'U', XBMCVK_U, NULL},
+    {XBMCK_v, 'V', 'V', XBMCVK_V, NULL},
+    {XBMCK_w, 'W', 'W', XBMCVK_W, NULL},
+    {XBMCK_x, 'X', 'X', XBMCVK_X, NULL},
+    {XBMCK_y, 'Y', 'Y', XBMCVK_Y, NULL},
+    {XBMCK_z, 'Z', 'Z', XBMCVK_Z, NULL}
+
+    ,
+    {XBMCK_a, 'a', 'a', XBMCVK_A, "a"},
+    {XBMCK_b, 'b', 'b', XBMCVK_B, "b"},
+    {XBMCK_c, 'c', 'c', XBMCVK_C, "c"},
+    {XBMCK_d, 'd', 'd', XBMCVK_D, "d"},
+    {XBMCK_e, 'e', 'e', XBMCVK_E, "e"},
+    {XBMCK_f, 'f', 'f', XBMCVK_F, "f"},
+    {XBMCK_g, 'g', 'g', XBMCVK_G, "g"},
+    {XBMCK_h, 'h', 'h', XBMCVK_H, "h"},
+    {XBMCK_i, 'i', 'i', XBMCVK_I, "i"},
+    {XBMCK_j, 'j', 'j', XBMCVK_J, "j"},
+    {XBMCK_k, 'k', 'k', XBMCVK_K, "k"},
+    {XBMCK_l, 'l', 'l', XBMCVK_L, "l"},
+    {XBMCK_m, 'm', 'm', XBMCVK_M, "m"},
+    {XBMCK_n, 'n', 'n', XBMCVK_N, "n"},
+    {XBMCK_o, 'o', 'o', XBMCVK_O, "o"},
+    {XBMCK_p, 'p', 'p', XBMCVK_P, "p"},
+    {XBMCK_q, 'q', 'q', XBMCVK_Q, "q"},
+    {XBMCK_r, 'r', 'r', XBMCVK_R, "r"},
+    {XBMCK_s, 's', 's', XBMCVK_S, "s"},
+    {XBMCK_t, 't', 't', XBMCVK_T, "t"},
+    {XBMCK_u, 'u', 'u', XBMCVK_U, "u"},
+    {XBMCK_v, 'v', 'v', XBMCVK_V, "v"},
+    {XBMCK_w, 'w', 'w', XBMCVK_W, "w"},
+    {XBMCK_x, 'x', 'x', XBMCVK_X, "x"},
+    {XBMCK_y, 'y', 'y', XBMCVK_Y, "y"},
+    {XBMCK_z, 'z', 'z', XBMCVK_Z, "z"}
+
+    // Misc printing characters
+    ,
+    {XBMCK_SPACE, ' ', ' ', XBMCVK_SPACE, "space"},
+    {XBMCK_EXCLAIM, '!', '!', XBMCVK_EXCLAIM, "exclaim"},
+    {XBMCK_QUOTEDBL, '"', '"', XBMCVK_QUOTEDBL, "doublequote"},
+    {XBMCK_HASH, '#', '#', XBMCVK_HASH, "hash"},
+    {XBMCK_DOLLAR, '$', '$', XBMCVK_DOLLAR, "dollar"},
+    {XBMCK_PERCENT, '%', '%', XBMCVK_PERCENT, "percent"},
+    {XBMCK_AMPERSAND, '&', '&', XBMCVK_AMPERSAND, "ampersand"},
+    {XBMCK_QUOTE, '\'', '\'', XBMCVK_QUOTE, "quote"},
+    {XBMCK_LEFTPAREN, '(', '(', XBMCVK_LEFTPAREN, "leftbracket"},
+    {XBMCK_RIGHTPAREN, ')', ')', XBMCVK_RIGHTPAREN, "rightbracket"},
+    {XBMCK_ASTERISK, '*', '*', XBMCVK_ASTERISK, "asterisk"},
+    {XBMCK_PLUS, '+', '+', XBMCVK_PLUS, "plus"},
+    {XBMCK_COMMA, ',', ',', XBMCVK_COMMA, "comma"},
+    {XBMCK_MINUS, '-', '-', XBMCVK_MINUS, "minus"},
+    {XBMCK_PERIOD, '.', '.', XBMCVK_PERIOD, "period"},
+    {XBMCK_SLASH, '/', '/', XBMCVK_SLASH, "forwardslash"}
+
+    ,
+    {XBMCK_COLON, ':', ':', XBMCVK_COLON, "colon"},
+    {XBMCK_SEMICOLON, ';', ';', XBMCVK_SEMICOLON, "semicolon"},
+    {XBMCK_LESS, '<', '<', XBMCVK_LESS, "lessthan"},
+    {XBMCK_EQUALS, '=', '=', XBMCVK_EQUALS, "equals"},
+    {XBMCK_GREATER, '>', '>', XBMCVK_GREATER, "greaterthan"},
+    {XBMCK_QUESTION, '?', '?', XBMCVK_QUESTION, "questionmark"},
+    {XBMCK_AT, '@', '@', XBMCVK_AT, "at"}
+
+    ,
+    {XBMCK_LEFTBRACKET, '[', '[', XBMCVK_LEFTBRACKET, "opensquarebracket"},
+    {XBMCK_BACKSLASH, '\\', '\\', XBMCVK_BACKSLASH, "backslash"},
+    {XBMCK_RIGHTBRACKET, ']', ']', XBMCVK_RIGHTBRACKET, "closesquarebracket"},
+    {XBMCK_CARET, '^', '^', XBMCVK_CARET, "caret"},
+    {XBMCK_UNDERSCORE, '_', '_', XBMCVK_UNDERSCORE, "underline"},
+    {XBMCK_BACKQUOTE, '`', '`', XBMCVK_BACKQUOTE, "leftquote"}
+
+    ,
+    {XBMCK_LEFTBRACE, '{', '{', XBMCVK_LEFTBRACE, "openbrace"},
+    {XBMCK_PIPE, '|', '|', XBMCVK_PIPE, "pipe"},
+    {XBMCK_RIGHTBRACE, '}', '}', XBMCVK_RIGHTBRACE, "closebrace"},
+    {XBMCK_TILDE, '~', '~', XBMCVK_TILDE, "tilde"}
+
+    // Numeric keypad
+    ,
+    {XBMCK_KP0, '0', '0', XBMCVK_NUMPAD0, "numpadzero"},
+    {XBMCK_KP1, '1', '1', XBMCVK_NUMPAD1, "numpadone"},
+    {XBMCK_KP2, '2', '2', XBMCVK_NUMPAD2, "numpadtwo"},
+    {XBMCK_KP3, '3', '3', XBMCVK_NUMPAD3, "numpadthree"},
+    {XBMCK_KP4, '4', '4', XBMCVK_NUMPAD4, "numpadfour"},
+    {XBMCK_KP5, '5', '5', XBMCVK_NUMPAD5, "numpadfive"},
+    {XBMCK_KP6, '6', '6', XBMCVK_NUMPAD6, "numpadsix"},
+    {XBMCK_KP7, '7', '7', XBMCVK_NUMPAD7, "numpadseven"},
+    {XBMCK_KP8, '8', '8', XBMCVK_NUMPAD8, "numpadeight"},
+    {XBMCK_KP9, '9', '9', XBMCVK_NUMPAD9, "numpadnine"}
+
+    ,
+    {XBMCK_KP_DIVIDE, '/', '/', XBMCVK_NUMPADDIVIDE, "numpaddivide"},
+    {XBMCK_KP_MULTIPLY, '*', '*', XBMCVK_NUMPADTIMES, "numpadtimes"},
+    {XBMCK_KP_MINUS, '-', '-', XBMCVK_NUMPADMINUS, "numpadminus"},
+    {XBMCK_KP_PLUS, '+', '+', XBMCVK_NUMPADPLUS, "numpadplus"},
+    {XBMCK_KP_ENTER, 0, 0, XBMCVK_NUMPADENTER, "enter"},
+    {XBMCK_KP_PERIOD, '.', '.', XBMCVK_NUMPADPERIOD, "numpadperiod"}
+
+    // Multimedia keys
+    ,
+    {XBMCK_BROWSER_BACK, 0, 0, XBMCVK_BROWSER_BACK, "browser_back"},
+    {XBMCK_BROWSER_FORWARD, 0, 0, XBMCVK_BROWSER_FORWARD, "browser_forward"},
+    {XBMCK_BROWSER_REFRESH, 0, 0, XBMCVK_BROWSER_REFRESH, "browser_refresh"},
+    {XBMCK_BROWSER_STOP, 0, 0, XBMCVK_BROWSER_STOP, "browser_stop"},
+    {XBMCK_BROWSER_SEARCH, 0, 0, XBMCVK_BROWSER_SEARCH, "browser_search"},
+    {XBMCK_BROWSER_FAVORITES, 0, 0, XBMCVK_BROWSER_FAVORITES, "browser_favorites"},
+    {XBMCK_BROWSER_HOME, 0, 0, XBMCVK_BROWSER_HOME, "browser_home"},
+    {XBMCK_VOLUME_MUTE, 0, 0, XBMCVK_VOLUME_MUTE, "volume_mute"},
+    {XBMCK_VOLUME_DOWN, 0, 0, XBMCVK_VOLUME_DOWN, "volume_down"},
+    {XBMCK_VOLUME_UP, 0, 0, XBMCVK_VOLUME_UP, "volume_up"},
+    {XBMCK_MEDIA_NEXT_TRACK, 0, 0, XBMCVK_MEDIA_NEXT_TRACK, "next_track"},
+    {XBMCK_MEDIA_PREV_TRACK, 0, 0, XBMCVK_MEDIA_PREV_TRACK, "prev_track"},
+    {XBMCK_MEDIA_STOP, 0, 0, XBMCVK_MEDIA_STOP, "stop"},
+    {XBMCK_MEDIA_PLAY_PAUSE, 0, 0, XBMCVK_MEDIA_PLAY_PAUSE, "play_pause"},
+    {XBMCK_MEDIA_REWIND, 0, 0, XBMCVK_MEDIA_REWIND, "rewind"},
+    {XBMCK_MEDIA_FASTFORWARD, 0, 0, XBMCVK_MEDIA_FASTFORWARD, "fastforward"},
+    {XBMCK_LAUNCH_MAIL, 0, 0, XBMCVK_LAUNCH_MAIL, "launch_mail"},
+    {XBMCK_LAUNCH_MEDIA_SELECT, 0, 0, XBMCVK_LAUNCH_MEDIA_SELECT, "launch_media_select"},
+    {XBMCK_LAUNCH_APP1, 0, 0, XBMCVK_LAUNCH_APP1, "launch_app1_pc_icon"},
+    {XBMCK_LAUNCH_APP2, 0, 0, XBMCVK_LAUNCH_APP2, "launch_app2_pc_icon"},
+    {XBMCK_LAUNCH_FILE_BROWSER, 0, 0, XBMCVK_LAUNCH_FILE_BROWSER, "launch_file_browser"},
+    {XBMCK_LAUNCH_MEDIA_CENTER, 0, 0, XBMCVK_LAUNCH_MEDIA_CENTER, "launch_media_center"},
+    {XBMCK_PLAY, 0, 0, XBMCVK_MEDIA_PLAY_PAUSE, "play_pause"},
+    {XBMCK_STOP, 0, 0, XBMCVK_MEDIA_STOP, "stop"},
+    {XBMCK_REWIND, 0, 0, XBMCVK_MEDIA_REWIND, "rewind"},
+    {XBMCK_FASTFORWARD, 0, 0, XBMCVK_MEDIA_FASTFORWARD, "fastforward"},
+    {XBMCK_RECORD, 0, 0, XBMCVK_MEDIA_RECORD, "record"}
+
+
+    // Function keys
+    ,
+    {XBMCK_F1, 0, 0, XBMCVK_F1, "f1"},
+    {XBMCK_F2, 0, 0, XBMCVK_F2, "f2"},
+    {XBMCK_F3, 0, 0, XBMCVK_F3, "f3"},
+    {XBMCK_F4, 0, 0, XBMCVK_F4, "f4"},
+    {XBMCK_F5, 0, 0, XBMCVK_F5, "f5"},
+    {XBMCK_F6, 0, 0, XBMCVK_F6, "f6"},
+    {XBMCK_F7, 0, 0, XBMCVK_F7, "f7"},
+    {XBMCK_F8, 0, 0, XBMCVK_F8, "f8"},
+    {XBMCK_F9, 0, 0, XBMCVK_F9, "f9"},
+    {XBMCK_F10, 0, 0, XBMCVK_F10, "f10"},
+    {XBMCK_F11, 0, 0, XBMCVK_F11, "f11"},
+    {XBMCK_F12, 0, 0, XBMCVK_F12, "f12"},
+    {XBMCK_F13, 0, 0, XBMCVK_F13, "f13"},
+    {XBMCK_F14, 0, 0, XBMCVK_F14, "f14"},
+    {XBMCK_F15, 0, 0, XBMCVK_F15, "f15"}
+
+    // Misc non-printing keys
+    ,
+    {XBMCK_UP, 0, 0, XBMCVK_UP, "up"},
+    {XBMCK_DOWN, 0, 0, XBMCVK_DOWN, "down"},
+    {XBMCK_RIGHT, 0, 0, XBMCVK_RIGHT, "right"},
+    {XBMCK_LEFT, 0, 0, XBMCVK_LEFT, "left"},
+    {XBMCK_INSERT, 0, 0, XBMCVK_INSERT, "insert"},
+    {XBMCK_DELETE, 0, 0, XBMCVK_DELETE, "delete"},
+    {XBMCK_HOME, 0, 0, XBMCVK_HOME, "home"},
+    {XBMCK_END, 0, 0, XBMCVK_END, "end"},
+    {XBMCK_PAGEUP, 0, 0, XBMCVK_PAGEUP, "pageup"},
+    {XBMCK_PAGEDOWN, 0, 0, XBMCVK_PAGEDOWN, "pagedown"},
+    {XBMCK_NUMLOCK, 0, 0, XBMCVK_NUMLOCK, "numlock"},
+    {XBMCK_CAPSLOCK, 0, 0, XBMCVK_CAPSLOCK, "capslock"},
+    {XBMCK_RSHIFT, 0, 0, XBMCVK_RSHIFT, "rightshift"},
+    {XBMCK_LSHIFT, 0, 0, XBMCVK_LSHIFT, "leftshift"},
+    {XBMCK_RCTRL, 0, 0, XBMCVK_RCONTROL, "rightctrl"},
+    {XBMCK_LCTRL, 0, 0, XBMCVK_LCONTROL, "leftctrl"},
+    {XBMCK_LALT, 0, 0, XBMCVK_LMENU, "leftalt"},
+    {XBMCK_LSUPER, 0, 0, XBMCVK_LWIN, "leftwindows"},
+    {XBMCK_RSUPER, 0, 0, XBMCVK_RWIN, "rightwindows"},
+    {XBMCK_MENU, 0, 0, XBMCVK_MENU, "menu"},
+    {XBMCK_PAUSE, 0, 0, XBMCVK_PAUSE, "pause"},
+    {XBMCK_SCROLLOCK, 0, 0, XBMCVK_SCROLLLOCK, "scrolllock"},
+    {XBMCK_PRINT, 0, 0, XBMCVK_PRINTSCREEN, "printscreen"},
+    {XBMCK_POWER, 0, 0, XBMCVK_POWER, "power"},
+    {XBMCK_SLEEP, 0, 0, XBMCVK_SLEEP, "sleep"},
+    {XBMCK_GUIDE, 0, 0, XBMCVK_GUIDE, "guide"},
+    {XBMCK_SETTINGS, 0, 0, XBMCVK_SETTINGS, "settings"},
+    {XBMCK_INFO, 0, 0, XBMCVK_INFO, "info"},
+    {XBMCK_RED, 0, 0, XBMCVK_RED, "red"},
+    {XBMCK_GREEN, 0, 0, XBMCVK_GREEN, "green"},
+    {XBMCK_YELLOW, 0, 0, XBMCVK_YELLOW, "yellow"},
+    {XBMCK_BLUE, 0, 0, XBMCVK_BLUE, "blue"},
+    {XBMCK_ZOOM, 0, 0, XBMCVK_ZOOM, "zoom"},
+    {XBMCK_TEXT, 0, 0, XBMCVK_TEXT, "text"},
+    {XBMCK_FAVORITES, 0, 0, XBMCVK_FAVORITES, "favorites"},
+    {XBMCK_HOMEPAGE, 0, 0, XBMCVK_HOMEPAGE, "homepage"},
+    {XBMCK_CONFIG, 0, 0, XBMCVK_CONFIG, "config"},
+    {XBMCK_EPG, 0, 0, XBMCVK_EPG, "epg"}};
+
+static int XBMCKeyTableSize = sizeof(XBMCKeyTable) / sizeof(XBMCKEYTABLE);
 
 bool KeyTableLookupName(std::string keyname, XBMCKEYTABLE* keytable)
 {
@@ -247,9 +258,12 @@ bool KeyTableLookupName(std::string keyname, XBMCKEYTABLE* keytable)
 
   // Look up the key name in XBMCKeyTable
   for (int i = 0; i < XBMCKeyTableSize; i++)
-  { if (XBMCKeyTable[i].keyname)
-    { if (strcmp(keyname.c_str(), XBMCKeyTable[i].keyname) == 0)
-      { *keytable = XBMCKeyTable[i];
+  {
+    if (XBMCKeyTable[i].keyname)
+    {
+      if (strcmp(keyname.c_str(), XBMCKeyTable[i].keyname) == 0)
+      {
+        *keytable = XBMCKeyTable[i];
         return true;
       }
     }
@@ -267,8 +281,10 @@ bool KeyTableLookupSym(uint16_t sym, XBMCKEYTABLE* keytable)
 
   // Look up the sym in XBMCKeyTable
   for (int i = 0; i < XBMCKeyTableSize; i++)
-  { if (sym == XBMCKeyTable[i].sym)
-    { *keytable = XBMCKeyTable[i];
+  {
+    if (sym == XBMCKeyTable[i].sym)
+    {
+      *keytable = XBMCKeyTable[i];
       return true;
     }
   }
@@ -285,8 +301,10 @@ bool KeyTableLookupUnicode(uint16_t unicode, XBMCKEYTABLE* keytable)
 
   // Look up the unicode in XBMCKeyTable
   for (int i = 0; i < XBMCKeyTableSize; i++)
-  { if (unicode == XBMCKeyTable[i].unicode)
-    { *keytable = XBMCKeyTable[i];
+  {
+    if (unicode == XBMCKeyTable[i].unicode)
+    {
+      *keytable = XBMCKeyTable[i];
       return true;
     }
   }
@@ -304,8 +322,10 @@ bool KeyTableLookupSymAndUnicode(uint16_t sym, uint16_t unicode, XBMCKEYTABLE* k
 
   // Look up the sym and unicode in XBMCKeyTable
   for (int i = 0; i < XBMCKeyTableSize; i++)
-  { if (sym == XBMCKeyTable[i].sym && unicode == XBMCKeyTable[i].unicode)
-    { *keytable = XBMCKeyTable[i];
+  {
+    if (sym == XBMCKeyTable[i].sym && unicode == XBMCKeyTable[i].unicode)
+    {
+      *keytable = XBMCKeyTable[i];
       return true;
     }
   }
@@ -322,8 +342,10 @@ bool KeyTableLookupVKeyName(uint32_t vkey, XBMCKEYTABLE* keytable)
 
   // Look up the vkey in XBMCKeyTable
   for (int i = 0; i < XBMCKeyTableSize; i++)
-  { if (vkey == XBMCKeyTable[i].vkey && XBMCKeyTable[i].keyname)
-    { *keytable = XBMCKeyTable[i];
+  {
+    if (vkey == XBMCKeyTable[i].vkey && XBMCKeyTable[i].keyname)
+    {
+      *keytable = XBMCKeyTable[i];
       return true;
     }
   }
diff --git a/xbmc/input/XBMC_keytable.h b/xbmc/input/XBMC_keytable.h
index 22751c88fd60..1a4990ee0fa9 100644
--- a/xbmc/input/XBMC_keytable.h
+++ b/xbmc/input/XBMC_keytable.h
@@ -24,14 +24,14 @@ typedef struct struct_XBMCKEYTABLE
   // key is a non-printing character, e.g. a function or arrow key,
   // the unicode and ascii member variables are zero.
   uint16_t unicode;
-  char     ascii;
+  char ascii;
 
   // The following two member variables are used to specify the
   // action/function assigned to a key.
   // The keynames are used as tags in keyboard.xml. When reading keyboard.xml
   // TranslateKeyboardString uses the keyname to look up the vkey, and
   // this is used in the mapping table.
-  uint32_t    vkey;
+  uint32_t vkey;
   const char* keyname;
 
 } XBMCKEYTABLE;
@@ -41,4 +41,3 @@ bool KeyTableLookupSym(uint16_t sym, XBMCKEYTABLE* keytable);
 bool KeyTableLookupUnicode(uint16_t unicode, XBMCKEYTABLE* keytable);
 bool KeyTableLookupSymAndUnicode(uint16_t sym, uint16_t unicode, XBMCKEYTABLE* keytable);
 bool KeyTableLookupVKeyName(uint32_t vkey, XBMCKEYTABLE* keytable);
-
diff --git a/xbmc/input/XBMC_vkeys.h b/xbmc/input/XBMC_vkeys.h
index 496f33662927..833d2dafade6 100644
--- a/xbmc/input/XBMC_vkeys.h
+++ b/xbmc/input/XBMC_vkeys.h
@@ -18,256 +18,256 @@
 // Non-printing keypresses get a value in the range 0x80 - 0xFF.
 // Note that the vkey is a byte value so it cannot be greater than 0xFF.
 
-typedef enum {
-  XBMCVK_BACK           = 0x08,
-  XBMCVK_TAB            = 0x09,
-  XBMCVK_RETURN         = 0x0D,
-  XBMCVK_ESCAPE         = 0x1B,
+typedef enum
+{
+  XBMCVK_BACK = 0x08,
+  XBMCVK_TAB = 0x09,
+  XBMCVK_RETURN = 0x0D,
+  XBMCVK_ESCAPE = 0x1B,
 
-  XBMCVK_SPACE          = 0x20,
-  XBMCVK_EXCLAIM        = 0x21,
-  XBMCVK_QUOTEDBL       = 0x22,
-  XBMCVK_HASH           = 0x23,
-  XBMCVK_DOLLAR         = 0x24,
-  XBMCVK_PERCENT        = 0x25,
-  XBMCVK_AMPERSAND      = 0x26,
-  XBMCVK_QUOTE          = 0x27,
-  XBMCVK_LEFTPAREN      = 0x28,
-  XBMCVK_RIGHTPAREN     = 0x29,
-  XBMCVK_ASTERISK       = 0x2A,
-  XBMCVK_PLUS           = 0x2B,
-  XBMCVK_COMMA          = 0x2C,
-  XBMCVK_MINUS          = 0x2D,
-  XBMCVK_PERIOD         = 0x2E,
-  XBMCVK_SLASH          = 0x2F,
+  XBMCVK_SPACE = 0x20,
+  XBMCVK_EXCLAIM = 0x21,
+  XBMCVK_QUOTEDBL = 0x22,
+  XBMCVK_HASH = 0x23,
+  XBMCVK_DOLLAR = 0x24,
+  XBMCVK_PERCENT = 0x25,
+  XBMCVK_AMPERSAND = 0x26,
+  XBMCVK_QUOTE = 0x27,
+  XBMCVK_LEFTPAREN = 0x28,
+  XBMCVK_RIGHTPAREN = 0x29,
+  XBMCVK_ASTERISK = 0x2A,
+  XBMCVK_PLUS = 0x2B,
+  XBMCVK_COMMA = 0x2C,
+  XBMCVK_MINUS = 0x2D,
+  XBMCVK_PERIOD = 0x2E,
+  XBMCVK_SLASH = 0x2F,
 
-  XBMCVK_0              = 0x30,
-  XBMCVK_1              = 0x31,
-  XBMCVK_2              = 0x32,
-  XBMCVK_3              = 0x33,
-  XBMCVK_4              = 0x34,
-  XBMCVK_5              = 0x35,
-  XBMCVK_6              = 0x36,
-  XBMCVK_7              = 0x37,
-  XBMCVK_8              = 0x38,
-  XBMCVK_9              = 0x39,
+  XBMCVK_0 = 0x30,
+  XBMCVK_1 = 0x31,
+  XBMCVK_2 = 0x32,
+  XBMCVK_3 = 0x33,
+  XBMCVK_4 = 0x34,
+  XBMCVK_5 = 0x35,
+  XBMCVK_6 = 0x36,
+  XBMCVK_7 = 0x37,
+  XBMCVK_8 = 0x38,
+  XBMCVK_9 = 0x39,
 
-  XBMCVK_COLON          = 0x3A,
-  XBMCVK_SEMICOLON      = 0x3B,
-  XBMCVK_LESS           = 0x3C,
-  XBMCVK_EQUALS         = 0x3D,
-  XBMCVK_GREATER        = 0x3E,
-  XBMCVK_QUESTION       = 0x3F,
-  XBMCVK_AT             = 0x40,
+  XBMCVK_COLON = 0x3A,
+  XBMCVK_SEMICOLON = 0x3B,
+  XBMCVK_LESS = 0x3C,
+  XBMCVK_EQUALS = 0x3D,
+  XBMCVK_GREATER = 0x3E,
+  XBMCVK_QUESTION = 0x3F,
+  XBMCVK_AT = 0x40,
 
-  XBMCVK_A              = 0x41,
-  XBMCVK_B              = 0x42,
-  XBMCVK_C              = 0x43,
-  XBMCVK_D              = 0x44,
-  XBMCVK_E              = 0x45,
-  XBMCVK_F              = 0x46,
-  XBMCVK_G              = 0x47,
-  XBMCVK_H              = 0x48,
-  XBMCVK_I              = 0x49,
-  XBMCVK_J              = 0x4A,
-  XBMCVK_K              = 0x4B,
-  XBMCVK_L              = 0x4C,
-  XBMCVK_M              = 0x4D,
-  XBMCVK_N              = 0x4E,
-  XBMCVK_O              = 0x4F,
-  XBMCVK_P              = 0x50,
-  XBMCVK_Q              = 0x51,
-  XBMCVK_R              = 0x52,
-  XBMCVK_S              = 0x53,
-  XBMCVK_T              = 0x54,
-  XBMCVK_U              = 0x55,
-  XBMCVK_V              = 0x56,
-  XBMCVK_W              = 0x57,
-  XBMCVK_X              = 0x58,
-  XBMCVK_Y              = 0x59,
-  XBMCVK_Z              = 0x5A,
+  XBMCVK_A = 0x41,
+  XBMCVK_B = 0x42,
+  XBMCVK_C = 0x43,
+  XBMCVK_D = 0x44,
+  XBMCVK_E = 0x45,
+  XBMCVK_F = 0x46,
+  XBMCVK_G = 0x47,
+  XBMCVK_H = 0x48,
+  XBMCVK_I = 0x49,
+  XBMCVK_J = 0x4A,
+  XBMCVK_K = 0x4B,
+  XBMCVK_L = 0x4C,
+  XBMCVK_M = 0x4D,
+  XBMCVK_N = 0x4E,
+  XBMCVK_O = 0x4F,
+  XBMCVK_P = 0x50,
+  XBMCVK_Q = 0x51,
+  XBMCVK_R = 0x52,
+  XBMCVK_S = 0x53,
+  XBMCVK_T = 0x54,
+  XBMCVK_U = 0x55,
+  XBMCVK_V = 0x56,
+  XBMCVK_W = 0x57,
+  XBMCVK_X = 0x58,
+  XBMCVK_Y = 0x59,
+  XBMCVK_Z = 0x5A,
 
-  XBMCVK_LEFTBRACKET    = 0x5B,
-  XBMCVK_BACKSLASH      = 0x5C,
-  XBMCVK_RIGHTBRACKET   = 0x5D,
-  XBMCVK_CARET          = 0x5E,
-  XBMCVK_UNDERSCORE     = 0x5F,
-  XBMCVK_BACKQUOTE      = 0x60,
+  XBMCVK_LEFTBRACKET = 0x5B,
+  XBMCVK_BACKSLASH = 0x5C,
+  XBMCVK_RIGHTBRACKET = 0x5D,
+  XBMCVK_CARET = 0x5E,
+  XBMCVK_UNDERSCORE = 0x5F,
+  XBMCVK_BACKQUOTE = 0x60,
 
-// Lowercase letters 0x61 - 0x7a have the same vkey as uppercase, so
-// use this block for the numpad keys
-  XBMCVK_NUMPADDIVIDE   = 0x61,
-  XBMCVK_NUMPADTIMES    = 0x62,
-  XBMCVK_NUMPADMINUS    = 0x63,
-  XBMCVK_NUMPADPLUS     = 0x64,
-  XBMCVK_NUMPADENTER    = 0x65,
-  XBMCVK_NUMPADPERIOD   = 0x66,
-  XBMCVK_NUMPAD0        = 0x70,
-  XBMCVK_NUMPAD1        = 0x71,
-  XBMCVK_NUMPAD2        = 0x72,
-  XBMCVK_NUMPAD3        = 0x73,
-  XBMCVK_NUMPAD4        = 0x74,
-  XBMCVK_NUMPAD5        = 0x75,
-  XBMCVK_NUMPAD6        = 0x76,
-  XBMCVK_NUMPAD7        = 0x77,
-  XBMCVK_NUMPAD8        = 0x78,
-  XBMCVK_NUMPAD9        = 0x79,
+  // Lowercase letters 0x61 - 0x7a have the same vkey as uppercase, so
+  // use this block for the numpad keys
+  XBMCVK_NUMPADDIVIDE = 0x61,
+  XBMCVK_NUMPADTIMES = 0x62,
+  XBMCVK_NUMPADMINUS = 0x63,
+  XBMCVK_NUMPADPLUS = 0x64,
+  XBMCVK_NUMPADENTER = 0x65,
+  XBMCVK_NUMPADPERIOD = 0x66,
+  XBMCVK_NUMPAD0 = 0x70,
+  XBMCVK_NUMPAD1 = 0x71,
+  XBMCVK_NUMPAD2 = 0x72,
+  XBMCVK_NUMPAD3 = 0x73,
+  XBMCVK_NUMPAD4 = 0x74,
+  XBMCVK_NUMPAD5 = 0x75,
+  XBMCVK_NUMPAD6 = 0x76,
+  XBMCVK_NUMPAD7 = 0x77,
+  XBMCVK_NUMPAD8 = 0x78,
+  XBMCVK_NUMPAD9 = 0x79,
 
-  XBMCVK_LEFTBRACE      = 0x7B,
-  XBMCVK_PIPE           = 0x7C,
-  XBMCVK_RIGHTBRACE     = 0x7D,
-  XBMCVK_TILDE          = 0x7E,
+  XBMCVK_LEFTBRACE = 0x7B,
+  XBMCVK_PIPE = 0x7C,
+  XBMCVK_RIGHTBRACE = 0x7D,
+  XBMCVK_TILDE = 0x7E,
 
-// Non-printing characters
+  // Non-printing characters
 
-  XBMCVK_UP             = 0x80,
-  XBMCVK_DOWN           = 0x81,
-  XBMCVK_LEFT           = 0x82,
-  XBMCVK_RIGHT          = 0x83,
-  XBMCVK_PAGEUP         = 0x84,
-  XBMCVK_PAGEDOWN       = 0x85,
-  XBMCVK_INSERT         = 0x86,
-  XBMCVK_DELETE         = 0x87,
-  XBMCVK_HOME           = 0x88,
-  XBMCVK_END            = 0x89,
+  XBMCVK_UP = 0x80,
+  XBMCVK_DOWN = 0x81,
+  XBMCVK_LEFT = 0x82,
+  XBMCVK_RIGHT = 0x83,
+  XBMCVK_PAGEUP = 0x84,
+  XBMCVK_PAGEDOWN = 0x85,
+  XBMCVK_INSERT = 0x86,
+  XBMCVK_DELETE = 0x87,
+  XBMCVK_HOME = 0x88,
+  XBMCVK_END = 0x89,
 
-  XBMCVK_F1             = 0x90,
-  XBMCVK_F2             = 0x91,
-  XBMCVK_F3             = 0x92,
-  XBMCVK_F4             = 0x93,
-  XBMCVK_F5             = 0x94,
-  XBMCVK_F6             = 0x95,
-  XBMCVK_F7             = 0x96,
-  XBMCVK_F8             = 0x97,
-  XBMCVK_F9             = 0x98,
-  XBMCVK_F10            = 0x99,
-  XBMCVK_F11            = 0x9A,
-  XBMCVK_F12            = 0x9B,
-  XBMCVK_F13            = 0x9C,
-  XBMCVK_F14            = 0x9D,
-  XBMCVK_F15            = 0x9E,
-  XBMCVK_F16            = 0x9F,
-  XBMCVK_F17            = 0xA0,
-  XBMCVK_F18            = 0xA1,
-  XBMCVK_F19            = 0xA2,
-  XBMCVK_F20            = 0xA3,
-  XBMCVK_F21            = 0xA4,
-  XBMCVK_F22            = 0xA5,
-  XBMCVK_F23            = 0xA6,
-  XBMCVK_F24            = 0xA7,
+  XBMCVK_F1 = 0x90,
+  XBMCVK_F2 = 0x91,
+  XBMCVK_F3 = 0x92,
+  XBMCVK_F4 = 0x93,
+  XBMCVK_F5 = 0x94,
+  XBMCVK_F6 = 0x95,
+  XBMCVK_F7 = 0x96,
+  XBMCVK_F8 = 0x97,
+  XBMCVK_F9 = 0x98,
+  XBMCVK_F10 = 0x99,
+  XBMCVK_F11 = 0x9A,
+  XBMCVK_F12 = 0x9B,
+  XBMCVK_F13 = 0x9C,
+  XBMCVK_F14 = 0x9D,
+  XBMCVK_F15 = 0x9E,
+  XBMCVK_F16 = 0x9F,
+  XBMCVK_F17 = 0xA0,
+  XBMCVK_F18 = 0xA1,
+  XBMCVK_F19 = 0xA2,
+  XBMCVK_F20 = 0xA3,
+  XBMCVK_F21 = 0xA4,
+  XBMCVK_F22 = 0xA5,
+  XBMCVK_F23 = 0xA6,
+  XBMCVK_F24 = 0xA7,
 
-  XBMCVK_BROWSER_BACK        = 0xB0,
-  XBMCVK_BROWSER_FORWARD     = 0xB1,
-  XBMCVK_BROWSER_REFRESH     = 0xB2,
-  XBMCVK_BROWSER_STOP        = 0xB3,
-  XBMCVK_BROWSER_SEARCH      = 0xB4,
-  XBMCVK_BROWSER_FAVORITES   = 0xB5,
-  XBMCVK_BROWSER_HOME        = 0xB6,
-  XBMCVK_VOLUME_MUTE         = 0xB7,
-  XBMCVK_VOLUME_DOWN         = 0xB8,
-  XBMCVK_VOLUME_UP           = 0xB9,
-  XBMCVK_MEDIA_NEXT_TRACK    = 0xBA,
-  XBMCVK_MEDIA_PREV_TRACK    = 0xBB,
-  XBMCVK_MEDIA_STOP          = 0xBC,
-  XBMCVK_MEDIA_PLAY_PAUSE    = 0xBD,
-  XBMCVK_LAUNCH_MAIL         = 0xBE,
+  XBMCVK_BROWSER_BACK = 0xB0,
+  XBMCVK_BROWSER_FORWARD = 0xB1,
+  XBMCVK_BROWSER_REFRESH = 0xB2,
+  XBMCVK_BROWSER_STOP = 0xB3,
+  XBMCVK_BROWSER_SEARCH = 0xB4,
+  XBMCVK_BROWSER_FAVORITES = 0xB5,
+  XBMCVK_BROWSER_HOME = 0xB6,
+  XBMCVK_VOLUME_MUTE = 0xB7,
+  XBMCVK_VOLUME_DOWN = 0xB8,
+  XBMCVK_VOLUME_UP = 0xB9,
+  XBMCVK_MEDIA_NEXT_TRACK = 0xBA,
+  XBMCVK_MEDIA_PREV_TRACK = 0xBB,
+  XBMCVK_MEDIA_STOP = 0xBC,
+  XBMCVK_MEDIA_PLAY_PAUSE = 0xBD,
+  XBMCVK_LAUNCH_MAIL = 0xBE,
   XBMCVK_LAUNCH_MEDIA_SELECT = 0xBF,
-  XBMCVK_LAUNCH_APP1         = 0xC0,
-  XBMCVK_LAUNCH_APP2         = 0xC1,
+  XBMCVK_LAUNCH_APP1 = 0xC0,
+  XBMCVK_LAUNCH_APP2 = 0xC1,
   XBMCVK_LAUNCH_FILE_BROWSER = 0xC2,
   XBMCVK_LAUNCH_MEDIA_CENTER = 0xC3,
-  XBMCVK_MEDIA_REWIND        = 0xC4,
-  XBMCVK_MEDIA_FASTFORWARD   = 0xC5,
-  XBMCVK_MEDIA_RECORD        = 0xC6,
+  XBMCVK_MEDIA_REWIND = 0xC4,
+  XBMCVK_MEDIA_FASTFORWARD = 0xC5,
+  XBMCVK_MEDIA_RECORD = 0xC6,
 
-  XBMCVK_LCONTROL       = 0xD0,
-  XBMCVK_RCONTROL       = 0xD1,
-  XBMCVK_LSHIFT         = 0xD2,
-  XBMCVK_RSHIFT         = 0xD3,
-  XBMCVK_LMENU          = 0xD4,
-  XBMCVK_RMENU          = 0xD5,
-  XBMCVK_LWIN           = 0xD6,
-  XBMCVK_RWIN           = 0xD7,
-  XBMCVK_MENU           = 0xD8,
-  XBMCVK_CAPSLOCK       = 0xD9,
-  XBMCVK_NUMLOCK        = 0xDA,
+  XBMCVK_LCONTROL = 0xD0,
+  XBMCVK_RCONTROL = 0xD1,
+  XBMCVK_LSHIFT = 0xD2,
+  XBMCVK_RSHIFT = 0xD3,
+  XBMCVK_LMENU = 0xD4,
+  XBMCVK_RMENU = 0xD5,
+  XBMCVK_LWIN = 0xD6,
+  XBMCVK_RWIN = 0xD7,
+  XBMCVK_MENU = 0xD8,
+  XBMCVK_CAPSLOCK = 0xD9,
+  XBMCVK_NUMLOCK = 0xDA,
 
-  XBMCVK_PRINTSCREEN    = 0xDB,
-  XBMCVK_SCROLLLOCK     = 0xDC,
-  XBMCVK_PAUSE          = 0XDD,
-  XBMCVK_POWER          = 0XDE,
-  XBMCVK_SLEEP          = 0XDF,
-  XBMCVK_GUIDE          = 0xE0,
-  XBMCVK_SETTINGS       = 0xE1,
-  XBMCVK_INFO           = 0xE2,
-  XBMCVK_RED            = 0xE3,
-  XBMCVK_GREEN          = 0xE4,
-  XBMCVK_YELLOW         = 0xE5,
-  XBMCVK_BLUE           = 0xE6,
-  XBMCVK_ZOOM           = 0xE7,
-  XBMCVK_TEXT           = 0xE8,
-  XBMCVK_FAVORITES      = 0xE9,
-  XBMCVK_HOMEPAGE       = 0xEA,
-  XBMCVK_CONFIG         = 0xEB,
-  XBMCVK_EPG            = 0xEC,
+  XBMCVK_PRINTSCREEN = 0xDB,
+  XBMCVK_SCROLLLOCK = 0xDC,
+  XBMCVK_PAUSE = 0XDD,
+  XBMCVK_POWER = 0XDE,
+  XBMCVK_SLEEP = 0XDF,
+  XBMCVK_GUIDE = 0xE0,
+  XBMCVK_SETTINGS = 0xE1,
+  XBMCVK_INFO = 0xE2,
+  XBMCVK_RED = 0xE3,
+  XBMCVK_GREEN = 0xE4,
+  XBMCVK_YELLOW = 0xE5,
+  XBMCVK_BLUE = 0xE6,
+  XBMCVK_ZOOM = 0xE7,
+  XBMCVK_TEXT = 0xE8,
+  XBMCVK_FAVORITES = 0xE9,
+  XBMCVK_HOMEPAGE = 0xEA,
+  XBMCVK_CONFIG = 0xEB,
+  XBMCVK_EPG = 0xEC,
 
-  XBMCVK_LAST           = 0xFF
+  XBMCVK_LAST = 0xFF
 } XBMCVKey;
 
 // These should be in winuser.h. Not sure why they have been defined here
 #ifndef VK_0
-#define VK_0	'0'
-#define VK_1	'1'
-#define VK_2	'2'
-#define VK_3	'3'
-#define VK_4	'4'
-#define VK_5	'5'
-#define VK_6	'6'
-#define VK_7	'7'
-#define VK_8	'8'
-#define VK_9	'9'
-#define VK_A	'A'
-#define VK_B	'B'
-#define VK_C	'C'
-#define VK_D	'D'
-#define VK_E	'E'
-#define VK_F	'F'
-#define VK_G	'G'
-#define VK_H	'H'
-#define VK_I	'I'
-#define VK_J	'J'
-#define VK_K	'K'
-#define VK_L	'L'
-#define VK_M	'M'
-#define VK_N	'N'
-#define VK_O	'O'
-#define VK_P	'P'
-#define VK_Q	'Q'
-#define VK_R	'R'
-#define VK_S	'S'
-#define VK_T	'T'
-#define VK_U	'U'
-#define VK_V	'V'
-#define VK_W	'W'
-#define VK_X	'X'
-#define VK_Y	'Y'
-#define VK_Z	'Z'
+#define VK_0 '0'
+#define VK_1 '1'
+#define VK_2 '2'
+#define VK_3 '3'
+#define VK_4 '4'
+#define VK_5 '5'
+#define VK_6 '6'
+#define VK_7 '7'
+#define VK_8 '8'
+#define VK_9 '9'
+#define VK_A 'A'
+#define VK_B 'B'
+#define VK_C 'C'
+#define VK_D 'D'
+#define VK_E 'E'
+#define VK_F 'F'
+#define VK_G 'G'
+#define VK_H 'H'
+#define VK_I 'I'
+#define VK_J 'J'
+#define VK_K 'K'
+#define VK_L 'L'
+#define VK_M 'M'
+#define VK_N 'N'
+#define VK_O 'O'
+#define VK_P 'P'
+#define VK_Q 'Q'
+#define VK_R 'R'
+#define VK_S 'S'
+#define VK_T 'T'
+#define VK_U 'U'
+#define VK_V 'V'
+#define VK_W 'W'
+#define VK_X 'X'
+#define VK_Y 'Y'
+#define VK_Z 'Z'
 #endif /* VK_0 */
 
 /* These keys haven't been defined, but were experimentally determined */
 #ifndef VK_SEMICOLON
-#define VK_SEMICOLON	0xBA
-#define VK_EQUALS	0xBB
-#define VK_COMMA	0xBC
-#define VK_MINUS	0xBD
-#define VK_PERIOD	0xBE
-#define VK_SLASH	0xBF
-#define VK_GRAVE	0xC0
-#define VK_LBRACKET	0xDB
-#define VK_BACKSLASH	0xDC
-#define VK_RBRACKET	0xDD
-#define VK_APOSTROPHE	0xDE
-#define VK_BACKTICK	0xDF
-#define VK_OEM_102	0xE2
+#define VK_SEMICOLON 0xBA
+#define VK_EQUALS 0xBB
+#define VK_COMMA 0xBC
+#define VK_MINUS 0xBD
+#define VK_PERIOD 0xBE
+#define VK_SLASH 0xBF
+#define VK_GRAVE 0xC0
+#define VK_LBRACKET 0xDB
+#define VK_BACKSLASH 0xDC
+#define VK_RBRACKET 0xDD
+#define VK_APOSTROPHE 0xDE
+#define VK_BACKTICK 0xDF
+#define VK_OEM_102 0xE2
 #endif
-
diff --git a/xbmc/input/actions/Action.cpp b/xbmc/input/actions/Action.cpp
index 2ebda16b589b..59ca2a4907c4 100644
--- a/xbmc/input/actions/Action.cpp
+++ b/xbmc/input/actions/Action.cpp
@@ -12,12 +12,15 @@
 #include "ActionTranslator.h"
 #include "input/Key.h"
 
-CAction::CAction() :
-  m_id(ACTION_NONE)
+CAction::CAction() : m_id(ACTION_NONE)
 {
 }
 
-CAction::CAction(int actionID, float amount1 /* = 1.0f */, float amount2 /* = 0.0f */, const std::string &name /* = "" */, unsigned int holdTime /*= 0*/)
+CAction::CAction(int actionID,
+                 float amount1 /* = 1.0f */,
+                 float amount2 /* = 0.0f */,
+                 const std::string& name /* = "" */,
+                 unsigned int holdTime /*= 0*/)
 {
   m_id = actionID;
   m_amount[0] = amount1;
@@ -29,8 +32,16 @@ CAction::CAction(int actionID, float amount1 /* = 1.0f */, float amount2 /* = 0.
   m_holdTime = holdTime;
 }
 
-CAction::CAction(int actionID, unsigned int state, float posX, float posY, float offsetX, float offsetY, float velocityX, float velocityY, const std::string &name):
-  m_name(name)
+CAction::CAction(int actionID,
+                 unsigned int state,
+                 float posX,
+                 float posY,
+                 float offsetX,
+                 float offsetY,
+                 float velocityX,
+                 float velocityY,
+                 const std::string& name)
+  : m_name(name)
 {
   m_id = actionID;
   m_amount[0] = posX;
@@ -54,8 +65,7 @@ CAction::CAction(int actionID, wchar_t unicode)
   m_holdTime = 0;
 }
 
-CAction::CAction(int actionID, const std::string &name, const CKey &key):
-  m_name(name)
+CAction::CAction(int actionID, const std::string& name, const CKey& key) : m_name(name)
 {
   m_id = actionID;
   m_amount[0] = 1; // digital button (could change this for repeat acceleration)
@@ -96,8 +106,7 @@ CAction::CAction(int actionID, const std::string &name, const CKey &key):
     m_amount[0] = key.GetRightThumbX();
 }
 
-CAction::CAction(int actionID, const std::string &name):
-  m_name(name)
+CAction::CAction(int actionID, const std::string& name) : m_name(name)
 {
   m_id = actionID;
   m_repeat = 0;
diff --git a/xbmc/input/actions/Action.h b/xbmc/input/actions/Action.h
index 78d96bb0429f..940fc0555981 100644
--- a/xbmc/input/actions/Action.h
+++ b/xbmc/input/actions/Action.h
@@ -16,17 +16,30 @@ class CKey;
 
 /*!
   \ingroup actionkeys
-  \brief class encapsulating information regarding a particular user action to be sent to windows and controls
+  \brief class encapsulating information regarding a particular user action to be sent to windows
+  and controls
   */
 class CAction
 {
 public:
   CAction();
-  CAction(int actionID, float amount1 = 1.0f, float amount2 = 0.0f, const std::string &name = "", unsigned int holdTime = 0);
+  CAction(int actionID,
+          float amount1 = 1.0f,
+          float amount2 = 0.0f,
+          const std::string& name = "",
+          unsigned int holdTime = 0);
   CAction(int actionID, wchar_t unicode);
-  CAction(int actionID, unsigned int state, float posX, float posY, float offsetX, float offsetY, float velocityX = 0.0f, float velocityY = 0.0f, const std::string &name = "");
-  CAction(int actionID, const std::string &name, const CKey &key);
-  CAction(int actionID, const std::string &name);
+  CAction(int actionID,
+          unsigned int state,
+          float posX,
+          float posY,
+          float offsetX,
+          float offsetY,
+          float velocityX = 0.0f,
+          float velocityY = 0.0f,
+          const std::string& name = "");
+  CAction(int actionID, const std::string& name, const CKey& key);
+  CAction(int actionID, const std::string& name);
 
   CAction(const CAction& other) { *this = other; }
   CAction& operator=(const CAction& rhs);
@@ -46,23 +59,26 @@ class CAction
   /*! \brief Human-readable name of the action
    \return name of the action
    */
-  const std::string &GetName() const { return m_name; };
+  const std::string& GetName() const { return m_name; };
 
   /*! \brief Text of the action if any
    \return text payload of this action.
    */
-  const std::string &GetText() const { return m_text; };
+  const std::string& GetText() const { return m_text; };
 
   /*! \brief Set the text payload of the action
    \param text to be set
    */
-  void SetText(const std::string &text) { m_text = text; };
+  void SetText(const std::string& text) { m_text = text; };
 
   /*! \brief Get an amount associated with this action
    \param zero-based index of amount to retrieve, defaults to 0
    \return an amount associated with this action
    */
-  float GetAmount(unsigned int index = 0) const { return (index < max_amounts) ? m_amount[index] : 0; };
+  float GetAmount(unsigned int index = 0) const
+  {
+    return (index < max_amounts) ? m_amount[index] : 0;
+  };
 
   /*! \brief Reset all amount values to zero
    */
@@ -91,17 +107,17 @@ class CAction
   bool IsAnalog() const;
 
 private:
-  int          m_id;
-  std::string   m_name;
+  int m_id;
+  std::string m_name;
 
   static const unsigned int max_amounts = 6; // Must be at least 6
-  float        m_amount[max_amounts] = {};
+  float m_amount[max_amounts] = {};
 
-  float        m_repeat = 0.0f;
+  float m_repeat = 0.0f;
   unsigned int m_holdTime = 0;
   unsigned int m_buttonCode = 0;
-  wchar_t      m_unicode = 0;
-  std::string  m_text;
+  wchar_t m_unicode = 0;
+  std::string m_text;
 };
 
 #endif
diff --git a/xbmc/input/actions/ActionIDs.h b/xbmc/input/actions/ActionIDs.h
index 2ca1a554aa06..e68d2802825e 100644
--- a/xbmc/input/actions/ActionIDs.h
+++ b/xbmc/input/actions/ActionIDs.h
@@ -15,299 +15,367 @@
  * @{
  * @brief Actions that we have defined.
  */
-#define ACTION_NONE                    0
-#define ACTION_MOVE_LEFT               1
-#define ACTION_MOVE_RIGHT              2
-#define ACTION_MOVE_UP                 3
-#define ACTION_MOVE_DOWN               4
-#define ACTION_PAGE_UP                 5
-#define ACTION_PAGE_DOWN               6
-#define ACTION_SELECT_ITEM             7
-#define ACTION_HIGHLIGHT_ITEM          8
-#define ACTION_PARENT_DIR              9
-#define ACTION_PREVIOUS_MENU          10
-#define ACTION_SHOW_INFO              11
-
-#define ACTION_PAUSE                  12
-#define ACTION_STOP                   13
-#define ACTION_NEXT_ITEM              14
-#define ACTION_PREV_ITEM              15
-#define ACTION_FORWARD                16 //!< Can be used to specify specific action in a window, Playback control is handled in ACTION_PLAYER_*
-#define ACTION_REWIND                 17 //!< Can be used to specify specific action in a window, Playback control is handled in ACTION_PLAYER_*
-
-#define ACTION_SHOW_GUI               18 //!< toggle between GUI and movie or GUI and visualisation.
-#define ACTION_ASPECT_RATIO           19 //!< toggle quick-access zoom modes. Can b used in videoFullScreen.zml window id=2005
-#define ACTION_STEP_FORWARD           20 //!< seek +1% in the movie. Can b used in videoFullScreen.xml window id=2005
-#define ACTION_STEP_BACK              21 //!< seek -1% in the movie. Can b used in videoFullScreen.xml window id=2005
-#define ACTION_BIG_STEP_FORWARD       22 //!< seek +10% in the movie. Can b used in videoFullScreen.xml window id=2005
-#define ACTION_BIG_STEP_BACK          23 //!< seek -10% in the movie. Can b used in videoFullScreen.xml window id=2005
-#define ACTION_SHOW_OSD               24 //!< show/hide OSD. Can b used in videoFullScreen.xml window id=2005
-#define ACTION_SHOW_SUBTITLES         25 //!< turn subtitles on/off. Can b used in videoFullScreen.xml window id=2005
-#define ACTION_NEXT_SUBTITLE          26 //!< switch to next subtitle of movie. Can b used in videoFullScreen.xml window id=2005
-#define ACTION_BROWSE_SUBTITLE       247 //!< Browse for subtitle. Can be used in videofullscreen
-#define ACTION_PLAYER_DEBUG           27 //!< show debug info for VideoPlayer
-#define ACTION_NEXT_PICTURE           28 //!< show next picture of slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_PREV_PICTURE           29 //!< show previous picture of slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_OUT               30 //!< zoom in picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_IN                31 //!< zoom out picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_TOGGLE_SOURCE_DEST     32 //!< used to toggle between source view and destination view. Can be used in myfiles.xml window id=3
-#define ACTION_SHOW_PLAYLIST          33 //!< used to toggle between current view and playlist view. Can b used in all mymusic xml files
-#define ACTION_QUEUE_ITEM             34 //!< used to queue a item to the playlist. Can b used in all mymusic xml files
-#define ACTION_REMOVE_ITEM            35 //!< not used anymore
-#define ACTION_SHOW_FULLSCREEN        36 //!< not used anymore
-#define ACTION_ZOOM_LEVEL_NORMAL      37 //!< zoom 1x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_1           38 //!< zoom 2x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_2           39 //!< zoom 3x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_3           40 //!< zoom 4x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_4           41 //!< zoom 5x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_5           42 //!< zoom 6x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_6           43 //!< zoom 7x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_7           44 //!< zoom 8x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_8           45 //!< zoom 9x picture during slideshow. Can b used in slideshow.xml window id=2007
-#define ACTION_ZOOM_LEVEL_9           46 //!< zoom 10x picture during slideshow. Can b used in slideshow.xml window id=2007
-
-#define ACTION_CALIBRATE_SWAP_ARROWS  47 //!< select next arrow. Can b used in: settingsScreenCalibration.xml windowid=11
-#define ACTION_CALIBRATE_RESET        48 //!< reset calibration to defaults. Can b used in: `settingsScreenCalibration.xml` windowid=11/settingsUICalibration.xml windowid=10
-#define ACTION_ANALOG_MOVE            49 //!< analog thumbstick move. Can b used in: `slideshow.xml` windowid=2007/settingsScreenCalibration.xml windowid=11/settingsUICalibration.xml windowid=10
-                                         //!< @note see also ACTION_ANALOG_MOVE_X_LEFT, ACTION_ANALOG_MOVE_X_RIGHT, ACTION_ANALOG_MOVE_Y_UP, ACTION_ANALOG_MOVE_Y_DOWN
-#define ACTION_ROTATE_PICTURE_CW      50 //!< rotate current picture clockwise during slideshow. Can be used in slideshow.xml window id=2007
-#define ACTION_ROTATE_PICTURE_CCW     51 //!< rotate current picture counterclockwise during slideshow. Can be used in slideshow.xml window id=2007
-
-#define ACTION_SUBTITLE_DELAY_MIN     52 //!< Decrease subtitle/movie Delay.  Can b used in videoFullScreen.xml window id=2005
-#define ACTION_SUBTITLE_DELAY_PLUS    53 //!< Increase subtitle/movie Delay.  Can b used in videoFullScreen.xml window id=2005
-#define ACTION_AUDIO_DELAY_MIN        54 //!< Increase avsync delay.  Can b used in videoFullScreen.xml window id=2005
-#define ACTION_AUDIO_DELAY_PLUS       55 //!< Decrease avsync delay.  Can b used in videoFullScreen.xml window id=2005
-#define ACTION_AUDIO_NEXT_LANGUAGE    56 //!< Select next language in movie.  Can b used in videoFullScreen.xml window id=2005
-#define ACTION_CHANGE_RESOLUTION      57 //!< switch 2 next resolution. Can b used during screen calibration settingsScreenCalibration.xml windowid=11
-
-#define REMOTE_0                      58  //!< remote keys 0-9. are used by multiple windows
-#define REMOTE_1                      59  //!< for example in videoFullScreen.xml window id=2005 you can
-#define REMOTE_2                      60  //!< enter time (mmss) to jump to particular point in the movie
-#define REMOTE_3                      61
-#define REMOTE_4                      62  //!< with spincontrols you can enter 3digit number to quickly set
-#define REMOTE_5                      63  //!< spincontrol to desired value
-#define REMOTE_6                      64
-#define REMOTE_7                      65
-#define REMOTE_8                      66
-#define REMOTE_9                      67
-
-#define ACTION_PLAYER_PROCESS_INFO    69 //!< show player process info (video decoder, pixel format, pvr signal strength and the like
-#define ACTION_PLAYER_PROGRAM_SELECT  70
-#define ACTION_PLAYER_RESOLUTION_SELECT  71
-#define ACTION_SMALL_STEP_BACK        76  //!< jumps a few seconds back during playback of movie. Can b used in videoFullScreen.xml window id=2005
-
-#define ACTION_PLAYER_FORWARD         77  //!< FF in current file played. global action, can be used anywhere
-#define ACTION_PLAYER_REWIND          78  //!< RW in current file played. global action, can be used anywhere
-#define ACTION_PLAYER_PLAY            79  //!< Play current song. Unpauses song and sets playspeed to 1x. global action, can be used anywhere
-
-#define ACTION_DELETE_ITEM            80  //!< delete current selected item. Can be used in myfiles.xml window id=3 and in myvideoTitle.xml window id=25
-#define ACTION_COPY_ITEM              81  //!< copy current selected item. Can be used in myfiles.xml window id=3
-#define ACTION_MOVE_ITEM              82  //!< move current selected item. Can be used in myfiles.xml window id=3
-#define ACTION_TAKE_SCREENSHOT        85  //!< take a screenshot
-#define ACTION_RENAME_ITEM            87  //!< rename item
-
-#define ACTION_VOLUME_UP            88
-#define ACTION_VOLUME_DOWN          89
-#define ACTION_VOLAMP               90
-#define ACTION_MUTE                 91
-#define ACTION_NAV_BACK             92
-#define ACTION_VOLAMP_UP            93
-#define ACTION_VOLAMP_DOWN          94
-
-#define ACTION_CREATE_EPISODE_BOOKMARK 95 //!< Creates an episode bookmark on the currently playing video file containing more than one episode
-#define ACTION_CREATE_BOOKMARK         96 //!< Creates a bookmark of the currently playing video file
-
-#define ACTION_CHAPTER_OR_BIG_STEP_FORWARD       97 //!< Goto the next chapter, if not available perform a big step forward
-#define ACTION_CHAPTER_OR_BIG_STEP_BACK          98 //!< Goto the previous chapter, if not available perform a big step back
-
-#define ACTION_CYCLE_SUBTITLE         99 //!< switch to next subtitle of movie, but will not enable/disable the subtitles. Can be used in videoFullScreen.xml window id=2005
-
-#define ACTION_MOUSE_START            100
-#define ACTION_MOUSE_LEFT_CLICK       100
-#define ACTION_MOUSE_RIGHT_CLICK      101
-#define ACTION_MOUSE_MIDDLE_CLICK     102
-#define ACTION_MOUSE_DOUBLE_CLICK     103
-#define ACTION_MOUSE_WHEEL_UP         104
-#define ACTION_MOUSE_WHEEL_DOWN       105
-#define ACTION_MOUSE_DRAG             106
-#define ACTION_MOUSE_MOVE             107
-#define ACTION_MOUSE_LONG_CLICK       108
-#define ACTION_MOUSE_DRAG_END         109
-#define ACTION_MOUSE_END              109
-
-#define ACTION_BACKSPACE          110
-#define ACTION_SCROLL_UP          111
-#define ACTION_SCROLL_DOWN        112
-#define ACTION_ANALOG_FORWARD     113
-#define ACTION_ANALOG_REWIND      114
-
-#define ACTION_MOVE_ITEM_UP       115  //!< move item up in playlist
-#define ACTION_MOVE_ITEM_DOWN     116  //!< move item down in playlist
-#define ACTION_CONTEXT_MENU       117  //!< pops up the context menu
+#define ACTION_NONE 0
+#define ACTION_MOVE_LEFT 1
+#define ACTION_MOVE_RIGHT 2
+#define ACTION_MOVE_UP 3
+#define ACTION_MOVE_DOWN 4
+#define ACTION_PAGE_UP 5
+#define ACTION_PAGE_DOWN 6
+#define ACTION_SELECT_ITEM 7
+#define ACTION_HIGHLIGHT_ITEM 8
+#define ACTION_PARENT_DIR 9
+#define ACTION_PREVIOUS_MENU 10
+#define ACTION_SHOW_INFO 11
+
+#define ACTION_PAUSE 12
+#define ACTION_STOP 13
+#define ACTION_NEXT_ITEM 14
+#define ACTION_PREV_ITEM 15
+#define ACTION_FORWARD \
+  16 //!< Can be used to specify specific action in a window, Playback control is handled in
+     //!< ACTION_PLAYER_*
+#define ACTION_REWIND \
+  17 //!< Can be used to specify specific action in a window, Playback control is handled in
+     //!< ACTION_PLAYER_*
+
+#define ACTION_SHOW_GUI 18 //!< toggle between GUI and movie or GUI and visualisation.
+#define ACTION_ASPECT_RATIO \
+  19 //!< toggle quick-access zoom modes. Can b used in videoFullScreen.zml window id=2005
+#define ACTION_STEP_FORWARD \
+  20 //!< seek +1% in the movie. Can b used in videoFullScreen.xml window id=2005
+#define ACTION_STEP_BACK \
+  21 //!< seek -1% in the movie. Can b used in videoFullScreen.xml window id=2005
+#define ACTION_BIG_STEP_FORWARD \
+  22 //!< seek +10% in the movie. Can b used in videoFullScreen.xml window id=2005
+#define ACTION_BIG_STEP_BACK \
+  23 //!< seek -10% in the movie. Can b used in videoFullScreen.xml window id=2005
+#define ACTION_SHOW_OSD 24 //!< show/hide OSD. Can b used in videoFullScreen.xml window id=2005
+#define ACTION_SHOW_SUBTITLES \
+  25 //!< turn subtitles on/off. Can b used in videoFullScreen.xml window id=2005
+#define ACTION_NEXT_SUBTITLE \
+  26 //!< switch to next subtitle of movie. Can b used in videoFullScreen.xml window id=2005
+#define ACTION_BROWSE_SUBTITLE 247 //!< Browse for subtitle. Can be used in videofullscreen
+#define ACTION_PLAYER_DEBUG 27 //!< show debug info for VideoPlayer
+#define ACTION_NEXT_PICTURE \
+  28 //!< show next picture of slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_PREV_PICTURE \
+  29 //!< show previous picture of slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_OUT \
+  30 //!< zoom in picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_IN \
+  31 //!< zoom out picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_TOGGLE_SOURCE_DEST \
+  32 //!< used to toggle between source view and destination view. Can be used in myfiles.xml window
+     //!< id=3
+#define ACTION_SHOW_PLAYLIST \
+  33 //!< used to toggle between current view and playlist view. Can b used in all mymusic xml files
+#define ACTION_QUEUE_ITEM \
+  34 //!< used to queue a item to the playlist. Can b used in all mymusic xml files
+#define ACTION_REMOVE_ITEM 35 //!< not used anymore
+#define ACTION_SHOW_FULLSCREEN 36 //!< not used anymore
+#define ACTION_ZOOM_LEVEL_NORMAL \
+  37 //!< zoom 1x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_1 \
+  38 //!< zoom 2x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_2 \
+  39 //!< zoom 3x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_3 \
+  40 //!< zoom 4x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_4 \
+  41 //!< zoom 5x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_5 \
+  42 //!< zoom 6x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_6 \
+  43 //!< zoom 7x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_7 \
+  44 //!< zoom 8x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_8 \
+  45 //!< zoom 9x picture during slideshow. Can b used in slideshow.xml window id=2007
+#define ACTION_ZOOM_LEVEL_9 \
+  46 //!< zoom 10x picture during slideshow. Can b used in slideshow.xml window id=2007
+
+#define ACTION_CALIBRATE_SWAP_ARROWS \
+  47 //!< select next arrow. Can b used in: settingsScreenCalibration.xml windowid=11
+#define ACTION_CALIBRATE_RESET \
+  48 //!< reset calibration to defaults. Can b used in: `settingsScreenCalibration.xml`
+     //!< windowid=11/settingsUICalibration.xml windowid=10
+#define ACTION_ANALOG_MOVE \
+  49 //!< analog thumbstick move. Can b used in: `slideshow.xml`
+     //!< windowid=2007/settingsScreenCalibration.xml windowid=11/settingsUICalibration.xml
+     //!< windowid=10
+     //!< @note see also ACTION_ANALOG_MOVE_X_LEFT, ACTION_ANALOG_MOVE_X_RIGHT,
+     //!< ACTION_ANALOG_MOVE_Y_UP, ACTION_ANALOG_MOVE_Y_DOWN
+#define ACTION_ROTATE_PICTURE_CW \
+  50 //!< rotate current picture clockwise during slideshow. Can be used in slideshow.xml window
+     //!< id=2007
+#define ACTION_ROTATE_PICTURE_CCW \
+  51 //!< rotate current picture counterclockwise during slideshow. Can be used in slideshow.xml
+     //!< window id=2007
+
+#define ACTION_SUBTITLE_DELAY_MIN \
+  52 //!< Decrease subtitle/movie Delay.  Can b used in videoFullScreen.xml window id=2005
+#define ACTION_SUBTITLE_DELAY_PLUS \
+  53 //!< Increase subtitle/movie Delay.  Can b used in videoFullScreen.xml window id=2005
+#define ACTION_AUDIO_DELAY_MIN \
+  54 //!< Increase avsync delay.  Can b used in videoFullScreen.xml window id=2005
+#define ACTION_AUDIO_DELAY_PLUS \
+  55 //!< Decrease avsync delay.  Can b used in videoFullScreen.xml window id=2005
+#define ACTION_AUDIO_NEXT_LANGUAGE \
+  56 //!< Select next language in movie.  Can b used in videoFullScreen.xml window id=2005
+#define ACTION_CHANGE_RESOLUTION \
+  57 //!< switch 2 next resolution. Can b used during screen calibration
+     //!< settingsScreenCalibration.xml windowid=11
+
+#define REMOTE_0 58 //!< remote keys 0-9. are used by multiple windows
+#define REMOTE_1 59 //!< for example in videoFullScreen.xml window id=2005 you can
+#define REMOTE_2 60 //!< enter time (mmss) to jump to particular point in the movie
+#define REMOTE_3 61
+#define REMOTE_4 62 //!< with spincontrols you can enter 3digit number to quickly set
+#define REMOTE_5 63 //!< spincontrol to desired value
+#define REMOTE_6 64
+#define REMOTE_7 65
+#define REMOTE_8 66
+#define REMOTE_9 67
+
+#define ACTION_PLAYER_PROCESS_INFO \
+  69 //!< show player process info (video decoder, pixel format, pvr signal strength and the like
+#define ACTION_PLAYER_PROGRAM_SELECT 70
+#define ACTION_PLAYER_RESOLUTION_SELECT 71
+#define ACTION_SMALL_STEP_BACK \
+  76 //!< jumps a few seconds back during playback of movie. Can b used in videoFullScreen.xml
+     //!< window id=2005
+
+#define ACTION_PLAYER_FORWARD 77 //!< FF in current file played. global action, can be used anywhere
+#define ACTION_PLAYER_REWIND 78 //!< RW in current file played. global action, can be used anywhere
+#define ACTION_PLAYER_PLAY \
+  79 //!< Play current song. Unpauses song and sets playspeed to 1x. global action, can be used
+     //!< anywhere
+
+#define ACTION_DELETE_ITEM \
+  80 //!< delete current selected item. Can be used in myfiles.xml window id=3 and in
+     //!< myvideoTitle.xml window id=25
+#define ACTION_COPY_ITEM 81 //!< copy current selected item. Can be used in myfiles.xml window id=3
+#define ACTION_MOVE_ITEM 82 //!< move current selected item. Can be used in myfiles.xml window id=3
+#define ACTION_TAKE_SCREENSHOT 85 //!< take a screenshot
+#define ACTION_RENAME_ITEM 87 //!< rename item
+
+#define ACTION_VOLUME_UP 88
+#define ACTION_VOLUME_DOWN 89
+#define ACTION_VOLAMP 90
+#define ACTION_MUTE 91
+#define ACTION_NAV_BACK 92
+#define ACTION_VOLAMP_UP 93
+#define ACTION_VOLAMP_DOWN 94
+
+#define ACTION_CREATE_EPISODE_BOOKMARK \
+  95 //!< Creates an episode bookmark on the currently playing video file containing more than one
+     //!< episode
+#define ACTION_CREATE_BOOKMARK 96 //!< Creates a bookmark of the currently playing video file
+
+#define ACTION_CHAPTER_OR_BIG_STEP_FORWARD \
+  97 //!< Goto the next chapter, if not available perform a big step forward
+#define ACTION_CHAPTER_OR_BIG_STEP_BACK \
+  98 //!< Goto the previous chapter, if not available perform a big step back
+
+#define ACTION_CYCLE_SUBTITLE \
+  99 //!< switch to next subtitle of movie, but will not enable/disable the subtitles. Can be used
+     //!< in videoFullScreen.xml window id=2005
+
+#define ACTION_MOUSE_START 100
+#define ACTION_MOUSE_LEFT_CLICK 100
+#define ACTION_MOUSE_RIGHT_CLICK 101
+#define ACTION_MOUSE_MIDDLE_CLICK 102
+#define ACTION_MOUSE_DOUBLE_CLICK 103
+#define ACTION_MOUSE_WHEEL_UP 104
+#define ACTION_MOUSE_WHEEL_DOWN 105
+#define ACTION_MOUSE_DRAG 106
+#define ACTION_MOUSE_MOVE 107
+#define ACTION_MOUSE_LONG_CLICK 108
+#define ACTION_MOUSE_DRAG_END 109
+#define ACTION_MOUSE_END 109
+
+#define ACTION_BACKSPACE 110
+#define ACTION_SCROLL_UP 111
+#define ACTION_SCROLL_DOWN 112
+#define ACTION_ANALOG_FORWARD 113
+#define ACTION_ANALOG_REWIND 114
+
+#define ACTION_MOVE_ITEM_UP 115 //!< move item up in playlist
+#define ACTION_MOVE_ITEM_DOWN 116 //!< move item down in playlist
+#define ACTION_CONTEXT_MENU 117 //!< pops up the context menu
 
 // stuff for virtual keyboard shortcuts
-#define ACTION_SHIFT              118 //!< stuff for virtual keyboard shortcuts
-#define ACTION_SYMBOLS            119 //!< stuff for virtual keyboard shortcuts
-#define ACTION_CURSOR_LEFT        120 //!< stuff for virtual keyboard shortcuts
-#define ACTION_CURSOR_RIGHT       121 //!< stuff for virtual keyboard shortcuts
-
-#define ACTION_BUILT_IN_FUNCTION  122
-
-#define ACTION_SHOW_OSD_TIME      123 //!< displays current time, can be used in videoFullScreen.xml window id=2005
-#define ACTION_ANALOG_SEEK_FORWARD  124 //!< seeks forward, and displays the seek bar.
-#define ACTION_ANALOG_SEEK_BACK     125 //!< seeks backward, and displays the seek bar.
-
-#define ACTION_VIS_PRESET_SHOW        126
-#define ACTION_VIS_PRESET_NEXT        128
-#define ACTION_VIS_PRESET_PREV        129
-#define ACTION_VIS_PRESET_LOCK        130
-#define ACTION_VIS_PRESET_RANDOM      131
-#define ACTION_VIS_RATE_PRESET_PLUS   132
-#define ACTION_VIS_RATE_PRESET_MINUS  133
-
-#define ACTION_SHOW_VIDEOMENU         134
-#define ACTION_ENTER                  135
-
-#define ACTION_INCREASE_RATING        136
-#define ACTION_DECREASE_RATING        137
-
-#define ACTION_NEXT_SCENE             138 //!< switch to next scene/cutpoint in movie
-#define ACTION_PREV_SCENE             139 //!< switch to previous scene/cutpoint in movie
-
-#define ACTION_NEXT_LETTER            140 //!< jump through a list or container by letter
-#define ACTION_PREV_LETTER            141
-
-#define ACTION_JUMP_SMS2              142 //!< jump direct to a particular letter using SMS-style input
-#define ACTION_JUMP_SMS3              143
-#define ACTION_JUMP_SMS4              144
-#define ACTION_JUMP_SMS5              145
-#define ACTION_JUMP_SMS6              146
-#define ACTION_JUMP_SMS7              147
-#define ACTION_JUMP_SMS8              148
-#define ACTION_JUMP_SMS9              149
-
-#define ACTION_FILTER_CLEAR           150
-#define ACTION_FILTER_SMS2            151
-#define ACTION_FILTER_SMS3            152
-#define ACTION_FILTER_SMS4            153
-#define ACTION_FILTER_SMS5            154
-#define ACTION_FILTER_SMS6            155
-#define ACTION_FILTER_SMS7            156
-#define ACTION_FILTER_SMS8            157
-#define ACTION_FILTER_SMS9            158
-
-#define ACTION_FIRST_PAGE             159
-#define ACTION_LAST_PAGE              160
-
-#define ACTION_AUDIO_DELAY            161
-#define ACTION_SUBTITLE_DELAY         162
-#define ACTION_MENU                   163
-
-#define ACTION_SET_RATING             164
-
-#define ACTION_RECORD                 170
-
-#define ACTION_PASTE                  180
-#define ACTION_NEXT_CONTROL           181
-#define ACTION_PREV_CONTROL           182
-#define ACTION_CHANNEL_SWITCH         183
-#define ACTION_CHANNEL_UP             184
-#define ACTION_CHANNEL_DOWN           185
-#define ACTION_NEXT_CHANNELGROUP      186
-#define ACTION_PREVIOUS_CHANNELGROUP  187
-#define ACTION_PVR_PLAY               188
-#define ACTION_PVR_PLAY_TV            189
-#define ACTION_PVR_PLAY_RADIO         190
-#define ACTION_PVR_SHOW_TIMER_RULE    191
-#define ACTION_CHANNEL_NUMBER_SEP     192
+#define ACTION_SHIFT 118 //!< stuff for virtual keyboard shortcuts
+#define ACTION_SYMBOLS 119 //!< stuff for virtual keyboard shortcuts
+#define ACTION_CURSOR_LEFT 120 //!< stuff for virtual keyboard shortcuts
+#define ACTION_CURSOR_RIGHT 121 //!< stuff for virtual keyboard shortcuts
+
+#define ACTION_BUILT_IN_FUNCTION 122
+
+#define ACTION_SHOW_OSD_TIME \
+  123 //!< displays current time, can be used in videoFullScreen.xml window id=2005
+#define ACTION_ANALOG_SEEK_FORWARD 124 //!< seeks forward, and displays the seek bar.
+#define ACTION_ANALOG_SEEK_BACK 125 //!< seeks backward, and displays the seek bar.
+
+#define ACTION_VIS_PRESET_SHOW 126
+#define ACTION_VIS_PRESET_NEXT 128
+#define ACTION_VIS_PRESET_PREV 129
+#define ACTION_VIS_PRESET_LOCK 130
+#define ACTION_VIS_PRESET_RANDOM 131
+#define ACTION_VIS_RATE_PRESET_PLUS 132
+#define ACTION_VIS_RATE_PRESET_MINUS 133
+
+#define ACTION_SHOW_VIDEOMENU 134
+#define ACTION_ENTER 135
+
+#define ACTION_INCREASE_RATING 136
+#define ACTION_DECREASE_RATING 137
+
+#define ACTION_NEXT_SCENE 138 //!< switch to next scene/cutpoint in movie
+#define ACTION_PREV_SCENE 139 //!< switch to previous scene/cutpoint in movie
+
+#define ACTION_NEXT_LETTER 140 //!< jump through a list or container by letter
+#define ACTION_PREV_LETTER 141
+
+#define ACTION_JUMP_SMS2 142 //!< jump direct to a particular letter using SMS-style input
+#define ACTION_JUMP_SMS3 143
+#define ACTION_JUMP_SMS4 144
+#define ACTION_JUMP_SMS5 145
+#define ACTION_JUMP_SMS6 146
+#define ACTION_JUMP_SMS7 147
+#define ACTION_JUMP_SMS8 148
+#define ACTION_JUMP_SMS9 149
+
+#define ACTION_FILTER_CLEAR 150
+#define ACTION_FILTER_SMS2 151
+#define ACTION_FILTER_SMS3 152
+#define ACTION_FILTER_SMS4 153
+#define ACTION_FILTER_SMS5 154
+#define ACTION_FILTER_SMS6 155
+#define ACTION_FILTER_SMS7 156
+#define ACTION_FILTER_SMS8 157
+#define ACTION_FILTER_SMS9 158
+
+#define ACTION_FIRST_PAGE 159
+#define ACTION_LAST_PAGE 160
+
+#define ACTION_AUDIO_DELAY 161
+#define ACTION_SUBTITLE_DELAY 162
+#define ACTION_MENU 163
+
+#define ACTION_SET_RATING 164
+
+#define ACTION_RECORD 170
+
+#define ACTION_PASTE 180
+#define ACTION_NEXT_CONTROL 181
+#define ACTION_PREV_CONTROL 182
+#define ACTION_CHANNEL_SWITCH 183
+#define ACTION_CHANNEL_UP 184
+#define ACTION_CHANNEL_DOWN 185
+#define ACTION_NEXT_CHANNELGROUP 186
+#define ACTION_PREVIOUS_CHANNELGROUP 187
+#define ACTION_PVR_PLAY 188
+#define ACTION_PVR_PLAY_TV 189
+#define ACTION_PVR_PLAY_RADIO 190
+#define ACTION_PVR_SHOW_TIMER_RULE 191
+#define ACTION_CHANNEL_NUMBER_SEP 192
 #define ACTION_PVR_ANNOUNCE_REMINDERS 193
 
-#define ACTION_TOGGLE_FULLSCREEN      199 //!< switch 2 desktop resolution
-#define ACTION_TOGGLE_WATCHED         200 //!< Toggle watched status (videos)
-#define ACTION_SCAN_ITEM              201 //!< scan item
-#define ACTION_TOGGLE_DIGITAL_ANALOG  202 //!< switch digital <-> analog
-#define ACTION_RELOAD_KEYMAPS         203 //!< reloads CButtonTranslator's keymaps
-#define ACTION_GUIPROFILE_BEGIN       204 //!< start the GUIControlProfiler running
+#define ACTION_TOGGLE_FULLSCREEN 199 //!< switch 2 desktop resolution
+#define ACTION_TOGGLE_WATCHED 200 //!< Toggle watched status (videos)
+#define ACTION_SCAN_ITEM 201 //!< scan item
+#define ACTION_TOGGLE_DIGITAL_ANALOG 202 //!< switch digital <-> analog
+#define ACTION_RELOAD_KEYMAPS 203 //!< reloads CButtonTranslator's keymaps
+#define ACTION_GUIPROFILE_BEGIN 204 //!< start the GUIControlProfiler running
 
-#define ACTION_TELETEXT_RED           215 //!< Teletext Color button <b>Red</b> to control TopText
-#define ACTION_TELETEXT_GREEN         216 //!< Teletext Color button <b>Green</b> to control TopText
-#define ACTION_TELETEXT_YELLOW        217 //!< Teletext Color button <b>Yellow</b> to control TopText
-#define ACTION_TELETEXT_BLUE          218 //!< Teletext Color button <b>Blue</b> to control TopText
+#define ACTION_TELETEXT_RED 215 //!< Teletext Color button <b>Red</b> to control TopText
+#define ACTION_TELETEXT_GREEN 216 //!< Teletext Color button <b>Green</b> to control TopText
+#define ACTION_TELETEXT_YELLOW 217 //!< Teletext Color button <b>Yellow</b> to control TopText
+#define ACTION_TELETEXT_BLUE 218 //!< Teletext Color button <b>Blue</b> to control TopText
 
-#define ACTION_INCREASE_PAR           219
-#define ACTION_DECREASE_PAR           220
+#define ACTION_INCREASE_PAR 219
+#define ACTION_DECREASE_PAR 220
 
-#define ACTION_VSHIFT_UP              227 //!< shift up video image in VideoPlayer
-#define ACTION_VSHIFT_DOWN            228 //!< shift down video image in VideoPlayer
+#define ACTION_VSHIFT_UP 227 //!< shift up video image in VideoPlayer
+#define ACTION_VSHIFT_DOWN 228 //!< shift down video image in VideoPlayer
 
-#define ACTION_PLAYER_PLAYPAUSE       229 //!< Play/pause. If playing it pauses, if paused it plays.
+#define ACTION_PLAYER_PLAYPAUSE 229 //!< Play/pause. If playing it pauses, if paused it plays.
 
-#define ACTION_SUBTITLE_VSHIFT_UP     230 //!< shift up subtitles in VideoPlayer
-#define ACTION_SUBTITLE_VSHIFT_DOWN   231 //!< shift down subtitles in VideoPlayer
-#define ACTION_SUBTITLE_ALIGN         232 //!< toggle vertical alignment of subtitles
+#define ACTION_SUBTITLE_VSHIFT_UP 230 //!< shift up subtitles in VideoPlayer
+#define ACTION_SUBTITLE_VSHIFT_DOWN 231 //!< shift down subtitles in VideoPlayer
+#define ACTION_SUBTITLE_ALIGN 232 //!< toggle vertical alignment of subtitles
 
-#define ACTION_FILTER                 233
+#define ACTION_FILTER 233
 
-#define ACTION_SWITCH_PLAYER          234
+#define ACTION_SWITCH_PLAYER 234
 
-#define ACTION_STEREOMODE_NEXT        235
-#define ACTION_STEREOMODE_PREVIOUS    236
-#define ACTION_STEREOMODE_TOGGLE      237 //!< turns 3d mode on/off
-#define ACTION_STEREOMODE_SELECT      238
-#define ACTION_STEREOMODE_TOMONO      239
-#define ACTION_STEREOMODE_SET         240
+#define ACTION_STEREOMODE_NEXT 235
+#define ACTION_STEREOMODE_PREVIOUS 236
+#define ACTION_STEREOMODE_TOGGLE 237 //!< turns 3d mode on/off
+#define ACTION_STEREOMODE_SELECT 238
+#define ACTION_STEREOMODE_TOMONO 239
+#define ACTION_STEREOMODE_SET 240
 
-#define ACTION_SETTINGS_RESET         241
-#define ACTION_SETTINGS_LEVEL_CHANGE  242
+#define ACTION_SETTINGS_RESET 241
+#define ACTION_SETTINGS_LEVEL_CHANGE 242
 
-#define ACTION_TRIGGER_OSD            243 //!< show autoclosing OSD. Can b used in videoFullScreen.xml window id=2005
-#define ACTION_INPUT_TEXT             244
-#define ACTION_VOLUME_SET             245
-#define ACTION_TOGGLE_COMMSKIP        246
+#define ACTION_TRIGGER_OSD \
+  243 //!< show autoclosing OSD. Can b used in videoFullScreen.xml window id=2005
+#define ACTION_INPUT_TEXT 244
+#define ACTION_VOLUME_SET 245
+#define ACTION_TOGGLE_COMMSKIP 246
 
-#define ACTION_PLAYER_RESET           248 //!< Send a reset command to the active game
+#define ACTION_PLAYER_RESET 248 //!< Send a reset command to the active game
 
-#define ACTION_TOGGLE_FONT            249 //!< Toggle font. Used in TextViewer dialog
+#define ACTION_TOGGLE_FONT 249 //!< Toggle font. Used in TextViewer dialog
 
-#define ACTION_VIDEO_NEXT_STREAM      250 //!< Cycle video streams. Used in videofullscreen.
-#define ACTION_QUEUE_ITEM_NEXT        251 //!< used to queue an item to the next position in the playlist
+#define ACTION_VIDEO_NEXT_STREAM 250 //!< Cycle video streams. Used in videofullscreen.
+#define ACTION_QUEUE_ITEM_NEXT 251 //!< used to queue an item to the next position in the playlist
 
 // Voice actions
-#define ACTION_VOICE_RECOGNIZE        300
+#define ACTION_VOICE_RECOGNIZE 300
 
 // Touch actions
-#define ACTION_TOUCH_TAP              401 //!< touch actions
-#define ACTION_TOUCH_TAP_TEN          410 //!< touch actions
-#define ACTION_TOUCH_LONGPRESS        411 //!< touch actions
-#define ACTION_TOUCH_LONGPRESS_TEN    420 //!< touch actions
-
-#define ACTION_GESTURE_NOTIFY         500
-#define ACTION_GESTURE_BEGIN          501
-#define ACTION_GESTURE_ZOOM           502 //!< sendaction with point and currentPinchScale (fingers together < 1.0 -> fingers apart > 1.0)
-#define ACTION_GESTURE_ROTATE         503
-#define ACTION_GESTURE_PAN            504
-#define ACTION_GESTURE_ABORT          505 //!< gesture was interrupted in unspecified state
-
-#define ACTION_GESTURE_SWIPE_LEFT       511
-#define ACTION_GESTURE_SWIPE_LEFT_TEN   520
-#define ACTION_GESTURE_SWIPE_RIGHT      521
-#define ACTION_GESTURE_SWIPE_RIGHT_TEN  530
-#define ACTION_GESTURE_SWIPE_UP         531
-#define ACTION_GESTURE_SWIPE_UP_TEN     540
-#define ACTION_GESTURE_SWIPE_DOWN       541
-#define ACTION_GESTURE_SWIPE_DOWN_TEN   550
+#define ACTION_TOUCH_TAP 401 //!< touch actions
+#define ACTION_TOUCH_TAP_TEN 410 //!< touch actions
+#define ACTION_TOUCH_LONGPRESS 411 //!< touch actions
+#define ACTION_TOUCH_LONGPRESS_TEN 420 //!< touch actions
+
+#define ACTION_GESTURE_NOTIFY 500
+#define ACTION_GESTURE_BEGIN 501
+#define ACTION_GESTURE_ZOOM \
+  502 //!< sendaction with point and currentPinchScale (fingers together < 1.0 -> fingers apart
+      //!< > 1.0)
+#define ACTION_GESTURE_ROTATE 503
+#define ACTION_GESTURE_PAN 504
+#define ACTION_GESTURE_ABORT 505 //!< gesture was interrupted in unspecified state
+
+#define ACTION_GESTURE_SWIPE_LEFT 511
+#define ACTION_GESTURE_SWIPE_LEFT_TEN 520
+#define ACTION_GESTURE_SWIPE_RIGHT 521
+#define ACTION_GESTURE_SWIPE_RIGHT_TEN 530
+#define ACTION_GESTURE_SWIPE_UP 531
+#define ACTION_GESTURE_SWIPE_UP_TEN 540
+#define ACTION_GESTURE_SWIPE_DOWN 541
+#define ACTION_GESTURE_SWIPE_DOWN_TEN 550
 // 5xx is reserved for additional gesture actions
-#define ACTION_GESTURE_END            599
+#define ACTION_GESTURE_END 599
 
 // other, non-gesture actions
-#define ACTION_ANALOG_MOVE_X_LEFT       601 //!< analog thumbstick move, horizontal axis, left; see ACTION_ANALOG_MOVE
-#define ACTION_ANALOG_MOVE_X_RIGHT      602 //!< analog thumbstick move, horizontal axis, right; see ACTION_ANALOG_MOVE
-#define ACTION_ANALOG_MOVE_Y_UP         603 //!< analog thumbstick move, vertical axis, up; see ACTION_ANALOG_MOVE
-#define ACTION_ANALOG_MOVE_Y_DOWN       604 //!< analog thumbstick move, vertical axis, down; see ACTION_ANALOG_MOVE
+#define ACTION_ANALOG_MOVE_X_LEFT \
+  601 //!< analog thumbstick move, horizontal axis, left; see ACTION_ANALOG_MOVE
+#define ACTION_ANALOG_MOVE_X_RIGHT \
+  602 //!< analog thumbstick move, horizontal axis, right; see ACTION_ANALOG_MOVE
+#define ACTION_ANALOG_MOVE_Y_UP \
+  603 //!< analog thumbstick move, vertical axis, up; see ACTION_ANALOG_MOVE
+#define ACTION_ANALOG_MOVE_Y_DOWN \
+  604 //!< analog thumbstick move, vertical axis, down; see ACTION_ANALOG_MOVE
 //@}
 
 // The NOOP action can be specified to disable an input event. This is
 // useful in user keyboard.xml etc to disable actions specified in the
 // system mappings. ERROR action is used to play an error sound
-#define ACTION_ERROR                  998
-#define ACTION_NOOP                   999
+#define ACTION_ERROR 998
+#define ACTION_NOOP 999
diff --git a/xbmc/input/actions/ActionTranslator.cpp b/xbmc/input/actions/ActionTranslator.cpp
index 9a9f624c9208..8731459326f6 100644
--- a/xbmc/input/actions/ActionTranslator.cpp
+++ b/xbmc/input/actions/ActionTranslator.cpp
@@ -20,234 +20,232 @@ namespace
 using ActionName = std::string;
 using ActionID = unsigned int;
 
-static const std::map<ActionName, ActionID> ActionMappings =
-{
-    { "left"                     , ACTION_MOVE_LEFT },
-    { "right"                    , ACTION_MOVE_RIGHT },
-    { "up"                       , ACTION_MOVE_UP },
-    { "down"                     , ACTION_MOVE_DOWN },
-    { "pageup"                   , ACTION_PAGE_UP },
-    { "pagedown"                 , ACTION_PAGE_DOWN },
-    { "select"                   , ACTION_SELECT_ITEM },
-    { "highlight"                , ACTION_HIGHLIGHT_ITEM },
-    { "parentdir"                , ACTION_NAV_BACK },            // backward compatibility
-    { "parentfolder"             , ACTION_PARENT_DIR },
-    { "back"                     , ACTION_NAV_BACK },
-    { "menu"                     , ACTION_MENU},
-    { "previousmenu"             , ACTION_PREVIOUS_MENU },
-    { "info"                     , ACTION_SHOW_INFO },
-    { "pause"                    , ACTION_PAUSE },
-    { "stop"                     , ACTION_STOP },
-    { "skipnext"                 , ACTION_NEXT_ITEM },
-    { "skipprevious"             , ACTION_PREV_ITEM },
-    { "fullscreen"               , ACTION_SHOW_GUI },
-    { "aspectratio"              , ACTION_ASPECT_RATIO },
-    { "stepforward"              , ACTION_STEP_FORWARD },
-    { "stepback"                 , ACTION_STEP_BACK },
-    { "bigstepforward"           , ACTION_BIG_STEP_FORWARD },
-    { "bigstepback"              , ACTION_BIG_STEP_BACK },
-    { "chapterorbigstepforward"  , ACTION_CHAPTER_OR_BIG_STEP_FORWARD },
-    { "chapterorbigstepback"     , ACTION_CHAPTER_OR_BIG_STEP_BACK },
-    { "osd"                      , ACTION_SHOW_OSD },
-    { "showsubtitles"            , ACTION_SHOW_SUBTITLES },
-    { "nextsubtitle"             , ACTION_NEXT_SUBTITLE },
-    { "browsesubtitle"           , ACTION_BROWSE_SUBTITLE },
-    { "cyclesubtitle"            , ACTION_CYCLE_SUBTITLE },
-    { "playerdebug"              , ACTION_PLAYER_DEBUG },
-    { "codecinfo"                , ACTION_PLAYER_PROCESS_INFO },
-    { "playerprocessinfo"        , ACTION_PLAYER_PROCESS_INFO },
-    { "playerprogramselect"      , ACTION_PLAYER_PROGRAM_SELECT },
-    { "playerresolutionselect"   , ACTION_PLAYER_RESOLUTION_SELECT },
-    { "nextpicture"              , ACTION_NEXT_PICTURE },
-    { "previouspicture"          , ACTION_PREV_PICTURE },
-    { "zoomout"                  , ACTION_ZOOM_OUT },
-    { "zoomin"                   , ACTION_ZOOM_IN },
-    { "playlist"                 , ACTION_SHOW_PLAYLIST },
-    { "queue"                    , ACTION_QUEUE_ITEM },
-    { "playnext"                 , ACTION_QUEUE_ITEM_NEXT },
-    { "zoomnormal"               , ACTION_ZOOM_LEVEL_NORMAL },
-    { "zoomlevel1"               , ACTION_ZOOM_LEVEL_1 },
-    { "zoomlevel2"               , ACTION_ZOOM_LEVEL_2 },
-    { "zoomlevel3"               , ACTION_ZOOM_LEVEL_3 },
-    { "zoomlevel4"               , ACTION_ZOOM_LEVEL_4 },
-    { "zoomlevel5"               , ACTION_ZOOM_LEVEL_5 },
-    { "zoomlevel6"               , ACTION_ZOOM_LEVEL_6 },
-    { "zoomlevel7"               , ACTION_ZOOM_LEVEL_7 },
-    { "zoomlevel8"               , ACTION_ZOOM_LEVEL_8 },
-    { "zoomlevel9"               , ACTION_ZOOM_LEVEL_9 },
-    { "nextcalibration"          , ACTION_CALIBRATE_SWAP_ARROWS },
-    { "resetcalibration"         , ACTION_CALIBRATE_RESET },
-    { "analogmove"               , ACTION_ANALOG_MOVE },
-    { "analogmovexleft"          , ACTION_ANALOG_MOVE_X_LEFT },
-    { "analogmovexright"         , ACTION_ANALOG_MOVE_X_RIGHT },
-    { "analogmoveyup"            , ACTION_ANALOG_MOVE_Y_UP },
-    { "analogmoveydown"          , ACTION_ANALOG_MOVE_Y_DOWN },
-    { "rotate"                   , ACTION_ROTATE_PICTURE_CW },
-    { "rotateccw"                , ACTION_ROTATE_PICTURE_CCW },
-    { "close"                    , ACTION_NAV_BACK },            // backwards compatibility
-    { "subtitledelayminus"       , ACTION_SUBTITLE_DELAY_MIN },
-    { "subtitledelay"            , ACTION_SUBTITLE_DELAY },
-    { "subtitledelayplus"        , ACTION_SUBTITLE_DELAY_PLUS },
-    { "audiodelayminus"          , ACTION_AUDIO_DELAY_MIN },
-    { "audiodelay"               , ACTION_AUDIO_DELAY },
-    { "audiodelayplus"           , ACTION_AUDIO_DELAY_PLUS },
-    { "subtitleshiftup"          , ACTION_SUBTITLE_VSHIFT_UP },
-    { "subtitleshiftdown"        , ACTION_SUBTITLE_VSHIFT_DOWN },
-    { "subtitlealign"            , ACTION_SUBTITLE_ALIGN },
-    { "audionextlanguage"        , ACTION_AUDIO_NEXT_LANGUAGE },
-    { "verticalshiftup"          , ACTION_VSHIFT_UP },
-    { "verticalshiftdown"        , ACTION_VSHIFT_DOWN },
-    { "nextresolution"           , ACTION_CHANGE_RESOLUTION },
-    { "audiotoggledigital"       , ACTION_TOGGLE_DIGITAL_ANALOG },
-    { "number0"                  , REMOTE_0 },
-    { "number1"                  , REMOTE_1 },
-    { "number2"                  , REMOTE_2 },
-    { "number3"                  , REMOTE_3 },
-    { "number4"                  , REMOTE_4 },
-    { "number5"                  , REMOTE_5 },
-    { "number6"                  , REMOTE_6 },
-    { "number7"                  , REMOTE_7 },
-    { "number8"                  , REMOTE_8 },
-    { "number9"                  , REMOTE_9 },
-    { "smallstepback"            , ACTION_SMALL_STEP_BACK },
-    { "fastforward"              , ACTION_PLAYER_FORWARD },
-    { "rewind"                   , ACTION_PLAYER_REWIND },
-    { "play"                     , ACTION_PLAYER_PLAY },
-    { "playpause"                , ACTION_PLAYER_PLAYPAUSE },
-    { "switchplayer"             , ACTION_SWITCH_PLAYER },
-    { "delete"                   , ACTION_DELETE_ITEM },
-    { "copy"                     , ACTION_COPY_ITEM },
-    { "move"                     , ACTION_MOVE_ITEM },
-    { "screenshot"               , ACTION_TAKE_SCREENSHOT },
-    { "rename"                   , ACTION_RENAME_ITEM },
-    { "togglewatched"            , ACTION_TOGGLE_WATCHED },
-    { "scanitem"                 , ACTION_SCAN_ITEM },
-    { "reloadkeymaps"            , ACTION_RELOAD_KEYMAPS },
-    { "volumeup"                 , ACTION_VOLUME_UP },
-    { "volumedown"               , ACTION_VOLUME_DOWN },
-    { "mute"                     , ACTION_MUTE },
-    { "backspace"                , ACTION_BACKSPACE },
-    { "scrollup"                 , ACTION_SCROLL_UP },
-    { "scrolldown"               , ACTION_SCROLL_DOWN },
-    { "analogfastforward"        , ACTION_ANALOG_FORWARD },
-    { "analogrewind"             , ACTION_ANALOG_REWIND },
-    { "moveitemup"               , ACTION_MOVE_ITEM_UP },
-    { "moveitemdown"             , ACTION_MOVE_ITEM_DOWN },
-    { "contextmenu"              , ACTION_CONTEXT_MENU },
-    { "shift"                    , ACTION_SHIFT },
-    { "symbols"                  , ACTION_SYMBOLS },
-    { "cursorleft"               , ACTION_CURSOR_LEFT },
-    { "cursorright"              , ACTION_CURSOR_RIGHT },
-    { "showtime"                 , ACTION_SHOW_OSD_TIME },
-    { "analogseekforward"        , ACTION_ANALOG_SEEK_FORWARD },
-    { "analogseekback"           , ACTION_ANALOG_SEEK_BACK },
-    { "showpreset"               , ACTION_VIS_PRESET_SHOW },
-    { "nextpreset"               , ACTION_VIS_PRESET_NEXT },
-    { "previouspreset"           , ACTION_VIS_PRESET_PREV },
-    { "lockpreset"               , ACTION_VIS_PRESET_LOCK },
-    { "randompreset"             , ACTION_VIS_PRESET_RANDOM },
-    { "increasevisrating"        , ACTION_VIS_RATE_PRESET_PLUS },
-    { "decreasevisrating"        , ACTION_VIS_RATE_PRESET_MINUS },
-    { "showvideomenu"            , ACTION_SHOW_VIDEOMENU },
-    { "enter"                    , ACTION_ENTER },
-    { "increaserating"           , ACTION_INCREASE_RATING },
-    { "decreaserating"           , ACTION_DECREASE_RATING },
-    { "setrating"                , ACTION_SET_RATING },
-    { "togglefullscreen"         , ACTION_TOGGLE_FULLSCREEN },
-    { "nextscene"                , ACTION_NEXT_SCENE },
-    { "previousscene"            , ACTION_PREV_SCENE },
-    { "nextletter"               , ACTION_NEXT_LETTER },
-    { "prevletter"               , ACTION_PREV_LETTER },
-    { "jumpsms2"                 , ACTION_JUMP_SMS2 },
-    { "jumpsms3"                 , ACTION_JUMP_SMS3 },
-    { "jumpsms4"                 , ACTION_JUMP_SMS4 },
-    { "jumpsms5"                 , ACTION_JUMP_SMS5 },
-    { "jumpsms6"                 , ACTION_JUMP_SMS6 },
-    { "jumpsms7"                 , ACTION_JUMP_SMS7 },
-    { "jumpsms8"                 , ACTION_JUMP_SMS8 },
-    { "jumpsms9"                 , ACTION_JUMP_SMS9 },
-    { "filter"                   , ACTION_FILTER },
-    { "filterclear"              , ACTION_FILTER_CLEAR },
-    { "filtersms2"               , ACTION_FILTER_SMS2 },
-    { "filtersms3"               , ACTION_FILTER_SMS3 },
-    { "filtersms4"               , ACTION_FILTER_SMS4 },
-    { "filtersms5"               , ACTION_FILTER_SMS5 },
-    { "filtersms6"               , ACTION_FILTER_SMS6 },
-    { "filtersms7"               , ACTION_FILTER_SMS7 },
-    { "filtersms8"               , ACTION_FILTER_SMS8 },
-    { "filtersms9"               , ACTION_FILTER_SMS9 },
-    { "firstpage"                , ACTION_FIRST_PAGE },
-    { "lastpage"                 , ACTION_LAST_PAGE },
-    { "guiprofile"               , ACTION_GUIPROFILE_BEGIN },
-    { "red"                      , ACTION_TELETEXT_RED },
-    { "green"                    , ACTION_TELETEXT_GREEN },
-    { "yellow"                   , ACTION_TELETEXT_YELLOW },
-    { "blue"                     , ACTION_TELETEXT_BLUE },
-    { "increasepar"              , ACTION_INCREASE_PAR },
-    { "decreasepar"              , ACTION_DECREASE_PAR },
-    { "volampup"                 , ACTION_VOLAMP_UP },
-    { "volampdown"               , ACTION_VOLAMP_DOWN },
-    { "volumeamplification"      , ACTION_VOLAMP },
-    { "createbookmark"           , ACTION_CREATE_BOOKMARK },
-    { "createepisodebookmark"    , ACTION_CREATE_EPISODE_BOOKMARK },
-    { "settingsreset"            , ACTION_SETTINGS_RESET },
-    { "settingslevelchange"      , ACTION_SETTINGS_LEVEL_CHANGE },
-    { "togglefont"               , ACTION_TOGGLE_FONT},
-    { "videonextstream"          , ACTION_VIDEO_NEXT_STREAM},
+static const std::map<ActionName, ActionID> ActionMappings = {
+    {"left", ACTION_MOVE_LEFT},
+    {"right", ACTION_MOVE_RIGHT},
+    {"up", ACTION_MOVE_UP},
+    {"down", ACTION_MOVE_DOWN},
+    {"pageup", ACTION_PAGE_UP},
+    {"pagedown", ACTION_PAGE_DOWN},
+    {"select", ACTION_SELECT_ITEM},
+    {"highlight", ACTION_HIGHLIGHT_ITEM},
+    {"parentdir", ACTION_NAV_BACK}, // backward compatibility
+    {"parentfolder", ACTION_PARENT_DIR},
+    {"back", ACTION_NAV_BACK},
+    {"menu", ACTION_MENU},
+    {"previousmenu", ACTION_PREVIOUS_MENU},
+    {"info", ACTION_SHOW_INFO},
+    {"pause", ACTION_PAUSE},
+    {"stop", ACTION_STOP},
+    {"skipnext", ACTION_NEXT_ITEM},
+    {"skipprevious", ACTION_PREV_ITEM},
+    {"fullscreen", ACTION_SHOW_GUI},
+    {"aspectratio", ACTION_ASPECT_RATIO},
+    {"stepforward", ACTION_STEP_FORWARD},
+    {"stepback", ACTION_STEP_BACK},
+    {"bigstepforward", ACTION_BIG_STEP_FORWARD},
+    {"bigstepback", ACTION_BIG_STEP_BACK},
+    {"chapterorbigstepforward", ACTION_CHAPTER_OR_BIG_STEP_FORWARD},
+    {"chapterorbigstepback", ACTION_CHAPTER_OR_BIG_STEP_BACK},
+    {"osd", ACTION_SHOW_OSD},
+    {"showsubtitles", ACTION_SHOW_SUBTITLES},
+    {"nextsubtitle", ACTION_NEXT_SUBTITLE},
+    {"browsesubtitle", ACTION_BROWSE_SUBTITLE},
+    {"cyclesubtitle", ACTION_CYCLE_SUBTITLE},
+    {"playerdebug", ACTION_PLAYER_DEBUG},
+    {"codecinfo", ACTION_PLAYER_PROCESS_INFO},
+    {"playerprocessinfo", ACTION_PLAYER_PROCESS_INFO},
+    {"playerprogramselect", ACTION_PLAYER_PROGRAM_SELECT},
+    {"playerresolutionselect", ACTION_PLAYER_RESOLUTION_SELECT},
+    {"nextpicture", ACTION_NEXT_PICTURE},
+    {"previouspicture", ACTION_PREV_PICTURE},
+    {"zoomout", ACTION_ZOOM_OUT},
+    {"zoomin", ACTION_ZOOM_IN},
+    {"playlist", ACTION_SHOW_PLAYLIST},
+    {"queue", ACTION_QUEUE_ITEM},
+    {"playnext", ACTION_QUEUE_ITEM_NEXT},
+    {"zoomnormal", ACTION_ZOOM_LEVEL_NORMAL},
+    {"zoomlevel1", ACTION_ZOOM_LEVEL_1},
+    {"zoomlevel2", ACTION_ZOOM_LEVEL_2},
+    {"zoomlevel3", ACTION_ZOOM_LEVEL_3},
+    {"zoomlevel4", ACTION_ZOOM_LEVEL_4},
+    {"zoomlevel5", ACTION_ZOOM_LEVEL_5},
+    {"zoomlevel6", ACTION_ZOOM_LEVEL_6},
+    {"zoomlevel7", ACTION_ZOOM_LEVEL_7},
+    {"zoomlevel8", ACTION_ZOOM_LEVEL_8},
+    {"zoomlevel9", ACTION_ZOOM_LEVEL_9},
+    {"nextcalibration", ACTION_CALIBRATE_SWAP_ARROWS},
+    {"resetcalibration", ACTION_CALIBRATE_RESET},
+    {"analogmove", ACTION_ANALOG_MOVE},
+    {"analogmovexleft", ACTION_ANALOG_MOVE_X_LEFT},
+    {"analogmovexright", ACTION_ANALOG_MOVE_X_RIGHT},
+    {"analogmoveyup", ACTION_ANALOG_MOVE_Y_UP},
+    {"analogmoveydown", ACTION_ANALOG_MOVE_Y_DOWN},
+    {"rotate", ACTION_ROTATE_PICTURE_CW},
+    {"rotateccw", ACTION_ROTATE_PICTURE_CCW},
+    {"close", ACTION_NAV_BACK}, // backwards compatibility
+    {"subtitledelayminus", ACTION_SUBTITLE_DELAY_MIN},
+    {"subtitledelay", ACTION_SUBTITLE_DELAY},
+    {"subtitledelayplus", ACTION_SUBTITLE_DELAY_PLUS},
+    {"audiodelayminus", ACTION_AUDIO_DELAY_MIN},
+    {"audiodelay", ACTION_AUDIO_DELAY},
+    {"audiodelayplus", ACTION_AUDIO_DELAY_PLUS},
+    {"subtitleshiftup", ACTION_SUBTITLE_VSHIFT_UP},
+    {"subtitleshiftdown", ACTION_SUBTITLE_VSHIFT_DOWN},
+    {"subtitlealign", ACTION_SUBTITLE_ALIGN},
+    {"audionextlanguage", ACTION_AUDIO_NEXT_LANGUAGE},
+    {"verticalshiftup", ACTION_VSHIFT_UP},
+    {"verticalshiftdown", ACTION_VSHIFT_DOWN},
+    {"nextresolution", ACTION_CHANGE_RESOLUTION},
+    {"audiotoggledigital", ACTION_TOGGLE_DIGITAL_ANALOG},
+    {"number0", REMOTE_0},
+    {"number1", REMOTE_1},
+    {"number2", REMOTE_2},
+    {"number3", REMOTE_3},
+    {"number4", REMOTE_4},
+    {"number5", REMOTE_5},
+    {"number6", REMOTE_6},
+    {"number7", REMOTE_7},
+    {"number8", REMOTE_8},
+    {"number9", REMOTE_9},
+    {"smallstepback", ACTION_SMALL_STEP_BACK},
+    {"fastforward", ACTION_PLAYER_FORWARD},
+    {"rewind", ACTION_PLAYER_REWIND},
+    {"play", ACTION_PLAYER_PLAY},
+    {"playpause", ACTION_PLAYER_PLAYPAUSE},
+    {"switchplayer", ACTION_SWITCH_PLAYER},
+    {"delete", ACTION_DELETE_ITEM},
+    {"copy", ACTION_COPY_ITEM},
+    {"move", ACTION_MOVE_ITEM},
+    {"screenshot", ACTION_TAKE_SCREENSHOT},
+    {"rename", ACTION_RENAME_ITEM},
+    {"togglewatched", ACTION_TOGGLE_WATCHED},
+    {"scanitem", ACTION_SCAN_ITEM},
+    {"reloadkeymaps", ACTION_RELOAD_KEYMAPS},
+    {"volumeup", ACTION_VOLUME_UP},
+    {"volumedown", ACTION_VOLUME_DOWN},
+    {"mute", ACTION_MUTE},
+    {"backspace", ACTION_BACKSPACE},
+    {"scrollup", ACTION_SCROLL_UP},
+    {"scrolldown", ACTION_SCROLL_DOWN},
+    {"analogfastforward", ACTION_ANALOG_FORWARD},
+    {"analogrewind", ACTION_ANALOG_REWIND},
+    {"moveitemup", ACTION_MOVE_ITEM_UP},
+    {"moveitemdown", ACTION_MOVE_ITEM_DOWN},
+    {"contextmenu", ACTION_CONTEXT_MENU},
+    {"shift", ACTION_SHIFT},
+    {"symbols", ACTION_SYMBOLS},
+    {"cursorleft", ACTION_CURSOR_LEFT},
+    {"cursorright", ACTION_CURSOR_RIGHT},
+    {"showtime", ACTION_SHOW_OSD_TIME},
+    {"analogseekforward", ACTION_ANALOG_SEEK_FORWARD},
+    {"analogseekback", ACTION_ANALOG_SEEK_BACK},
+    {"showpreset", ACTION_VIS_PRESET_SHOW},
+    {"nextpreset", ACTION_VIS_PRESET_NEXT},
+    {"previouspreset", ACTION_VIS_PRESET_PREV},
+    {"lockpreset", ACTION_VIS_PRESET_LOCK},
+    {"randompreset", ACTION_VIS_PRESET_RANDOM},
+    {"increasevisrating", ACTION_VIS_RATE_PRESET_PLUS},
+    {"decreasevisrating", ACTION_VIS_RATE_PRESET_MINUS},
+    {"showvideomenu", ACTION_SHOW_VIDEOMENU},
+    {"enter", ACTION_ENTER},
+    {"increaserating", ACTION_INCREASE_RATING},
+    {"decreaserating", ACTION_DECREASE_RATING},
+    {"setrating", ACTION_SET_RATING},
+    {"togglefullscreen", ACTION_TOGGLE_FULLSCREEN},
+    {"nextscene", ACTION_NEXT_SCENE},
+    {"previousscene", ACTION_PREV_SCENE},
+    {"nextletter", ACTION_NEXT_LETTER},
+    {"prevletter", ACTION_PREV_LETTER},
+    {"jumpsms2", ACTION_JUMP_SMS2},
+    {"jumpsms3", ACTION_JUMP_SMS3},
+    {"jumpsms4", ACTION_JUMP_SMS4},
+    {"jumpsms5", ACTION_JUMP_SMS5},
+    {"jumpsms6", ACTION_JUMP_SMS6},
+    {"jumpsms7", ACTION_JUMP_SMS7},
+    {"jumpsms8", ACTION_JUMP_SMS8},
+    {"jumpsms9", ACTION_JUMP_SMS9},
+    {"filter", ACTION_FILTER},
+    {"filterclear", ACTION_FILTER_CLEAR},
+    {"filtersms2", ACTION_FILTER_SMS2},
+    {"filtersms3", ACTION_FILTER_SMS3},
+    {"filtersms4", ACTION_FILTER_SMS4},
+    {"filtersms5", ACTION_FILTER_SMS5},
+    {"filtersms6", ACTION_FILTER_SMS6},
+    {"filtersms7", ACTION_FILTER_SMS7},
+    {"filtersms8", ACTION_FILTER_SMS8},
+    {"filtersms9", ACTION_FILTER_SMS9},
+    {"firstpage", ACTION_FIRST_PAGE},
+    {"lastpage", ACTION_LAST_PAGE},
+    {"guiprofile", ACTION_GUIPROFILE_BEGIN},
+    {"red", ACTION_TELETEXT_RED},
+    {"green", ACTION_TELETEXT_GREEN},
+    {"yellow", ACTION_TELETEXT_YELLOW},
+    {"blue", ACTION_TELETEXT_BLUE},
+    {"increasepar", ACTION_INCREASE_PAR},
+    {"decreasepar", ACTION_DECREASE_PAR},
+    {"volampup", ACTION_VOLAMP_UP},
+    {"volampdown", ACTION_VOLAMP_DOWN},
+    {"volumeamplification", ACTION_VOLAMP},
+    {"createbookmark", ACTION_CREATE_BOOKMARK},
+    {"createepisodebookmark", ACTION_CREATE_EPISODE_BOOKMARK},
+    {"settingsreset", ACTION_SETTINGS_RESET},
+    {"settingslevelchange", ACTION_SETTINGS_LEVEL_CHANGE},
+    {"togglefont", ACTION_TOGGLE_FONT},
+    {"videonextstream", ACTION_VIDEO_NEXT_STREAM},
 
     // 3D movie playback/GUI
-    { "stereomode"               , ACTION_STEREOMODE_SELECT },   // cycle 3D modes, for now an alias for next
-    { "nextstereomode"           , ACTION_STEREOMODE_NEXT },
-    { "previousstereomode"       , ACTION_STEREOMODE_PREVIOUS },
-    { "togglestereomode"         , ACTION_STEREOMODE_TOGGLE },
-    { "stereomodetomono"         , ACTION_STEREOMODE_TOMONO },
+    {"stereomode", ACTION_STEREOMODE_SELECT}, // cycle 3D modes, for now an alias for next
+    {"nextstereomode", ACTION_STEREOMODE_NEXT},
+    {"previousstereomode", ACTION_STEREOMODE_PREVIOUS},
+    {"togglestereomode", ACTION_STEREOMODE_TOGGLE},
+    {"stereomodetomono", ACTION_STEREOMODE_TOMONO},
 
     // PVR actions
-    { "channelup"                , ACTION_CHANNEL_UP },
-    { "channeldown"              , ACTION_CHANNEL_DOWN },
-    { "previouschannelgroup"     , ACTION_PREVIOUS_CHANNELGROUP },
-    { "nextchannelgroup"         , ACTION_NEXT_CHANNELGROUP },
-    { "playpvr"                  , ACTION_PVR_PLAY },
-    { "playpvrtv"                , ACTION_PVR_PLAY_TV },
-    { "playpvrradio"             , ACTION_PVR_PLAY_RADIO },
-    { "record"                   , ACTION_RECORD },
-    { "togglecommskip"           , ACTION_TOGGLE_COMMSKIP },
-    { "showtimerrule"            , ACTION_PVR_SHOW_TIMER_RULE },
-    { "channelnumberseparator"   , ACTION_CHANNEL_NUMBER_SEP },
+    {"channelup", ACTION_CHANNEL_UP},
+    {"channeldown", ACTION_CHANNEL_DOWN},
+    {"previouschannelgroup", ACTION_PREVIOUS_CHANNELGROUP},
+    {"nextchannelgroup", ACTION_NEXT_CHANNELGROUP},
+    {"playpvr", ACTION_PVR_PLAY},
+    {"playpvrtv", ACTION_PVR_PLAY_TV},
+    {"playpvrradio", ACTION_PVR_PLAY_RADIO},
+    {"record", ACTION_RECORD},
+    {"togglecommskip", ACTION_TOGGLE_COMMSKIP},
+    {"showtimerrule", ACTION_PVR_SHOW_TIMER_RULE},
+    {"channelnumberseparator", ACTION_CHANNEL_NUMBER_SEP},
 
     // Mouse actions
-    { "leftclick"                , ACTION_MOUSE_LEFT_CLICK },
-    { "rightclick"               , ACTION_MOUSE_RIGHT_CLICK },
-    { "middleclick"              , ACTION_MOUSE_MIDDLE_CLICK },
-    { "doubleclick"              , ACTION_MOUSE_DOUBLE_CLICK },
-    { "longclick"                , ACTION_MOUSE_LONG_CLICK },
-    { "wheelup"                  , ACTION_MOUSE_WHEEL_UP },
-    { "wheeldown"                , ACTION_MOUSE_WHEEL_DOWN },
-    { "mousedrag"                , ACTION_MOUSE_DRAG },
-    { "mousedragend"             , ACTION_MOUSE_DRAG_END },
-    { "mousemove"                , ACTION_MOUSE_MOVE },
+    {"leftclick", ACTION_MOUSE_LEFT_CLICK},
+    {"rightclick", ACTION_MOUSE_RIGHT_CLICK},
+    {"middleclick", ACTION_MOUSE_MIDDLE_CLICK},
+    {"doubleclick", ACTION_MOUSE_DOUBLE_CLICK},
+    {"longclick", ACTION_MOUSE_LONG_CLICK},
+    {"wheelup", ACTION_MOUSE_WHEEL_UP},
+    {"wheeldown", ACTION_MOUSE_WHEEL_DOWN},
+    {"mousedrag", ACTION_MOUSE_DRAG},
+    {"mousedragend", ACTION_MOUSE_DRAG_END},
+    {"mousemove", ACTION_MOUSE_MOVE},
 
     // Touch
-    { "tap"                      , ACTION_TOUCH_TAP },
-    { "longpress"                , ACTION_TOUCH_LONGPRESS },
-    { "pangesture"               , ACTION_GESTURE_PAN },
-    { "zoomgesture"              , ACTION_GESTURE_ZOOM },
-    { "rotategesture"            , ACTION_GESTURE_ROTATE },
-    { "swipeleft"                , ACTION_GESTURE_SWIPE_LEFT },
-    { "swiperight"               , ACTION_GESTURE_SWIPE_RIGHT },
-    { "swipeup"                  , ACTION_GESTURE_SWIPE_UP },
-    { "swipedown"                , ACTION_GESTURE_SWIPE_DOWN },
+    {"tap", ACTION_TOUCH_TAP},
+    {"longpress", ACTION_TOUCH_LONGPRESS},
+    {"pangesture", ACTION_GESTURE_PAN},
+    {"zoomgesture", ACTION_GESTURE_ZOOM},
+    {"rotategesture", ACTION_GESTURE_ROTATE},
+    {"swipeleft", ACTION_GESTURE_SWIPE_LEFT},
+    {"swiperight", ACTION_GESTURE_SWIPE_RIGHT},
+    {"swipeup", ACTION_GESTURE_SWIPE_UP},
+    {"swipedown", ACTION_GESTURE_SWIPE_DOWN},
 
     // Voice
-    { "voicerecognizer"          , ACTION_VOICE_RECOGNIZE },
+    {"voicerecognizer", ACTION_VOICE_RECOGNIZE},
 
     // Do nothing / error action
-    { "error"                    , ACTION_ERROR },
-    { "noop"                     , ACTION_NOOP }
-};
-}
+    {"error", ACTION_ERROR},
+    {"noop", ACTION_NOOP}};
+} // namespace
 
-void CActionTranslator::GetActions(std::vector<std::string> &actionList)
+void CActionTranslator::GetActions(std::vector<std::string>& actionList)
 {
   actionList.reserve(ActionMappings.size());
   for (auto& actionMapping : ActionMappings)
@@ -258,30 +256,30 @@ bool CActionTranslator::IsAnalog(unsigned int actionID)
 {
   switch (actionID)
   {
-  case ACTION_ANALOG_SEEK_FORWARD:
-  case ACTION_ANALOG_SEEK_BACK:
-  case ACTION_SCROLL_UP:
-  case ACTION_SCROLL_DOWN:
-  case ACTION_ANALOG_FORWARD:
-  case ACTION_ANALOG_REWIND:
-  case ACTION_ANALOG_MOVE:
-  case ACTION_ANALOG_MOVE_X_LEFT:
-  case ACTION_ANALOG_MOVE_X_RIGHT:
-  case ACTION_ANALOG_MOVE_Y_UP:
-  case ACTION_ANALOG_MOVE_Y_DOWN:
-  case ACTION_CURSOR_LEFT:
-  case ACTION_CURSOR_RIGHT:
-  case ACTION_VOLUME_UP:
-  case ACTION_VOLUME_DOWN:
-  case ACTION_ZOOM_IN:
-  case ACTION_ZOOM_OUT:
-    return true;
-  default:
-    return false;
+    case ACTION_ANALOG_SEEK_FORWARD:
+    case ACTION_ANALOG_SEEK_BACK:
+    case ACTION_SCROLL_UP:
+    case ACTION_SCROLL_DOWN:
+    case ACTION_ANALOG_FORWARD:
+    case ACTION_ANALOG_REWIND:
+    case ACTION_ANALOG_MOVE:
+    case ACTION_ANALOG_MOVE_X_LEFT:
+    case ACTION_ANALOG_MOVE_X_RIGHT:
+    case ACTION_ANALOG_MOVE_Y_UP:
+    case ACTION_ANALOG_MOVE_Y_DOWN:
+    case ACTION_CURSOR_LEFT:
+    case ACTION_CURSOR_RIGHT:
+    case ACTION_VOLUME_UP:
+    case ACTION_VOLUME_DOWN:
+    case ACTION_ZOOM_IN:
+    case ACTION_ZOOM_OUT:
+      return true;
+    default:
+      return false;
   }
 }
 
-bool CActionTranslator::TranslateString(std::string strAction, unsigned int &actionId)
+bool CActionTranslator::TranslateString(std::string strAction, unsigned int& actionId)
 {
   actionId = ACTION_NONE;
 
diff --git a/xbmc/input/actions/ActionTranslator.h b/xbmc/input/actions/ActionTranslator.h
index e4ada87c8671..91c146ae1cdb 100644
--- a/xbmc/input/actions/ActionTranslator.h
+++ b/xbmc/input/actions/ActionTranslator.h
@@ -14,7 +14,7 @@
 class CActionTranslator
 {
 public:
-  static void GetActions(std::vector<std::string> &actionList);
+  static void GetActions(std::vector<std::string>& actionList);
   static bool IsAnalog(unsigned int actionId);
-  static bool TranslateString(std::string strAction, unsigned int &actionId);
+  static bool TranslateString(std::string strAction, unsigned int& actionId);
 };
diff --git a/xbmc/input/hardware/IHardwareInput.h b/xbmc/input/hardware/IHardwareInput.h
index 6ac1d1f96974..6bfa75741cec 100644
--- a/xbmc/input/hardware/IHardwareInput.h
+++ b/xbmc/input/hardware/IHardwareInput.h
@@ -14,19 +14,19 @@ namespace KODI
 {
 namespace HARDWARE
 {
+/*!
+ * \ingroup hardware
+ * \brief Handles events for hardware such as reset buttons on a game console
+ */
+class IHardwareInput
+{
+public:
+  virtual ~IHardwareInput() = default;
+
   /*!
-   * \ingroup hardware
-   * \brief Handles events for hardware such as reset buttons on a game console
+   * \brief A hardware reset button has been pressed
    */
-  class IHardwareInput
-  {
-  public:
-    virtual ~IHardwareInput() = default;
-
-    /*!
-     * \brief A hardware reset button has been pressed
-     */
-    virtual void OnResetButton() = 0;
-  };
-}
-}
+  virtual void OnResetButton() = 0;
+};
+} // namespace HARDWARE
+} // namespace KODI
diff --git a/xbmc/input/joysticks/DeadzoneFilter.cpp b/xbmc/input/joysticks/DeadzoneFilter.cpp
index b3dc01745941..7b565c6abef8 100644
--- a/xbmc/input/joysticks/DeadzoneFilter.cpp
+++ b/xbmc/input/joysticks/DeadzoneFilter.cpp
@@ -20,26 +20,29 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-#define AXIS_EPSILON  0.01f // Allowed noise for detecting discrete D-pads (value of 0.007 when centered has been observed)
+#define AXIS_EPSILON \
+  0.01f // Allowed noise for detecting discrete D-pads (value of 0.007 when centered has been
+        // observed)
 
 // Settings for analog sticks
-#define SETTING_LEFT_STICK_DEADZONE   "left_stick_deadzone"
-#define SETTING_RIGHT_STICK_DEADZONE  "right_stick_deadzone"
+#define SETTING_LEFT_STICK_DEADZONE "left_stick_deadzone"
+#define SETTING_RIGHT_STICK_DEADZONE "right_stick_deadzone"
 
-CDeadzoneFilter::CDeadzoneFilter(IButtonMap* buttonMap, PERIPHERALS::CPeripheral* peripheral) :
-  m_buttonMap(buttonMap),
-  m_peripheral(peripheral)
+CDeadzoneFilter::CDeadzoneFilter(IButtonMap* buttonMap, PERIPHERALS::CPeripheral* peripheral)
+  : m_buttonMap(buttonMap), m_peripheral(peripheral)
 {
   if (m_buttonMap->ControllerID() != DEFAULT_CONTROLLER_ID)
-    CLog::Log(LOGERROR, "ERROR: Must use default controller profile instead of %s", m_buttonMap->ControllerID().c_str());
+    CLog::Log(LOGERROR, "ERROR: Must use default controller profile instead of %s",
+              m_buttonMap->ControllerID().c_str());
 }
 
 float CDeadzoneFilter::FilterAxis(unsigned int axisIndex, float axisValue)
 {
   float deadzone = 0.0f;
 
-  bool bSuccess = GetDeadzone(axisIndex, deadzone, DEFAULT_LEFT_STICK_NAME, SETTING_LEFT_STICK_DEADZONE) ||
-                  GetDeadzone(axisIndex, deadzone, DEFAULT_RIGHT_STICK_NAME, SETTING_RIGHT_STICK_DEADZONE);
+  bool bSuccess =
+      GetDeadzone(axisIndex, deadzone, DEFAULT_LEFT_STICK_NAME, SETTING_LEFT_STICK_DEADZONE) ||
+      GetDeadzone(axisIndex, deadzone, DEFAULT_RIGHT_STICK_NAME, SETTING_RIGHT_STICK_DEADZONE);
 
   if (bSuccess)
     return ApplyDeadzone(axisValue, deadzone);
@@ -51,13 +54,16 @@ float CDeadzoneFilter::FilterAxis(unsigned int axisIndex, float axisValue)
   return axisValue;
 }
 
-bool CDeadzoneFilter::GetDeadzone(unsigned int axisIndex, float& deadzone, const char* featureName, const char* settingName)
+bool CDeadzoneFilter::GetDeadzone(unsigned int axisIndex,
+                                  float& deadzone,
+                                  const char* featureName,
+                                  const char* settingName)
 {
   std::vector<ANALOG_STICK_DIRECTION> dirs = {
-    ANALOG_STICK_DIRECTION::UP,
-    ANALOG_STICK_DIRECTION::RIGHT,
-    ANALOG_STICK_DIRECTION::DOWN,
-    ANALOG_STICK_DIRECTION::LEFT,
+      ANALOG_STICK_DIRECTION::UP,
+      ANALOG_STICK_DIRECTION::RIGHT,
+      ANALOG_STICK_DIRECTION::DOWN,
+      ANALOG_STICK_DIRECTION::LEFT,
   };
 
   CDriverPrimitive primitive;
diff --git a/xbmc/input/joysticks/DeadzoneFilter.h b/xbmc/input/joysticks/DeadzoneFilter.h
index 8ae96b231f40..454705045386 100644
--- a/xbmc/input/joysticks/DeadzoneFilter.h
+++ b/xbmc/input/joysticks/DeadzoneFilter.h
@@ -10,70 +10,73 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheral;
+class CPeripheral;
 }
 
 namespace KODI
 {
 namespace JOYSTICK
 {
-  class IButtonMap;
+class IButtonMap;
+
+/*!
+ * \ingroup joystick
+ * \brief Analog axis deadzone filtering
+ *
+ * Axis is scaled appropriately, so position is continuous
+ * from -1.0 to 1.0:
+ *
+ *            |    / 1.0
+ *            |   /
+ *          __|__/
+ *         /  |
+ *        /   |--| Deadzone
+ *  -1.0 /    |
+ *
+ * After deadzone filtering, the value will be:
+ *
+ *   - Negative in the interval [-1.0, -deadzone)
+ *   - Zero in the interval [-deadzone, deadzone]
+ *   - Positive in the interval (deadzone, 1.0]
+ */
+class CDeadzoneFilter
+{
+public:
+  CDeadzoneFilter(IButtonMap* buttonMap, PERIPHERALS::CPeripheral* peripheral);
 
   /*!
-   * \ingroup joystick
-   * \brief Analog axis deadzone filtering
-   *
-   * Axis is scaled appropriately, so position is continuous
-   * from -1.0 to 1.0:
-   *
-   *            |    / 1.0
-   *            |   /
-   *          __|__/
-   *         /  |
-   *        /   |--| Deadzone
-   *  -1.0 /    |
-   *
-   * After deadzone filtering, the value will be:
-   *
-   *   - Negative in the interval [-1.0, -deadzone)
-   *   - Zero in the interval [-deadzone, deadzone]
-   *   - Positive in the interval (deadzone, 1.0]
+   * \brief Apply deadzone filtering to an axis
+   * \param axisIndex The axis index
+   * \param axisValue The axis value
+   * \return The value after applying deadzone filtering
    */
-  class CDeadzoneFilter
-  {
-  public:
-    CDeadzoneFilter(IButtonMap* buttonMap, PERIPHERALS::CPeripheral* peripheral);
+  float FilterAxis(unsigned int axisIndex, float axisValue);
 
-    /*!
-     * \brief Apply deadzone filtering to an axis
-     * \param axisIndex The axis index
-     * \param axisValue The axis value
-     * \return The value after applying deadzone filtering
-     */
-    float FilterAxis(unsigned int axisIndex, float axisValue);
-
-  private:
-    /*!
-     * \brief Get the deadzone value from the peripheral's settings
-     * \param axisIndex The axis index
-     * \param[out] result The deadzone value
-     * \param featureName The feature that axisIndex is mapped to
-     * \param settingName The setting corresponding to the given feature
-     * \return True if the feature is an analog stick and the peripheral has the setting
-     */
-    bool GetDeadzone(unsigned int axisIndex, float& result, const char* featureName, const char* settingName);
+private:
+  /*!
+   * \brief Get the deadzone value from the peripheral's settings
+   * \param axisIndex The axis index
+   * \param[out] result The deadzone value
+   * \param featureName The feature that axisIndex is mapped to
+   * \param settingName The setting corresponding to the given feature
+   * \return True if the feature is an analog stick and the peripheral has the setting
+   */
+  bool GetDeadzone(unsigned int axisIndex,
+                   float& result,
+                   const char* featureName,
+                   const char* settingName);
 
-    /*!
-     * \brief Utility function to calculate the deadzone
-     * \param value The value
-     * \param deadzone The deadzone
-     * \return The scaled deadzone
-     */
-    static float ApplyDeadzone(float value, float deadzone);
+  /*!
+   * \brief Utility function to calculate the deadzone
+   * \param value The value
+   * \param deadzone The deadzone
+   * \return The scaled deadzone
+   */
+  static float ApplyDeadzone(float value, float deadzone);
 
-    // Construction parameters
-    IButtonMap* const               m_buttonMap;
-    PERIPHERALS::CPeripheral* const m_peripheral;
-  };
-}
-}
+  // Construction parameters
+  IButtonMap* const m_buttonMap;
+  PERIPHERALS::CPeripheral* const m_peripheral;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/DriverPrimitive.cpp b/xbmc/input/joysticks/DriverPrimitive.cpp
index 492b88e0a995..9540dfd2ede4 100644
--- a/xbmc/input/joysticks/DriverPrimitive.cpp
+++ b/xbmc/input/joysticks/DriverPrimitive.cpp
@@ -16,19 +16,19 @@ using namespace JOYSTICK;
 CDriverPrimitive::CDriverPrimitive(void) = default;
 
 CDriverPrimitive::CDriverPrimitive(PRIMITIVE_TYPE type, unsigned int index)
-  : m_type(type),
-    m_driverIndex(index)
+  : m_type(type), m_driverIndex(index)
 {
 }
 
 CDriverPrimitive::CDriverPrimitive(unsigned int hatIndex, HAT_DIRECTION direction)
-  : m_type(PRIMITIVE_TYPE::HAT),
-    m_driverIndex(hatIndex),
-    m_hatDirection(direction)
+  : m_type(PRIMITIVE_TYPE::HAT), m_driverIndex(hatIndex), m_hatDirection(direction)
 {
 }
 
-CDriverPrimitive::CDriverPrimitive(unsigned int axisIndex, int center, SEMIAXIS_DIRECTION direction, unsigned int range)
+CDriverPrimitive::CDriverPrimitive(unsigned int axisIndex,
+                                   int center,
+                                   SEMIAXIS_DIRECTION direction,
+                                   unsigned int range)
   : m_type(PRIMITIVE_TYPE::SEMIAXIS),
     m_driverIndex(axisIndex),
     m_center(center),
@@ -37,21 +37,18 @@ CDriverPrimitive::CDriverPrimitive(unsigned int axisIndex, int center, SEMIAXIS_
 {
 }
 
-CDriverPrimitive::CDriverPrimitive(XBMCKey keycode) :
-  m_type(PRIMITIVE_TYPE::KEY),
-  m_keycode(keycode)
+CDriverPrimitive::CDriverPrimitive(XBMCKey keycode)
+  : m_type(PRIMITIVE_TYPE::KEY), m_keycode(keycode)
 {
 }
 
-CDriverPrimitive::CDriverPrimitive(MOUSE::BUTTON_ID index) :
-  m_type(PRIMITIVE_TYPE::MOUSE_BUTTON),
-  m_driverIndex(static_cast<unsigned int>(index))
+CDriverPrimitive::CDriverPrimitive(MOUSE::BUTTON_ID index)
+  : m_type(PRIMITIVE_TYPE::MOUSE_BUTTON), m_driverIndex(static_cast<unsigned int>(index))
 {
 }
 
-CDriverPrimitive::CDriverPrimitive(RELATIVE_POINTER_DIRECTION direction) :
-  m_type(PRIMITIVE_TYPE::RELATIVE_POINTER),
-  m_pointerDirection(direction)
+CDriverPrimitive::CDriverPrimitive(RELATIVE_POINTER_DIRECTION direction)
+  : m_type(PRIMITIVE_TYPE::RELATIVE_POINTER), m_pointerDirection(direction)
 {
 }
 
@@ -61,23 +58,21 @@ bool CDriverPrimitive::operator==(const CDriverPrimitive& rhs) const
   {
     switch (m_type)
     {
-    case PRIMITIVE_TYPE::BUTTON:
-    case PRIMITIVE_TYPE::MOTOR:
-    case PRIMITIVE_TYPE::MOUSE_BUTTON:
-      return m_driverIndex == rhs.m_driverIndex;
-    case PRIMITIVE_TYPE::HAT:
-      return m_driverIndex == rhs.m_driverIndex && m_hatDirection == rhs.m_hatDirection;
-    case PRIMITIVE_TYPE::SEMIAXIS:
-      return m_driverIndex       == rhs.m_driverIndex &&
-             m_center            == rhs.m_center &&
-             m_semiAxisDirection == rhs.m_semiAxisDirection &&
-             m_range             == rhs.m_range;
-    case PRIMITIVE_TYPE::KEY:
-      return m_keycode == rhs.m_keycode;
-    case PRIMITIVE_TYPE::RELATIVE_POINTER:
-      return m_pointerDirection == rhs.m_pointerDirection;
-    default:
-      return true;
+      case PRIMITIVE_TYPE::BUTTON:
+      case PRIMITIVE_TYPE::MOTOR:
+      case PRIMITIVE_TYPE::MOUSE_BUTTON:
+        return m_driverIndex == rhs.m_driverIndex;
+      case PRIMITIVE_TYPE::HAT:
+        return m_driverIndex == rhs.m_driverIndex && m_hatDirection == rhs.m_hatDirection;
+      case PRIMITIVE_TYPE::SEMIAXIS:
+        return m_driverIndex == rhs.m_driverIndex && m_center == rhs.m_center &&
+               m_semiAxisDirection == rhs.m_semiAxisDirection && m_range == rhs.m_range;
+      case PRIMITIVE_TYPE::KEY:
+        return m_keycode == rhs.m_keycode;
+      case PRIMITIVE_TYPE::RELATIVE_POINTER:
+        return m_pointerDirection == rhs.m_pointerDirection;
+      default:
+        return true;
     }
   }
   return false;
@@ -85,47 +80,61 @@ bool CDriverPrimitive::operator==(const CDriverPrimitive& rhs) const
 
 bool CDriverPrimitive::operator<(const CDriverPrimitive& rhs) const
 {
-  if (m_type < rhs.m_type) return true;
-  if (m_type > rhs.m_type) return false;
+  if (m_type < rhs.m_type)
+    return true;
+  if (m_type > rhs.m_type)
+    return false;
 
-  if (m_type == PRIMITIVE_TYPE::BUTTON ||
-      m_type == PRIMITIVE_TYPE::HAT ||
-      m_type == PRIMITIVE_TYPE::SEMIAXIS ||
-      m_type == PRIMITIVE_TYPE::MOTOR ||
+  if (m_type == PRIMITIVE_TYPE::BUTTON || m_type == PRIMITIVE_TYPE::HAT ||
+      m_type == PRIMITIVE_TYPE::SEMIAXIS || m_type == PRIMITIVE_TYPE::MOTOR ||
       m_type == PRIMITIVE_TYPE::MOUSE_BUTTON)
   {
-    if (m_driverIndex < rhs.m_driverIndex) return true;
-    if (m_driverIndex > rhs.m_driverIndex) return false;
+    if (m_driverIndex < rhs.m_driverIndex)
+      return true;
+    if (m_driverIndex > rhs.m_driverIndex)
+      return false;
   }
 
   if (m_type == PRIMITIVE_TYPE::HAT)
   {
-    if (m_hatDirection < rhs.m_hatDirection) return true;
-    if (m_hatDirection > rhs.m_hatDirection) return false;
+    if (m_hatDirection < rhs.m_hatDirection)
+      return true;
+    if (m_hatDirection > rhs.m_hatDirection)
+      return false;
   }
 
   if (m_type == PRIMITIVE_TYPE::SEMIAXIS)
   {
-    if (m_center < rhs.m_center) return true;
-    if (m_center > rhs.m_center) return false;
+    if (m_center < rhs.m_center)
+      return true;
+    if (m_center > rhs.m_center)
+      return false;
 
-    if (m_semiAxisDirection < rhs.m_semiAxisDirection) return true;
-    if (m_semiAxisDirection > rhs.m_semiAxisDirection) return false;
+    if (m_semiAxisDirection < rhs.m_semiAxisDirection)
+      return true;
+    if (m_semiAxisDirection > rhs.m_semiAxisDirection)
+      return false;
 
-    if (m_range < rhs.m_range) return true;
-    if (m_range > rhs.m_range) return false;
+    if (m_range < rhs.m_range)
+      return true;
+    if (m_range > rhs.m_range)
+      return false;
   }
 
   if (m_type == PRIMITIVE_TYPE::KEY)
   {
-    if (m_keycode < rhs.m_keycode) return true;
-    if (m_keycode > rhs.m_keycode) return false;
+    if (m_keycode < rhs.m_keycode)
+      return true;
+    if (m_keycode > rhs.m_keycode)
+      return false;
   }
 
   if (m_type == PRIMITIVE_TYPE::RELATIVE_POINTER)
   {
-    if (m_pointerDirection < rhs.m_pointerDirection) return true;
-    if (m_pointerDirection > rhs.m_pointerDirection) return false;
+    if (m_pointerDirection < rhs.m_pointerDirection)
+      return true;
+    if (m_pointerDirection > rhs.m_pointerDirection)
+      return false;
   }
 
   return false;
@@ -133,17 +142,14 @@ bool CDriverPrimitive::operator<(const CDriverPrimitive& rhs) const
 
 bool CDriverPrimitive::IsValid(void) const
 {
-  if (m_type == PRIMITIVE_TYPE::BUTTON ||
-      m_type == PRIMITIVE_TYPE::MOTOR ||
+  if (m_type == PRIMITIVE_TYPE::BUTTON || m_type == PRIMITIVE_TYPE::MOTOR ||
       m_type == PRIMITIVE_TYPE::MOUSE_BUTTON)
     return true;
 
   if (m_type == PRIMITIVE_TYPE::HAT)
   {
-    return m_hatDirection == HAT_DIRECTION::UP    ||
-           m_hatDirection == HAT_DIRECTION::DOWN  ||
-           m_hatDirection == HAT_DIRECTION::RIGHT ||
-           m_hatDirection == HAT_DIRECTION::LEFT;
+    return m_hatDirection == HAT_DIRECTION::UP || m_hatDirection == HAT_DIRECTION::DOWN ||
+           m_hatDirection == HAT_DIRECTION::RIGHT || m_hatDirection == HAT_DIRECTION::LEFT;
   }
 
   if (m_type == PRIMITIVE_TYPE::SEMIAXIS)
@@ -152,29 +158,29 @@ bool CDriverPrimitive::IsValid(void) const
 
     switch (m_center)
     {
-    case -1:
-    {
-      if (m_semiAxisDirection != SEMIAXIS_DIRECTION::POSITIVE)
-        return false;
-      maxRange = 2;
-      break;
-    }
-    case 0:
-    {
-      if (m_semiAxisDirection != SEMIAXIS_DIRECTION::POSITIVE &&
-          m_semiAxisDirection != SEMIAXIS_DIRECTION::NEGATIVE)
-        return false;
-      break;
-    }
-    case 1:
-    {
-      if (m_semiAxisDirection != SEMIAXIS_DIRECTION::POSITIVE)
-        return false;
-      maxRange = 2;
-      break;
-    }
-    default:
-      break;
+      case -1:
+      {
+        if (m_semiAxisDirection != SEMIAXIS_DIRECTION::POSITIVE)
+          return false;
+        maxRange = 2;
+        break;
+      }
+      case 0:
+      {
+        if (m_semiAxisDirection != SEMIAXIS_DIRECTION::POSITIVE &&
+            m_semiAxisDirection != SEMIAXIS_DIRECTION::NEGATIVE)
+          return false;
+        break;
+      }
+      case 1:
+      {
+        if (m_semiAxisDirection != SEMIAXIS_DIRECTION::POSITIVE)
+          return false;
+        maxRange = 2;
+        break;
+      }
+      default:
+        break;
     }
 
     return 1 <= m_range && m_range <= maxRange;
@@ -185,8 +191,8 @@ bool CDriverPrimitive::IsValid(void) const
 
   if (m_type == PRIMITIVE_TYPE::RELATIVE_POINTER)
   {
-    return m_pointerDirection == RELATIVE_POINTER_DIRECTION::UP    ||
-           m_pointerDirection == RELATIVE_POINTER_DIRECTION::DOWN  ||
+    return m_pointerDirection == RELATIVE_POINTER_DIRECTION::UP ||
+           m_pointerDirection == RELATIVE_POINTER_DIRECTION::DOWN ||
            m_pointerDirection == RELATIVE_POINTER_DIRECTION::RIGHT ||
            m_pointerDirection == RELATIVE_POINTER_DIRECTION::LEFT;
   }
diff --git a/xbmc/input/joysticks/DriverPrimitive.h b/xbmc/input/joysticks/DriverPrimitive.h
index c97661c80411..07d80e3f7c76 100644
--- a/xbmc/input/joysticks/DriverPrimitive.h
+++ b/xbmc/input/joysticks/DriverPrimitive.h
@@ -18,173 +18,176 @@ namespace KODI
 {
 namespace JOYSTICK
 {
+/*!
+ * \ingroup joystick
+ * \brief Basic driver element associated with input events
+ *
+ * Driver input (bools, floats and enums) is split into primitives that better
+ * map to the physical features on a joystick.
+ *
+ * A bool obviously only maps to a single feature, so it is a driver
+ * primitive. Here, these are called "buttons".
+ *
+ * A hat enum encodes the state of the four hat directions. Each direction
+ * can map to a different feature, so a hat enum consists of four driver
+ * primitives called "hat directions".
+ *
+ * A float is a little trickier. Trivially, it can map to an analog stick or
+ * trigger. However, DirectInput combines two triggers onto a single axis.
+ * Therefore, the axis is split into two primitives called "semiaxes".
+ *
+ * The type determines the fields in use:
+ *
+ *    Button:
+ *       - driver index
+ *
+ *    Hat direction:
+ *       - driver index
+ *       - hat direction (up/right/down/left)
+ *
+ *    Semiaxis:
+ *       - driver index
+ *       - center (-1, 0 or 1)
+ *       - semiaxis direction (positive/negative)
+ *       - range (1 or 2)
+ *
+ *    Motor:
+ *       - driver index
+ *
+ *    Key:
+ *       - keycode
+ *
+ *    Mouse button:
+ *       - driver index
+ *
+ *    Relative pointer:
+ *       - pointer direction
+ *
+ * For more info, see "Chapter 2. Joystick drivers" in the documentation
+ * thread: http://forum.kodi.tv/showthread.php?tid=257764
+ */
+class CDriverPrimitive
+{
+public:
   /*!
-   * \ingroup joystick
-   * \brief Basic driver element associated with input events
-   *
-   * Driver input (bools, floats and enums) is split into primitives that better
-   * map to the physical features on a joystick.
-   *
-   * A bool obviously only maps to a single feature, so it is a driver
-   * primitive. Here, these are called "buttons".
-   *
-   * A hat enum encodes the state of the four hat directions. Each direction
-   * can map to a different feature, so a hat enum consists of four driver
-   * primitives called "hat directions".
-   *
-   * A float is a little trickier. Trivially, it can map to an analog stick or
-   * trigger. However, DirectInput combines two triggers onto a single axis.
-   * Therefore, the axis is split into two primitives called "semiaxes".
-   *
-   * The type determines the fields in use:
-   *
-   *    Button:
-   *       - driver index
-   *
-   *    Hat direction:
-   *       - driver index
-   *       - hat direction (up/right/down/left)
-   *
-   *    Semiaxis:
-   *       - driver index
-   *       - center (-1, 0 or 1)
-   *       - semiaxis direction (positive/negative)
-   *       - range (1 or 2)
-   *
-   *    Motor:
-   *       - driver index
-   *
-   *    Key:
-   *       - keycode
+   * \brief Construct an invalid driver primitive
+   */
+  CDriverPrimitive(void);
+
+  /*!
+   * \brief Construct a driver primitive representing a button or motor
+   */
+  CDriverPrimitive(PRIMITIVE_TYPE type, unsigned int index);
+
+  /*!
+   * \brief Construct a driver primitive representing one of the four
+   *        direction arrows on a dpad
+   */
+  CDriverPrimitive(unsigned int hatIndex, HAT_DIRECTION direction);
+
+  /*!
+   * \brief Construct a driver primitive representing the positive or negative
+   *        half of an axis
+   */
+  CDriverPrimitive(unsigned int axisIndex,
+                   int center,
+                   SEMIAXIS_DIRECTION direction,
+                   unsigned int range);
+
+  /*!
+   * \brief Construct a driver primitive representing a key on a keyboard
+   */
+  CDriverPrimitive(KEYBOARD::KeySymbol keycode);
+
+  /*!
+   * \brief Construct a driver primitive representing a mouse button
+   */
+  CDriverPrimitive(MOUSE::BUTTON_ID index);
+
+  /*!
+   * \brief Construct a driver primitive representing a relative pointer
+   */
+  CDriverPrimitive(RELATIVE_POINTER_DIRECTION direction);
+
+  bool operator==(const CDriverPrimitive& rhs) const;
+  bool operator<(const CDriverPrimitive& rhs) const;
+
+  bool operator!=(const CDriverPrimitive& rhs) const { return !operator==(rhs); }
+  bool operator>(const CDriverPrimitive& rhs) const { return !(operator<(rhs) || operator==(rhs)); }
+  bool operator<=(const CDriverPrimitive& rhs) const { return operator<(rhs) || operator==(rhs); }
+  bool operator>=(const CDriverPrimitive& rhs) const { return !operator<(rhs); }
+
+  /*!
+   * \brief The type of driver primitive
+   */
+  PRIMITIVE_TYPE Type(void) const { return m_type; }
+
+  /*!
+   * \brief The index used by the joystick driver
    *
-   *    Mouse button:
-   *       - driver index
+   * Valid for:
+   *   - buttons
+   *   - hats
+   *   - semiaxes
+   *   - motors
+   */
+  unsigned int Index(void) const { return m_driverIndex; }
+
+  /*!
+   * \brief The direction arrow (valid for hat directions)
+   */
+  HAT_DIRECTION HatDirection(void) const { return m_hatDirection; }
+
+  /*!
+   * \brief The location of the zero point of the semiaxis
+   */
+  int Center() const { return m_center; }
+
+  /*!
+   * \brief The semiaxis direction (valid for semiaxes)
+   */
+  SEMIAXIS_DIRECTION SemiAxisDirection(void) const { return m_semiAxisDirection; }
+
+  /*!
+   * \brief The distance between the center and the farthest valid value (valid for semiaxes)
+   */
+  unsigned int Range() const { return m_range; }
+
+  /*!
+   * \brief The keybord symbol (valid for keys)
+   */
+  KEYBOARD::KeySymbol Keycode() const { return m_keycode; }
+
+  /*!
+   * \brief The mouse button ID (valid for mouse buttons)
+   */
+  MOUSE::BUTTON_ID MouseButton() const { return static_cast<MOUSE::BUTTON_ID>(m_driverIndex); }
+
+  /*!
+   * \brief The relative pointer direction (valid for relative pointers)
+   */
+  RELATIVE_POINTER_DIRECTION PointerDirection() const { return m_pointerDirection; }
+
+  /*!
+   * \brief Test if an driver primitive is valid
    *
-   *    Relative pointer:
-   *       - pointer direction
+   * A driver primitive is valid if it has a known type and:
    *
-   * For more info, see "Chapter 2. Joystick drivers" in the documentation
-   * thread: http://forum.kodi.tv/showthread.php?tid=257764
-   */
-  class CDriverPrimitive
-  {
-  public:
-    /*!
-     * \brief Construct an invalid driver primitive
-     */
-    CDriverPrimitive(void);
-
-    /*!
-     * \brief Construct a driver primitive representing a button or motor
-     */
-    CDriverPrimitive(PRIMITIVE_TYPE type, unsigned int index);
-
-    /*!
-     * \brief Construct a driver primitive representing one of the four
-     *        direction arrows on a dpad
-     */
-    CDriverPrimitive(unsigned int hatIndex, HAT_DIRECTION direction);
-
-    /*!
-     * \brief Construct a driver primitive representing the positive or negative
-     *        half of an axis
-     */
-    CDriverPrimitive(unsigned int axisIndex, int center, SEMIAXIS_DIRECTION direction, unsigned int range);
-
-    /*!
-     * \brief Construct a driver primitive representing a key on a keyboard
-     */
-    CDriverPrimitive(KEYBOARD::KeySymbol keycode);
-
-    /*!
-     * \brief Construct a driver primitive representing a mouse button
-     */
-    CDriverPrimitive(MOUSE::BUTTON_ID index);
-
-    /*!
-     * \brief Construct a driver primitive representing a relative pointer
-     */
-    CDriverPrimitive(RELATIVE_POINTER_DIRECTION direction);
-
-    bool operator==(const CDriverPrimitive& rhs) const;
-    bool operator<(const CDriverPrimitive& rhs) const;
-
-    bool operator!=(const CDriverPrimitive& rhs) const { return !operator==(rhs); }
-    bool operator>(const CDriverPrimitive& rhs) const  { return !(operator<(rhs) || operator==(rhs)); }
-    bool operator<=(const CDriverPrimitive& rhs) const { return   operator<(rhs) || operator==(rhs); }
-    bool operator>=(const CDriverPrimitive& rhs) const { return  !operator<(rhs); }
-
-    /*!
-     * \brief The type of driver primitive
-     */
-    PRIMITIVE_TYPE Type(void) const { return m_type; }
-
-    /*!
-     * \brief The index used by the joystick driver
-     *
-     * Valid for:
-     *   - buttons
-     *   - hats
-     *   - semiaxes
-     *   - motors
-     */
-    unsigned int Index(void) const { return m_driverIndex; }
-
-    /*!
-     * \brief The direction arrow (valid for hat directions)
-     */
-    HAT_DIRECTION HatDirection(void) const { return m_hatDirection; }
-
-    /*!
-     * \brief The location of the zero point of the semiaxis
-     */
-    int Center() const { return m_center; }
-
-    /*!
-     * \brief The semiaxis direction (valid for semiaxes)
-     */
-    SEMIAXIS_DIRECTION SemiAxisDirection(void) const { return m_semiAxisDirection; }
-
-    /*!
-     * \brief The distance between the center and the farthest valid value (valid for semiaxes)
-     */
-    unsigned int Range() const { return m_range; }
-
-    /*!
-     * \brief The keybord symbol (valid for keys)
-     */
-    KEYBOARD::KeySymbol Keycode() const { return m_keycode; }
-
-    /*!
-     * \brief The mouse button ID (valid for mouse buttons)
-     */
-    MOUSE::BUTTON_ID MouseButton() const { return static_cast<MOUSE::BUTTON_ID>(m_driverIndex); }
-
-    /*!
-     * \brief The relative pointer direction (valid for relative pointers)
-     */
-    RELATIVE_POINTER_DIRECTION PointerDirection() const { return m_pointerDirection; }
-
-    /*!
-     * \brief Test if an driver primitive is valid
-     *
-     * A driver primitive is valid if it has a known type and:
-     *
-     *   1) for hats, it is a cardinal direction
-     *   2) for semi-axes, it is a positive or negative direction
-     *   3) for keys, the keycode is non-empty
-     */
-    bool IsValid(void) const;
-
-  private:
-    PRIMITIVE_TYPE     m_type = PRIMITIVE_TYPE::UNKNOWN;
-    unsigned int       m_driverIndex = 0;
-    HAT_DIRECTION      m_hatDirection = HAT_DIRECTION::NONE;
-    int                m_center = 0;
-    SEMIAXIS_DIRECTION m_semiAxisDirection = SEMIAXIS_DIRECTION::ZERO;
-    unsigned int       m_range = 1;
-    KEYBOARD::KeySymbol m_keycode = XBMCK_UNKNOWN;
-    RELATIVE_POINTER_DIRECTION m_pointerDirection = RELATIVE_POINTER_DIRECTION::NONE;
-  };
-}
-}
+   *   1) for hats, it is a cardinal direction
+   *   2) for semi-axes, it is a positive or negative direction
+   *   3) for keys, the keycode is non-empty
+   */
+  bool IsValid(void) const;
+
+private:
+  PRIMITIVE_TYPE m_type = PRIMITIVE_TYPE::UNKNOWN;
+  unsigned int m_driverIndex = 0;
+  HAT_DIRECTION m_hatDirection = HAT_DIRECTION::NONE;
+  int m_center = 0;
+  SEMIAXIS_DIRECTION m_semiAxisDirection = SEMIAXIS_DIRECTION::ZERO;
+  unsigned int m_range = 1;
+  KEYBOARD::KeySymbol m_keycode = XBMCK_UNKNOWN;
+  RELATIVE_POINTER_DIRECTION m_pointerDirection = RELATIVE_POINTER_DIRECTION::NONE;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/JoystickEasterEgg.cpp b/xbmc/input/joysticks/JoystickEasterEgg.cpp
index ccfdfa8894e9..0c63e664702e 100644
--- a/xbmc/input/joysticks/JoystickEasterEgg.cpp
+++ b/xbmc/input/joysticks/JoystickEasterEgg.cpp
@@ -18,43 +18,41 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-const std::map<std::string, std::vector<FeatureName>> CJoystickEasterEgg::m_sequence =
-{
-  {
-    DEFAULT_CONTROLLER_ID,
+const std::map<std::string, std::vector<FeatureName>> CJoystickEasterEgg::m_sequence = {
     {
-      "up",
-      "up",
-      "down",
-      "down",
-      "left",
-      "right",
-      "left",
-      "right",
-      "b",
-      "a",
+        DEFAULT_CONTROLLER_ID,
+        {
+            "up",
+            "up",
+            "down",
+            "down",
+            "left",
+            "right",
+            "left",
+            "right",
+            "b",
+            "a",
+        },
     },
-  },
-  {
-    DEFAULT_REMOTE_ID,
     {
-      "up",
-      "up",
-      "down",
-      "down",
-      "left",
-      "right",
-      "left",
-      "right",
-      "back",
-      "ok",
+        DEFAULT_REMOTE_ID,
+        {
+            "up",
+            "up",
+            "down",
+            "down",
+            "left",
+            "right",
+            "left",
+            "right",
+            "back",
+            "ok",
+        },
     },
-  },
 };
 
-CJoystickEasterEgg::CJoystickEasterEgg(const std::string& controllerId) :
-  m_controllerId(controllerId),
-  m_state(0)
+CJoystickEasterEgg::CJoystickEasterEgg(const std::string& controllerId)
+  : m_controllerId(controllerId), m_state(0)
 {
 }
 
@@ -96,7 +94,7 @@ bool CJoystickEasterEgg::IsCapturing()
 
 void CJoystickEasterEgg::OnFinish(void)
 {
-  GAME::CGameSettings &gameSettings = CServiceBroker::GetGameServices().GameSettings();
+  GAME::CGameSettings& gameSettings = CServiceBroker::GetGameServices().GameSettings();
   gameSettings.ToggleGames();
 
   WINDOW_SOUND sound = gameSettings.GamesEnabled() ? SOUND_INIT : SOUND_DEINIT;
diff --git a/xbmc/input/joysticks/JoystickEasterEgg.h b/xbmc/input/joysticks/JoystickEasterEgg.h
index 0579b273a8c4..7059d1353569 100644
--- a/xbmc/input/joysticks/JoystickEasterEgg.h
+++ b/xbmc/input/joysticks/JoystickEasterEgg.h
@@ -18,28 +18,28 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  /*!
-   * \brief Hush!!!
-   */
-  class CJoystickEasterEgg : public IButtonSequence
-  {
-  public:
-    explicit CJoystickEasterEgg(const std::string& controllerId);
-    ~CJoystickEasterEgg() override = default;
-
-    // implementation of IButtonSequence
-    bool OnButtonPress(const FeatureName& feature) override;
-    bool IsCapturing() override;
-
-    static void OnFinish(void);
-
-  private:
-    // Construction parameters
-    const std::string m_controllerId;
-
-    static const std::map<std::string, std::vector<FeatureName>> m_sequence;
-
-    unsigned int m_state;
-  };
-}
-}
+/*!
+ * \brief Hush!!!
+ */
+class CJoystickEasterEgg : public IButtonSequence
+{
+public:
+  explicit CJoystickEasterEgg(const std::string& controllerId);
+  ~CJoystickEasterEgg() override = default;
+
+  // implementation of IButtonSequence
+  bool OnButtonPress(const FeatureName& feature) override;
+  bool IsCapturing() override;
+
+  static void OnFinish(void);
+
+private:
+  // Construction parameters
+  const std::string m_controllerId;
+
+  static const std::map<std::string, std::vector<FeatureName>> m_sequence;
+
+  unsigned int m_state;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/JoystickIDs.h b/xbmc/input/joysticks/JoystickIDs.h
index d17c1bb13bd6..52ffcf47df39 100644
--- a/xbmc/input/joysticks/JoystickIDs.h
+++ b/xbmc/input/joysticks/JoystickIDs.h
@@ -8,6 +8,6 @@
 
 #pragma once
 
- // Analog sticks on the default controller
-#define DEFAULT_LEFT_STICK_NAME   "leftstick"
-#define DEFAULT_RIGHT_STICK_NAME  "rightstick"
+// Analog sticks on the default controller
+#define DEFAULT_LEFT_STICK_NAME "leftstick"
+#define DEFAULT_RIGHT_STICK_NAME "rightstick"
diff --git a/xbmc/input/joysticks/JoystickMonitor.cpp b/xbmc/input/joysticks/JoystickMonitor.cpp
index 72b671a37084..2687ef988266 100644
--- a/xbmc/input/joysticks/JoystickMonitor.cpp
+++ b/xbmc/input/joysticks/JoystickMonitor.cpp
@@ -18,7 +18,7 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-#define AXIS_DEADZONE  0.05f
+#define AXIS_DEADZONE 0.05f
 
 std::string CJoystickMonitor::ControllerID() const
 {
@@ -42,7 +42,9 @@ bool CJoystickMonitor::OnButtonPress(const FeatureName& feature, bool bPressed)
   return false;
 }
 
-bool CJoystickMonitor::OnButtonMotion(const FeatureName& feature, float magnitude, unsigned int motionTimeMs)
+bool CJoystickMonitor::OnButtonMotion(const FeatureName& feature,
+                                      float magnitude,
+                                      unsigned int motionTimeMs)
 {
   if (std::fabs(magnitude) > AXIS_DEADZONE)
   {
@@ -53,7 +55,10 @@ bool CJoystickMonitor::OnButtonMotion(const FeatureName& feature, float magnitud
   return false;
 }
 
-bool CJoystickMonitor::OnAnalogStickMotion(const FeatureName& feature, float x, float y, unsigned int motionTimeMs)
+bool CJoystickMonitor::OnAnalogStickMotion(const FeatureName& feature,
+                                           float x,
+                                           float y,
+                                           unsigned int motionTimeMs)
 {
   // Analog stick deadzone already processed
   if (x != 0.0f || y != 0.0f)
@@ -65,7 +70,9 @@ bool CJoystickMonitor::OnAnalogStickMotion(const FeatureName& feature, float x,
   return false;
 }
 
-bool CJoystickMonitor::OnWheelMotion(const FeatureName& feature, float position, unsigned int motionTimeMs)
+bool CJoystickMonitor::OnWheelMotion(const FeatureName& feature,
+                                     float position,
+                                     unsigned int motionTimeMs)
 {
   if (std::fabs(position) > AXIS_DEADZONE)
   {
@@ -76,7 +83,9 @@ bool CJoystickMonitor::OnWheelMotion(const FeatureName& feature, float position,
   return false;
 }
 
-bool CJoystickMonitor::OnThrottleMotion(const FeatureName& feature, float position, unsigned int motionTimeMs)
+bool CJoystickMonitor::OnThrottleMotion(const FeatureName& feature,
+                                        float position,
+                                        unsigned int motionTimeMs)
 {
   if (std::fabs(position) > AXIS_DEADZONE)
   {
diff --git a/xbmc/input/joysticks/JoystickMonitor.h b/xbmc/input/joysticks/JoystickMonitor.h
index 8821ce5cd009..45636012271c 100644
--- a/xbmc/input/joysticks/JoystickMonitor.h
+++ b/xbmc/input/joysticks/JoystickMonitor.h
@@ -14,32 +14,44 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  /*!
-   * \ingroup joystick
-   * \brief Monitors joystick input and resets screensaver/shutdown timers
-   *        whenever motion occurs.
-   */
-  class CJoystickMonitor : public IInputHandler
+/*!
+ * \ingroup joystick
+ * \brief Monitors joystick input and resets screensaver/shutdown timers
+ *        whenever motion occurs.
+ */
+class CJoystickMonitor : public IInputHandler
+{
+public:
+  // implementation of IInputHandler
+  std::string ControllerID() const override;
+  bool HasFeature(const FeatureName& feature) const override { return true; }
+  bool AcceptsInput(const FeatureName& feature) const override;
+  bool OnButtonPress(const FeatureName& feature, bool bPressed) override;
+  void OnButtonHold(const FeatureName& feature, unsigned int holdTimeMs) override {}
+  bool OnButtonMotion(const FeatureName& feature,
+                      float magnitude,
+                      unsigned int motionTimeMs) override;
+  bool OnAnalogStickMotion(const FeatureName& feature,
+                           float x,
+                           float y,
+                           unsigned int motionTimeMs) override;
+  bool OnAccelerometerMotion(const FeatureName& feature, float x, float y, float z) override
   {
-  public:
-    // implementation of IInputHandler
-    std::string ControllerID() const override;
-    bool HasFeature(const FeatureName& feature) const override { return true; }
-    bool AcceptsInput(const FeatureName& feature) const override;
-    bool OnButtonPress(const FeatureName& feature, bool bPressed) override;
-    void OnButtonHold(const FeatureName& feature, unsigned int holdTimeMs) override {}
-    bool OnButtonMotion(const FeatureName& feature, float magnitude, unsigned int motionTimeMs) override;
-    bool OnAnalogStickMotion(const FeatureName& feature, float x, float y, unsigned int motionTimeMs) override;
-    bool OnAccelerometerMotion(const FeatureName& feature, float x, float y, float z) override { return false; }
-    bool OnWheelMotion(const FeatureName& feature, float position, unsigned int motionTimeMs) override;
-    bool OnThrottleMotion(const FeatureName& feature, float position, unsigned int motionTimeMs) override;
+    return false;
+  }
+  bool OnWheelMotion(const FeatureName& feature,
+                     float position,
+                     unsigned int motionTimeMs) override;
+  bool OnThrottleMotion(const FeatureName& feature,
+                        float position,
+                        unsigned int motionTimeMs) override;
 
-  private:
-    /*!
-     * \brief  Reset screensaver and shutdown timers
-     * \return True if the application was woken from screensaver
-     */
-    bool ResetTimers(void);
-  };
-}
-}
+private:
+  /*!
+   * \brief  Reset screensaver and shutdown timers
+   * \return True if the application was woken from screensaver
+   */
+  bool ResetTimers(void);
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/JoystickTranslator.cpp b/xbmc/input/joysticks/JoystickTranslator.cpp
index f6116b7df651..d5a2642b3d7f 100644
--- a/xbmc/input/joysticks/JoystickTranslator.cpp
+++ b/xbmc/input/joysticks/JoystickTranslator.cpp
@@ -19,14 +19,22 @@ const char* CJoystickTranslator::HatStateToString(HAT_STATE state)
 {
   switch (state)
   {
-    case HAT_STATE::UP:        return "UP";
-    case HAT_STATE::DOWN:      return "DOWN";
-    case HAT_STATE::RIGHT:     return "RIGHT";
-    case HAT_STATE::LEFT:      return "LEFT";
-    case HAT_STATE::RIGHTUP:   return "UP RIGHT";
-    case HAT_STATE::RIGHTDOWN: return "DOWN RIGHT";
-    case HAT_STATE::LEFTUP:    return "UP LEFT";
-    case HAT_STATE::LEFTDOWN:  return "DOWN LEFT";
+    case HAT_STATE::UP:
+      return "UP";
+    case HAT_STATE::DOWN:
+      return "DOWN";
+    case HAT_STATE::RIGHT:
+      return "RIGHT";
+    case HAT_STATE::LEFT:
+      return "LEFT";
+    case HAT_STATE::RIGHTUP:
+      return "UP RIGHT";
+    case HAT_STATE::RIGHTDOWN:
+      return "DOWN RIGHT";
+    case HAT_STATE::LEFTUP:
+      return "UP LEFT";
+    case HAT_STATE::LEFTDOWN:
+      return "DOWN LEFT";
     default:
       break;
   }
@@ -38,23 +46,31 @@ const char* CJoystickTranslator::TranslateAnalogStickDirection(ANALOG_STICK_DIRE
 {
   switch (dir)
   {
-  case ANALOG_STICK_DIRECTION::UP:    return "up";
-  case ANALOG_STICK_DIRECTION::DOWN:  return "down";
-  case ANALOG_STICK_DIRECTION::RIGHT: return "right";
-  case ANALOG_STICK_DIRECTION::LEFT:  return "left";
-  default:
-    break;
+    case ANALOG_STICK_DIRECTION::UP:
+      return "up";
+    case ANALOG_STICK_DIRECTION::DOWN:
+      return "down";
+    case ANALOG_STICK_DIRECTION::RIGHT:
+      return "right";
+    case ANALOG_STICK_DIRECTION::LEFT:
+      return "left";
+    default:
+      break;
   }
 
   return "";
 }
 
-ANALOG_STICK_DIRECTION CJoystickTranslator::TranslateAnalogStickDirection(const std::string &dir)
+ANALOG_STICK_DIRECTION CJoystickTranslator::TranslateAnalogStickDirection(const std::string& dir)
 {
-  if (dir == "up")    return ANALOG_STICK_DIRECTION::UP;
-  if (dir == "down")  return ANALOG_STICK_DIRECTION::DOWN;
-  if (dir == "right") return ANALOG_STICK_DIRECTION::RIGHT;
-  if (dir == "left")  return ANALOG_STICK_DIRECTION::LEFT;
+  if (dir == "up")
+    return ANALOG_STICK_DIRECTION::UP;
+  if (dir == "down")
+    return ANALOG_STICK_DIRECTION::DOWN;
+  if (dir == "right")
+    return ANALOG_STICK_DIRECTION::RIGHT;
+  if (dir == "left")
+    return ANALOG_STICK_DIRECTION::LEFT;
 
   return ANALOG_STICK_DIRECTION::NONE;
 }
@@ -63,8 +79,10 @@ const char* CJoystickTranslator::TranslateWheelDirection(WHEEL_DIRECTION dir)
 {
   switch (dir)
   {
-    case WHEEL_DIRECTION::RIGHT: return "right";
-    case WHEEL_DIRECTION::LEFT:  return "left";
+    case WHEEL_DIRECTION::RIGHT:
+      return "right";
+    case WHEEL_DIRECTION::LEFT:
+      return "left";
     default:
       break;
   }
@@ -72,10 +90,12 @@ const char* CJoystickTranslator::TranslateWheelDirection(WHEEL_DIRECTION dir)
   return "";
 }
 
-WHEEL_DIRECTION CJoystickTranslator::TranslateWheelDirection(const std::string &dir)
+WHEEL_DIRECTION CJoystickTranslator::TranslateWheelDirection(const std::string& dir)
 {
-  if (dir == "right") return WHEEL_DIRECTION::RIGHT;
-  if (dir == "left")  return WHEEL_DIRECTION::LEFT;
+  if (dir == "right")
+    return WHEEL_DIRECTION::RIGHT;
+  if (dir == "left")
+    return WHEEL_DIRECTION::LEFT;
 
   return WHEEL_DIRECTION::NONE;
 }
@@ -84,8 +104,10 @@ const char* CJoystickTranslator::TranslateThrottleDirection(THROTTLE_DIRECTION d
 {
   switch (dir)
   {
-    case THROTTLE_DIRECTION::UP:    return "up";
-    case THROTTLE_DIRECTION::DOWN:  return "down";
+    case THROTTLE_DIRECTION::UP:
+      return "up";
+    case THROTTLE_DIRECTION::DOWN:
+      return "down";
     default:
       break;
   }
@@ -93,34 +115,42 @@ const char* CJoystickTranslator::TranslateThrottleDirection(THROTTLE_DIRECTION d
   return "";
 }
 
-THROTTLE_DIRECTION CJoystickTranslator::TranslateThrottleDirection(const std::string &dir)
+THROTTLE_DIRECTION CJoystickTranslator::TranslateThrottleDirection(const std::string& dir)
 {
-  if (dir == "up")    return THROTTLE_DIRECTION::UP;
-  if (dir == "down")  return THROTTLE_DIRECTION::DOWN;
+  if (dir == "up")
+    return THROTTLE_DIRECTION::UP;
+  if (dir == "down")
+    return THROTTLE_DIRECTION::DOWN;
 
   return THROTTLE_DIRECTION::NONE;
 }
 
 SEMIAXIS_DIRECTION CJoystickTranslator::PositionToSemiAxisDirection(float position)
 {
-  if      (position > 0) return SEMIAXIS_DIRECTION::POSITIVE;
-  else if (position < 0) return SEMIAXIS_DIRECTION::NEGATIVE;
+  if (position > 0)
+    return SEMIAXIS_DIRECTION::POSITIVE;
+  else if (position < 0)
+    return SEMIAXIS_DIRECTION::NEGATIVE;
 
   return SEMIAXIS_DIRECTION::ZERO;
 }
 
 WHEEL_DIRECTION CJoystickTranslator::PositionToWheelDirection(float position)
 {
-  if      (position > 0.0f) return WHEEL_DIRECTION::RIGHT;
-  else if (position < 0.0f) return WHEEL_DIRECTION::LEFT;
+  if (position > 0.0f)
+    return WHEEL_DIRECTION::RIGHT;
+  else if (position < 0.0f)
+    return WHEEL_DIRECTION::LEFT;
 
   return WHEEL_DIRECTION::NONE;
 }
 
 THROTTLE_DIRECTION CJoystickTranslator::PositionToThrottleDirection(float position)
 {
-  if      (position > 0.0f) return THROTTLE_DIRECTION::UP;
-  else if (position < 0.0f) return THROTTLE_DIRECTION::DOWN;
+  if (position > 0.0f)
+    return THROTTLE_DIRECTION::UP;
+  else if (position < 0.0f)
+    return THROTTLE_DIRECTION::DOWN;
 
   return THROTTLE_DIRECTION::NONE;
 }
@@ -137,7 +167,8 @@ std::string CJoystickTranslator::GetPrimitiveName(const CDriverPrimitive& primit
     case PRIMITIVE_TYPE::SEMIAXIS:
       primitiveTemplate = g_localizeStrings.Get(35016); // "Axis %d"
       break;
-    default: break;
+    default:
+      break;
   }
 
   return StringUtils::Format(primitiveTemplate.c_str(), primitive.Index());
diff --git a/xbmc/input/joysticks/JoystickTranslator.h b/xbmc/input/joysticks/JoystickTranslator.h
index 86e9528cb34a..2efeacc9912b 100644
--- a/xbmc/input/joysticks/JoystickTranslator.h
+++ b/xbmc/input/joysticks/JoystickTranslator.h
@@ -14,112 +14,112 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class CDriverPrimitive;
+class CDriverPrimitive;
 
+/*!
+ * \brief Joystick translation utilities
+ */
+class CJoystickTranslator
+{
+public:
   /*!
-   * \brief Joystick translation utilities
+   * \brief Translate a hat state to a string representation
+   *
+   * \param state The hat state
+   *
+   * \return A capitalized string representation, or "RELEASED" if the hat is centered.
    */
-  class CJoystickTranslator
-  {
-  public:
-    /*!
-     * \brief Translate a hat state to a string representation
-     *
-     * \param state The hat state
-     *
-     * \return A capitalized string representation, or "RELEASED" if the hat is centered.
-     */
-    static const char* HatStateToString(HAT_STATE state);
+  static const char* HatStateToString(HAT_STATE state);
 
-    /*!
-     * \brief Translate an analog stick direction to a lower-case string
-     *
-     * \param dir The analog stick direction
-     *
-     * \return A lower-case string representation, or "" if the direction is invalid
-     */
-    static const char* TranslateAnalogStickDirection(ANALOG_STICK_DIRECTION dir);
+  /*!
+   * \brief Translate an analog stick direction to a lower-case string
+   *
+   * \param dir The analog stick direction
+   *
+   * \return A lower-case string representation, or "" if the direction is invalid
+   */
+  static const char* TranslateAnalogStickDirection(ANALOG_STICK_DIRECTION dir);
 
-    /*!
-     * \brief Translate an analog stick direction string to an enum value
-     *
-     * \param dir The analog stick direction
-     *
-     * \return The translated direction, or ANALOG_STICK_DIRECTION::UNKNOWN if unknown
-     */
-    static ANALOG_STICK_DIRECTION TranslateAnalogStickDirection(const std::string &dir);
+  /*!
+   * \brief Translate an analog stick direction string to an enum value
+   *
+   * \param dir The analog stick direction
+   *
+   * \return The translated direction, or ANALOG_STICK_DIRECTION::UNKNOWN if unknown
+   */
+  static ANALOG_STICK_DIRECTION TranslateAnalogStickDirection(const std::string& dir);
 
-    /*!
-     * \brief Translate a wheel direction to a lower-case string
-     *
-     * \param dir The wheel direction
-     *
-     * \return A lower-case string representation, or "" if the direction is invalid
-     */
-    static const char* TranslateWheelDirection(WHEEL_DIRECTION dir);
+  /*!
+   * \brief Translate a wheel direction to a lower-case string
+   *
+   * \param dir The wheel direction
+   *
+   * \return A lower-case string representation, or "" if the direction is invalid
+   */
+  static const char* TranslateWheelDirection(WHEEL_DIRECTION dir);
 
-    /*!
-     * \brief Translate a wheel direction string to an enum value
-     *
-     * \param dir The wheel direction
-     *
-     * \return The translated direction, or WHEEL_DIRECTION::UNKNOWN if unknown
-     */
-    static WHEEL_DIRECTION TranslateWheelDirection(const std::string &dir);
+  /*!
+   * \brief Translate a wheel direction string to an enum value
+   *
+   * \param dir The wheel direction
+   *
+   * \return The translated direction, or WHEEL_DIRECTION::UNKNOWN if unknown
+   */
+  static WHEEL_DIRECTION TranslateWheelDirection(const std::string& dir);
 
-    /*!
-     * \brief Translate a throttle direction to a lower-case string
-     *
-     * \param dir The analog stick direction
-     *
-     * \return A lower-case string representation, or "" if the direction is invalid
-     */
-    static const char* TranslateThrottleDirection(THROTTLE_DIRECTION dir);
+  /*!
+   * \brief Translate a throttle direction to a lower-case string
+   *
+   * \param dir The analog stick direction
+   *
+   * \return A lower-case string representation, or "" if the direction is invalid
+   */
+  static const char* TranslateThrottleDirection(THROTTLE_DIRECTION dir);
 
-    /*!
-     * \brief Translate a throttle direction string to an enum value
-     *
-     * \param dir The throttle direction
-     *
-     * \return The translated direction, or THROTTLE_DIRECTION::UNKNOWN if unknown
-     */
-    static THROTTLE_DIRECTION TranslateThrottleDirection(const std::string &dir);
+  /*!
+   * \brief Translate a throttle direction string to an enum value
+   *
+   * \param dir The throttle direction
+   *
+   * \return The translated direction, or THROTTLE_DIRECTION::UNKNOWN if unknown
+   */
+  static THROTTLE_DIRECTION TranslateThrottleDirection(const std::string& dir);
 
-    /*!
-     * \brief Get the semi-axis direction containing the specified position
-     *
-     * \param position The position of the axis
-     *
-     * \return POSITIVE, NEGATIVE, or UNKNOWN if position is 0
-     */
-    static SEMIAXIS_DIRECTION PositionToSemiAxisDirection(float position);
+  /*!
+   * \brief Get the semi-axis direction containing the specified position
+   *
+   * \param position The position of the axis
+   *
+   * \return POSITIVE, NEGATIVE, or UNKNOWN if position is 0
+   */
+  static SEMIAXIS_DIRECTION PositionToSemiAxisDirection(float position);
 
-    /*!
-     * \brief Get the wheel direction containing the specified position
-     *
-     * \param position The position of the axis
-     *
-     * \return LEFT, RIGHT, or UNKNOWN if position is 0
-     */
-    static WHEEL_DIRECTION PositionToWheelDirection(float position);
+  /*!
+   * \brief Get the wheel direction containing the specified position
+   *
+   * \param position The position of the axis
+   *
+   * \return LEFT, RIGHT, or UNKNOWN if position is 0
+   */
+  static WHEEL_DIRECTION PositionToWheelDirection(float position);
 
-    /*!
-     * \brief Get the throttle direction containing the specified position
-     *
-     * \param position The position of the axis
-     *
-     * \return UP, DOWN, or UNKNOWN if position is 0
-     */
-    static THROTTLE_DIRECTION PositionToThrottleDirection(float position);
+  /*!
+   * \brief Get the throttle direction containing the specified position
+   *
+   * \param position The position of the axis
+   *
+   * \return UP, DOWN, or UNKNOWN if position is 0
+   */
+  static THROTTLE_DIRECTION PositionToThrottleDirection(float position);
 
-    /*!
-     * \brief Get the localized name of the primitive
-     *
-     * \param primitive The primitive, currently only buttons and axes are supported
-     *
-     * \return A title for the primitive, e.g. "Button 0" or "Axis 1"
-     */
-    static std::string GetPrimitiveName(const CDriverPrimitive& primitive);
-  };
-}
-}
+  /*!
+   * \brief Get the localized name of the primitive
+   *
+   * \param primitive The primitive, currently only buttons and axes are supported
+   *
+   * \return A title for the primitive, e.g. "Button 0" or "Axis 1"
+   */
+  static std::string GetPrimitiveName(const CDriverPrimitive& primitive);
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/JoystickTypes.h b/xbmc/input/joysticks/JoystickTypes.h
index 67cc92cf0320..5925793dbbe2 100644
--- a/xbmc/input/joysticks/JoystickTypes.h
+++ b/xbmc/input/joysticks/JoystickTypes.h
@@ -22,168 +22,165 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  /*!
-   * \brief Name of a physical feature belonging to the joystick
-   */
-  using FeatureName = std::string;
-
-  /*!
-   * \brief Types of features used in the joystick library
-   *
-   * Available types:
-   *
-   *   1) scalar[*]
-   *   2) analog stick
-   *   3) accelerometer
-   *   4) rumble motor
-   *   5) relative pointer
-   *   6) absolute pointer
-   *   7) wheel
-   *   8) throttle
-   *   9) keyboard key
-   *
-   * [*] All three driver primitives (buttons, hats and axes) have a state that
-   *     can be represented using a single scalar value. For this reason,
-   *     features that map to a single primitive are called "scalar features".
-   */
-  enum class FEATURE_TYPE
-  {
-    UNKNOWN,
-    SCALAR,
-    ANALOG_STICK,
-    ACCELEROMETER,
-    MOTOR,
-    RELPOINTER,
-    ABSPOINTER,
-    WHEEL,
-    THROTTLE,
-    KEY,
-  };
-
-  /*!
-   * \brief Categories of features used in the joystick library
-   */
-  enum class FEATURE_CATEGORY
-  {
-    UNKNOWN,
-    FACE,
-    SHOULDER,
-    TRIGGER,
-    ANALOG_STICK,
-    ACCELEROMETER,
-    HAPTICS,
-    MOUSE_BUTTON,
-    POINTER,
-    LIGHTGUN,
-    OFFSCREEN, // Virtual button to shoot light gun offscreen
-    KEY, // A keyboard key
-    KEYPAD, // A key on a numeric keymap, including star and pound
-    HARDWARE, // A button or functionality on the console
-    WHEEL,
-    JOYSTICK,
-    PADDLE,
-  };
-
-  /*!
-   * \brief Direction arrows on the hat (directional pad)
-   */
-  using HAT_DIRECTION = INPUT::CARDINAL_DIRECTION;
-
-  /*!
-   * \brief States in which a hat can be
-   */
-  using HAT_STATE = INPUT::INTERCARDINAL_DIRECTION;
-
-  /*!
-   * \brief Typedef for analog stick directions
-   */
-  using ANALOG_STICK_DIRECTION = INPUT::CARDINAL_DIRECTION;
-
-  /*!
-   * \brief Directions of motion for a relative pointer
-   */
-  using RELATIVE_POINTER_DIRECTION = INPUT::CARDINAL_DIRECTION;
-
-  /*!
-   * \brief Directions in which a semiaxis can point
-   */
-  enum class SEMIAXIS_DIRECTION
-  {
-    NEGATIVE = -1,  // semiaxis lies in the interval [-1.0, 0.0]
-    ZERO     =  0,  // semiaxis is unknown or invalid
-    POSITIVE =  1,  // semiaxis lies in the interval [0.0, 1.0]
-  };
-
-  /*!
-   * \brief Directions on a wheel
-   */
-  enum class WHEEL_DIRECTION
-  {
-    NONE,
-    RIGHT,
-    LEFT,
-  };
-
-  /*!
-   * \brief Directions on a throttle
-   */
-  enum class THROTTLE_DIRECTION
-  {
-    NONE,
-    UP,
-    DOWN,
-  };
-
-  /*!
-   * \brief Types of input available for scalar features
-   */
-  enum class INPUT_TYPE
-  {
-    UNKNOWN,
-    DIGITAL,
-    ANALOG,
-  };
-
-  /*!
-  * \brief Type of driver primitive
-  */
-  enum class PRIMITIVE_TYPE
-  {
-    UNKNOWN = 0, // primitive has no type (invalid)
-    BUTTON,      // a digital button
-    HAT,         // one of the four direction arrows on a D-pad
-    SEMIAXIS,    // the positive or negative half of an axis
-    MOTOR,       // a rumble motor
-    KEY,         // a keyboard key
-    MOUSE_BUTTON, // a mouse button
-    RELATIVE_POINTER, // a relative pointer, such as on a mouse
-  };
-
-  /*!
-   * \ingroup joystick
-   * \brief Action entry in joystick.xml
-   */
-  struct KeymapAction
-  {
-    unsigned int actionId;
-    std::string actionString;
-    unsigned int holdTimeMs;
-    std::set<std::string> hotkeys;
-
-    bool operator<(const KeymapAction &rhs) const
-    {
-      return holdTimeMs < rhs.holdTimeMs;
-    }
-  };
-
-  /*!
-   * \ingroup joystick
-   * \brief Container that sorts action entries by their holdtime
-   */
-  struct KeymapActionGroup
-  {
-    int windowId = -1;
-    std::set<KeymapAction> actions;
-  };
-}
-}
+/*!
+ * \brief Name of a physical feature belonging to the joystick
+ */
+using FeatureName = std::string;
+
+/*!
+ * \brief Types of features used in the joystick library
+ *
+ * Available types:
+ *
+ *   1) scalar[*]
+ *   2) analog stick
+ *   3) accelerometer
+ *   4) rumble motor
+ *   5) relative pointer
+ *   6) absolute pointer
+ *   7) wheel
+ *   8) throttle
+ *   9) keyboard key
+ *
+ * [*] All three driver primitives (buttons, hats and axes) have a state that
+ *     can be represented using a single scalar value. For this reason,
+ *     features that map to a single primitive are called "scalar features".
+ */
+enum class FEATURE_TYPE
+{
+  UNKNOWN,
+  SCALAR,
+  ANALOG_STICK,
+  ACCELEROMETER,
+  MOTOR,
+  RELPOINTER,
+  ABSPOINTER,
+  WHEEL,
+  THROTTLE,
+  KEY,
+};
+
+/*!
+ * \brief Categories of features used in the joystick library
+ */
+enum class FEATURE_CATEGORY
+{
+  UNKNOWN,
+  FACE,
+  SHOULDER,
+  TRIGGER,
+  ANALOG_STICK,
+  ACCELEROMETER,
+  HAPTICS,
+  MOUSE_BUTTON,
+  POINTER,
+  LIGHTGUN,
+  OFFSCREEN, // Virtual button to shoot light gun offscreen
+  KEY, // A keyboard key
+  KEYPAD, // A key on a numeric keymap, including star and pound
+  HARDWARE, // A button or functionality on the console
+  WHEEL,
+  JOYSTICK,
+  PADDLE,
+};
+
+/*!
+ * \brief Direction arrows on the hat (directional pad)
+ */
+using HAT_DIRECTION = INPUT::CARDINAL_DIRECTION;
+
+/*!
+ * \brief States in which a hat can be
+ */
+using HAT_STATE = INPUT::INTERCARDINAL_DIRECTION;
+
+/*!
+ * \brief Typedef for analog stick directions
+ */
+using ANALOG_STICK_DIRECTION = INPUT::CARDINAL_DIRECTION;
+
+/*!
+ * \brief Directions of motion for a relative pointer
+ */
+using RELATIVE_POINTER_DIRECTION = INPUT::CARDINAL_DIRECTION;
+
+/*!
+ * \brief Directions in which a semiaxis can point
+ */
+enum class SEMIAXIS_DIRECTION
+{
+  NEGATIVE = -1, // semiaxis lies in the interval [-1.0, 0.0]
+  ZERO = 0, // semiaxis is unknown or invalid
+  POSITIVE = 1, // semiaxis lies in the interval [0.0, 1.0]
+};
+
+/*!
+ * \brief Directions on a wheel
+ */
+enum class WHEEL_DIRECTION
+{
+  NONE,
+  RIGHT,
+  LEFT,
+};
+
+/*!
+ * \brief Directions on a throttle
+ */
+enum class THROTTLE_DIRECTION
+{
+  NONE,
+  UP,
+  DOWN,
+};
+
+/*!
+ * \brief Types of input available for scalar features
+ */
+enum class INPUT_TYPE
+{
+  UNKNOWN,
+  DIGITAL,
+  ANALOG,
+};
+
+/*!
+ * \brief Type of driver primitive
+ */
+enum class PRIMITIVE_TYPE
+{
+  UNKNOWN = 0, // primitive has no type (invalid)
+  BUTTON, // a digital button
+  HAT, // one of the four direction arrows on a D-pad
+  SEMIAXIS, // the positive or negative half of an axis
+  MOTOR, // a rumble motor
+  KEY, // a keyboard key
+  MOUSE_BUTTON, // a mouse button
+  RELATIVE_POINTER, // a relative pointer, such as on a mouse
+};
+
+/*!
+ * \ingroup joystick
+ * \brief Action entry in joystick.xml
+ */
+struct KeymapAction
+{
+  unsigned int actionId;
+  std::string actionString;
+  unsigned int holdTimeMs;
+  std::set<std::string> hotkeys;
+
+  bool operator<(const KeymapAction& rhs) const { return holdTimeMs < rhs.holdTimeMs; }
+};
+
+/*!
+ * \ingroup joystick
+ * \brief Container that sorts action entries by their holdtime
+ */
+struct KeymapActionGroup
+{
+  int windowId = -1;
+  std::set<KeymapAction> actions;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/JoystickUtils.cpp b/xbmc/input/joysticks/JoystickUtils.cpp
index 0176f19faffe..3c251215c54a 100644
--- a/xbmc/input/joysticks/JoystickUtils.cpp
+++ b/xbmc/input/joysticks/JoystickUtils.cpp
@@ -14,12 +14,12 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-std::string CJoystickUtils::MakeKeyName(const FeatureName &feature)
+std::string CJoystickUtils::MakeKeyName(const FeatureName& feature)
 {
   return feature;
 }
 
-std::string CJoystickUtils::MakeKeyName(const FeatureName &feature, ANALOG_STICK_DIRECTION dir)
+std::string CJoystickUtils::MakeKeyName(const FeatureName& feature, ANALOG_STICK_DIRECTION dir)
 {
   std::string keyName = feature;
 
@@ -29,26 +29,26 @@ std::string CJoystickUtils::MakeKeyName(const FeatureName &feature, ANALOG_STICK
   return keyName;
 }
 
-std::string CJoystickUtils::MakeKeyName(const FeatureName &feature, WHEEL_DIRECTION dir)
+std::string CJoystickUtils::MakeKeyName(const FeatureName& feature, WHEEL_DIRECTION dir)
 {
   ANALOG_STICK_DIRECTION stickDir = ANALOG_STICK_DIRECTION::NONE;
 
   switch (dir)
   {
-  case WHEEL_DIRECTION::LEFT:
-    stickDir = ANALOG_STICK_DIRECTION::LEFT;
-    break;
-  case WHEEL_DIRECTION::RIGHT:
-    stickDir = ANALOG_STICK_DIRECTION::RIGHT;
-    break;
-  default:
-    break;
+    case WHEEL_DIRECTION::LEFT:
+      stickDir = ANALOG_STICK_DIRECTION::LEFT;
+      break;
+    case WHEEL_DIRECTION::RIGHT:
+      stickDir = ANALOG_STICK_DIRECTION::RIGHT;
+      break;
+    default:
+      break;
   }
 
   return MakeKeyName(feature, stickDir);
 }
 
-std::string CJoystickUtils::MakeKeyName(const FeatureName &feature, THROTTLE_DIRECTION dir)
+std::string CJoystickUtils::MakeKeyName(const FeatureName& feature, THROTTLE_DIRECTION dir)
 {
   ANALOG_STICK_DIRECTION stickDir = ANALOG_STICK_DIRECTION::NONE;
 
@@ -67,7 +67,7 @@ std::string CJoystickUtils::MakeKeyName(const FeatureName &feature, THROTTLE_DIR
   return MakeKeyName(feature, stickDir);
 }
 
-const std::vector<ANALOG_STICK_DIRECTION> &CJoystickUtils::GetAnalogStickDirections()
+const std::vector<ANALOG_STICK_DIRECTION>& CJoystickUtils::GetAnalogStickDirections()
 {
   static std::vector<ANALOG_STICK_DIRECTION> directions;
   if (directions.empty())
@@ -80,7 +80,7 @@ const std::vector<ANALOG_STICK_DIRECTION> &CJoystickUtils::GetAnalogStickDirecti
   return directions;
 }
 
-const std::vector<WHEEL_DIRECTION> &CJoystickUtils::GetWheelDirections()
+const std::vector<WHEEL_DIRECTION>& CJoystickUtils::GetWheelDirections()
 {
   static std::vector<WHEEL_DIRECTION> directions;
   if (directions.empty())
@@ -91,7 +91,7 @@ const std::vector<WHEEL_DIRECTION> &CJoystickUtils::GetWheelDirections()
   return directions;
 }
 
-const std::vector<THROTTLE_DIRECTION> &CJoystickUtils::GetThrottleDirections()
+const std::vector<THROTTLE_DIRECTION>& CJoystickUtils::GetThrottleDirections()
 {
   static std::vector<THROTTLE_DIRECTION> directions;
   if (directions.empty())
diff --git a/xbmc/input/joysticks/JoystickUtils.h b/xbmc/input/joysticks/JoystickUtils.h
index ccb6022d9000..49095d247ca8 100644
--- a/xbmc/input/joysticks/JoystickUtils.h
+++ b/xbmc/input/joysticks/JoystickUtils.h
@@ -56,7 +56,7 @@ class CJoystickUtils
    *
    * \return A valid name for a key in the joystick keymap
    */
-  static std::string MakeKeyName(const FeatureName &feature);
+  static std::string MakeKeyName(const FeatureName& feature);
 
   /*!
    * \brief Create a key name used to index an action in the keymap
@@ -66,7 +66,7 @@ class CJoystickUtils
    *
    * \return A valid name for a key in the joystick keymap
    */
-  static std::string MakeKeyName(const FeatureName &feature, ANALOG_STICK_DIRECTION dir);
+  static std::string MakeKeyName(const FeatureName& feature, ANALOG_STICK_DIRECTION dir);
 
   /*!
    * \brief Create a key name used to index an action in the keymap
@@ -76,7 +76,7 @@ class CJoystickUtils
    *
    * \return A valid name for a key in the joystick keymap
    */
-  static std::string MakeKeyName(const FeatureName &feature, WHEEL_DIRECTION dir);
+  static std::string MakeKeyName(const FeatureName& feature, WHEEL_DIRECTION dir);
 
   /*!
    * \brief Create a key name used to index an action in the keymap
@@ -86,25 +86,25 @@ class CJoystickUtils
    *
    * \return A valid name for a key in the joystick keymap
    */
-  static std::string MakeKeyName(const FeatureName &feature, THROTTLE_DIRECTION dir);
+  static std::string MakeKeyName(const FeatureName& feature, THROTTLE_DIRECTION dir);
 
   /*!
-    * \brief Return a vector of the four cardinal directions
-    */
-  static const std::vector<ANALOG_STICK_DIRECTION> &GetAnalogStickDirections();
+   * \brief Return a vector of the four cardinal directions
+   */
+  static const std::vector<ANALOG_STICK_DIRECTION>& GetAnalogStickDirections();
 
   /*!
    * \brief Return a vector of the two wheel directions
    */
-  static const std::vector<WHEEL_DIRECTION> &GetWheelDirections();
+  static const std::vector<WHEEL_DIRECTION>& GetWheelDirections();
 
   /*!
    * \brief Return a vector of the two throttle directions
    */
-  static const std::vector<THROTTLE_DIRECTION> &GetThrottleDirections();
+  static const std::vector<THROTTLE_DIRECTION>& GetThrottleDirections();
 };
 
-}
-}
+} // namespace JOYSTICK
+} // namespace KODI
 
 /// \}
diff --git a/xbmc/input/joysticks/RumbleGenerator.cpp b/xbmc/input/joysticks/RumbleGenerator.cpp
index c5ba799a9558..0640b1b52c3d 100644
--- a/xbmc/input/joysticks/RumbleGenerator.cpp
+++ b/xbmc/input/joysticks/RumbleGenerator.cpp
@@ -16,18 +16,17 @@
 
 #include <algorithm>
 
-#define RUMBLE_TEST_DURATION_MS          1000 // Per motor
-#define RUMBLE_NOTIFICATION_DURATION_MS  300
+#define RUMBLE_TEST_DURATION_MS 1000 // Per motor
+#define RUMBLE_NOTIFICATION_DURATION_MS 300
 
- // From game.controller.default profile
-#define WEAK_MOTOR_NAME        "rightmotor"
+// From game.controller.default profile
+#define WEAK_MOTOR_NAME "rightmotor"
 
 using namespace KODI;
 using namespace JOYSTICK;
 
-CRumbleGenerator::CRumbleGenerator() :
-  CThread("RumbleGenerator"),
-  m_motors(GetMotors(ControllerID()))
+CRumbleGenerator::CRumbleGenerator()
+  : CThread("RumbleGenerator"), m_motors(GetMotors(ControllerID()))
 {
 }
 
@@ -62,52 +61,52 @@ bool CRumbleGenerator::DoTest(IInputReceiver* receiver)
 
     return true;
   }
-  return  false;
+  return false;
 }
 
 void CRumbleGenerator::Process(void)
 {
   switch (m_type)
   {
-  case RUMBLE_NOTIFICATION:
-  {
-    std::vector<std::string> motors;
+    case RUMBLE_NOTIFICATION:
+    {
+      std::vector<std::string> motors;
 
-    if (std::find(m_motors.begin(), m_motors.end(), WEAK_MOTOR_NAME) != m_motors.end())
-      motors.emplace_back(WEAK_MOTOR_NAME);
-    else
-      motors = m_motors; // Not using default profile? Just rumble all motors
+      if (std::find(m_motors.begin(), m_motors.end(), WEAK_MOTOR_NAME) != m_motors.end())
+        motors.emplace_back(WEAK_MOTOR_NAME);
+      else
+        motors = m_motors; // Not using default profile? Just rumble all motors
 
-    for (const std::string& motor : motors)
-      m_receiver->SetRumbleState(motor, 1.0f);
+      for (const std::string& motor : motors)
+        m_receiver->SetRumbleState(motor, 1.0f);
 
-    CThread::Sleep(RUMBLE_NOTIFICATION_DURATION_MS);
+      CThread::Sleep(RUMBLE_NOTIFICATION_DURATION_MS);
 
-    if (m_bStop)
-      break;
+      if (m_bStop)
+        break;
 
-    for (const std::string& motor : motors)
-      m_receiver->SetRumbleState(motor, 0.0f);
+      for (const std::string& motor : motors)
+        m_receiver->SetRumbleState(motor, 0.0f);
 
-    break;
-  }
-  case RUMBLE_TEST:
-  {
-    for (const std::string& motor : m_motors)
+      break;
+    }
+    case RUMBLE_TEST:
     {
-      m_receiver->SetRumbleState(motor, 1.0f);
+      for (const std::string& motor : m_motors)
+      {
+        m_receiver->SetRumbleState(motor, 1.0f);
 
-      CThread::Sleep(RUMBLE_TEST_DURATION_MS);
+        CThread::Sleep(RUMBLE_TEST_DURATION_MS);
 
-      if (m_bStop)
-        break;
+        if (m_bStop)
+          break;
 
-      m_receiver->SetRumbleState(motor, 0.0f);
+        m_receiver->SetRumbleState(motor, 0.0f);
+      }
+      break;
     }
-    break;
-  }
-  default:
-    break;
+    default:
+      break;
   }
 }
 
diff --git a/xbmc/input/joysticks/RumbleGenerator.h b/xbmc/input/joysticks/RumbleGenerator.h
index 231d3e25e4a7..a6e98531fc93 100644
--- a/xbmc/input/joysticks/RumbleGenerator.h
+++ b/xbmc/input/joysticks/RumbleGenerator.h
@@ -17,42 +17,42 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IInputReceiver;
+class IInputReceiver;
 
-  class CRumbleGenerator : public CThread
-  {
-  public:
-    CRumbleGenerator();
+class CRumbleGenerator : public CThread
+{
+public:
+  CRumbleGenerator();
 
-    ~CRumbleGenerator() override { AbortRumble(); }
+  ~CRumbleGenerator() override { AbortRumble(); }
 
-    std::string ControllerID() const;
+  std::string ControllerID() const;
 
-    void NotifyUser(IInputReceiver* receiver);
-    bool DoTest(IInputReceiver* receiver);
+  void NotifyUser(IInputReceiver* receiver);
+  bool DoTest(IInputReceiver* receiver);
 
-    void AbortRumble(void) { StopThread(); }
+  void AbortRumble(void) { StopThread(); }
 
-  protected:
-    // implementation of CThread
-    void Process() override;
+protected:
+  // implementation of CThread
+  void Process() override;
 
-  private:
-    enum RUMBLE_TYPE
-    {
-      RUMBLE_UNKNOWN,
-      RUMBLE_NOTIFICATION,
-      RUMBLE_TEST,
-    };
+private:
+  enum RUMBLE_TYPE
+  {
+    RUMBLE_UNKNOWN,
+    RUMBLE_NOTIFICATION,
+    RUMBLE_TEST,
+  };
 
-    static std::vector<std::string> GetMotors(const std::string& controllerId);
+  static std::vector<std::string> GetMotors(const std::string& controllerId);
 
-    // Construction param
-    const std::vector<std::string> m_motors;
+  // Construction param
+  const std::vector<std::string> m_motors;
 
-    // Test param
-    IInputReceiver* m_receiver = nullptr;
-    RUMBLE_TYPE     m_type = RUMBLE_UNKNOWN;
-  };
-}
-}
+  // Test param
+  IInputReceiver* m_receiver = nullptr;
+  RUMBLE_TYPE m_type = RUMBLE_UNKNOWN;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/dialogs/GUIDialogNewJoystick.cpp b/xbmc/input/joysticks/dialogs/GUIDialogNewJoystick.cpp
index 4d6cbc27c134..8ac8adee1145 100644
--- a/xbmc/input/joysticks/dialogs/GUIDialogNewJoystick.cpp
+++ b/xbmc/input/joysticks/dialogs/GUIDialogNewJoystick.cpp
@@ -19,8 +19,7 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-CGUIDialogNewJoystick::CGUIDialogNewJoystick() :
-  CThread("NewJoystickDlg")
+CGUIDialogNewJoystick::CGUIDialogNewJoystick() : CThread("NewJoystickDlg")
 {
 }
 
@@ -30,9 +29,11 @@ void CGUIDialogNewJoystick::ShowAsync()
 
   if (IsRunning())
     bShow = false;
-  else if (!CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_INPUT_ASKNEWCONTROLLERS))
+  else if (!CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+               CSettings::SETTING_INPUT_ASKNEWCONTROLLERS))
     bShow = false;
-  else if (CServiceBroker::GetGUI()->GetWindowManager().IsWindowActive(WINDOW_DIALOG_GAME_CONTROLLERS, false))
+  else if (CServiceBroker::GetGUI()->GetWindowManager().IsWindowActive(
+               WINDOW_DIALOG_GAME_CONTROLLERS, false))
     bShow = false;
 
   if (bShow)
@@ -44,13 +45,15 @@ void CGUIDialogNewJoystick::Process()
   using namespace MESSAGING::HELPERS;
 
   // "New controller detected"
-  // "A new controller has been detected. Configuration can be done at any time in "Settings -> System Settings -> Input". Would you like to configure it now?"
-  if (ShowYesNoDialogText(CVariant{ 35011 }, CVariant{ 35012 }) == DialogResponse::YES)
+  // "A new controller has been detected. Configuration can be done at any time in "Settings ->
+  // System Settings -> Input". Would you like to configure it now?"
+  if (ShowYesNoDialogText(CVariant{35011}, CVariant{35012}) == DialogResponse::YES)
   {
     CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(WINDOW_DIALOG_GAME_CONTROLLERS);
   }
   else
   {
-    CServiceBroker::GetSettingsComponent()->GetSettings()->SetBool(CSettings::SETTING_INPUT_ASKNEWCONTROLLERS, false);
+    CServiceBroker::GetSettingsComponent()->GetSettings()->SetBool(
+        CSettings::SETTING_INPUT_ASKNEWCONTROLLERS, false);
   }
 }
diff --git a/xbmc/input/joysticks/dialogs/GUIDialogNewJoystick.h b/xbmc/input/joysticks/dialogs/GUIDialogNewJoystick.h
index 6ff0feeafbb8..334191f9e4dc 100644
--- a/xbmc/input/joysticks/dialogs/GUIDialogNewJoystick.h
+++ b/xbmc/input/joysticks/dialogs/GUIDialogNewJoystick.h
@@ -14,17 +14,17 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class CGUIDialogNewJoystick : protected CThread
-  {
-  public:
-    CGUIDialogNewJoystick();
-    ~CGUIDialogNewJoystick() override = default;
+class CGUIDialogNewJoystick : protected CThread
+{
+public:
+  CGUIDialogNewJoystick();
+  ~CGUIDialogNewJoystick() override = default;
 
-    void ShowAsync();
+  void ShowAsync();
 
-  protected:
-    // implementation of CThread
-    void Process() override;
-  };
-}
-}
+protected:
+  // implementation of CThread
+  void Process() override;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/generic/ButtonMapping.cpp b/xbmc/input/joysticks/generic/ButtonMapping.cpp
index a5cd134ff634..7a967cb8798b 100644
--- a/xbmc/input/joysticks/generic/ButtonMapping.cpp
+++ b/xbmc/input/joysticks/generic/ButtonMapping.cpp
@@ -31,18 +31,19 @@ using namespace KODI;
 using namespace JOYSTICK;
 using namespace XbmcThreads;
 
-#define MAPPING_COOLDOWN_MS  50    // Guard against repeated input
-#define AXIS_THRESHOLD       0.75f // Axis must exceed this value to be mapped
-#define TRIGGER_DELAY_MS     200   // Delay trigger detection to handle anomalous triggers with non-zero center
+#define MAPPING_COOLDOWN_MS 50 // Guard against repeated input
+#define AXIS_THRESHOLD 0.75f // Axis must exceed this value to be mapped
+#define TRIGGER_DELAY_MS \
+  200 // Delay trigger detection to handle anomalous triggers with non-zero center
 
 // --- CPrimitiveDetector ------------------------------------------------------
 
-CPrimitiveDetector::CPrimitiveDetector(CButtonMapping* buttonMapping) :
-  m_buttonMapping(buttonMapping)
+CPrimitiveDetector::CPrimitiveDetector(CButtonMapping* buttonMapping)
+  : m_buttonMapping(buttonMapping)
 {
 }
 
-bool CPrimitiveDetector::MapPrimitive(const CDriverPrimitive &primitive)
+bool CPrimitiveDetector::MapPrimitive(const CDriverPrimitive& primitive)
 {
   if (primitive.IsValid())
     return m_buttonMapping->MapPrimitive(primitive);
@@ -52,9 +53,8 @@ bool CPrimitiveDetector::MapPrimitive(const CDriverPrimitive &primitive)
 
 // --- CButtonDetector ---------------------------------------------------------
 
-CButtonDetector::CButtonDetector(CButtonMapping* buttonMapping, unsigned int buttonIndex) :
-  CPrimitiveDetector(buttonMapping),
-  m_buttonIndex(buttonIndex)
+CButtonDetector::CButtonDetector(CButtonMapping* buttonMapping, unsigned int buttonIndex)
+  : CPrimitiveDetector(buttonMapping), m_buttonIndex(buttonIndex)
 {
 }
 
@@ -68,9 +68,8 @@ bool CButtonDetector::OnMotion(bool bPressed)
 
 // --- CHatDetector ------------------------------------------------------------
 
-CHatDetector::CHatDetector(CButtonMapping* buttonMapping, unsigned int hatIndex) :
-  CPrimitiveDetector(buttonMapping),
-  m_hatIndex(hatIndex)
+CHatDetector::CHatDetector(CButtonMapping* buttonMapping, unsigned int hatIndex)
+  : CPrimitiveDetector(buttonMapping), m_hatIndex(hatIndex)
 {
 }
 
@@ -81,16 +80,18 @@ bool CHatDetector::OnMotion(HAT_STATE state)
 
 // --- CAxisDetector -----------------------------------------------------------
 
-CAxisDetector::CAxisDetector(CButtonMapping* buttonMapping, unsigned int axisIndex, const AxisConfiguration& config) :
-  CPrimitiveDetector(buttonMapping),
-  m_axisIndex(axisIndex),
-  m_config(config),
-  m_state(AXIS_STATE::INACTIVE),
-  m_type(AXIS_TYPE::UNKNOWN),
-  m_initialPositionKnown(false),
-  m_initialPosition(0.0f),
-  m_initialPositionChanged(false),
-  m_activationTimeMs(0)
+CAxisDetector::CAxisDetector(CButtonMapping* buttonMapping,
+                             unsigned int axisIndex,
+                             const AxisConfiguration& config)
+  : CPrimitiveDetector(buttonMapping),
+    m_axisIndex(axisIndex),
+    m_config(config),
+    m_state(AXIS_STATE::INACTIVE),
+    m_type(AXIS_TYPE::UNKNOWN),
+    m_initialPositionKnown(false),
+    m_initialPosition(0.0f),
+    m_initialPositionChanged(false),
+    m_activationTimeMs(0)
 {
 }
 
@@ -123,7 +124,9 @@ bool CAxisDetector::OnMotion(float position)
       if (m_state == AXIS_STATE::ACTIVATED)
       {
         // Range is set later for anomalous triggers
-        m_activatedPrimitive = CDriverPrimitive(m_axisIndex, m_config.center, CJoystickTranslator::PositionToSemiAxisDirection(position), 1);
+        m_activatedPrimitive =
+            CDriverPrimitive(m_axisIndex, m_config.center,
+                             CJoystickTranslator::PositionToSemiAxisDirection(position), 1);
         m_activationTimeMs = SystemClockMillis();
       }
     }
@@ -151,10 +154,9 @@ void CAxisDetector::ProcessMotion()
       // Update driver primitive's range if we're mapping an anomalous trigger
       if (m_type == AXIS_TYPE::OFFSET)
       {
-        m_activatedPrimitive = CDriverPrimitive(m_activatedPrimitive.Index(),
-                                                m_activatedPrimitive.Center(),
-                                                m_activatedPrimitive.SemiAxisDirection(),
-                                                m_config.range);
+        m_activatedPrimitive =
+            CDriverPrimitive(m_activatedPrimitive.Index(), m_activatedPrimitive.Center(),
+                             m_activatedPrimitive.SemiAxisDirection(), m_config.range);
       }
 
       // Map primitive
@@ -219,13 +221,15 @@ void CAxisDetector::DetectType(float position)
     {
       m_config.center = -1;
       m_type = AXIS_TYPE::OFFSET;
-      CLog::Log(LOGDEBUG, "Anomalous trigger detected on axis %u with center %d", m_axisIndex, m_config.center);
+      CLog::Log(LOGDEBUG, "Anomalous trigger detected on axis %u with center %d", m_axisIndex,
+                m_config.center);
     }
     else if (m_initialPosition > 0.5f)
     {
       m_config.center = 1;
       m_type = AXIS_TYPE::OFFSET;
-      CLog::Log(LOGDEBUG, "Anomalous trigger detected on axis %u with center %d", m_axisIndex, m_config.center);
+      CLog::Log(LOGDEBUG, "Anomalous trigger detected on axis %u with center %d", m_axisIndex,
+                m_config.center);
     }
     else
     {
@@ -237,9 +241,8 @@ void CAxisDetector::DetectType(float position)
 
 // --- CKeyDetector ---------------------------------------------------------
 
-CKeyDetector::CKeyDetector(CButtonMapping* buttonMapping, XBMCKey keycode) :
-  CPrimitiveDetector(buttonMapping),
-  m_keycode(keycode)
+CKeyDetector::CKeyDetector(CButtonMapping* buttonMapping, XBMCKey keycode)
+  : CPrimitiveDetector(buttonMapping), m_keycode(keycode)
 {
 }
 
@@ -253,9 +256,9 @@ bool CKeyDetector::OnMotion(bool bPressed)
 
 // --- CMouseButtonDetector ----------------------------------------------------
 
-CMouseButtonDetector::CMouseButtonDetector(CButtonMapping* buttonMapping, MOUSE::BUTTON_ID buttonIndex) :
-  CPrimitiveDetector(buttonMapping),
-  m_buttonIndex(buttonIndex)
+CMouseButtonDetector::CMouseButtonDetector(CButtonMapping* buttonMapping,
+                                           MOUSE::BUTTON_ID buttonIndex)
+  : CPrimitiveDetector(buttonMapping), m_buttonIndex(buttonIndex)
 {
 }
 
@@ -269,8 +272,8 @@ bool CMouseButtonDetector::OnMotion(bool bPressed)
 
 // --- CPointerDetector --------------------------------------------------------
 
-CPointerDetector::CPointerDetector(CButtonMapping* buttonMapping) :
-  CPrimitiveDetector(buttonMapping)
+CPointerDetector::CPointerDetector(CButtonMapping* buttonMapping)
+  : CPrimitiveDetector(buttonMapping)
 {
 }
 
@@ -309,17 +312,18 @@ KODI::INPUT::INTERCARDINAL_DIRECTION CPointerDetector::GetPointerDirection(int x
   // Translate from left-handed coordinate system to right-handed coordinate system
   y *= -1;
 
-  return CInputTranslator::VectorToIntercardinalDirection(static_cast<float>(x), static_cast<float>(y));
+  return CInputTranslator::VectorToIntercardinalDirection(static_cast<float>(x),
+                                                          static_cast<float>(y));
 }
 
 // --- CButtonMapping ----------------------------------------------------------
 
-CButtonMapping::CButtonMapping(IButtonMapper* buttonMapper, IButtonMap* buttonMap, IKeymap* keymap) :
-  m_buttonMapper(buttonMapper),
-  m_buttonMap(buttonMap),
-  m_keymap(keymap),
-  m_lastAction(0),
-  m_frameCount(0)
+CButtonMapping::CButtonMapping(IButtonMapper* buttonMapper, IButtonMap* buttonMap, IKeymap* keymap)
+  : m_buttonMapper(buttonMapper),
+    m_buttonMap(buttonMap),
+    m_keymap(keymap),
+    m_lastAction(0),
+    m_frameCount(0)
 {
   assert(m_buttonMapper != nullptr);
   assert(m_buttonMap != nullptr);
@@ -338,7 +342,8 @@ CButtonMapping::CButtonMapping(IButtonMapper* buttonMapper, IButtonMap* buttonMa
     {
       bool bIsSelectAction = false;
 
-      const auto &actions = m_keymap->GetActions(CJoystickUtils::MakeKeyName(feature.Name())).actions;
+      const auto& actions =
+          m_keymap->GetActions(CJoystickUtils::MakeKeyName(feature.Name())).actions;
       if (!actions.empty() && actions.begin()->actionId == ACTION_SELECT_ITEM)
         bIsSelectAction = true;
 
@@ -358,7 +363,8 @@ CButtonMapping::CButtonMapping(IButtonMapper* buttonMapper, IButtonMap* buttonMa
       axisConfig.center = primitive.Center();
       axisConfig.range = primitive.Range();
 
-      GetAxis(primitive.Index(), static_cast<float>(primitive.Center()), axisConfig).SetEmitted(primitive);
+      GetAxis(primitive.Index(), static_cast<float>(primitive.Center()), axisConfig)
+          .SetEmitted(primitive);
     }
   }
 }
@@ -379,7 +385,10 @@ bool CButtonMapping::OnHatMotion(unsigned int hatIndex, HAT_STATE state)
   return GetHat(hatIndex).OnMotion(state);
 }
 
-bool CButtonMapping::OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range)
+bool CButtonMapping::OnAxisMotion(unsigned int axisIndex,
+                                  float position,
+                                  int center,
+                                  unsigned int range)
 {
   if (!m_buttonMapper->AcceptsPrimitive(PRIMITIVE_TYPE::SEMIAXIS))
     return false;
@@ -515,9 +524,10 @@ CHatDetector& CButtonMapping::GetHat(unsigned int hatIndex)
   return itHat->second;
 }
 
-CAxisDetector& CButtonMapping::GetAxis(unsigned int axisIndex,
-                                       float position,
-                                       const AxisConfiguration& initialConfig /* = AxisConfiguration() */)
+CAxisDetector& CButtonMapping::GetAxis(
+    unsigned int axisIndex,
+    float position,
+    const AxisConfiguration& initialConfig /* = AxisConfiguration() */)
 {
   auto itAxis = m_axes.find(axisIndex);
 
@@ -532,8 +542,8 @@ CAxisDetector& CButtonMapping::GetAxis(unsigned int axisIndex,
     }
 
     // Report axis
-    CLog::Log(LOGDEBUG, "Axis %u discovered at position %.4f after %lu frames",
-              axisIndex, position, static_cast<unsigned long>(m_frameCount));
+    CLog::Log(LOGDEBUG, "Axis %u discovered at position %.4f after %lu frames", axisIndex, position,
+              static_cast<unsigned long>(m_frameCount));
 
     m_axes.insert(std::make_pair(axisIndex, CAxisDetector(this, axisIndex, config)));
     itAxis = m_axes.find(axisIndex);
@@ -568,7 +578,7 @@ CMouseButtonDetector& CButtonMapping::GetMouseButton(MOUSE::BUTTON_ID buttonInde
   return itButton->second;
 }
 
-CPointerDetector &CButtonMapping::GetPointer()
+CPointerDetector& CButtonMapping::GetPointer()
 {
   if (!m_pointer)
     m_pointer.reset(new CPointerDetector(this));
diff --git a/xbmc/input/joysticks/generic/ButtonMapping.h b/xbmc/input/joysticks/generic/ButtonMapping.h
index 16648bdea600..b513235ec5fb 100644
--- a/xbmc/input/joysticks/generic/ButtonMapping.h
+++ b/xbmc/input/joysticks/generic/ButtonMapping.h
@@ -25,360 +25,368 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class CButtonMapping;
-  class IButtonMap;
-  class IButtonMapper;
+class CButtonMapping;
+class IButtonMap;
+class IButtonMapper;
+
+/*!
+ * \brief Detects and dispatches mapping events
+ *
+ * A mapping event usually occurs when a driver primitive is pressed or
+ * exceeds a certain threshold.
+ *
+ * Detection can be quite complicated due to driver bugs, so each type of
+ * driver primitive is given its own detector class inheriting from this one.
+ */
+class CPrimitiveDetector
+{
+protected:
+  CPrimitiveDetector(CButtonMapping* buttonMapping);
 
   /*!
-   * \brief Detects and dispatches mapping events
-   *
-   * A mapping event usually occurs when a driver primitive is pressed or
-   * exceeds a certain threshold.
+   * \brief Dispatch a mapping event
    *
-   * Detection can be quite complicated due to driver bugs, so each type of
-   * driver primitive is given its own detector class inheriting from this one.
+   * \return True if the primitive was mapped, false otherwise
    */
-  class CPrimitiveDetector
-  {
-  protected:
-    CPrimitiveDetector(CButtonMapping* buttonMapping);
+  bool MapPrimitive(const CDriverPrimitive& primitive);
 
-    /*!
-     * \brief Dispatch a mapping event
-     *
-     * \return True if the primitive was mapped, false otherwise
-     */
-    bool MapPrimitive(const CDriverPrimitive &primitive);
+private:
+  CButtonMapping* const m_buttonMapping;
+};
 
-  private:
-    CButtonMapping* const m_buttonMapping;
-  };
+/*!
+ * \brief Detects when a button should be mapped
+ */
+class CButtonDetector : public CPrimitiveDetector
+{
+public:
+  CButtonDetector(CButtonMapping* buttonMapping, unsigned int buttonIndex);
 
   /*!
-   * \brief Detects when a button should be mapped
+   * \brief Button state has been updated
+   *
+   * \param bPressed The new state
+   *
+   * \return True if this press was handled, false if it should fall through
+   *         to the next driver handler
    */
-  class CButtonDetector : public CPrimitiveDetector
-  {
-  public:
-    CButtonDetector(CButtonMapping* buttonMapping, unsigned int buttonIndex);
+  bool OnMotion(bool bPressed);
 
-    /*!
-     * \brief Button state has been updated
-     *
-     * \param bPressed The new state
-     *
-     * \return True if this press was handled, false if it should fall through
-     *         to the next driver handler
-     */
-    bool OnMotion(bool bPressed);
+private:
+  // Construction parameters
+  const unsigned int m_buttonIndex;
+};
 
-  private:
-    // Construction parameters
-    const unsigned int m_buttonIndex;
-  };
+/*!
+ * \brief Detects when a D-pad direction should be mapped
+ */
+class CHatDetector : public CPrimitiveDetector
+{
+public:
+  CHatDetector(CButtonMapping* buttonMapping, unsigned int hatIndex);
 
   /*!
-   * \brief Detects when a D-pad direction should be mapped
+   * \brief Hat state has been updated
+   *
+   * \param state The new state
+   *
+   * \return True if state is a cardinal direction, false otherwise
    */
-  class CHatDetector : public CPrimitiveDetector
-  {
-  public:
-    CHatDetector(CButtonMapping* buttonMapping, unsigned int hatIndex);
+  bool OnMotion(HAT_STATE state);
 
-    /*!
-     * \brief Hat state has been updated
-     *
-     * \param state The new state
-     *
-     * \return True if state is a cardinal direction, false otherwise
-     */
-    bool OnMotion(HAT_STATE state);
+private:
+  // Construction parameters
+  const unsigned int m_hatIndex;
+};
 
-  private:
-    // Construction parameters
-    const unsigned int m_hatIndex;
-  };
+struct AxisConfiguration
+{
+  bool bKnown = false;
+  int center = 0;
+  unsigned int range = 1;
+  bool bLateDiscovery = false;
+};
+
+/*!
+ * \brief Detects when an axis should be mapped
+ */
+class CAxisDetector : public CPrimitiveDetector
+{
+public:
+  CAxisDetector(CButtonMapping* buttonMapping,
+                unsigned int axisIndex,
+                const AxisConfiguration& config);
 
-  struct AxisConfiguration
-  {
-    bool bKnown = false;
-    int center = 0;
-    unsigned int range = 1;
-    bool bLateDiscovery = false;
-  };
+  /*!
+   * \brief Axis state has been updated
+   *
+   * \param position The new state
+   *
+   * \return Always true - axis motion events are always absorbed while button mapping
+   */
+  bool OnMotion(float position);
 
   /*!
-   * \brief Detects when an axis should be mapped
+   * \brief Called once per frame
+   *
+   * If an axis was activated, the button mapping command will be emitted
+   * here.
    */
-  class CAxisDetector : public CPrimitiveDetector
+  void ProcessMotion();
+
+  /*!
+   * \brief Check if the axis was mapped and is still in motion
+   *
+   * \return True between when the axis is mapped and when it crosses zero
+   */
+  bool IsMapping() const { return m_state == AXIS_STATE::MAPPED; }
+
+  /*!
+   * \brief Set the state such that this axis has generated a mapping event
+   *
+   * If an axis is mapped to the Select action, it may be pressed when button
+   * mapping begins. This function is used to indicate that the axis shouldn't
+   * be mapped until after it crosses zero again.
+   */
+  void SetEmitted(const CDriverPrimitive& activePrimitive);
+
+private:
+  enum class AXIS_STATE
   {
-  public:
-    CAxisDetector(CButtonMapping* buttonMapping, unsigned int axisIndex, const AxisConfiguration& config);
+    /*!
+     * \brief Axis is inactive (position is less than threshold)
+     */
+    INACTIVE,
 
     /*!
-     * \brief Axis state has been updated
-     *
-     * \param position The new state
-     *
-     * \return Always true - axis motion events are always absorbed while button mapping
+     * \brief Axis is activated (position has exceeded threshold)
      */
-    bool OnMotion(float position);
+    ACTIVATED,
 
     /*!
-     * \brief Called once per frame
-     *
-     * If an axis was activated, the button mapping command will be emitted
-     * here.
+     * \brief Axis has generated a mapping event, but has not been centered yet
      */
-    void ProcessMotion();
+    MAPPED,
+  };
 
+  enum class AXIS_TYPE
+  {
     /*!
-     * \brief Check if the axis was mapped and is still in motion
+     * \brief Axis type is initially unknown
+     */
+    UNKNOWN,
+
+    /*!
+     * \brief Axis is centered about 0
      *
-     * \return True between when the axis is mapped and when it crosses zero
+     *   - If the axis is an analog stick, it can travel to -1 or +1.
+     *   - If the axis is a pressure-sensitive button or a normal trigger,
+     *     it can travel to +1.
+     *   - If the axis is a DirectInput trigger, then it is possible that two
+     *     triggers can be on the same axis in opposite directions.
+     *   - Normally, D-pads  appear as a hat or four buttons. However, some
+     *     D-pads are reported as two axes that can have the discrete values
+     *     -1, 0 or 1. This is called a "discrete D-pad".
      */
-    bool IsMapping() const { return m_state == AXIS_STATE::MAPPED; }
+    NORMAL,
 
     /*!
-     * \brief Set the state such that this axis has generated a mapping event
+     * \brief Axis is centered about -1 or 1
      *
-     * If an axis is mapped to the Select action, it may be pressed when button
-     * mapping begins. This function is used to indicate that the axis shouldn't
-     * be mapped until after it crosses zero again.
+     *   - On OSX, with the cocoa driver, triggers are centered about -1 and
+     *     travel to +1. In this case, the range is 2 and the direction is
+     *     positive.
+     *   - The author of SDL has observed triggers centered at +1 and travel
+     *     to 0. In this case, the range is 1 and the direction is negative.
      */
-    void SetEmitted(const CDriverPrimitive& activePrimitive);
-
-  private:
-    enum class AXIS_STATE
-    {
-      /*!
-       * \brief Axis is inactive (position is less than threshold)
-       */
-      INACTIVE,
-
-      /*!
-       * \brief Axis is activated (position has exceeded threshold)
-       */
-      ACTIVATED,
-
-      /*!
-       * \brief Axis has generated a mapping event, but has not been centered yet
-       */
-      MAPPED,
-    };
-
-    enum class AXIS_TYPE
-    {
-      /*!
-       * \brief Axis type is initially unknown
-       */
-      UNKNOWN,
-
-      /*!
-       * \brief Axis is centered about 0
-       *
-       *   - If the axis is an analog stick, it can travel to -1 or +1.
-       *   - If the axis is a pressure-sensitive button or a normal trigger,
-       *     it can travel to +1.
-       *   - If the axis is a DirectInput trigger, then it is possible that two
-       *     triggers can be on the same axis in opposite directions.
-       *   - Normally, D-pads  appear as a hat or four buttons. However, some
-       *     D-pads are reported as two axes that can have the discrete values
-       *     -1, 0 or 1. This is called a "discrete D-pad".
-       */
-      NORMAL,
-
-      /*!
-       * \brief Axis is centered about -1 or 1
-       *
-       *   - On OSX, with the cocoa driver, triggers are centered about -1 and
-       *     travel to +1. In this case, the range is 2 and the direction is
-       *     positive.
-       *   - The author of SDL has observed triggers centered at +1 and travel
-       *     to 0. In this case, the range is 1 and the direction is negative.
-       */
-      OFFSET,
-    };
-
-    void DetectType(float position);
-
-    // Construction parameters
-    const unsigned int m_axisIndex;
-    AxisConfiguration m_config; // mutable
-
-    // State variables
-    AXIS_STATE m_state;
-    CDriverPrimitive m_activatedPrimitive;
-    AXIS_TYPE m_type;
-    bool m_initialPositionKnown; // set to true on first motion
-    float m_initialPosition; // set to position of first motion
-    bool m_initialPositionChanged; // set to true when position differs from the initial position
-    unsigned int m_activationTimeMs; // only used to delay anomalous trigger mapping to detect full range
+    OFFSET,
   };
 
+  void DetectType(float position);
+
+  // Construction parameters
+  const unsigned int m_axisIndex;
+  AxisConfiguration m_config; // mutable
+
+  // State variables
+  AXIS_STATE m_state;
+  CDriverPrimitive m_activatedPrimitive;
+  AXIS_TYPE m_type;
+  bool m_initialPositionKnown; // set to true on first motion
+  float m_initialPosition; // set to position of first motion
+  bool m_initialPositionChanged; // set to true when position differs from the initial position
+  unsigned int
+      m_activationTimeMs; // only used to delay anomalous trigger mapping to detect full range
+};
+
+/*!
+ * \brief Detects when a keyboard key should be mapped
+ */
+class CKeyDetector : public CPrimitiveDetector
+{
+public:
+  CKeyDetector(CButtonMapping* buttonMapping, XBMCKey keycode);
+
   /*!
-   * \brief Detects when a keyboard key should be mapped
+   * \brief Key state has been updated
+   *
+   * \param bPressed The new state
+   *
+   * \return True if this press was handled, false if it should fall through
+   *         to the next driver handler
    */
-  class CKeyDetector : public CPrimitiveDetector
-  {
-  public:
-    CKeyDetector(CButtonMapping* buttonMapping, XBMCKey keycode);
+  bool OnMotion(bool bPressed);
 
-    /*!
-     * \brief Key state has been updated
-     *
-     * \param bPressed The new state
-     *
-     * \return True if this press was handled, false if it should fall through
-     *         to the next driver handler
-     */
-    bool OnMotion(bool bPressed);
+private:
+  // Construction parameters
+  const XBMCKey m_keycode;
+};
 
-  private:
-    // Construction parameters
-    const XBMCKey m_keycode;
-  };
+/*!
+ * \brief Detects when a mouse button should be mapped
+ */
+class CMouseButtonDetector : public CPrimitiveDetector
+{
+public:
+  CMouseButtonDetector(CButtonMapping* buttonMapping, MOUSE::BUTTON_ID buttonIndex);
 
   /*!
-   * \brief Detects when a mouse button should be mapped
+   * \brief Button state has been updated
+   *
+   * \param bPressed The new state
+   *
+   * \return True if this press was handled, false if it should fall through
+   *         to the next driver handler
    */
-  class CMouseButtonDetector : public CPrimitiveDetector
-  {
-  public:
-    CMouseButtonDetector(CButtonMapping* buttonMapping, MOUSE::BUTTON_ID buttonIndex);
+  bool OnMotion(bool bPressed);
 
-    /*!
-     * \brief Button state has been updated
-     *
-     * \param bPressed The new state
-     *
-     * \return True if this press was handled, false if it should fall through
-     *         to the next driver handler
-     */
-    bool OnMotion(bool bPressed);
+private:
+  // Construction parameters
+  const MOUSE::BUTTON_ID m_buttonIndex;
+};
 
-  private:
-    // Construction parameters
-    const MOUSE::BUTTON_ID m_buttonIndex;
-  };
+/*!
+ * \brief Detects when a mouse button should be mapped
+ */
+class CPointerDetector : public CPrimitiveDetector
+{
+public:
+  CPointerDetector(CButtonMapping* buttonMapping);
 
   /*!
-   * \brief Detects when a mouse button should be mapped
+   * \brief Pointer position has been updated
+   *
+   * \param x The new x coordinate
+   * \param y The new y coordinate
+   *
+   * \return Always true - pointer motion events are always absorbed while
+   *         button mapping
    */
-  class CPointerDetector : public CPrimitiveDetector
-  {
-  public:
-    CPointerDetector(CButtonMapping* buttonMapping);
-
-    /*!
-     * \brief Pointer position has been updated
-     *
-     * \param x The new x coordinate
-     * \param y The new y coordinate
-     *
-     * \return Always true - pointer motion events are always absorbed while
-     *         button mapping
-     */
-    bool OnMotion(int x, int y);
+  bool OnMotion(int x, int y);
 
-  private:
-    // Utility function
-    static INPUT::INTERCARDINAL_DIRECTION GetPointerDirection(int x, int y);
+private:
+  // Utility function
+  static INPUT::INTERCARDINAL_DIRECTION GetPointerDirection(int x, int y);
 
-    static const unsigned int MIN_FRAME_COUNT = 10;
+  static const unsigned int MIN_FRAME_COUNT = 10;
 
-    // State variables
-    bool m_bStarted = false;
-    int m_startX = 0;
-    int m_startY = 0;
-    unsigned int m_frameCount = 0;
-  };
+  // State variables
+  bool m_bStarted = false;
+  int m_startX = 0;
+  int m_startY = 0;
+  unsigned int m_frameCount = 0;
+};
 
+/*!
+ * \ingroup joystick
+ * \brief Generic implementation of a class that provides button mapping by
+ *        translating driver events to button mapping commands
+ *
+ * Button mapping commands are invoked instantly for buttons and hats.
+ *
+ * Button mapping commands are deferred for a short while after an axis is
+ * activated, and only one button mapping command will be invoked per
+ * activation.
+ */
+class CButtonMapping : public IDriverHandler,
+                       public KEYBOARD::IKeyboardDriverHandler,
+                       public MOUSE::IMouseDriverHandler,
+                       public IButtonMapCallback
+{
+public:
   /*!
-   * \ingroup joystick
-   * \brief Generic implementation of a class that provides button mapping by
-   *        translating driver events to button mapping commands
-   *
-   * Button mapping commands are invoked instantly for buttons and hats.
+   * \brief Constructor for CButtonMapping
    *
-   * Button mapping commands are deferred for a short while after an axis is
-   * activated, and only one button mapping command will be invoked per
-   * activation.
+   * \param buttonMapper Carries out button-mapping commands using <buttonMap>
+   * \param buttonMap The button map given to <buttonMapper> on each command
    */
-  class CButtonMapping : public IDriverHandler,
-                         public KEYBOARD::IKeyboardDriverHandler,
-                         public MOUSE::IMouseDriverHandler,
-                         public IButtonMapCallback
-  {
-  public:
-    /*!
-     * \brief Constructor for CButtonMapping
-     *
-     * \param buttonMapper Carries out button-mapping commands using <buttonMap>
-     * \param buttonMap The button map given to <buttonMapper> on each command
-     */
-    CButtonMapping(IButtonMapper* buttonMapper, IButtonMap* buttonMap, IKeymap* keymap);
+  CButtonMapping(IButtonMapper* buttonMapper, IButtonMap* buttonMap, IKeymap* keymap);
 
-    ~CButtonMapping() override = default;
+  ~CButtonMapping() override = default;
 
-    // implementation of IDriverHandler
-    bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) override;
-    bool OnHatMotion(unsigned int hatIndex, HAT_STATE state) override;
-    bool OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range) override;
-    void ProcessAxisMotions() override;
+  // implementation of IDriverHandler
+  bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) override;
+  bool OnHatMotion(unsigned int hatIndex, HAT_STATE state) override;
+  bool OnAxisMotion(unsigned int axisIndex,
+                    float position,
+                    int center,
+                    unsigned int range) override;
+  void ProcessAxisMotions() override;
 
-    // implementation of IKeyboardDriverHandler
-    bool OnKeyPress(const CKey& key) override;
-    void OnKeyRelease(const CKey& key) override { }
+  // implementation of IKeyboardDriverHandler
+  bool OnKeyPress(const CKey& key) override;
+  void OnKeyRelease(const CKey& key) override {}
 
-    // implementation of IMouseDriverHandler
-    bool OnPosition(int x, int y) override;
-    bool OnButtonPress(MOUSE::BUTTON_ID button) override;
-    void OnButtonRelease(MOUSE::BUTTON_ID button) override;
+  // implementation of IMouseDriverHandler
+  bool OnPosition(int x, int y) override;
+  bool OnButtonPress(MOUSE::BUTTON_ID button) override;
+  void OnButtonRelease(MOUSE::BUTTON_ID button) override;
 
-    // implementation of IButtonMapCallback
-    void SaveButtonMap() override;
-    void ResetIgnoredPrimitives() override;
-    void RevertButtonMap() override;
+  // implementation of IButtonMapCallback
+  void SaveButtonMap() override;
+  void ResetIgnoredPrimitives() override;
+  void RevertButtonMap() override;
 
-    /*!
-     * \brief Process the primitive mapping command
-     *
-     * First, this function checks if the input should be dropped. This can
-     * happen if the input is ignored or the cooldown period is active. If the
-     * input is dropped, this returns true with no effect, effectively absorbing
-     * the input. Otherwise, the mapping command is sent to m_buttonMapper.
-     *
-     * \param primitive The primitive being mapped
-     * \return True if the mapping command was handled, false otherwise
-     */
-    bool MapPrimitive(const CDriverPrimitive& primitive);
-
-  private:
-    bool IsMapping() const;
-
-    void OnLateDiscovery(unsigned int axisIndex);
-
-    CButtonDetector& GetButton(unsigned int buttonIndex);
-    CHatDetector& GetHat(unsigned int hatIndex);
-    CAxisDetector& GetAxis(unsigned int axisIndex, float position, const AxisConfiguration& initialConfig = AxisConfiguration());
-    CKeyDetector& GetKey(XBMCKey keycode);
-    CMouseButtonDetector& GetMouseButton(MOUSE::BUTTON_ID buttonIndex);
-    CPointerDetector &GetPointer();
-
-    // Construction parameters
-    IButtonMapper* const m_buttonMapper;
-    IButtonMap* const    m_buttonMap;
-    IKeymap* const       m_keymap;
-
-    std::map<unsigned int, CButtonDetector> m_buttons;
-    std::map<unsigned int, CHatDetector> m_hats;
-    std::map<unsigned int, CAxisDetector> m_axes;
-    std::map<XBMCKey, CKeyDetector> m_keys;
-    std::map<MOUSE::BUTTON_ID, CMouseButtonDetector> m_mouseButtons;
-    std::unique_ptr<CPointerDetector> m_pointer;
-    unsigned int m_lastAction;
-    uint64_t m_frameCount;
-  };
-}
-}
+  /*!
+   * \brief Process the primitive mapping command
+   *
+   * First, this function checks if the input should be dropped. This can
+   * happen if the input is ignored or the cooldown period is active. If the
+   * input is dropped, this returns true with no effect, effectively absorbing
+   * the input. Otherwise, the mapping command is sent to m_buttonMapper.
+   *
+   * \param primitive The primitive being mapped
+   * \return True if the mapping command was handled, false otherwise
+   */
+  bool MapPrimitive(const CDriverPrimitive& primitive);
+
+private:
+  bool IsMapping() const;
+
+  void OnLateDiscovery(unsigned int axisIndex);
+
+  CButtonDetector& GetButton(unsigned int buttonIndex);
+  CHatDetector& GetHat(unsigned int hatIndex);
+  CAxisDetector& GetAxis(unsigned int axisIndex,
+                         float position,
+                         const AxisConfiguration& initialConfig = AxisConfiguration());
+  CKeyDetector& GetKey(XBMCKey keycode);
+  CMouseButtonDetector& GetMouseButton(MOUSE::BUTTON_ID buttonIndex);
+  CPointerDetector& GetPointer();
+
+  // Construction parameters
+  IButtonMapper* const m_buttonMapper;
+  IButtonMap* const m_buttonMap;
+  IKeymap* const m_keymap;
+
+  std::map<unsigned int, CButtonDetector> m_buttons;
+  std::map<unsigned int, CHatDetector> m_hats;
+  std::map<unsigned int, CAxisDetector> m_axes;
+  std::map<XBMCKey, CKeyDetector> m_keys;
+  std::map<MOUSE::BUTTON_ID, CMouseButtonDetector> m_mouseButtons;
+  std::unique_ptr<CPointerDetector> m_pointer;
+  unsigned int m_lastAction;
+  uint64_t m_frameCount;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/generic/DriverReceiving.cpp b/xbmc/input/joysticks/generic/DriverReceiving.cpp
index c5f5a6ec62ba..bf52f4ffa40b 100644
--- a/xbmc/input/joysticks/generic/DriverReceiving.cpp
+++ b/xbmc/input/joysticks/generic/DriverReceiving.cpp
@@ -16,8 +16,7 @@ using namespace KODI;
 using namespace JOYSTICK;
 
 CDriverReceiving::CDriverReceiving(IDriverReceiver* receiver, IButtonMap* buttonMap)
- : m_receiver(receiver),
-   m_buttonMap(buttonMap)
+  : m_receiver(receiver), m_buttonMap(buttonMap)
 {
 }
 
diff --git a/xbmc/input/joysticks/generic/DriverReceiving.h b/xbmc/input/joysticks/generic/DriverReceiving.h
index 40043f3551f0..758b560c11f1 100644
--- a/xbmc/input/joysticks/generic/DriverReceiving.h
+++ b/xbmc/input/joysticks/generic/DriverReceiving.h
@@ -17,30 +17,30 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IDriverReceiver;
-  class IButtonMap;
-
-  /*!
-   * \ingroup joystick
-   * \brief Class to translate input events from higher-level features to driver primitives
-   *
-   * A button map is used to translate controller features to driver primitives.
-   * The button map has been abstracted away behind the IButtonMap interface
-   * so that it can be provided by an add-on.
-   */
-  class CDriverReceiving : public IInputReceiver
-  {
-  public:
-    CDriverReceiving(IDriverReceiver* receiver, IButtonMap* buttonMap);
-
-    ~CDriverReceiving() override = default;
-
-    // implementation of IInputReceiver
-    bool SetRumbleState(const FeatureName& feature, float magnitude) override;
-
-  private:
-    IDriverReceiver* const m_receiver;
-    IButtonMap*      const m_buttonMap;
-  };
-}
-}
+class IDriverReceiver;
+class IButtonMap;
+
+/*!
+ * \ingroup joystick
+ * \brief Class to translate input events from higher-level features to driver primitives
+ *
+ * A button map is used to translate controller features to driver primitives.
+ * The button map has been abstracted away behind the IButtonMap interface
+ * so that it can be provided by an add-on.
+ */
+class CDriverReceiving : public IInputReceiver
+{
+public:
+  CDriverReceiving(IDriverReceiver* receiver, IButtonMap* buttonMap);
+
+  ~CDriverReceiving() override = default;
+
+  // implementation of IInputReceiver
+  bool SetRumbleState(const FeatureName& feature, float magnitude) override;
+
+private:
+  IDriverReceiver* const m_receiver;
+  IButtonMap* const m_buttonMap;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/generic/FeatureHandling.cpp b/xbmc/input/joysticks/generic/FeatureHandling.cpp
index 39c3f00f3fa4..e324ed47c0f7 100644
--- a/xbmc/input/joysticks/generic/FeatureHandling.cpp
+++ b/xbmc/input/joysticks/generic/FeatureHandling.cpp
@@ -22,17 +22,19 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-#define ANALOG_DIGITAL_THRESHOLD  0.5f
-#define DISCRETE_ANALOG_RAMPUP_TIME_MS  1500
-#define DISCRETE_ANALOG_START_VALUE     0.3f
+#define ANALOG_DIGITAL_THRESHOLD 0.5f
+#define DISCRETE_ANALOG_RAMPUP_TIME_MS 1500
+#define DISCRETE_ANALOG_START_VALUE 0.3f
 
 // --- CJoystickFeature --------------------------------------------------------
 
-CJoystickFeature::CJoystickFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap) :
-  m_name(name),
-  m_handler(handler),
-  m_buttonMap(buttonMap),
-  m_bEnabled(m_handler->HasFeature(name))
+CJoystickFeature::CJoystickFeature(const FeatureName& name,
+                                   IInputHandler* handler,
+                                   IButtonMap* buttonMap)
+  : m_name(name),
+    m_handler(handler),
+    m_buttonMap(buttonMap),
+    m_bEnabled(m_handler->HasFeature(name))
 {
 }
 
@@ -74,14 +76,17 @@ unsigned int CJoystickFeature::MotionTimeMs() const
 
 // --- CScalarFeature ----------------------------------------------------------
 
-CScalarFeature::CScalarFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap) :
-  CJoystickFeature(name, handler, buttonMap),
-  m_bDigitalState(false),
-  m_analogState(0.0f),
-  m_bActivated(false),
-  m_bDiscrete(true)
+CScalarFeature::CScalarFeature(const FeatureName& name,
+                               IInputHandler* handler,
+                               IButtonMap* buttonMap)
+  : CJoystickFeature(name, handler, buttonMap),
+    m_bDigitalState(false),
+    m_analogState(0.0f),
+    m_bActivated(false),
+    m_bDiscrete(true)
 {
-  GAME::ControllerPtr controller = CServiceBroker::GetGameControllerManager().GetController(handler->ControllerID());
+  GAME::ControllerPtr controller =
+      CServiceBroker::GetGameControllerManager().GetController(handler->ControllerID());
   if (controller)
     m_inputType = controller->GetInputType(name);
 }
@@ -142,10 +147,11 @@ bool CScalarFeature::OnDigitalMotion(bool bPressed)
     bHandled = m_bInitialPressHandled = m_handler->OnButtonPress(m_name, bPressed);
 
     if (m_bDigitalState)
-      CLog::Log(LOGDEBUG, "FEATURE [ %s ] on %s pressed (%s)", m_name.c_str(), m_handler->ControllerID().c_str(),
-        bHandled ? "handled" : "ignored");
+      CLog::Log(LOGDEBUG, "FEATURE [ %s ] on %s pressed (%s)", m_name.c_str(),
+                m_handler->ControllerID().c_str(), bHandled ? "handled" : "ignored");
     else
-      CLog::Log(LOGDEBUG, "FEATURE [ %s ] on %s released", m_name.c_str(), m_handler->ControllerID().c_str());
+      CLog::Log(LOGDEBUG, "FEATURE [ %s ] on %s released", m_name.c_str(),
+                m_handler->ControllerID().c_str());
   }
   else if (m_bDigitalState)
   {
@@ -172,8 +178,8 @@ bool CScalarFeature::OnAnalogMotion(float magnitude)
   if (m_bDigitalState != bActivated)
   {
     m_bDigitalState = bActivated;
-    CLog::Log(LOGDEBUG, "FEATURE [ %s ] on %s %s", m_name.c_str(), m_handler->ControllerID().c_str(),
-              bActivated ? "activated" : "deactivated");
+    CLog::Log(LOGDEBUG, "FEATURE [ %s ] on %s %s", m_name.c_str(),
+              m_handler->ControllerID().c_str(), bActivated ? "activated" : "deactivated");
   }
 
   return true;
@@ -218,9 +224,8 @@ void CScalarFeature::ProcessAnalogMotion()
 
 // --- CAxisFeature ------------------------------------------------------------
 
-CAxisFeature::CAxisFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap) :
-  CJoystickFeature(name, handler, buttonMap),
-  m_state(0.0f)
+CAxisFeature::CAxisFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap)
+  : CJoystickFeature(name, handler, buttonMap), m_state(0.0f)
 {
 }
 
@@ -245,8 +250,7 @@ void CAxisFeature::ProcessMotions(void)
   else if (bActivated && !bWasActivated)
   {
     CLog::Log(LOGDEBUG, "Feature [ %s ] on %s activated %s", m_name.c_str(),
-              m_handler->ControllerID().c_str(),
-              newState > 0.0f ? "positive" : "negative");
+              m_handler->ControllerID().c_str(), newState > 0.0f ? "positive" : "negative");
   }
 
   if (bActivated || bWasActivated)
@@ -281,8 +285,8 @@ void CAxisFeature::ProcessMotions(void)
 
 // --- CWheel ------------------------------------------------------------------
 
-CWheel::CWheel(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap) :
-  CAxisFeature(name, handler, buttonMap)
+CWheel::CWheel(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap)
+  : CAxisFeature(name, handler, buttonMap)
 {
 }
 
@@ -291,8 +295,8 @@ bool CWheel::OnAnalogMotion(const CDriverPrimitive& source, float magnitude)
   WHEEL_DIRECTION direction = WHEEL_DIRECTION::NONE;
 
   std::vector<WHEEL_DIRECTION> dirs = {
-    WHEEL_DIRECTION::RIGHT,
-    WHEEL_DIRECTION::LEFT,
+      WHEEL_DIRECTION::RIGHT,
+      WHEEL_DIRECTION::LEFT,
   };
 
   CDriverPrimitive primitive;
@@ -327,8 +331,8 @@ bool CWheel::OnAnalogMotion(const CDriverPrimitive& source, float magnitude)
 
 // --- CThrottle ---------------------------------------------------------------
 
-CThrottle::CThrottle(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap) :
-  CAxisFeature(name, handler, buttonMap)
+CThrottle::CThrottle(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap)
+  : CAxisFeature(name, handler, buttonMap)
 {
 }
 
@@ -337,8 +341,8 @@ bool CThrottle::OnAnalogMotion(const CDriverPrimitive& source, float magnitude)
   THROTTLE_DIRECTION direction = THROTTLE_DIRECTION::NONE;
 
   std::vector<THROTTLE_DIRECTION> dirs = {
-    THROTTLE_DIRECTION::UP,
-    THROTTLE_DIRECTION::DOWN,
+      THROTTLE_DIRECTION::UP,
+      THROTTLE_DIRECTION::DOWN,
   };
 
   CDriverPrimitive primitive;
@@ -373,10 +377,8 @@ bool CThrottle::OnAnalogMotion(const CDriverPrimitive& source, float magnitude)
 
 // --- CAnalogStick ------------------------------------------------------------
 
-CAnalogStick::CAnalogStick(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap) :
-  CJoystickFeature(name, handler, buttonMap),
-  m_vertState(0.0f),
-  m_horizState(0.0f)
+CAnalogStick::CAnalogStick(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap)
+  : CJoystickFeature(name, handler, buttonMap), m_vertState(0.0f), m_horizState(0.0f)
 {
 }
 
@@ -390,10 +392,10 @@ bool CAnalogStick::OnAnalogMotion(const CDriverPrimitive& source, float magnitud
   ANALOG_STICK_DIRECTION direction = ANALOG_STICK_DIRECTION::NONE;
 
   std::vector<ANALOG_STICK_DIRECTION> dirs = {
-    ANALOG_STICK_DIRECTION::UP,
-    ANALOG_STICK_DIRECTION::DOWN,
-    ANALOG_STICK_DIRECTION::RIGHT,
-    ANALOG_STICK_DIRECTION::LEFT,
+      ANALOG_STICK_DIRECTION::UP,
+      ANALOG_STICK_DIRECTION::DOWN,
+      ANALOG_STICK_DIRECTION::RIGHT,
+      ANALOG_STICK_DIRECTION::LEFT,
   };
 
   CDriverPrimitive primitive;
@@ -411,23 +413,23 @@ bool CAnalogStick::OnAnalogMotion(const CDriverPrimitive& source, float magnitud
 
   switch (direction)
   {
-  case ANALOG_STICK_DIRECTION::UP:
-    m_vertAxis.SetPositiveDistance(magnitude);
-    break;
-  case ANALOG_STICK_DIRECTION::DOWN:
-    m_vertAxis.SetNegativeDistance(magnitude);
-    break;
-  case ANALOG_STICK_DIRECTION::RIGHT:
-    m_horizAxis.SetPositiveDistance(magnitude);
-    break;
-  case ANALOG_STICK_DIRECTION::LEFT:
-    m_horizAxis.SetNegativeDistance(magnitude);
-    break;
-  default:
-    // Just in case, avoid sticking
-    m_vertAxis.Reset();
-    m_horizAxis.Reset();
-    break;
+    case ANALOG_STICK_DIRECTION::UP:
+      m_vertAxis.SetPositiveDistance(magnitude);
+      break;
+    case ANALOG_STICK_DIRECTION::DOWN:
+      m_vertAxis.SetNegativeDistance(magnitude);
+      break;
+    case ANALOG_STICK_DIRECTION::RIGHT:
+      m_horizAxis.SetPositiveDistance(magnitude);
+      break;
+    case ANALOG_STICK_DIRECTION::LEFT:
+      m_horizAxis.SetNegativeDistance(magnitude);
+      break;
+    default:
+      // Just in case, avoid sticking
+      m_vertAxis.Reset();
+      m_horizAxis.Reset();
+      break;
   }
 
   return bHandled;
@@ -447,8 +449,8 @@ void CAnalogStick::ProcessMotions(void)
 
   if (bActivated ^ bWasActivated)
   {
-    CLog::Log(LOGDEBUG, "Feature [ %s ] on %s %s", m_name.c_str(), m_handler->ControllerID().c_str(),
-              bActivated ? "activated" : "deactivated");
+    CLog::Log(LOGDEBUG, "Feature [ %s ] on %s %s", m_name.c_str(),
+              m_handler->ControllerID().c_str(), bActivated ? "activated" : "deactivated");
   }
 
   if (bActivated || bWasActivated)
@@ -476,11 +478,13 @@ void CAnalogStick::ProcessMotions(void)
 
 // --- CAccelerometer ----------------------------------------------------------
 
-CAccelerometer::CAccelerometer(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap) :
-  CJoystickFeature(name, handler, buttonMap),
-  m_xAxisState(0.0f),
-  m_yAxisState(0.0f),
-  m_zAxisState(0.0f)
+CAccelerometer::CAccelerometer(const FeatureName& name,
+                               IInputHandler* handler,
+                               IButtonMap* buttonMap)
+  : CJoystickFeature(name, handler, buttonMap),
+    m_xAxisState(0.0f),
+    m_yAxisState(0.0f),
+    m_zAxisState(0.0f)
 {
 }
 
diff --git a/xbmc/input/joysticks/generic/FeatureHandling.h b/xbmc/input/joysticks/generic/FeatureHandling.h
index 7cfe3fa7d5ca..4010781dabe7 100644
--- a/xbmc/input/joysticks/generic/FeatureHandling.h
+++ b/xbmc/input/joysticks/generic/FeatureHandling.h
@@ -16,266 +16,266 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class CDriverPrimitive;
-  class IInputHandler;
-  class IButtonMap;
+class CDriverPrimitive;
+class IInputHandler;
+class IButtonMap;
 
-  class CJoystickFeature;
-  using FeaturePtr = std::shared_ptr<CJoystickFeature>;
+class CJoystickFeature;
+using FeaturePtr = std::shared_ptr<CJoystickFeature>;
+
+/*!
+ * \ingroup joystick
+ * \brief Base class for joystick features
+ *
+ * See list of feature types in JoystickTypes.h.
+ */
+class CJoystickFeature
+{
+public:
+  CJoystickFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
+  virtual ~CJoystickFeature() = default;
 
   /*!
-   * \ingroup joystick
-   * \brief Base class for joystick features
+   * \brief A digital motion has occured
+   *
+   * \param source The source of the motion. Must be digital (button or hat)
+   * \param bPressed True for press motion, false for release motion
    *
-   * See list of feature types in JoystickTypes.h.
+   * \return true if the motion was handled, false otherwise
    */
-  class CJoystickFeature
-  {
-  public:
-    CJoystickFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
-    virtual ~CJoystickFeature() = default;
-
-    /*!
-     * \brief A digital motion has occured
-     *
-     * \param source The source of the motion. Must be digital (button or hat)
-     * \param bPressed True for press motion, false for release motion
-     *
-     * \return true if the motion was handled, false otherwise
-     */
-    virtual bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) = 0;
-
-    /*!
-     * \brief An analog motion has occured
-     *
-     * \param source The source of the motion. Must be a semiaxis
-     * \param magnitude The magnitude of the press or motion in the interval [0.0, 1.0]
-     *
-     * For semiaxes, the magnitude is the force or travel distance in the
-     * direction of the semiaxis. If the value is in the opposite direction,
-     * the magnitude is 0.0.
-     *
-     * For example, if the analog stick goes left, the negative semiaxis will
-     * have a value of 1.0 and the positive semiaxis will have a value of 0.0.
-     */
-    virtual bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) = 0;
-
-    /*!
-     * \brief Process the motions that have occured since the last invocation
-     *
-     * This allows features with motion on multiple driver primitives to call
-     * their handler once all driver primitives are accounted for.
-     */
-    virtual void ProcessMotions(void) = 0;
-
-    /*!
-     * \brief Check if the input handler is accepting input
-     *
-     * \param bActivation True if the motion is activating (true or positive),
-     *                    false if the motion is deactivating (false or zero)
-     *
-     * \return True if input should be sent to the input handler, false otherwise
-     */
-    bool AcceptsInput(bool bActivation);
-
-  protected:
-    /*!
-     * \brief Reset motion timer
-     */
-    void ResetMotion();
-
-    /*!
-     * \brief Start the motion timer
-     */
-    void StartMotion();
-
-    /*!
-     * \brief Check if the feature is in motion
-     */
-    bool InMotion() const;
-
-    /*!
-     * \brief Get the time for which the feature has been in motion
-     */
-    unsigned int MotionTimeMs() const;
-
-    const FeatureName    m_name;
-    IInputHandler* const m_handler;
-    IButtonMap* const    m_buttonMap;
-    const bool           m_bEnabled;
-
-  private:
-    unsigned int m_motionStartTimeMs = 0;
-  };
-
-  class CScalarFeature : public CJoystickFeature
-  {
-  public:
-    CScalarFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
-    ~CScalarFeature() override = default;
-
-    // implementation of CJoystickFeature
-    bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) override;
-    bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
-    void ProcessMotions() override;
-
-  private:
-    bool OnDigitalMotion(bool bPressed);
-    bool OnAnalogMotion(float magnitude);
-
-    void ProcessDigitalMotion();
-    void ProcessAnalogMotion();
-
-    // State variables
-    INPUT_TYPE       m_inputType = INPUT_TYPE::UNKNOWN;
-    bool             m_bDigitalState;
-    bool             m_bInitialPressHandled = false;
-
-    // Analog state variables
-    float            m_analogState; // The current magnitude
-    float            m_bActivated; // Set to true when first activated (magnitude > 0.0)
-    bool             m_bDiscrete; // Set to false when a non-discrete axis is detected
-  };
+  virtual bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) = 0;
 
   /*!
-   * \ingroup joystick
-   * \brief Axis of a feature (analog stick, accelerometer, etc)
+   * \brief An analog motion has occured
    *
-   * Axes are composed of two driver primitives, one for the positive semiaxis
-   * and one for the negative semiaxis.
+   * \param source The source of the motion. Must be a semiaxis
+   * \param magnitude The magnitude of the press or motion in the interval [0.0, 1.0]
    *
-   * This effectively means that an axis is two-dimensional, with each dimension
-   * either:
+   * For semiaxes, the magnitude is the force or travel distance in the
+   * direction of the semiaxis. If the value is in the opposite direction,
+   * the magnitude is 0.0.
    *
-   *    - a digital value (0.0 or 1.0)
-   *    - an analog value (continuous in the interval [0.0, 1.0])
+   * For example, if the analog stick goes left, the negative semiaxis will
+   * have a value of 1.0 and the positive semiaxis will have a value of 0.0.
    */
-  class CFeatureAxis
-  {
-  public:
-    CFeatureAxis(void) { Reset(); }
-
-    /*!
-     * \brief Set value of positive axis
-     */
-    void SetPositiveDistance(float distance) { m_positiveDistance = distance; }
-
-    /*!
-     * \brief Set value of negative axis
-     */
-    void SetNegativeDistance(float distance) { m_negativeDistance = distance; }
-
-    /*!
-     * \brief Get the final value of this axis.
-     *
-     * This axis is two-dimensional, so we need to compress these into a single
-     * dimension. This is done by subtracting the negative from the positive.
-     * Some examples:
-     *
-     *      Positive axis:  1.0 (User presses right or analog stick moves right)
-     *      Negative axis:  0.0
-     *      -------------------
-     *      Pos - Neg:      1.0 (Emulated analog stick moves right)
-     *
-     *
-     *      Positive axis:  0.0
-     *      Negative axis:  1.0 (User presses left or analog stick moves left)
-     *      -------------------
-     *      Pos - Neg:     -1.0 (Emulated analog stick moves left)
-     *
-     *
-     *      Positive axis:  1.0 (User presses both buttons)
-     *      Negative axis:  1.0
-     *      -------------------
-     *      Pos - Neg:      0.0 (Emulated analog stick is centered)
-     *
-     */
-    float GetPosition(void) const { return m_positiveDistance - m_negativeDistance; }
-
-    /*!
-     * \brief Reset both positive and negative values to zero
-     */
-    void Reset(void) { m_positiveDistance = m_negativeDistance = 0.0f; }
-
-  protected:
-    float m_positiveDistance;
-    float m_negativeDistance;
-  };
-
-  class CAxisFeature : public CJoystickFeature
-  {
-  public:
-    CAxisFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
-    ~CAxisFeature() override = default;
-
-    // partial implementation of CJoystickFeature
-    bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) override;
-    void ProcessMotions() override;
-
-  protected:
-    CFeatureAxis m_axis;
-
-    float m_state;
-  };
-
-  class CWheel : public CAxisFeature
-  {
-  public:
-    CWheel(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
-    ~CWheel() override = default;
-
-    // partial implementation of CJoystickFeature
-    bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
-  };
-
-  class CThrottle : public CAxisFeature
-  {
-  public:
-    CThrottle(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
-    ~CThrottle() override = default;
-
-    // partial implementation of CJoystickFeature
-    bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
-  };
-
-  class CAnalogStick : public CJoystickFeature
-  {
-  public:
-    CAnalogStick(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
-    ~CAnalogStick() override = default;
-
-    // implementation of CJoystickFeature
-    bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) override;
-    bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
-    void ProcessMotions() override;
-
-  protected:
-    CFeatureAxis m_vertAxis;
-    CFeatureAxis m_horizAxis;
-
-    float m_vertState;
-    float m_horizState;
-  };
-
-  class CAccelerometer : public CJoystickFeature
-  {
-  public:
-    CAccelerometer(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
-    ~CAccelerometer() override = default;
-
-    // implementation of CJoystickFeature
-    bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) override;
-    bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
-    void ProcessMotions() override;
-
-  protected:
-    CFeatureAxis m_xAxis;
-    CFeatureAxis m_yAxis;
-    CFeatureAxis m_zAxis;
-
-    float m_xAxisState;
-    float m_yAxisState;
-    float m_zAxisState;
-  };
-}
-}
+  virtual bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) = 0;
+
+  /*!
+   * \brief Process the motions that have occured since the last invocation
+   *
+   * This allows features with motion on multiple driver primitives to call
+   * their handler once all driver primitives are accounted for.
+   */
+  virtual void ProcessMotions(void) = 0;
+
+  /*!
+   * \brief Check if the input handler is accepting input
+   *
+   * \param bActivation True if the motion is activating (true or positive),
+   *                    false if the motion is deactivating (false or zero)
+   *
+   * \return True if input should be sent to the input handler, false otherwise
+   */
+  bool AcceptsInput(bool bActivation);
+
+protected:
+  /*!
+   * \brief Reset motion timer
+   */
+  void ResetMotion();
+
+  /*!
+   * \brief Start the motion timer
+   */
+  void StartMotion();
+
+  /*!
+   * \brief Check if the feature is in motion
+   */
+  bool InMotion() const;
+
+  /*!
+   * \brief Get the time for which the feature has been in motion
+   */
+  unsigned int MotionTimeMs() const;
+
+  const FeatureName m_name;
+  IInputHandler* const m_handler;
+  IButtonMap* const m_buttonMap;
+  const bool m_bEnabled;
+
+private:
+  unsigned int m_motionStartTimeMs = 0;
+};
+
+class CScalarFeature : public CJoystickFeature
+{
+public:
+  CScalarFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
+  ~CScalarFeature() override = default;
+
+  // implementation of CJoystickFeature
+  bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) override;
+  bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
+  void ProcessMotions() override;
+
+private:
+  bool OnDigitalMotion(bool bPressed);
+  bool OnAnalogMotion(float magnitude);
+
+  void ProcessDigitalMotion();
+  void ProcessAnalogMotion();
+
+  // State variables
+  INPUT_TYPE m_inputType = INPUT_TYPE::UNKNOWN;
+  bool m_bDigitalState;
+  bool m_bInitialPressHandled = false;
+
+  // Analog state variables
+  float m_analogState; // The current magnitude
+  float m_bActivated; // Set to true when first activated (magnitude > 0.0)
+  bool m_bDiscrete; // Set to false when a non-discrete axis is detected
+};
+
+/*!
+ * \ingroup joystick
+ * \brief Axis of a feature (analog stick, accelerometer, etc)
+ *
+ * Axes are composed of two driver primitives, one for the positive semiaxis
+ * and one for the negative semiaxis.
+ *
+ * This effectively means that an axis is two-dimensional, with each dimension
+ * either:
+ *
+ *    - a digital value (0.0 or 1.0)
+ *    - an analog value (continuous in the interval [0.0, 1.0])
+ */
+class CFeatureAxis
+{
+public:
+  CFeatureAxis(void) { Reset(); }
+
+  /*!
+   * \brief Set value of positive axis
+   */
+  void SetPositiveDistance(float distance) { m_positiveDistance = distance; }
+
+  /*!
+   * \brief Set value of negative axis
+   */
+  void SetNegativeDistance(float distance) { m_negativeDistance = distance; }
+
+  /*!
+   * \brief Get the final value of this axis.
+   *
+   * This axis is two-dimensional, so we need to compress these into a single
+   * dimension. This is done by subtracting the negative from the positive.
+   * Some examples:
+   *
+   *      Positive axis:  1.0 (User presses right or analog stick moves right)
+   *      Negative axis:  0.0
+   *      -------------------
+   *      Pos - Neg:      1.0 (Emulated analog stick moves right)
+   *
+   *
+   *      Positive axis:  0.0
+   *      Negative axis:  1.0 (User presses left or analog stick moves left)
+   *      -------------------
+   *      Pos - Neg:     -1.0 (Emulated analog stick moves left)
+   *
+   *
+   *      Positive axis:  1.0 (User presses both buttons)
+   *      Negative axis:  1.0
+   *      -------------------
+   *      Pos - Neg:      0.0 (Emulated analog stick is centered)
+   *
+   */
+  float GetPosition(void) const { return m_positiveDistance - m_negativeDistance; }
+
+  /*!
+   * \brief Reset both positive and negative values to zero
+   */
+  void Reset(void) { m_positiveDistance = m_negativeDistance = 0.0f; }
+
+protected:
+  float m_positiveDistance;
+  float m_negativeDistance;
+};
+
+class CAxisFeature : public CJoystickFeature
+{
+public:
+  CAxisFeature(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
+  ~CAxisFeature() override = default;
+
+  // partial implementation of CJoystickFeature
+  bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) override;
+  void ProcessMotions() override;
+
+protected:
+  CFeatureAxis m_axis;
+
+  float m_state;
+};
+
+class CWheel : public CAxisFeature
+{
+public:
+  CWheel(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
+  ~CWheel() override = default;
+
+  // partial implementation of CJoystickFeature
+  bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
+};
+
+class CThrottle : public CAxisFeature
+{
+public:
+  CThrottle(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
+  ~CThrottle() override = default;
+
+  // partial implementation of CJoystickFeature
+  bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
+};
+
+class CAnalogStick : public CJoystickFeature
+{
+public:
+  CAnalogStick(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
+  ~CAnalogStick() override = default;
+
+  // implementation of CJoystickFeature
+  bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) override;
+  bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
+  void ProcessMotions() override;
+
+protected:
+  CFeatureAxis m_vertAxis;
+  CFeatureAxis m_horizAxis;
+
+  float m_vertState;
+  float m_horizState;
+};
+
+class CAccelerometer : public CJoystickFeature
+{
+public:
+  CAccelerometer(const FeatureName& name, IInputHandler* handler, IButtonMap* buttonMap);
+  ~CAccelerometer() override = default;
+
+  // implementation of CJoystickFeature
+  bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed) override;
+  bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude) override;
+  void ProcessMotions() override;
+
+protected:
+  CFeatureAxis m_xAxis;
+  CFeatureAxis m_yAxis;
+  CFeatureAxis m_zAxis;
+
+  float m_xAxisState;
+  float m_yAxisState;
+  float m_zAxisState;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/generic/InputHandling.cpp b/xbmc/input/joysticks/generic/InputHandling.cpp
index b8fac8a2d7a8..3186f0a37334 100644
--- a/xbmc/input/joysticks/generic/InputHandling.cpp
+++ b/xbmc/input/joysticks/generic/InputHandling.cpp
@@ -23,8 +23,7 @@ using namespace JOYSTICK;
 CGUIDialogNewJoystick* const CInputHandling::m_dialog = new CGUIDialogNewJoystick;
 
 CInputHandling::CInputHandling(IInputHandler* handler, IButtonMap* buttonMap)
- : m_handler(handler),
-   m_buttonMap(buttonMap)
+  : m_handler(handler), m_buttonMap(buttonMap)
 {
 }
 
@@ -39,15 +38,22 @@ bool CInputHandling::OnHatMotion(unsigned int hatIndex, HAT_STATE state)
 {
   bool bHandled = false;
 
-  bHandled |= OnDigitalMotion(CDriverPrimitive(hatIndex, HAT_DIRECTION::UP),    state & HAT_DIRECTION::UP);
-  bHandled |= OnDigitalMotion(CDriverPrimitive(hatIndex, HAT_DIRECTION::RIGHT), state & HAT_DIRECTION::RIGHT);
-  bHandled |= OnDigitalMotion(CDriverPrimitive(hatIndex, HAT_DIRECTION::DOWN),  state & HAT_DIRECTION::DOWN);
-  bHandled |= OnDigitalMotion(CDriverPrimitive(hatIndex, HAT_DIRECTION::LEFT),  state & HAT_DIRECTION::LEFT);
+  bHandled |=
+      OnDigitalMotion(CDriverPrimitive(hatIndex, HAT_DIRECTION::UP), state & HAT_DIRECTION::UP);
+  bHandled |= OnDigitalMotion(CDriverPrimitive(hatIndex, HAT_DIRECTION::RIGHT),
+                              state & HAT_DIRECTION::RIGHT);
+  bHandled |=
+      OnDigitalMotion(CDriverPrimitive(hatIndex, HAT_DIRECTION::DOWN), state & HAT_DIRECTION::DOWN);
+  bHandled |=
+      OnDigitalMotion(CDriverPrimitive(hatIndex, HAT_DIRECTION::LEFT), state & HAT_DIRECTION::LEFT);
 
   return bHandled;
 }
 
-bool CInputHandling::OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range)
+bool CInputHandling::OnAxisMotion(unsigned int axisIndex,
+                                  float position,
+                                  int center,
+                                  unsigned int range)
 {
   bool bHandled = false;
 
diff --git a/xbmc/input/joysticks/generic/InputHandling.h b/xbmc/input/joysticks/generic/InputHandling.h
index 3efbc7786d3e..634826ad384a 100644
--- a/xbmc/input/joysticks/generic/InputHandling.h
+++ b/xbmc/input/joysticks/generic/InputHandling.h
@@ -18,49 +18,52 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class CDriverPrimitive;
-  class CGUIDialogNewJoystick;
-  class IInputHandler;
-  class IButtonMap;
+class CDriverPrimitive;
+class CGUIDialogNewJoystick;
+class IInputHandler;
+class IButtonMap;
 
-  /*!
-   * \ingroup joystick
-   * \brief Class to translate input from the driver into higher-level features
-   *
-   * Raw driver input arrives for three elements: buttons, hats and axes. When
-   * driver input is handled by this class, it translates the raw driver
-   * elements into physical joystick features, such as buttons, analog sticks,
-   * etc.
-   *
-   * A button map is used to translate driver primitives to controller features.
-   * The button map has been abstracted away behind the IButtonMap
-   * interface so that it can be provided by an add-on.
-   */
-  class CInputHandling : public IDriverHandler
-  {
-  public:
-    CInputHandling(IInputHandler* handler, IButtonMap* buttonMap);
+/*!
+ * \ingroup joystick
+ * \brief Class to translate input from the driver into higher-level features
+ *
+ * Raw driver input arrives for three elements: buttons, hats and axes. When
+ * driver input is handled by this class, it translates the raw driver
+ * elements into physical joystick features, such as buttons, analog sticks,
+ * etc.
+ *
+ * A button map is used to translate driver primitives to controller features.
+ * The button map has been abstracted away behind the IButtonMap
+ * interface so that it can be provided by an add-on.
+ */
+class CInputHandling : public IDriverHandler
+{
+public:
+  CInputHandling(IInputHandler* handler, IButtonMap* buttonMap);
 
-    ~CInputHandling() override;
+  ~CInputHandling() override;
 
-    // implementation of IDriverHandler
-    bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) override;
-    bool OnHatMotion(unsigned int hatIndex, HAT_STATE state) override;
-    bool OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range) override;
-    void ProcessAxisMotions() override;
+  // implementation of IDriverHandler
+  bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) override;
+  bool OnHatMotion(unsigned int hatIndex, HAT_STATE state) override;
+  bool OnAxisMotion(unsigned int axisIndex,
+                    float position,
+                    int center,
+                    unsigned int range) override;
+  void ProcessAxisMotions() override;
 
-  private:
-    bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed);
-    bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude);
+private:
+  bool OnDigitalMotion(const CDriverPrimitive& source, bool bPressed);
+  bool OnAnalogMotion(const CDriverPrimitive& source, float magnitude);
 
-    CJoystickFeature* CreateFeature(const FeatureName& featureName);
+  CJoystickFeature* CreateFeature(const FeatureName& featureName);
 
-    IInputHandler* const m_handler;
-    IButtonMap* const    m_buttonMap;
+  IInputHandler* const m_handler;
+  IButtonMap* const m_buttonMap;
 
-    std::map<FeatureName, FeaturePtr> m_features;
+  std::map<FeatureName, FeaturePtr> m_features;
 
-    static CGUIDialogNewJoystick* const m_dialog;
-  };
-}
-}
+  static CGUIDialogNewJoystick* const m_dialog;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IButtonMap.h b/xbmc/input/joysticks/interfaces/IButtonMap.h
index 923af0dc44ea..bd9e49b9da42 100644
--- a/xbmc/input/joysticks/interfaces/IButtonMap.h
+++ b/xbmc/input/joysticks/interfaces/IButtonMap.h
@@ -18,343 +18,308 @@ namespace KODI
 {
 namespace JOYSTICK
 {
+/*!
+ * \ingroup joystick
+ * \brief Button map interface to translate between the driver's raw
+ *        button/hat/axis elements and physical joystick features.
+ *
+ * \sa IButtonMapper
+ */
+class IButtonMap
+{
+public:
+  virtual ~IButtonMap() = default;
+
   /*!
-   * \ingroup joystick
-   * \brief Button map interface to translate between the driver's raw
-   *        button/hat/axis elements and physical joystick features.
+   * \brief The add-on ID of the game controller associated with this button map
    *
-   * \sa IButtonMapper
+   * The controller ID provided by the implementation serves as the context
+   * for the feature names below.
+   *
+   * \return The ID of this button map's game controller add-on
    */
-  class IButtonMap
-  {
-  public:
-    virtual ~IButtonMap() = default;
-
-    /*!
-     * \brief The add-on ID of the game controller associated with this button map
-     *
-     * The controller ID provided by the implementation serves as the context
-     * for the feature names below.
-     *
-     * \return The ID of this button map's game controller add-on
-     */
-    virtual std::string ControllerID(void) const = 0;
+  virtual std::string ControllerID(void) const = 0;
 
-    /*!
-     * \brief The name of the peripheral associated with this button map
-     *
-     * \return The peripheral's name
-     */
-    virtual std::string DeviceName(void) const = 0;
+  /*!
+   * \brief The name of the peripheral associated with this button map
+   *
+   * \return The peripheral's name
+   */
+  virtual std::string DeviceName(void) const = 0;
 
-    /*!
-     * \brief Load the button map into memory
-     *
-     * \return True if button map is ready to start translating buttons, false otherwise
-     */
-    virtual bool Load(void) = 0;
+  /*!
+   * \brief Load the button map into memory
+   *
+   * \return True if button map is ready to start translating buttons, false otherwise
+   */
+  virtual bool Load(void) = 0;
 
-    /*!
-     * \brief Reset the button map to its defaults, or clear button map if no defaults
-     */
-    virtual void Reset(void) = 0;
+  /*!
+   * \brief Reset the button map to its defaults, or clear button map if no defaults
+   */
+  virtual void Reset(void) = 0;
 
-    /*!
-     * \brief Check if the button map is empty
-     *
-     * \return True if the button map is empty, false if it has features
-     */
-    virtual bool IsEmpty(void) const = 0;
+  /*!
+   * \brief Check if the button map is empty
+   *
+   * \return True if the button map is empty, false if it has features
+   */
+  virtual bool IsEmpty(void) const = 0;
 
-    /*!
-     * \brief Get the feature associated with a driver primitive
-     *
-     * Multiple primitives can be mapped to the same feature. For example,
-     * analog sticks use one primitive for each direction.
-     *
-     * \param primitive    The driver primitive
-     * \param feature      The name of the resolved joystick feature, or
-     *                     invalid if false is returned
-     *
-     * \return True if the driver primitive is associated with a feature, false otherwise
-     */
-    virtual bool GetFeature(
-      const CDriverPrimitive& primitive,
-      FeatureName& feature
-    ) = 0;
+  /*!
+   * \brief Get the feature associated with a driver primitive
+   *
+   * Multiple primitives can be mapped to the same feature. For example,
+   * analog sticks use one primitive for each direction.
+   *
+   * \param primitive    The driver primitive
+   * \param feature      The name of the resolved joystick feature, or
+   *                     invalid if false is returned
+   *
+   * \return True if the driver primitive is associated with a feature, false otherwise
+   */
+  virtual bool GetFeature(const CDriverPrimitive& primitive, FeatureName& feature) = 0;
 
-    /*!
-     * \brief Get the type of the feature for the given name
-     *
-     * \param feature      The feature to look up
-     *
-     * \return The feature's type
-     */
-    virtual FEATURE_TYPE GetFeatureType(const FeatureName& feature) = 0;
+  /*!
+   * \brief Get the type of the feature for the given name
+   *
+   * \param feature      The feature to look up
+   *
+   * \return The feature's type
+   */
+  virtual FEATURE_TYPE GetFeatureType(const FeatureName& feature) = 0;
 
-    /*!
-     * \brief Get the driver primitive for a scalar feature
-     *
-     * When a feature can be represented by a single driver primitive, it is
-     * called a scalar feature.
-     *
-     *   - This includes buttons and triggers, because they can be mapped to a
-     *     single button/hat/semiaxis
-     *
-     *   - This does not include analog sticks, because they require two axes
-     *     and four driver primitives (one for each semiaxis)
-     *
-     * \param feature        Must be a scalar feature (a feature that only
-     *                       requires a single driver primitive)
-     * \param primitive      The resolved driver primitive
-     *
-     * \return True if the feature resolved to a driver primitive, false if the
-     *         feature didn't resolve or isn't a scalar feature
-     */
-    virtual bool GetScalar(
-      const FeatureName& feature,
-      CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Get the driver primitive for a scalar feature
+   *
+   * When a feature can be represented by a single driver primitive, it is
+   * called a scalar feature.
+   *
+   *   - This includes buttons and triggers, because they can be mapped to a
+   *     single button/hat/semiaxis
+   *
+   *   - This does not include analog sticks, because they require two axes
+   *     and four driver primitives (one for each semiaxis)
+   *
+   * \param feature        Must be a scalar feature (a feature that only
+   *                       requires a single driver primitive)
+   * \param primitive      The resolved driver primitive
+   *
+   * \return True if the feature resolved to a driver primitive, false if the
+   *         feature didn't resolve or isn't a scalar feature
+   */
+  virtual bool GetScalar(const FeatureName& feature, CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Add or update a scalar feature
-     *
-     * \param feature        Must be a scalar feature
-     * \param primitive      The feature's driver primitive
-     *
-     * \return True if the feature was updated, false if the feature is
-     *         unchanged or failure occurs
-     */
-    virtual void AddScalar(
-      const FeatureName& feature,
-      const CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Add or update a scalar feature
+   *
+   * \param feature        Must be a scalar feature
+   * \param primitive      The feature's driver primitive
+   *
+   * \return True if the feature was updated, false if the feature is
+   *         unchanged or failure occurs
+   */
+  virtual void AddScalar(const FeatureName& feature, const CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Get an analog stick direction from the button map
-     *
-     * \param      feature   Must be an analog stick or this will return false
-     * \param      direction The direction whose primitive is to be retrieved
-     * \param[out] primitive The primitive mapped to the specified direction
-     *
-     * \return True if the feature and direction resolved to a driver primitive
-     */
-    virtual bool GetAnalogStick(
-      const FeatureName& feature,
-      ANALOG_STICK_DIRECTION direction,
-      CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Get an analog stick direction from the button map
+   *
+   * \param      feature   Must be an analog stick or this will return false
+   * \param      direction The direction whose primitive is to be retrieved
+   * \param[out] primitive The primitive mapped to the specified direction
+   *
+   * \return True if the feature and direction resolved to a driver primitive
+   */
+  virtual bool GetAnalogStick(const FeatureName& feature,
+                              ANALOG_STICK_DIRECTION direction,
+                              CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Add or update an analog stick direction
-     *
-     * \param feature   Must be an analog stick or this will return false
-     * \param direction The direction being mapped
-     * \param primitive The driver primitive for the specified analog stick and direction
-     *
-     * \return True if the analog stick was updated, false otherwise
-     */
-    virtual void AddAnalogStick(
-      const FeatureName& feature,
-      ANALOG_STICK_DIRECTION direction,
-      const CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Add or update an analog stick direction
+   *
+   * \param feature   Must be an analog stick or this will return false
+   * \param direction The direction being mapped
+   * \param primitive The driver primitive for the specified analog stick and direction
+   *
+   * \return True if the analog stick was updated, false otherwise
+   */
+  virtual void AddAnalogStick(const FeatureName& feature,
+                              ANALOG_STICK_DIRECTION direction,
+                              const CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Get a relative pointer direction from the button map
-     *
-     * \param      feature   Must be a relative pointer stick or this will return false
-     * \param      direction The direction whose primitive is to be retrieved
-     * \param[out] primitive The primitive mapped to the specified direction
-     *
-     * \return True if the feature and direction resolved to a driver primitive
-     */
-    virtual bool GetRelativePointer(
-      const FeatureName& feature,
-      RELATIVE_POINTER_DIRECTION direction,
-      CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Get a relative pointer direction from the button map
+   *
+   * \param      feature   Must be a relative pointer stick or this will return false
+   * \param      direction The direction whose primitive is to be retrieved
+   * \param[out] primitive The primitive mapped to the specified direction
+   *
+   * \return True if the feature and direction resolved to a driver primitive
+   */
+  virtual bool GetRelativePointer(const FeatureName& feature,
+                                  RELATIVE_POINTER_DIRECTION direction,
+                                  CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Add or update a relative pointer direction
-     *
-     * \param feature   Must be a relative pointer or this will return false
-     * \param direction The direction being mapped
-     * \param primitive The driver primitive for the specified analog stick and direction
-     *
-     * \return True if the analog stick was updated, false otherwise
-     */
-    virtual void AddRelativePointer(
-      const FeatureName& feature,
-      RELATIVE_POINTER_DIRECTION direction,
-      const CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Add or update a relative pointer direction
+   *
+   * \param feature   Must be a relative pointer or this will return false
+   * \param direction The direction being mapped
+   * \param primitive The driver primitive for the specified analog stick and direction
+   *
+   * \return True if the analog stick was updated, false otherwise
+   */
+  virtual void AddRelativePointer(const FeatureName& feature,
+                                  RELATIVE_POINTER_DIRECTION direction,
+                                  const CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Get an accelerometer from the button map
-     *
-     * \param feature       Must be an accelerometer or this will return false
-     * \param positiveX     The semiaxis mapped to the positive X direction (possibly unknown)
-     * \param positiveY     The semiaxis mapped to the positive Y direction (possibly unknown)
-     * \param positiveZ     The semiaxis mapped to the positive Z direction (possibly unknown)
-     *
-     * \return True if the feature resolved to an accelerometer with at least 1 known axis
-     */
-    virtual bool GetAccelerometer(
-      const FeatureName& feature,
-      CDriverPrimitive& positiveX,
-      CDriverPrimitive& positiveY,
-      CDriverPrimitive& positiveZ
-    ) = 0;
+  /*!
+   * \brief Get an accelerometer from the button map
+   *
+   * \param feature       Must be an accelerometer or this will return false
+   * \param positiveX     The semiaxis mapped to the positive X direction (possibly unknown)
+   * \param positiveY     The semiaxis mapped to the positive Y direction (possibly unknown)
+   * \param positiveZ     The semiaxis mapped to the positive Z direction (possibly unknown)
+   *
+   * \return True if the feature resolved to an accelerometer with at least 1 known axis
+   */
+  virtual bool GetAccelerometer(const FeatureName& feature,
+                                CDriverPrimitive& positiveX,
+                                CDriverPrimitive& positiveY,
+                                CDriverPrimitive& positiveZ) = 0;
 
-    /*!
-     * \brief Get or update an accelerometer
-     *
-     * \param feature       Must be an accelerometer or this will return false
-     * \param positiveX     The semiaxis corresponding to the positive X direction
-     * \param positiveY     The semiaxis corresponding to the positive Y direction
-     * \param positiveZ     The semiaxis corresponding to the positive Z direction
-     *
-     * The driver primitives must be mapped to a semiaxis or this function will fail.
-     *
-     * \return True if the accelerometer was updated, false if unchanged or failure occurred
-     */
-    virtual void AddAccelerometer(
-      const FeatureName& feature,
-      const CDriverPrimitive& positiveX,
-      const CDriverPrimitive& positiveY,
-      const CDriverPrimitive& positiveZ
-    ) = 0;
+  /*!
+   * \brief Get or update an accelerometer
+   *
+   * \param feature       Must be an accelerometer or this will return false
+   * \param positiveX     The semiaxis corresponding to the positive X direction
+   * \param positiveY     The semiaxis corresponding to the positive Y direction
+   * \param positiveZ     The semiaxis corresponding to the positive Z direction
+   *
+   * The driver primitives must be mapped to a semiaxis or this function will fail.
+   *
+   * \return True if the accelerometer was updated, false if unchanged or failure occurred
+   */
+  virtual void AddAccelerometer(const FeatureName& feature,
+                                const CDriverPrimitive& positiveX,
+                                const CDriverPrimitive& positiveY,
+                                const CDriverPrimitive& positiveZ) = 0;
 
-    /*!
-     * \brief Get a wheel direction from the button map
-     *
-     * \param      feature   Must be a wheel or this will return false
-     * \param      direction The direction whose primitive is to be retrieved
-     * \param[out] primitive The primitive mapped to the specified direction
-     *
-     * \return True if the feature and direction resolved to a driver primitive
-     */
-    virtual bool GetWheel(
-      const FeatureName& feature,
-      WHEEL_DIRECTION direction,
-      CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Get a wheel direction from the button map
+   *
+   * \param      feature   Must be a wheel or this will return false
+   * \param      direction The direction whose primitive is to be retrieved
+   * \param[out] primitive The primitive mapped to the specified direction
+   *
+   * \return True if the feature and direction resolved to a driver primitive
+   */
+  virtual bool GetWheel(const FeatureName& feature,
+                        WHEEL_DIRECTION direction,
+                        CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Add or update a wheel direction
-     *
-     * \param      feature   Must be a wheel or this will return false
-     * \param direction The direction being mapped
-     * \param primitive The driver primitive for the specified analog stick and direction
-     *
-     * \return True if the analog stick was updated, false otherwise
-     */
-    virtual void AddWheel(
-      const FeatureName& feature,
-      WHEEL_DIRECTION direction,
-      const CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Add or update a wheel direction
+   *
+   * \param      feature   Must be a wheel or this will return false
+   * \param direction The direction being mapped
+   * \param primitive The driver primitive for the specified analog stick and direction
+   *
+   * \return True if the analog stick was updated, false otherwise
+   */
+  virtual void AddWheel(const FeatureName& feature,
+                        WHEEL_DIRECTION direction,
+                        const CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Get a throttle direction from the button map
-     *
-     * \param      feature   Must be a throttle or this will return false
-     * \param      direction The direction whose primitive is to be retrieved
-     * \param[out] primitive The primitive mapped to the specified direction
-     *
-     * \return True if the feature and direction resolved to a driver primitive
-     */
-    virtual bool GetThrottle(
-      const FeatureName& feature,
-      THROTTLE_DIRECTION direction,
-      CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Get a throttle direction from the button map
+   *
+   * \param      feature   Must be a throttle or this will return false
+   * \param      direction The direction whose primitive is to be retrieved
+   * \param[out] primitive The primitive mapped to the specified direction
+   *
+   * \return True if the feature and direction resolved to a driver primitive
+   */
+  virtual bool GetThrottle(const FeatureName& feature,
+                           THROTTLE_DIRECTION direction,
+                           CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Add or update a throttle direction
-     *
-     * \param      feature   Must be a throttle or this will return false
-     * \param direction The direction being mapped
-     * \param primitive The driver primitive for the specified analog stick and direction
-     *
-     * \return True if the analog stick was updated, false otherwise
-     */
-    virtual void AddThrottle(
-      const FeatureName& feature,
-      THROTTLE_DIRECTION direction,
-      const CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Add or update a throttle direction
+   *
+   * \param      feature   Must be a throttle or this will return false
+   * \param direction The direction being mapped
+   * \param primitive The driver primitive for the specified analog stick and direction
+   *
+   * \return True if the analog stick was updated, false otherwise
+   */
+  virtual void AddThrottle(const FeatureName& feature,
+                           THROTTLE_DIRECTION direction,
+                           const CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Get the driver primitive for a keyboard key
-     *
-     * \param feature        Must be a key
-     * \param primitive      The resolved driver primitive
-     *
-     * \return True if the feature resolved to a driver primitive, false if the
-     *         feature didn't resolve or isn't a scalar feature
-     */
-    virtual bool GetKey(
-      const FeatureName& feature,
-      CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Get the driver primitive for a keyboard key
+   *
+   * \param feature        Must be a key
+   * \param primitive      The resolved driver primitive
+   *
+   * \return True if the feature resolved to a driver primitive, false if the
+   *         feature didn't resolve or isn't a scalar feature
+   */
+  virtual bool GetKey(const FeatureName& feature, CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Add or update a key
-     *
-     * \param feature        Must be a key
-     * \param primitive      The feature's driver primitive
-     *
-     * \return True if the feature was updated, false if the feature is
-     *         unchanged or failure occurs
-     */
-    virtual void AddKey(
-      const FeatureName& feature,
-      const CDriverPrimitive& primitive
-    ) = 0;
+  /*!
+   * \brief Add or update a key
+   *
+   * \param feature        Must be a key
+   * \param primitive      The feature's driver primitive
+   *
+   * \return True if the feature was updated, false if the feature is
+   *         unchanged or failure occurs
+   */
+  virtual void AddKey(const FeatureName& feature, const CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Set a list of driver primitives to be ignored
-     *
-     * This is necessary to prevent features from interfering with the button
-     * mapping process. This includes accelerometers, as well as PS4 triggers
-     * which send both a button press and an analog value.
-     *
-     * \param primitives      The driver primitives to be ignored
-     */
-    virtual void SetIgnoredPrimitives(const std::vector<CDriverPrimitive>& primitives) = 0;
+  /*!
+   * \brief Set a list of driver primitives to be ignored
+   *
+   * This is necessary to prevent features from interfering with the button
+   * mapping process. This includes accelerometers, as well as PS4 triggers
+   * which send both a button press and an analog value.
+   *
+   * \param primitives      The driver primitives to be ignored
+   */
+  virtual void SetIgnoredPrimitives(const std::vector<CDriverPrimitive>& primitives) = 0;
 
-    /*!
-     * \brief Check if a primitive is in the list of primitives to be ignored
-     *
-     * \param primitive      The primitive to check
-     *
-     * \return True if the primitive should be ignored in the mapping process
-     */
-    virtual bool IsIgnored(const CDriverPrimitive& primitive) = 0;
+  /*!
+   * \brief Check if a primitive is in the list of primitives to be ignored
+   *
+   * \param primitive      The primitive to check
+   *
+   * \return True if the primitive should be ignored in the mapping process
+   */
+  virtual bool IsIgnored(const CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Get the properties of an axis
-     *
-     * \param axisIndex The index of the axis to check
-     * \param center[out] The center, if known
-     * \param range[out] The range, if known
-     *
-     * \return True if the properties are known, false otherwise
-     */
-    virtual bool GetAxisProperties(unsigned int axisIndex, int& center, unsigned int& range) = 0;
+  /*!
+   * \brief Get the properties of an axis
+   *
+   * \param axisIndex The index of the axis to check
+   * \param center[out] The center, if known
+   * \param range[out] The range, if known
+   *
+   * \return True if the properties are known, false otherwise
+   */
+  virtual bool GetAxisProperties(unsigned int axisIndex, int& center, unsigned int& range) = 0;
 
-    /*!
-     * \brief Save the button map
-     */
-    virtual void SaveButtonMap() = 0;
+  /*!
+   * \brief Save the button map
+   */
+  virtual void SaveButtonMap() = 0;
 
-    /*!
-    * \brief Revert changes to the button map since the last time it was loaded
-    *        or commited to disk
-    */
-    virtual void RevertButtonMap() = 0;
-  };
-}
-}
+  /*!
+   * \brief Revert changes to the button map since the last time it was loaded
+   *        or commited to disk
+   */
+  virtual void RevertButtonMap() = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IButtonMapCallback.h b/xbmc/input/joysticks/interfaces/IButtonMapCallback.h
index ccf80e6b664e..40744f8a1f7b 100644
--- a/xbmc/input/joysticks/interfaces/IButtonMapCallback.h
+++ b/xbmc/input/joysticks/interfaces/IButtonMapCallback.h
@@ -12,36 +12,36 @@ namespace KODI
 {
 namespace JOYSTICK
 {
+/*!
+ * \brief Interface for handling button maps
+ */
+class IButtonMapCallback
+{
+public:
+  virtual ~IButtonMapCallback() = default;
+
   /*!
-   * \brief Interface for handling button maps
+   * \brief Save the button map
    */
-  class IButtonMapCallback
-  {
-  public:
-    virtual ~IButtonMapCallback() = default;
-
-    /*!
-     * \brief Save the button map
-     */
-    virtual void SaveButtonMap() = 0;
+  virtual void SaveButtonMap() = 0;
 
-    /*!
-     * \brief Clear the list of ignored driver primitives
-     *
-     * Called if the user begins capturing primitives to be ignored, and
-     * no primitives are captured before the dialog is accepted by the user.
-     *
-     * In this case, the button mapper won't have been given access to the
-     * button map, so a callback is needed to indicate that no primitives were
-     * captured and the user accepted this.
-     */
-    virtual void ResetIgnoredPrimitives() = 0;
+  /*!
+   * \brief Clear the list of ignored driver primitives
+   *
+   * Called if the user begins capturing primitives to be ignored, and
+   * no primitives are captured before the dialog is accepted by the user.
+   *
+   * In this case, the button mapper won't have been given access to the
+   * button map, so a callback is needed to indicate that no primitives were
+   * captured and the user accepted this.
+   */
+  virtual void ResetIgnoredPrimitives() = 0;
 
-    /*!
-     * \brief Revert changes to the button map since the last time it was loaded
-     *        or committed to disk
-     */
-    virtual void RevertButtonMap() = 0;
-  };
-}
-}
+  /*!
+   * \brief Revert changes to the button map since the last time it was loaded
+   *        or committed to disk
+   */
+  virtual void RevertButtonMap() = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IButtonMapper.h b/xbmc/input/joysticks/interfaces/IButtonMapper.h
index f948b364a0ca..1f5b796b64e8 100644
--- a/xbmc/input/joysticks/interfaces/IButtonMapper.h
+++ b/xbmc/input/joysticks/interfaces/IButtonMapper.h
@@ -19,101 +19,106 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class CDriverPrimitive;
-  class IButtonMap;
-  class IButtonMapCallback;
+class CDriverPrimitive;
+class IButtonMap;
+class IButtonMapCallback;
+
+/*!
+ * \ingroup joystick
+ * \brief Button mapper interface to assign the driver's raw button/hat/axis
+ *        elements to physical joystick features using a provided button map.
+ *
+ * \sa IButtonMap
+ */
+class IButtonMapper
+{
+public:
+  IButtonMapper() = default;
+
+  virtual ~IButtonMapper() = default;
 
   /*!
-   * \ingroup joystick
-   * \brief Button mapper interface to assign the driver's raw button/hat/axis
-   *        elements to physical joystick features using a provided button map.
+   * \brief The add-on ID of the game controller associated with this button mapper
    *
-   * \sa IButtonMap
+   * \return The ID of the add-on extending kodi.game.controller
    */
-  class IButtonMapper
-  {
-  public:
-    IButtonMapper() = default;
-
-    virtual ~IButtonMapper() = default;
+  virtual std::string ControllerID(void) const = 0;
 
-    /*!
-     * \brief The add-on ID of the game controller associated with this button mapper
-     *
-     * \return The ID of the add-on extending kodi.game.controller
-     */
-    virtual std::string ControllerID(void) const = 0;
-
-    /*!
-     * \brief Return true if the button mapper wants a cooldown between button
-     *        mapping commands
-     *
-     * \return True to only send button mapping commands that occur after a small
-     *         timeout from the previous command.
-     */
-    virtual bool NeedsCooldown(void) const = 0;
+  /*!
+   * \brief Return true if the button mapper wants a cooldown between button
+   *        mapping commands
+   *
+   * \return True to only send button mapping commands that occur after a small
+   *         timeout from the previous command.
+   */
+  virtual bool NeedsCooldown(void) const = 0;
 
-    /*!
-     * \brief Return true if the button mapper accepts primitives of the given type
-     *
-     * \param type The primitive type
-     *
-     * \return True if the button mapper can map the primitive type, false otherwise
-     */
-    virtual bool AcceptsPrimitive(PRIMITIVE_TYPE type) const = 0;
+  /*!
+   * \brief Return true if the button mapper accepts primitives of the given type
+   *
+   * \param type The primitive type
+   *
+   * \return True if the button mapper can map the primitive type, false otherwise
+   */
+  virtual bool AcceptsPrimitive(PRIMITIVE_TYPE type) const = 0;
 
-    /*!
-     * \brief Handle button/hat press or axis threshold
-     *
-     * \param buttonMap  The button map being manipulated
-     * \param keymap     An interface capable of translating features to Kodi actions
-     * \param primitive  The driver primitive
-     *
-     * Called in the same thread as \ref IButtonMapper::OnFrame.
-     *
-     * \return True if driver primitive was mapped to a feature
-     */
-    virtual bool MapPrimitive(IButtonMap* buttonMap, IKeymap* keyMap, const CDriverPrimitive& primitive) = 0;
+  /*!
+   * \brief Handle button/hat press or axis threshold
+   *
+   * \param buttonMap  The button map being manipulated
+   * \param keymap     An interface capable of translating features to Kodi actions
+   * \param primitive  The driver primitive
+   *
+   * Called in the same thread as \ref IButtonMapper::OnFrame.
+   *
+   * \return True if driver primitive was mapped to a feature
+   */
+  virtual bool MapPrimitive(IButtonMap* buttonMap,
+                            IKeymap* keyMap,
+                            const CDriverPrimitive& primitive) = 0;
 
-    /*!
-     * \brief Called once per event frame to notify the implementation of motion status
-     *
-     * \param buttonMap The button map passed to MapPrimitive() (shall not be modified)
-     * \param bMotion True if a previously-mapped axis is still in motion
-     *
-     * This allows the implementer to wait for an axis to be centered before
-     * allowing it to be used as Kodi input.
-     *
-     * If mapping finishes on an axis, then the axis will still be pressed and
-     * sending input every frame when the mapping ends. For example, when the
-     * right analog stick is the last feature to be mapped, it is still pressed
-     * when mapping ends and immediately sends Volume Down actions.
-     *
-     * The fix is to allow implementers to wait until all axes are motionless
-     * before detaching themselves.
-     *
-     * Called in the same thread as \ref IButtonMapper::MapPrimitive.
-     */
-    virtual void OnEventFrame(const IButtonMap* buttonMap, bool bMotion) = 0;
+  /*!
+   * \brief Called once per event frame to notify the implementation of motion status
+   *
+   * \param buttonMap The button map passed to MapPrimitive() (shall not be modified)
+   * \param bMotion True if a previously-mapped axis is still in motion
+   *
+   * This allows the implementer to wait for an axis to be centered before
+   * allowing it to be used as Kodi input.
+   *
+   * If mapping finishes on an axis, then the axis will still be pressed and
+   * sending input every frame when the mapping ends. For example, when the
+   * right analog stick is the last feature to be mapped, it is still pressed
+   * when mapping ends and immediately sends Volume Down actions.
+   *
+   * The fix is to allow implementers to wait until all axes are motionless
+   * before detaching themselves.
+   *
+   * Called in the same thread as \ref IButtonMapper::MapPrimitive.
+   */
+  virtual void OnEventFrame(const IButtonMap* buttonMap, bool bMotion) = 0;
 
-    /*!
-     * \brief Called when an axis has been detected after mapping began
-     *
-     * \param axisIndex The index of the axis being discovered
-     *
-     * Some joystick drivers don't report an initial value for analog axes.
-     *
-     * Called in the same thread as \ref IButtonMapper::MapPrimitive.
-     */
-    virtual void OnLateAxis(const IButtonMap* buttonMap, unsigned int axisIndex) = 0;
+  /*!
+   * \brief Called when an axis has been detected after mapping began
+   *
+   * \param axisIndex The index of the axis being discovered
+   *
+   * Some joystick drivers don't report an initial value for analog axes.
+   *
+   * Called in the same thread as \ref IButtonMapper::MapPrimitive.
+   */
+  virtual void OnLateAxis(const IButtonMap* buttonMap, unsigned int axisIndex) = 0;
 
-    // Button map callback interface
-    void SetButtonMapCallback(const std::string& deviceName, IButtonMapCallback* callback) { m_callbacks[deviceName] = callback; }
-    void ResetButtonMapCallbacks(void) { m_callbacks.clear(); }
-    std::map<std::string, IButtonMapCallback*>& ButtonMapCallbacks(void) { return m_callbacks; }
+  // Button map callback interface
+  void SetButtonMapCallback(const std::string& deviceName, IButtonMapCallback* callback)
+  {
+    m_callbacks[deviceName] = callback;
+  }
+  void ResetButtonMapCallbacks(void) { m_callbacks.clear(); }
+  std::map<std::string, IButtonMapCallback*>& ButtonMapCallbacks(void) { return m_callbacks; }
 
-  private:
-    std::map<std::string, IButtonMapCallback*> m_callbacks;
-  };
-}
-}
+private:
+  std::map<std::string, IButtonMapCallback*> m_callbacks;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IButtonSequence.h b/xbmc/input/joysticks/interfaces/IButtonSequence.h
index ce5a2298370a..5c642e6ed928 100644
--- a/xbmc/input/joysticks/interfaces/IButtonSequence.h
+++ b/xbmc/input/joysticks/interfaces/IButtonSequence.h
@@ -14,18 +14,18 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IButtonSequence
-  {
-  public:
-    virtual ~IButtonSequence() = default;
+class IButtonSequence
+{
+public:
+  virtual ~IButtonSequence() = default;
 
-    virtual bool OnButtonPress(const FeatureName& feature) = 0;
+  virtual bool OnButtonPress(const FeatureName& feature) = 0;
 
-    /*!
-     * \brief Returns true if a sequence is being captured to prevent input
-     *        from falling through to the application
-     */
-    virtual bool IsCapturing() = 0;
-  };
-}
-}
+  /*!
+   * \brief Returns true if a sequence is being captured to prevent input
+   *        from falling through to the application
+   */
+  virtual bool IsCapturing() = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IDriverHandler.h b/xbmc/input/joysticks/interfaces/IDriverHandler.h
index 9a78e0a59103..42529f4a7c40 100644
--- a/xbmc/input/joysticks/interfaces/IDriverHandler.h
+++ b/xbmc/input/joysticks/interfaces/IDriverHandler.h
@@ -14,61 +14,64 @@ namespace KODI
 {
 namespace JOYSTICK
 {
+/*!
+ * \brief Interface defining methods to handle joystick events for raw driver
+ *        elements (buttons, hats, axes)
+ */
+class IDriverHandler
+{
+public:
+  virtual ~IDriverHandler() = default;
+
   /*!
-   * \brief Interface defining methods to handle joystick events for raw driver
-   *        elements (buttons, hats, axes)
+   * \brief Handle button motion
+   *
+   * \param buttonIndex The index of the button as reported by the driver
+   * \param bPressed    true for press motion, false for release motion
+   *
+   * \return True if a press was handled, false otherwise
    */
-  class IDriverHandler
-  {
-  public:
-    virtual ~IDriverHandler() = default;
+  virtual bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) = 0;
 
-    /*!
-     * \brief Handle button motion
-     *
-     * \param buttonIndex The index of the button as reported by the driver
-     * \param bPressed    true for press motion, false for release motion
-     *
-     * \return True if a press was handled, false otherwise
-     */
-    virtual bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) = 0;
-
-    /*!
-     * \brief Handle hat motion
-     *
-     * \param hatIndex     The index of the hat as reported by the driver
-     * \param state        The direction the hat is now being pressed
-     *
-     * \return True if the new direction was handled, false otherwise
-     */
-    virtual bool OnHatMotion(unsigned int hatIndex, HAT_STATE state) = 0;
+  /*!
+   * \brief Handle hat motion
+   *
+   * \param hatIndex     The index of the hat as reported by the driver
+   * \param state        The direction the hat is now being pressed
+   *
+   * \return True if the new direction was handled, false otherwise
+   */
+  virtual bool OnHatMotion(unsigned int hatIndex, HAT_STATE state) = 0;
 
-    /*!
-     * \brief Handle axis motion
-     *
-     * If a joystick feature requires multiple axes (analog sticks, accelerometers),
-     * they can be buffered for later processing.
-     *
-     * \param axisIndex   The index of the axis as reported by the driver
-     * \param position    The position of the axis in the closed interval [-1.0, 1.0]
-     * \param center      The center point of the axis (either -1, 0 or 1)
-     * \param range       The maximum distance the axis can move (either 1 or 2)
-     *
-     * \return True if the motion was handled, false otherwise
-     */
-    virtual bool OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range) = 0;
+  /*!
+   * \brief Handle axis motion
+   *
+   * If a joystick feature requires multiple axes (analog sticks, accelerometers),
+   * they can be buffered for later processing.
+   *
+   * \param axisIndex   The index of the axis as reported by the driver
+   * \param position    The position of the axis in the closed interval [-1.0, 1.0]
+   * \param center      The center point of the axis (either -1, 0 or 1)
+   * \param range       The maximum distance the axis can move (either 1 or 2)
+   *
+   * \return True if the motion was handled, false otherwise
+   */
+  virtual bool OnAxisMotion(unsigned int axisIndex,
+                            float position,
+                            int center,
+                            unsigned int range) = 0;
 
-    /*!
-     * \brief Handle buffered axis positions for features that require multiple axes
-     *
-     * ProcessAxisMotions() is called at the end of the frame when all axis motions
-     * have been reported. This has several uses, including:
-     *
-     *  - Combining multiple axes into a single analog stick or accelerometer event
-     *  - Imitating an analog feature with a digital button so that events can be
-     *    dispatched every frame.
-     */
-    virtual void ProcessAxisMotions(void) = 0;
-  };
-}
-}
+  /*!
+   * \brief Handle buffered axis positions for features that require multiple axes
+   *
+   * ProcessAxisMotions() is called at the end of the frame when all axis motions
+   * have been reported. This has several uses, including:
+   *
+   *  - Combining multiple axes into a single analog stick or accelerometer event
+   *  - Imitating an analog feature with a digital button so that events can be
+   *    dispatched every frame.
+   */
+  virtual void ProcessAxisMotions(void) = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IDriverReceiver.h b/xbmc/input/joysticks/interfaces/IDriverReceiver.h
index 586eaa884ca1..2a4ff6c03912 100644
--- a/xbmc/input/joysticks/interfaces/IDriverReceiver.h
+++ b/xbmc/input/joysticks/interfaces/IDriverReceiver.h
@@ -12,24 +12,24 @@ namespace KODI
 {
 namespace JOYSTICK
 {
+/*!
+ * \ingroup joystick
+ * \brief Interface for sending input events to joystick drivers
+ */
+class IDriverReceiver
+{
+public:
+  virtual ~IDriverReceiver() = default;
+
   /*!
-   * \ingroup joystick
-   * \brief Interface for sending input events to joystick drivers
+   * \brief Set the value of a rumble motor
+   *
+   * \param motorIndex   The driver index of the motor to rumble
+   * \param magnitude    The motor's new magnitude of vibration in the closed interval [0, 1]
+   *
+   * \return True if the event was handled otherwise false
    */
-  class IDriverReceiver
-  {
-  public:
-    virtual ~IDriverReceiver() = default;
-
-    /*!
-     * \brief Set the value of a rumble motor
-     *
-     * \param motorIndex   The driver index of the motor to rumble
-     * \param magnitude    The motor's new magnitude of vibration in the closed interval [0, 1]
-     *
-     * \return True if the event was handled otherwise false
-     */
-    virtual bool SetMotorState(unsigned int motorIndex, float magnitude) = 0;
-  };
-}
-}
+  virtual bool SetMotorState(unsigned int motorIndex, float magnitude) = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IInputHandler.h b/xbmc/input/joysticks/interfaces/IInputHandler.h
index a7642e9e39cd..45bf721dff8c 100644
--- a/xbmc/input/joysticks/interfaces/IInputHandler.h
+++ b/xbmc/input/joysticks/interfaces/IInputHandler.h
@@ -16,137 +16,149 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IInputReceiver;
+class IInputReceiver;
+
+/*!
+ * \ingroup joystick
+ * \brief Interface for handling input events for game controllers
+ */
+class IInputHandler
+{
+public:
+  virtual ~IInputHandler() = default;
+
+  /*!
+   * \brief The add-on ID of the game controller associated with this input handler
+   *
+   * \return The ID of the add-on extending kodi.game.controller
+   */
+  virtual std::string ControllerID(void) const = 0;
+
+  /*!
+   * \brief Return true if the input handler accepts the given feature
+   *
+   * \param feature A feature belonging to the controller specified by ControllerID()
+   *
+   * \return True if the feature is used for input, false otherwise
+   */
+  virtual bool HasFeature(const FeatureName& feature) const = 0;
+
+  /*!
+   * \brief Return true if the input handler is currently accepting input for the
+   *        given feature
+   *
+   * \param feature A feature belonging to the controller specified by ControllerID()
+   *
+   * \return True if the feature is currently accepting input, false otherwise
+   *
+   * This does not prevent the input events from being called, but can return
+   * false to indicate that input wasn't handled for the specified feature.
+   */
+  virtual bool AcceptsInput(const FeatureName& feature) const = 0;
+
+  /*!
+   * \brief A digital button has been pressed or released
+   *
+   * \param feature      The feature being pressed
+   * \param bPressed     True if pressed, false if released
+   *
+   * \return True if the event was handled otherwise false
+   */
+  virtual bool OnButtonPress(const FeatureName& feature, bool bPressed) = 0;
 
   /*!
-   * \ingroup joystick
-   * \brief Interface for handling input events for game controllers
+   * \brief A digital button has been pressed for more than one event frame
+   *
+   * \param feature      The feature being held
+   * \param holdTimeMs   The time elapsed since the initial press (ms)
+   *
+   * If OnButtonPress() returns true for the initial press, then this callback
+   * is invoked on subsequent frames until the button is released.
    */
-  class IInputHandler
+  virtual void OnButtonHold(const FeatureName& feature, unsigned int holdTimeMs) = 0;
+
+  /*!
+   * \brief An analog button (trigger or a pressure-sensitive button) has changed state
+   *
+   * \param feature      The feature changing state
+   * \param magnitude    The button pressure or trigger travel distance in the
+   *                     closed interval [0, 1]
+   * \param motionTimeMs The time elapsed since the magnitude was 0
+   *
+   * \return True if the event was handled otherwise false
+   */
+  virtual bool OnButtonMotion(const FeatureName& feature,
+                              float magnitude,
+                              unsigned int motionTimeMs) = 0;
+
+  /*!
+   * \brief An analog stick has moved
+   *
+   * \param feature      The analog stick being moved
+   * \param x            The x coordinate in the closed interval [-1, 1]
+   * \param y            The y coordinate in the closed interval [-1, 1]
+   * \param motionTimeMs The time elapsed since this analog stick was centered,
+   *                     or 0 if the analog stick is centered
+   *
+   * \return True if the event was handled otherwise false
+   */
+  virtual bool OnAnalogStickMotion(const FeatureName& feature,
+                                   float x,
+                                   float y,
+                                   unsigned int motionTimeMs) = 0;
+
+  /*!
+   * \brief An accelerometer's state has changed
+   *
+   * \param feature      The accelerometer being accelerated
+   * \param x            The x coordinate in the closed interval [-1, 1]
+   * \param y            The y coordinate in the closed interval [-1, 1]
+   * \param z            The z coordinate in the closed interval [-1, 1]
+   *
+   * \return True if the event was handled otherwise false
+   */
+  virtual bool OnAccelerometerMotion(const FeatureName& feature, float x, float y, float z)
   {
-  public:
-    virtual ~IInputHandler() = default;
-
-    /*!
-     * \brief The add-on ID of the game controller associated with this input handler
-     *
-     * \return The ID of the add-on extending kodi.game.controller
-     */
-    virtual std::string ControllerID(void) const = 0;
-
-    /*!
-     * \brief Return true if the input handler accepts the given feature
-     *
-     * \param feature A feature belonging to the controller specified by ControllerID()
-     *
-     * \return True if the feature is used for input, false otherwise
-     */
-    virtual bool HasFeature(const FeatureName& feature) const = 0;
-
-    /*!
-     * \brief Return true if the input handler is currently accepting input for the
-     *        given feature
-     *
-     * \param feature A feature belonging to the controller specified by ControllerID()
-     *
-     * \return True if the feature is currently accepting input, false otherwise
-     *
-     * This does not prevent the input events from being called, but can return
-     * false to indicate that input wasn't handled for the specified feature.
-     */
-    virtual bool AcceptsInput(const FeatureName &feature) const = 0;
-
-    /*!
-     * \brief A digital button has been pressed or released
-     *
-     * \param feature      The feature being pressed
-     * \param bPressed     True if pressed, false if released
-     *
-     * \return True if the event was handled otherwise false
-     */
-    virtual bool OnButtonPress(const FeatureName& feature, bool bPressed) = 0;
-
-    /*!
-     * \brief A digital button has been pressed for more than one event frame
-     *
-     * \param feature      The feature being held
-     * \param holdTimeMs   The time elapsed since the initial press (ms)
-     *
-     * If OnButtonPress() returns true for the initial press, then this callback
-     * is invoked on subsequent frames until the button is released.
-     */
-    virtual void OnButtonHold(const FeatureName& feature, unsigned int holdTimeMs) = 0;
-
-    /*!
-     * \brief An analog button (trigger or a pressure-sensitive button) has changed state
-     *
-     * \param feature      The feature changing state
-     * \param magnitude    The button pressure or trigger travel distance in the
-     *                     closed interval [0, 1]
-     * \param motionTimeMs The time elapsed since the magnitude was 0
-     *
-     * \return True if the event was handled otherwise false
-     */
-    virtual bool OnButtonMotion(const FeatureName& feature, float magnitude, unsigned int motionTimeMs) = 0;
-
-    /*!
-     * \brief An analog stick has moved
-     *
-     * \param feature      The analog stick being moved
-     * \param x            The x coordinate in the closed interval [-1, 1]
-     * \param y            The y coordinate in the closed interval [-1, 1]
-     * \param motionTimeMs The time elapsed since this analog stick was centered,
-     *                     or 0 if the analog stick is centered
-     *
-     * \return True if the event was handled otherwise false
-     */
-    virtual bool OnAnalogStickMotion(const FeatureName& feature, float x, float y, unsigned int motionTimeMs) = 0;
-
-    /*!
-     * \brief An accelerometer's state has changed
-     *
-     * \param feature      The accelerometer being accelerated
-     * \param x            The x coordinate in the closed interval [-1, 1]
-     * \param y            The y coordinate in the closed interval [-1, 1]
-     * \param z            The z coordinate in the closed interval [-1, 1]
-     *
-     * \return True if the event was handled otherwise false
-     */
-    virtual bool OnAccelerometerMotion(const FeatureName& feature, float x, float y, float z) { return false; }
-
-    /*!
-     * \brief A wheel has changed state
-     *
-     * Left is negative position, right is positive position
-     *
-     * \param feature      The wheel changing state
-     * \param position     The position in the closed interval [-1, 1]
-     * \param motionTimeMs The time elapsed since the position was 0
-     *
-     * \return True if the event was handled otherwise false
-     */
-    virtual bool OnWheelMotion(const FeatureName& feature, float position, unsigned int motionTimeMs) = 0;
-
-    /*!
-     * \brief A throttle has changed state
-     *
-     * Up is positive position, down is negative position.
-     *
-     * \param feature      The wheel changing state
-     * \param position     The position in the closed interval [-1, 1]
-     * \param motionTimeMs The time elapsed since the position was 0
-     *
-     * \return True if the event was handled otherwise false
-     */
-    virtual bool OnThrottleMotion(const FeatureName& feature, float position, unsigned int motionTimeMs) = 0;
-
-    // Input receiver interface
-    void SetInputReceiver(IInputReceiver* receiver) { m_receiver = receiver; }
-    void ResetInputReceiver(void) { m_receiver = nullptr; }
-    IInputReceiver* InputReceiver(void) { return m_receiver; }
-
-  private:
-    IInputReceiver* m_receiver = nullptr;
-  };
-}
-}
+    return false;
+  }
+
+  /*!
+   * \brief A wheel has changed state
+   *
+   * Left is negative position, right is positive position
+   *
+   * \param feature      The wheel changing state
+   * \param position     The position in the closed interval [-1, 1]
+   * \param motionTimeMs The time elapsed since the position was 0
+   *
+   * \return True if the event was handled otherwise false
+   */
+  virtual bool OnWheelMotion(const FeatureName& feature,
+                             float position,
+                             unsigned int motionTimeMs) = 0;
+
+  /*!
+   * \brief A throttle has changed state
+   *
+   * Up is positive position, down is negative position.
+   *
+   * \param feature      The wheel changing state
+   * \param position     The position in the closed interval [-1, 1]
+   * \param motionTimeMs The time elapsed since the position was 0
+   *
+   * \return True if the event was handled otherwise false
+   */
+  virtual bool OnThrottleMotion(const FeatureName& feature,
+                                float position,
+                                unsigned int motionTimeMs) = 0;
+
+  // Input receiver interface
+  void SetInputReceiver(IInputReceiver* receiver) { m_receiver = receiver; }
+  void ResetInputReceiver(void) { m_receiver = nullptr; }
+  IInputReceiver* InputReceiver(void) { return m_receiver; }
+
+private:
+  IInputReceiver* m_receiver = nullptr;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IInputProvider.h b/xbmc/input/joysticks/interfaces/IInputProvider.h
index 2d51179f0d54..09a036634828 100644
--- a/xbmc/input/joysticks/interfaces/IInputProvider.h
+++ b/xbmc/input/joysticks/interfaces/IInputProvider.h
@@ -12,32 +12,32 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IInputHandler;
+class IInputHandler;
+
+/*!
+ * \ingroup joystick
+ * \brief Interface for classes that can provide input
+ */
+class IInputProvider
+{
+public:
+  virtual ~IInputProvider() = default;
 
   /*!
-   * \ingroup joystick
-   * \brief Interface for classes that can provide input
+   * \brief Register a handler for the provided input
+   *
+   * \param handler The handler to receive input provided by this class
+   * \param bPromiscuous  If true, receives all input (including handled input)
+   *                      in the background
    */
-  class IInputProvider
-  {
-  public:
-    virtual ~IInputProvider() = default;
+  virtual void RegisterInputHandler(IInputHandler* handler, bool bPromiscuous) = 0;
 
-    /*!
-     * \brief Register a handler for the provided input
-     *
-     * \param handler The handler to receive input provided by this class
-     * \param bPromiscuous  If true, receives all input (including handled input)
-     *                      in the background
-     */
-    virtual void RegisterInputHandler(IInputHandler* handler, bool bPromiscuous) = 0;
-
-    /*!
-     * \brief Unregister a handler
-     *
-     * \param handler The handler that was receiving input
-     */
-    virtual void UnregisterInputHandler(IInputHandler* handler) = 0;
-  };
-}
-}
+  /*!
+   * \brief Unregister a handler
+   *
+   * \param handler The handler that was receiving input
+   */
+  virtual void UnregisterInputHandler(IInputHandler* handler) = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IInputReceiver.h b/xbmc/input/joysticks/interfaces/IInputReceiver.h
index 1d716d0557d4..400da3fba0e4 100644
--- a/xbmc/input/joysticks/interfaces/IInputReceiver.h
+++ b/xbmc/input/joysticks/interfaces/IInputReceiver.h
@@ -14,24 +14,24 @@ namespace KODI
 {
 namespace JOYSTICK
 {
+/*!
+ * \ingroup joystick
+ * \brief Interface for sending input events to game controllers
+ */
+class IInputReceiver
+{
+public:
+  virtual ~IInputReceiver() = default;
+
   /*!
-   * \ingroup joystick
-   * \brief Interface for sending input events to game controllers
+   * \brief Set the value of a rumble motor
+   *
+   * \param feature      The name of the motor to rumble
+   * \param magnitude    The motor's new magnitude of vibration in the closed interval [0, 1]
+   *
+   * \return True if the event was handled otherwise false
    */
-  class IInputReceiver
-  {
-  public:
-    virtual ~IInputReceiver() = default;
-
-    /*!
-     * \brief Set the value of a rumble motor
-     *
-     * \param feature      The name of the motor to rumble
-     * \param magnitude    The motor's new magnitude of vibration in the closed interval [0, 1]
-     *
-     * \return True if the event was handled otherwise false
-     */
-    virtual bool SetRumbleState(const FeatureName& feature, float magnitude) = 0;
-  };
-}
-}
+  virtual bool SetRumbleState(const FeatureName& feature, float magnitude) = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IKeyHandler.h b/xbmc/input/joysticks/interfaces/IKeyHandler.h
index 2858c328f74e..30f49c50f37e 100644
--- a/xbmc/input/joysticks/interfaces/IKeyHandler.h
+++ b/xbmc/input/joysticks/interfaces/IKeyHandler.h
@@ -12,45 +12,45 @@ namespace KODI
 {
 namespace JOYSTICK
 {
+/*!
+ * \ingroup joystick
+ * \brief Interface for handling keymap keys
+ *
+ * Keys can be mapped to analog actions (e.g. "AnalogSeekForward") or digital
+ * actions (e.g. "Up").
+ */
+class IKeyHandler
+{
+public:
+  virtual ~IKeyHandler() = default;
+
   /*!
-   * \ingroup joystick
-   * \brief Interface for handling keymap keys
+   * \brief Return true if the key is "pressed" (has a magnitude greater
+   *        than 0.5)
    *
-   * Keys can be mapped to analog actions (e.g. "AnalogSeekForward") or digital
-   * actions (e.g. "Up").
+   * \return True if the key is "pressed", false otherwise
    */
-  class IKeyHandler
-  {
-  public:
-    virtual ~IKeyHandler() = default;
+  virtual bool IsPressed() const = 0;
 
-    /*!
-     * \brief Return true if the key is "pressed" (has a magnitude greater
-     *        than 0.5)
-     *
-     * \return True if the key is "pressed", false otherwise
-     */
-    virtual bool IsPressed() const = 0;
-
-    /*!
-     * \brief A key mapped to a digital feature has been pressed or released
-     *
-     * \param bPressed   true if the key's button/axis is activated, false if deactivated
-     * \param holdTimeMs The held time in ms for pressed buttons, or 0 for released
-     *
-     * \return True if the key is mapped to an action, false otherwise
-     */
-    virtual bool OnDigitalMotion(bool bPressed, unsigned int holdTimeMs) = 0;
+  /*!
+   * \brief A key mapped to a digital feature has been pressed or released
+   *
+   * \param bPressed   true if the key's button/axis is activated, false if deactivated
+   * \param holdTimeMs The held time in ms for pressed buttons, or 0 for released
+   *
+   * \return True if the key is mapped to an action, false otherwise
+   */
+  virtual bool OnDigitalMotion(bool bPressed, unsigned int holdTimeMs) = 0;
 
-    /*!
-     * \brief Callback for keys mapped to analog features
-     *
-     * \param magnitude     The amount of the analog action
-     * \param motionTimeMs  The time since the magnitude was 0
-     *
-     * \return True if the key is mapped to an action, false otherwise
-     */
-    virtual bool OnAnalogMotion(float magnitude, unsigned int motionTimeMs) = 0;
-  };
-}
-}
+  /*!
+   * \brief Callback for keys mapped to analog features
+   *
+   * \param magnitude     The amount of the analog action
+   * \param motionTimeMs  The time since the magnitude was 0
+   *
+   * \return True if the key is mapped to an action, false otherwise
+   */
+  virtual bool OnAnalogMotion(float magnitude, unsigned int motionTimeMs) = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/interfaces/IKeymapHandler.h b/xbmc/input/joysticks/interfaces/IKeymapHandler.h
index 00e3e0a01881..f0af427cde12 100644
--- a/xbmc/input/joysticks/interfaces/IKeymapHandler.h
+++ b/xbmc/input/joysticks/interfaces/IKeymapHandler.h
@@ -15,38 +15,38 @@ namespace KODI
 {
 namespace JOYSTICK
 {
+/*!
+ * \ingroup joystick
+ * \brief Interface for a class working with a keymap
+ */
+class IKeymapHandler
+{
+public:
+  virtual ~IKeymapHandler() = default;
+
   /*!
-   * \ingroup joystick
-   * \brief Interface for a class working with a keymap
+   * \brief Get the pressed state of the given keys
+   *
+   * \param keyNames The key names
+   *
+   * \return True if all keys are pressed or no keys are given, false otherwise
    */
-  class IKeymapHandler
-  {
-  public:
-    virtual ~IKeymapHandler() = default;
-
-    /*!
-     * \brief Get the pressed state of the given keys
-     *
-     * \param keyNames The key names
-     *
-     * \return True if all keys are pressed or no keys are given, false otherwise
-     */
-    virtual bool HotkeysPressed(const std::set<std::string> &keyNames) const = 0;
+  virtual bool HotkeysPressed(const std::set<std::string>& keyNames) const = 0;
 
-    /*!
-     * \brief Get the key name of the last button pressed
-     *
-     * \return The key name of the last-pressed button, or empty if no button
-     *         is pressed
-     */
-    virtual std::string GetLastPressed() const = 0;
+  /*!
+   * \brief Get the key name of the last button pressed
+   *
+   * \return The key name of the last-pressed button, or empty if no button
+   *         is pressed
+   */
+  virtual std::string GetLastPressed() const = 0;
 
-    /*!
-     * \brief Called when a key has emitted an action after bring pressed
-     *
-     * \param keyName the key name that emitted the action
-     */
-    virtual void OnPress(const std::string& keyName) = 0;
-  };
-}
-}
+  /*!
+   * \brief Called when a key has emitted an action after bring pressed
+   *
+   * \param keyName the key name that emitted the action
+   */
+  virtual void OnPress(const std::string& keyName) = 0;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/keymaps/KeyHandler.cpp b/xbmc/input/joysticks/keymaps/KeyHandler.cpp
index f80dc3488bf2..5df45e2c236b 100644
--- a/xbmc/input/joysticks/keymaps/KeyHandler.cpp
+++ b/xbmc/input/joysticks/keymaps/KeyHandler.cpp
@@ -21,16 +21,19 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-#define DIGITAL_ANALOG_THRESHOLD  0.5f
-
-#define HOLD_TIMEOUT_MS     500
-#define REPEAT_TIMEOUT_MS   50
-
-CKeyHandler::CKeyHandler(const std::string &keyName, IActionListener *actionHandler, const IKeymap *keymap, IKeymapHandler *keymapHandler) :
-  m_keyName(keyName),
-  m_actionHandler(actionHandler),
-  m_keymap(keymap),
-  m_keymapHandler(keymapHandler)
+#define DIGITAL_ANALOG_THRESHOLD 0.5f
+
+#define HOLD_TIMEOUT_MS 500
+#define REPEAT_TIMEOUT_MS 50
+
+CKeyHandler::CKeyHandler(const std::string& keyName,
+                         IActionListener* actionHandler,
+                         const IKeymap* keymap,
+                         IKeymapHandler* keymapHandler)
+  : m_keyName(keyName),
+    m_actionHandler(actionHandler),
+    m_keymap(keymap),
+    m_keymapHandler(keymapHandler)
 {
   assert(m_actionHandler != nullptr);
   assert(m_keymap != nullptr);
@@ -63,9 +66,9 @@ bool CKeyHandler::OnAnalogMotion(float magnitude, unsigned int motionTimeMs)
     return false;
 
   // Get actions for the key
-  const auto &actionGroup = m_keymap->GetActions(m_keyName);
+  const auto& actionGroup = m_keymap->GetActions(m_keyName);
   const int windowId = actionGroup.windowId;
-  const auto &actions = actionGroup.actions;
+  const auto& actions = actionGroup.actions;
 
   // Calculate press state
   const bool bPressed = IsPressed(magnitude);
@@ -92,20 +95,21 @@ bool CKeyHandler::OnAnalogMotion(float magnitude, unsigned int motionTimeMs)
   // Give priority to actions with hotkeys
   std::vector<const KeymapAction*> actionsWithHotkeys;
 
-  for (const auto &action : actions)
+  for (const auto& action : actions)
   {
     if (!action.hotkeys.empty())
       actionsWithHotkeys.emplace_back(&action);
   }
 
-  CAction dispatchAction = ProcessActions(std::move(actionsWithHotkeys), windowId, magnitude, holdTimeMs);
+  CAction dispatchAction =
+      ProcessActions(std::move(actionsWithHotkeys), windowId, magnitude, holdTimeMs);
 
   // If that failed, try again with all actions
   if (dispatchAction.GetID() == ACTION_NONE)
   {
     std::vector<const KeymapAction*> allActions;
 
-    for (const auto &action : actions)
+    for (const auto& action : actions)
       allActions.emplace_back(&action);
 
     dispatchAction = ProcessActions(std::move(allActions), windowId, magnitude, holdTimeMs);
@@ -137,16 +141,19 @@ bool CKeyHandler::OnAnalogMotion(float magnitude, unsigned int motionTimeMs)
   return bHandled;
 }
 
-CAction CKeyHandler::ProcessActions(std::vector<const KeymapAction*> actions, int windowId, float magnitude, unsigned int holdTimeMs)
+CAction CKeyHandler::ProcessActions(std::vector<const KeymapAction*> actions,
+                                    int windowId,
+                                    float magnitude,
+                                    unsigned int holdTimeMs)
 {
   CAction dispatchAction;
 
   // Filter out actions without pressed hotkeys
   actions.erase(std::remove_if(actions.begin(), actions.end(),
-    [this](const KeymapAction *action)
-    {
-      return !m_keymapHandler->HotkeysPressed(action->hotkeys);
-    }), actions.end());
+                               [this](const KeymapAction* action) {
+                                 return !m_keymapHandler->HotkeysPressed(action->hotkeys);
+                               }),
+                actions.end());
 
   if (actions.empty())
     return false;
@@ -197,9 +204,9 @@ CAction CKeyHandler::ProcessRelease(std::vector<const KeymapAction*> actions, in
   const unsigned int holdTimeMs = m_lastHoldTimeMs;
 
   // Send an action on release if one occurs before the holdtime
-  for (auto it = actions.begin(); it != actions.end(); )
+  for (auto it = actions.begin(); it != actions.end();)
   {
-    const KeymapAction &action = **it;
+    const KeymapAction& action = **it;
 
     unsigned int thisHoldTime = (*it)->holdTimeMs;
 
@@ -219,7 +226,10 @@ CAction CKeyHandler::ProcessRelease(std::vector<const KeymapAction*> actions, in
   return dispatchAction;
 }
 
-CAction CKeyHandler::ProcessAction(const KeymapAction& action, int windowId, float magnitude, unsigned int holdTimeMs)
+CAction CKeyHandler::ProcessAction(const KeymapAction& action,
+                                   int windowId,
+                                   float magnitude,
+                                   unsigned int holdTimeMs)
 {
   CAction dispatchAction;
 
diff --git a/xbmc/input/joysticks/keymaps/KeyHandler.h b/xbmc/input/joysticks/keymaps/KeyHandler.h
index 4847e48f86f2..3b5a46cf0641 100644
--- a/xbmc/input/joysticks/keymaps/KeyHandler.h
+++ b/xbmc/input/joysticks/keymaps/KeyHandler.h
@@ -24,82 +24,91 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IKeymapHandler;
+class IKeymapHandler;
+
+/*!
+ * \ingroup joystick
+ * \brief
+ */
+class CKeyHandler : public IKeyHandler
+{
+public:
+  CKeyHandler(const std::string& keyName,
+              IActionListener* actionHandler,
+              const IKeymap* keymap,
+              IKeymapHandler* keymapHandler);
+
+  ~CKeyHandler() override = default;
+
+  // implementation of IKeyHandler
+  bool IsPressed() const override { return m_bHeld; }
+  bool OnDigitalMotion(bool bPressed, unsigned int holdTimeMs) override;
+  bool OnAnalogMotion(float magnitude, unsigned int motionTimeMs) override;
+
+private:
+  void Reset();
+
+  /*!
+   * \brief Process actions to see if an action should be dispatched
+   *
+   * \param actions All actions from the keymap defined for the current window
+   * \param windowId The current window ID
+   * \param magnitude The magnitude or distance of the feature being handled
+   * \param holdTimeMs The time which the feature has been past the hold threshold
+   *
+   * \return The action to dispatch, or action with ID ACTION_NONE if no action should be dispatched
+   */
+  CAction ProcessActions(std::vector<const KeymapAction*> actions,
+                         int windowId,
+                         float magnitude,
+                         unsigned int holdTimeMs);
+
+  /*!
+   * \brief Process actions after release event to see if an action should be dispatched
+   *
+   * \param actions All actions from the keymap defined for the current window
+   * \param windowId The current window ID
+   *
+   * \return The action to dispatch, or action with ID ACTION_NONE if no action should be dispatched
+   */
+  CAction ProcessRelease(std::vector<const KeymapAction*> actions, int windowId);
 
   /*!
-   * \ingroup joystick
-   * \brief
+   * \brief Process an action to see if it should be dispatched
+   *
+   * \param action The action chosen to be dispatched
+   * \param windowId The current window ID
+   * \param magnitude The magnitude or distance of the feature being handled
+   * \param holdTimeMs The time which the feature has been past the hold threshold
+   *
+   * \return The action to dispatch, or action with ID ACTION_NONE if no action should be dispatched
    */
-  class CKeyHandler : public IKeyHandler
-  {
-  public:
-    CKeyHandler(const std::string &keyName, IActionListener *actionHandler, const IKeymap *keymap, IKeymapHandler *keymapHandler);
-
-    ~CKeyHandler() override = default;
-
-    // implementation of IKeyHandler
-    bool IsPressed() const override { return m_bHeld; }
-    bool OnDigitalMotion(bool bPressed, unsigned int holdTimeMs) override;
-    bool OnAnalogMotion(float magnitude, unsigned int motionTimeMs) override;
-
-  private:
-    void Reset();
-
-    /*!
-     * \brief Process actions to see if an action should be dispatched
-     *
-     * \param actions All actions from the keymap defined for the current window
-     * \param windowId The current window ID
-     * \param magnitude The magnitude or distance of the feature being handled
-     * \param holdTimeMs The time which the feature has been past the hold threshold
-     *
-     * \return The action to dispatch, or action with ID ACTION_NONE if no action should be dispatched
-     */
-    CAction ProcessActions(std::vector<const KeymapAction*> actions, int windowId, float magnitude, unsigned int holdTimeMs);
-
-    /*!
-     * \brief Process actions after release event to see if an action should be dispatched
-     *
-     * \param actions All actions from the keymap defined for the current window
-     * \param windowId The current window ID
-     *
-     * \return The action to dispatch, or action with ID ACTION_NONE if no action should be dispatched
-     */
-    CAction ProcessRelease(std::vector<const KeymapAction*> actions, int windowId);
-
-    /*!
-     * \brief Process an action to see if it should be dispatched
-     *
-     * \param action The action chosen to be dispatched
-     * \param windowId The current window ID
-     * \param magnitude The magnitude or distance of the feature being handled
-     * \param holdTimeMs The time which the feature has been past the hold threshold
-     *
-     * \return The action to dispatch, or action with ID ACTION_NONE if no action should be dispatched
-     */
-    CAction ProcessAction(const KeymapAction& action, int windowId, float magnitude, unsigned int holdTimeMs);
-
-    // Check criteria for sending a repeat action
-    bool SendRepeatAction(unsigned int holdTimeMs);
-
-    // Helper function
-    static bool IsPressed(float magnitude);
-
-    // Construction parameters
-    const std::string m_keyName;
-    IActionListener *const m_actionHandler;
-    const IKeymap *const m_keymap;
-    IKeymapHandler *const m_keymapHandler;
-
-    // State variables
-    bool m_bHeld;
-    float m_magnitude;
-    unsigned int m_holdStartTimeMs;
-    unsigned int m_lastHoldTimeMs;
-    bool m_bActionSent;
-    unsigned int m_lastActionMs;
-    int m_activeWindowId = -1; // Window that activated the key
-    CAction m_lastAction;
-  };
-}
-}
+  CAction ProcessAction(const KeymapAction& action,
+                        int windowId,
+                        float magnitude,
+                        unsigned int holdTimeMs);
+
+  // Check criteria for sending a repeat action
+  bool SendRepeatAction(unsigned int holdTimeMs);
+
+  // Helper function
+  static bool IsPressed(float magnitude);
+
+  // Construction parameters
+  const std::string m_keyName;
+  IActionListener* const m_actionHandler;
+  const IKeymap* const m_keymap;
+  IKeymapHandler* const m_keymapHandler;
+
+  // State variables
+  bool m_bHeld;
+  float m_magnitude;
+  unsigned int m_holdStartTimeMs;
+  unsigned int m_lastHoldTimeMs;
+  bool m_bActionSent;
+  unsigned int m_lastActionMs;
+  int m_activeWindowId = -1; // Window that activated the key
+  CAction m_lastAction;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/keymaps/KeymapHandler.cpp b/xbmc/input/joysticks/keymaps/KeymapHandler.cpp
index eb05c7ef7c53..24e2a0b300c6 100644
--- a/xbmc/input/joysticks/keymaps/KeymapHandler.cpp
+++ b/xbmc/input/joysticks/keymaps/KeymapHandler.cpp
@@ -26,9 +26,8 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-CKeymapHandler::CKeymapHandler(IActionListener *actionHandler, const IKeymap *keymap) :
-  m_actionHandler(actionHandler),
-  m_keymap(keymap)
+CKeymapHandler::CKeymapHandler(IActionListener* actionHandler, const IKeymap* keymap)
+  : m_actionHandler(actionHandler), m_keymap(keymap)
 {
   assert(m_actionHandler != nullptr);
   assert(m_keymap != nullptr);
@@ -37,11 +36,11 @@ CKeymapHandler::CKeymapHandler(IActionListener *actionHandler, const IKeymap *ke
     m_easterEgg.reset(new CJoystickEasterEgg(ControllerID()));
 }
 
-bool CKeymapHandler::HotkeysPressed(const std::set<std::string> &keyNames) const
+bool CKeymapHandler::HotkeysPressed(const std::set<std::string>& keyNames) const
 {
   bool bHotkeysPressed = true;
 
-  for (const auto &hotkey : keyNames)
+  for (const auto& hotkey : keyNames)
   {
     auto it = m_keyHandlers.find(hotkey);
     if (it == m_keyHandlers.end() || !it->second->IsPressed())
@@ -80,7 +79,7 @@ bool CKeymapHandler::OnButtonPress(const FeatureName& feature, bool bPressed)
 
   const std::string keyName = CJoystickUtils::MakeKeyName(feature);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   return handler->OnDigitalMotion(bPressed, 0);
 }
 
@@ -91,19 +90,24 @@ void CKeymapHandler::OnButtonHold(const FeatureName& feature, unsigned int holdT
 
   const std::string keyName = CJoystickUtils::MakeKeyName(feature);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   handler->OnDigitalMotion(true, holdTimeMs);
 }
 
-bool CKeymapHandler::OnButtonMotion(const FeatureName& feature, float magnitude, unsigned int motionTimeMs)
+bool CKeymapHandler::OnButtonMotion(const FeatureName& feature,
+                                    float magnitude,
+                                    unsigned int motionTimeMs)
 {
   const std::string keyName = CJoystickUtils::MakeKeyName(feature);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   return handler->OnAnalogMotion(magnitude, motionTimeMs);
 }
 
-bool CKeymapHandler::OnAnalogStickMotion(const FeatureName& feature, float x, float y, unsigned int motionTimeMs)
+bool CKeymapHandler::OnAnalogStickMotion(const FeatureName& feature,
+                                         float x,
+                                         float y,
+                                         unsigned int motionTimeMs)
 {
   using namespace INPUT;
 
@@ -129,7 +133,9 @@ bool CKeymapHandler::OnAnalogStickMotion(const FeatureName& feature, float x, fl
   return bHandled;
 }
 
-bool CKeymapHandler::OnWheelMotion(const FeatureName& feature, float position, unsigned int motionTimeMs)
+bool CKeymapHandler::OnWheelMotion(const FeatureName& feature,
+                                   float position,
+                                   unsigned int motionTimeMs)
 {
   bool bHandled = false;
 
@@ -153,7 +159,9 @@ bool CKeymapHandler::OnWheelMotion(const FeatureName& feature, float position, u
   return bHandled;
 }
 
-bool CKeymapHandler::OnThrottleMotion(const FeatureName& feature, float position, unsigned int motionTimeMs)
+bool CKeymapHandler::OnThrottleMotion(const FeatureName& feature,
+                                      float position,
+                                      unsigned int motionTimeMs)
 {
   bool bHandled = false;
 
@@ -182,11 +190,14 @@ bool CKeymapHandler::OnAccelerometerMotion(const FeatureName& feature, float x,
   return false; //! @todo implement
 }
 
-bool CKeymapHandler::ActivateDirection(const FeatureName& feature, float magnitude, ANALOG_STICK_DIRECTION dir, unsigned int motionTimeMs)
+bool CKeymapHandler::ActivateDirection(const FeatureName& feature,
+                                       float magnitude,
+                                       ANALOG_STICK_DIRECTION dir,
+                                       unsigned int motionTimeMs)
 {
   const std::string keyName = CJoystickUtils::MakeKeyName(feature, dir);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   return handler->OnAnalogMotion(magnitude, motionTimeMs);
 }
 
@@ -194,15 +205,18 @@ void CKeymapHandler::DeactivateDirection(const FeatureName& feature, ANALOG_STIC
 {
   const std::string keyName = CJoystickUtils::MakeKeyName(feature, dir);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   handler->OnAnalogMotion(0.0f, 0);
 }
 
-bool CKeymapHandler::ActivateDirection(const FeatureName& feature, float magnitude, WHEEL_DIRECTION dir, unsigned int motionTimeMs)
+bool CKeymapHandler::ActivateDirection(const FeatureName& feature,
+                                       float magnitude,
+                                       WHEEL_DIRECTION dir,
+                                       unsigned int motionTimeMs)
 {
   const std::string keyName = CJoystickUtils::MakeKeyName(feature, dir);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   return handler->OnAnalogMotion(magnitude, motionTimeMs);
 }
 
@@ -210,15 +224,18 @@ void CKeymapHandler::DeactivateDirection(const FeatureName& feature, WHEEL_DIREC
 {
   const std::string keyName = CJoystickUtils::MakeKeyName(feature, dir);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   handler->OnAnalogMotion(0.0f, 0);
 }
 
-bool CKeymapHandler::ActivateDirection(const FeatureName& feature, float magnitude, THROTTLE_DIRECTION dir, unsigned int motionTimeMs)
+bool CKeymapHandler::ActivateDirection(const FeatureName& feature,
+                                       float magnitude,
+                                       THROTTLE_DIRECTION dir,
+                                       unsigned int motionTimeMs)
 {
   const std::string keyName = CJoystickUtils::MakeKeyName(feature, dir);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   return handler->OnAnalogMotion(magnitude, motionTimeMs);
 }
 
@@ -226,11 +243,11 @@ void CKeymapHandler::DeactivateDirection(const FeatureName& feature, THROTTLE_DI
 {
   const std::string keyName = CJoystickUtils::MakeKeyName(feature, dir);
 
-  IKeyHandler *handler = GetKeyHandler(keyName);
+  IKeyHandler* handler = GetKeyHandler(keyName);
   handler->OnAnalogMotion(0.0f, 0);
 }
 
-IKeyHandler *CKeymapHandler::GetKeyHandler(const std::string &keyName)
+IKeyHandler* CKeymapHandler::GetKeyHandler(const std::string& keyName)
 {
   auto it = m_keyHandlers.find(keyName);
   if (it == m_keyHandlers.end())
@@ -243,12 +260,12 @@ IKeyHandler *CKeymapHandler::GetKeyHandler(const std::string &keyName)
   return it->second.get();
 }
 
-bool CKeymapHandler::HasAction(const std::string &keyName) const
+bool CKeymapHandler::HasAction(const std::string& keyName) const
 {
   bool bHasAction = false;
 
-  const auto &actions = m_keymap->GetActions(keyName).actions;
-  for (const auto &action : actions)
+  const auto& actions = m_keymap->GetActions(keyName).actions;
+  for (const auto& action : actions)
   {
     if (HotkeysPressed(action.hotkeys))
     {
diff --git a/xbmc/input/joysticks/keymaps/KeymapHandler.h b/xbmc/input/joysticks/keymaps/KeymapHandler.h
index a9e4eb810a60..aec42ec0d855 100644
--- a/xbmc/input/joysticks/keymaps/KeymapHandler.h
+++ b/xbmc/input/joysticks/keymaps/KeymapHandler.h
@@ -24,67 +24,84 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IKeyHandler;
-
-  /*!
-   * \ingroup joystick
-   * \brief
-   */
-  class CKeymapHandler : public IKeymapHandler,
-                         public IInputHandler
-  {
-  public:
-    CKeymapHandler(IActionListener *actionHandler, const IKeymap *keymap);
-
-    ~CKeymapHandler() override = default;
-
-    // implementation of IKeymapHandler
-    bool HotkeysPressed(const std::set<std::string>& keyNames) const override;
-    std::string GetLastPressed() const override { return m_lastPressed; }
-    void OnPress(const std::string& keyName) override { m_lastPressed = keyName; }
-
-    // implementation of IInputHandler
-    std::string ControllerID() const override;
-    bool HasFeature(const FeatureName& feature) const override { return true; }
-    bool AcceptsInput(const FeatureName& feature) const override;
-    bool OnButtonPress(const FeatureName& feature, bool bPressed) override;
-    void OnButtonHold(const FeatureName& feature, unsigned int holdTimeMs) override;
-    bool OnButtonMotion(const FeatureName& feature, float magnitude, unsigned int motionTimeMs) override;
-    bool OnAnalogStickMotion(const FeatureName& feature, float x, float y, unsigned int motionTimeMs) override;
-    bool OnAccelerometerMotion(const FeatureName& feature, float x, float y, float z) override;
-    bool OnWheelMotion(const FeatureName& feature, float position, unsigned int motionTimeMs) override;
-    bool OnThrottleMotion(const FeatureName& feature, float position, unsigned int motionTimeMs) override;
-
-  protected:
-    // Keep track of cheat code presses
-    std::unique_ptr<IButtonSequence> m_easterEgg;
-
-  private:
-    // Analog stick helper functions
-    bool ActivateDirection(const FeatureName& feature, float magnitude, ANALOG_STICK_DIRECTION dir, unsigned int motionTimeMs);
-    void DeactivateDirection(const FeatureName& feature, ANALOG_STICK_DIRECTION dir);
-
-    // Wheel helper functions
-    bool ActivateDirection(const FeatureName& feature, float magnitude, WHEEL_DIRECTION dir, unsigned int motionTimeMs);
-    void DeactivateDirection(const FeatureName& feature, WHEEL_DIRECTION dir);
-
-    // Throttle helper functions
-    bool ActivateDirection(const FeatureName& feature, float magnitude, THROTTLE_DIRECTION dir, unsigned int motionTimeMs);
-    void DeactivateDirection(const FeatureName& feature, THROTTLE_DIRECTION dir);
-
-    // Helper functions
-    IKeyHandler *GetKeyHandler(const std::string &keyName);
-    bool HasAction(const std::string &keyName) const;
-
-    // Construction parameters
-    IActionListener *const m_actionHandler;
-    const IKeymap *const m_keymap;
-
-    // Handlers for individual keys
-    std::map<std::string, std::unique_ptr<IKeyHandler>> m_keyHandlers; // Key name -> handler
-
-    // Last pressed key
-    std::string m_lastPressed;
-  };
-}
-}
+class IKeyHandler;
+
+/*!
+ * \ingroup joystick
+ * \brief
+ */
+class CKeymapHandler : public IKeymapHandler, public IInputHandler
+{
+public:
+  CKeymapHandler(IActionListener* actionHandler, const IKeymap* keymap);
+
+  ~CKeymapHandler() override = default;
+
+  // implementation of IKeymapHandler
+  bool HotkeysPressed(const std::set<std::string>& keyNames) const override;
+  std::string GetLastPressed() const override { return m_lastPressed; }
+  void OnPress(const std::string& keyName) override { m_lastPressed = keyName; }
+
+  // implementation of IInputHandler
+  std::string ControllerID() const override;
+  bool HasFeature(const FeatureName& feature) const override { return true; }
+  bool AcceptsInput(const FeatureName& feature) const override;
+  bool OnButtonPress(const FeatureName& feature, bool bPressed) override;
+  void OnButtonHold(const FeatureName& feature, unsigned int holdTimeMs) override;
+  bool OnButtonMotion(const FeatureName& feature,
+                      float magnitude,
+                      unsigned int motionTimeMs) override;
+  bool OnAnalogStickMotion(const FeatureName& feature,
+                           float x,
+                           float y,
+                           unsigned int motionTimeMs) override;
+  bool OnAccelerometerMotion(const FeatureName& feature, float x, float y, float z) override;
+  bool OnWheelMotion(const FeatureName& feature,
+                     float position,
+                     unsigned int motionTimeMs) override;
+  bool OnThrottleMotion(const FeatureName& feature,
+                        float position,
+                        unsigned int motionTimeMs) override;
+
+protected:
+  // Keep track of cheat code presses
+  std::unique_ptr<IButtonSequence> m_easterEgg;
+
+private:
+  // Analog stick helper functions
+  bool ActivateDirection(const FeatureName& feature,
+                         float magnitude,
+                         ANALOG_STICK_DIRECTION dir,
+                         unsigned int motionTimeMs);
+  void DeactivateDirection(const FeatureName& feature, ANALOG_STICK_DIRECTION dir);
+
+  // Wheel helper functions
+  bool ActivateDirection(const FeatureName& feature,
+                         float magnitude,
+                         WHEEL_DIRECTION dir,
+                         unsigned int motionTimeMs);
+  void DeactivateDirection(const FeatureName& feature, WHEEL_DIRECTION dir);
+
+  // Throttle helper functions
+  bool ActivateDirection(const FeatureName& feature,
+                         float magnitude,
+                         THROTTLE_DIRECTION dir,
+                         unsigned int motionTimeMs);
+  void DeactivateDirection(const FeatureName& feature, THROTTLE_DIRECTION dir);
+
+  // Helper functions
+  IKeyHandler* GetKeyHandler(const std::string& keyName);
+  bool HasAction(const std::string& keyName) const;
+
+  // Construction parameters
+  IActionListener* const m_actionHandler;
+  const IKeymap* const m_keymap;
+
+  // Handlers for individual keys
+  std::map<std::string, std::unique_ptr<IKeyHandler>> m_keyHandlers; // Key name -> handler
+
+  // Last pressed key
+  std::string m_lastPressed;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/joysticks/keymaps/KeymapHandling.cpp b/xbmc/input/joysticks/keymaps/KeymapHandling.cpp
index daa6f99cb29c..b87ea684b5a1 100644
--- a/xbmc/input/joysticks/keymaps/KeymapHandling.cpp
+++ b/xbmc/input/joysticks/keymaps/KeymapHandling.cpp
@@ -22,10 +22,10 @@
 using namespace KODI;
 using namespace JOYSTICK;
 
-CKeymapHandling::CKeymapHandling(IInputProvider *inputProvider, bool pPromiscuous, const IKeymapEnvironment *environment) :
-  m_inputProvider(inputProvider),
-  m_pPromiscuous(pPromiscuous),
-  m_environment(environment)
+CKeymapHandling::CKeymapHandling(IInputProvider* inputProvider,
+                                 bool pPromiscuous,
+                                 const IKeymapEnvironment* environment)
+  : m_inputProvider(inputProvider), m_pPromiscuous(pPromiscuous), m_environment(environment)
 {
   LoadKeymaps();
   CServiceBroker::GetInputManager().RegisterObserver(this);
@@ -37,13 +37,12 @@ CKeymapHandling::~CKeymapHandling()
   UnloadKeymaps();
 }
 
-IInputReceiver *CKeymapHandling::GetInputReceiver(const std::string &controllerId) const
+IInputReceiver* CKeymapHandling::GetInputReceiver(const std::string& controllerId) const
 {
   auto it = std::find_if(m_inputHandlers.begin(), m_inputHandlers.end(),
-    [&controllerId](const std::unique_ptr<IInputHandler> &inputHandler)
-    {
-      return inputHandler->ControllerID() == controllerId;
-    });
+                         [&controllerId](const std::unique_ptr<IInputHandler>& inputHandler) {
+                           return inputHandler->ControllerID() == controllerId;
+                         });
 
   if (it != m_inputHandlers.end())
     return (*it)->InputReceiver();
@@ -51,13 +50,12 @@ IInputReceiver *CKeymapHandling::GetInputReceiver(const std::string &controllerI
   return nullptr;
 }
 
-IKeymap *CKeymapHandling::GetKeymap(const std::string &controllerId) const
+IKeymap* CKeymapHandling::GetKeymap(const std::string& controllerId) const
 {
   auto it = std::find_if(m_keymaps.begin(), m_keymaps.end(),
-    [&controllerId](const std::unique_ptr<IKeymap> &keymap)
-    {
-      return keymap->ControllerID() == controllerId;
-    });
+                         [&controllerId](const std::unique_ptr<IKeymap>& keymap) {
+                           return keymap->ControllerID() == controllerId;
+                         });
 
   if (it != m_keymaps.end())
     return it->get();
@@ -65,7 +63,7 @@ IKeymap *CKeymapHandling::GetKeymap(const std::string &controllerId) const
   return nullptr;
 }
 
-void CKeymapHandling::Notify(const Observable &obs, const ObservableMessage msg)
+void CKeymapHandling::Notify(const Observable& obs, const ObservableMessage msg)
 {
   if (msg == ObservableMessageButtonMapsChanged)
     LoadKeymaps();
@@ -75,9 +73,9 @@ void CKeymapHandling::LoadKeymaps()
 {
   UnloadKeymaps();
 
-  auto &inputManager = CServiceBroker::GetInputManager();
+  auto& inputManager = CServiceBroker::GetInputManager();
 
-  for (auto &windowKeymap : inputManager.GetJoystickKeymaps())
+  for (auto& windowKeymap : inputManager.GetJoystickKeymaps())
   {
     // Create keymap
     std::unique_ptr<IKeymap> keymap(new CKeymap(std::move(windowKeymap), m_environment));
diff --git a/xbmc/input/joysticks/keymaps/KeymapHandling.h b/xbmc/input/joysticks/keymaps/KeymapHandling.h
index 43903bfecbe4..fdc64b70f90d 100644
--- a/xbmc/input/joysticks/keymaps/KeymapHandling.h
+++ b/xbmc/input/joysticks/keymaps/KeymapHandling.h
@@ -21,54 +21,56 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IInputHandler;
-  class IInputProvider;
-  class IInputReceiver;
+class IInputHandler;
+class IInputProvider;
+class IInputReceiver;
 
-  /*!
-   * \ingroup joystick
-   * \brief
-   */
-  class CKeymapHandling : public Observer
-  {
-  public:
-    CKeymapHandling(IInputProvider *inputProvider, bool pPromiscuous, const IKeymapEnvironment *environment);
+/*!
+ * \ingroup joystick
+ * \brief
+ */
+class CKeymapHandling : public Observer
+{
+public:
+  CKeymapHandling(IInputProvider* inputProvider,
+                  bool pPromiscuous,
+                  const IKeymapEnvironment* environment);
 
-    ~CKeymapHandling() override;
+  ~CKeymapHandling() override;
 
-    /*!
-     * \brief Unregister the input provider
-     *
-     * Call this if the input provider is invalidated, such as if a user
-     * disconnects a controller. This prevents accessing the invalidated
-     * input provider when keymaps are unloaded upon destruction.
-     */
-    void UnregisterInputProvider() { m_inputProvider = nullptr; }
+  /*!
+   * \brief Unregister the input provider
+   *
+   * Call this if the input provider is invalidated, such as if a user
+   * disconnects a controller. This prevents accessing the invalidated
+   * input provider when keymaps are unloaded upon destruction.
+   */
+  void UnregisterInputProvider() { m_inputProvider = nullptr; }
 
-    /*!
-     * \brief
-     */
-    IInputReceiver *GetInputReceiver(const std::string &controllerId) const;
+  /*!
+   * \brief
+   */
+  IInputReceiver* GetInputReceiver(const std::string& controllerId) const;
 
-    /*!
-     * \brief
-     */
-    IKeymap *GetKeymap(const std::string &controllerId) const;
+  /*!
+   * \brief
+   */
+  IKeymap* GetKeymap(const std::string& controllerId) const;
 
-    // implementation of Observer
-    void Notify(const Observable& obs, const ObservableMessage msg) override;
+  // implementation of Observer
+  void Notify(const Observable& obs, const ObservableMessage msg) override;
 
-  private:
-    void LoadKeymaps();
-    void UnloadKeymaps();
+private:
+  void LoadKeymaps();
+  void UnloadKeymaps();
 
-    // Construction parameter
-    IInputProvider *m_inputProvider;
-    const bool m_pPromiscuous;
-    const IKeymapEnvironment *const m_environment;
+  // Construction parameter
+  IInputProvider* m_inputProvider;
+  const bool m_pPromiscuous;
+  const IKeymapEnvironment* const m_environment;
 
-    std::vector<std::unique_ptr<IKeymap>> m_keymaps;
-    std::vector<std::unique_ptr<IInputHandler>> m_inputHandlers;
-  };
-}
-}
+  std::vector<std::unique_ptr<IKeymap>> m_keymaps;
+  std::vector<std::unique_ptr<IInputHandler>> m_inputHandlers;
+};
+} // namespace JOYSTICK
+} // namespace KODI
diff --git a/xbmc/input/keyboard/KeyboardEasterEgg.cpp b/xbmc/input/keyboard/KeyboardEasterEgg.cpp
index 47a992e8748d..8b7049d0c6fb 100644
--- a/xbmc/input/keyboard/KeyboardEasterEgg.cpp
+++ b/xbmc/input/keyboard/KeyboardEasterEgg.cpp
@@ -15,16 +15,8 @@ using namespace KODI;
 using namespace KEYBOARD;
 
 std::vector<XBMCVKey> CKeyboardEasterEgg::m_sequence = {
-  XBMCVK_UP,
-  XBMCVK_UP,
-  XBMCVK_DOWN,
-  XBMCVK_DOWN,
-  XBMCVK_LEFT,
-  XBMCVK_RIGHT,
-  XBMCVK_LEFT,
-  XBMCVK_RIGHT,
-  XBMCVK_B,
-  XBMCVK_A,
+    XBMCVK_UP,    XBMCVK_UP,   XBMCVK_DOWN,  XBMCVK_DOWN, XBMCVK_LEFT,
+    XBMCVK_RIGHT, XBMCVK_LEFT, XBMCVK_RIGHT, XBMCVK_B,    XBMCVK_A,
 };
 
 bool CKeyboardEasterEgg::OnKeyPress(const CKey& key)
diff --git a/xbmc/input/keyboard/KeyboardEasterEgg.h b/xbmc/input/keyboard/KeyboardEasterEgg.h
index 4e346fc74d90..00c1791416b4 100644
--- a/xbmc/input/keyboard/KeyboardEasterEgg.h
+++ b/xbmc/input/keyboard/KeyboardEasterEgg.h
@@ -17,22 +17,22 @@ namespace KODI
 {
 namespace KEYBOARD
 {
-  /*!
-   * \brief Hush!!!
-   */
-  class CKeyboardEasterEgg : public IKeyboardDriverHandler
-  {
-  public:
-    ~CKeyboardEasterEgg() override = default;
+/*!
+ * \brief Hush!!!
+ */
+class CKeyboardEasterEgg : public IKeyboardDriverHandler
+{
+public:
+  ~CKeyboardEasterEgg() override = default;
 
-    // implementation of IKeyboardDriverHandler
-    bool OnKeyPress(const CKey& key) override;
-    void OnKeyRelease(const CKey& key) override { }
+  // implementation of IKeyboardDriverHandler
+  bool OnKeyPress(const CKey& key) override;
+  void OnKeyRelease(const CKey& key) override {}
 
-  private:
-    static std::vector<XBMCVKey> m_sequence;
+private:
+  static std::vector<XBMCVKey> m_sequence;
 
-    unsigned int m_state = 0;
-  };
-}
-}
+  unsigned int m_state = 0;
+};
+} // namespace KEYBOARD
+} // namespace KODI
diff --git a/xbmc/input/keyboard/KeyboardTypes.h b/xbmc/input/keyboard/KeyboardTypes.h
index 8fbff5f92a23..5a5d39bcf145 100644
--- a/xbmc/input/keyboard/KeyboardTypes.h
+++ b/xbmc/input/keyboard/KeyboardTypes.h
@@ -17,24 +17,24 @@ namespace KODI
 {
 namespace KEYBOARD
 {
-  /*!
-   * \brief Symbol of a hardware-independent key
-   */
-  using KeySymbol = XBMCKey;
+/*!
+ * \brief Symbol of a hardware-independent key
+ */
+using KeySymbol = XBMCKey;
 
-  /*!
-   * \brief Name of a hardware-indendent symbol representing a key
-   *
-   * Names are defined in the keyboard's controller profile.
-   */
-  using KeyName = std::string;
+/*!
+ * \brief Name of a hardware-indendent symbol representing a key
+ *
+ * Names are defined in the keyboard's controller profile.
+ */
+using KeyName = std::string;
 
-  /*!
-   * \brief Modifier keys on a keyboard that can be held when
-   *        sending a key press
-   *
-   * \todo Move CKey enum to this file
-   */
-  using Modifier = CKey::Modifier;
-}
-}
+/*!
+ * \brief Modifier keys on a keyboard that can be held when
+ *        sending a key press
+ *
+ * \todo Move CKey enum to this file
+ */
+using Modifier = CKey::Modifier;
+} // namespace KEYBOARD
+} // namespace KODI
diff --git a/xbmc/input/keyboard/KeymapActionMap.cpp b/xbmc/input/keyboard/KeymapActionMap.cpp
index ee389a94e251..f6e691973c91 100644
--- a/xbmc/input/keyboard/KeymapActionMap.cpp
+++ b/xbmc/input/keyboard/KeymapActionMap.cpp
@@ -20,6 +20,7 @@ using namespace KEYBOARD;
 
 unsigned int CKeymapActionMap::GetActionID(const CKey& key)
 {
-  CAction action = CServiceBroker::GetInputManager().GetAction(CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog(), key);
+  CAction action = CServiceBroker::GetInputManager().GetAction(
+      CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindowOrDialog(), key);
   return action.GetID();
 }
diff --git a/xbmc/input/keyboard/KeymapActionMap.h b/xbmc/input/keyboard/KeymapActionMap.h
index 21ee1263c664..6ee934489401 100644
--- a/xbmc/input/keyboard/KeymapActionMap.h
+++ b/xbmc/input/keyboard/KeymapActionMap.h
@@ -14,15 +14,15 @@ namespace KODI
 {
 namespace KEYBOARD
 {
-  class CKeymapActionMap : public IActionMap
-  {
-  public:
-    CKeymapActionMap(void) = default;
+class CKeymapActionMap : public IActionMap
+{
+public:
+  CKeymapActionMap(void) = default;
 
-    ~CKeymapActionMap(void) override = default;
+  ~CKeymapActionMap(void) override = default;
 
-    // implementation of IActionMap
-    unsigned int GetActionID(const CKey& key) override;
-  };
-}
-}
+  // implementation of IActionMap
+  unsigned int GetActionID(const CKey& key) override;
+};
+} // namespace KEYBOARD
+} // namespace KODI
diff --git a/xbmc/input/keyboard/generic/KeyboardInputHandling.cpp b/xbmc/input/keyboard/generic/KeyboardInputHandling.cpp
index 6f653e75f5d8..5e84081a58a3 100644
--- a/xbmc/input/keyboard/generic/KeyboardInputHandling.cpp
+++ b/xbmc/input/keyboard/generic/KeyboardInputHandling.cpp
@@ -16,9 +16,9 @@
 using namespace KODI;
 using namespace KEYBOARD;
 
-CKeyboardInputHandling::CKeyboardInputHandling(IKeyboardInputHandler* handler, JOYSTICK::IButtonMap* buttonMap) :
-  m_handler(handler),
-  m_buttonMap(buttonMap)
+CKeyboardInputHandling::CKeyboardInputHandling(IKeyboardInputHandler* handler,
+                                               JOYSTICK::IButtonMap* buttonMap)
+  : m_handler(handler), m_buttonMap(buttonMap)
 {
 }
 
diff --git a/xbmc/input/keyboard/generic/KeyboardInputHandling.h b/xbmc/input/keyboard/generic/KeyboardInputHandling.h
index adf8434367bf..4cd2d2629551 100644
--- a/xbmc/input/keyboard/generic/KeyboardInputHandling.h
+++ b/xbmc/input/keyboard/generic/KeyboardInputHandling.h
@@ -12,35 +12,35 @@
 
 namespace KODI
 {
-  namespace JOYSTICK
-  {
-    class IButtonMap;
-  }
-
-  namespace KEYBOARD
-  {
-    class IKeyboardInputHandler;
-
-    /*!
-     * \ingroup keyboard
-     * \brief Class to translate input from Kodi keycodes to key names defined
-     *        by the keyboard's controller profile
-     */
-    class CKeyboardInputHandling : public IKeyboardDriverHandler
-    {
-    public:
-      CKeyboardInputHandling(IKeyboardInputHandler* handler, JOYSTICK::IButtonMap* buttonMap);
-
-      ~CKeyboardInputHandling(void) override = default;
-
-      // implementation of IKeyboardDriverHandler
-      bool OnKeyPress(const CKey& key) override;
-      void OnKeyRelease(const CKey& key) override;
-
-    private:
-      // Construction parameters
-      IKeyboardInputHandler* const m_handler;
-      JOYSTICK::IButtonMap* const m_buttonMap;
-    };
-  }
+namespace JOYSTICK
+{
+class IButtonMap;
 }
+
+namespace KEYBOARD
+{
+class IKeyboardInputHandler;
+
+/*!
+ * \ingroup keyboard
+ * \brief Class to translate input from Kodi keycodes to key names defined
+ *        by the keyboard's controller profile
+ */
+class CKeyboardInputHandling : public IKeyboardDriverHandler
+{
+public:
+  CKeyboardInputHandling(IKeyboardInputHandler* handler, JOYSTICK::IButtonMap* buttonMap);
+
+  ~CKeyboardInputHandling(void) override = default;
+
+  // implementation of IKeyboardDriverHandler
+  bool OnKeyPress(const CKey& key) override;
+  void OnKeyRelease(const CKey& key) override;
+
+private:
+  // Construction parameters
+  IKeyboardInputHandler* const m_handler;
+  JOYSTICK::IButtonMap* const m_buttonMap;
+};
+} // namespace KEYBOARD
+} // namespace KODI
diff --git a/xbmc/input/keyboard/interfaces/IActionMap.h b/xbmc/input/keyboard/interfaces/IActionMap.h
index 8dcf00226b6e..e77643e00f2d 100644
--- a/xbmc/input/keyboard/interfaces/IActionMap.h
+++ b/xbmc/input/keyboard/interfaces/IActionMap.h
@@ -14,23 +14,23 @@ namespace KODI
 {
 namespace KEYBOARD
 {
+/*!
+ * \brief Interface for translating keys to action IDs
+ */
+class IActionMap
+{
+public:
+  virtual ~IActionMap() = default;
+
   /*!
-   * \brief Interface for translating keys to action IDs
+   * \brief Get the action ID mapped to the specified key
+   *
+   * \param key The key to look up
+   *
+   * \return The action ID from ActionIDs.h, or ACTION_NONE if no action is
+   *         mapped to the specified key
    */
-  class IActionMap
-  {
-  public:
-    virtual ~IActionMap() = default;
-
-    /*!
-     * \brief Get the action ID mapped to the specified key
-     *
-     * \param key The key to look up
-     *
-     * \return The action ID from ActionIDs.h, or ACTION_NONE if no action is
-     *         mapped to the specified key
-     */
-    virtual unsigned int GetActionID(const CKey& key) = 0;
-  };
-}
-}
+  virtual unsigned int GetActionID(const CKey& key) = 0;
+};
+} // namespace KEYBOARD
+} // namespace KODI
diff --git a/xbmc/input/keyboard/interfaces/IKeyboardDriverHandler.h b/xbmc/input/keyboard/interfaces/IKeyboardDriverHandler.h
index 64962f7474f0..828f0a984cb8 100644
--- a/xbmc/input/keyboard/interfaces/IKeyboardDriverHandler.h
+++ b/xbmc/input/keyboard/interfaces/IKeyboardDriverHandler.h
@@ -14,30 +14,30 @@ namespace KODI
 {
 namespace KEYBOARD
 {
+/*!
+ * \ingroup keyboard
+ * \brief Interface for handling keyboard events
+ */
+class IKeyboardDriverHandler
+{
+public:
+  virtual ~IKeyboardDriverHandler() = default;
+
   /*!
-   * \ingroup keyboard
-   * \brief Interface for handling keyboard events
+   * \brief A key has been pressed
+   *
+   * \param key The pressed key
+   *
+   * \return True if the event was handled, false otherwise
    */
-  class IKeyboardDriverHandler
-  {
-  public:
-    virtual ~IKeyboardDriverHandler() = default;
+  virtual bool OnKeyPress(const CKey& key) = 0;
 
-    /*!
-     * \brief A key has been pressed
-     *
-     * \param key The pressed key
-     *
-     * \return True if the event was handled, false otherwise
-     */
-    virtual bool OnKeyPress(const CKey& key) = 0;
-
-    /*!
-     * \brief A key has been released
-     *
-     * \param key The released key
-     */
-    virtual void OnKeyRelease(const CKey& key) = 0;
-  };
-}
-}
+  /*!
+   * \brief A key has been released
+   *
+   * \param key The released key
+   */
+  virtual void OnKeyRelease(const CKey& key) = 0;
+};
+} // namespace KEYBOARD
+} // namespace KODI
diff --git a/xbmc/input/keyboard/interfaces/IKeyboardInputHandler.h b/xbmc/input/keyboard/interfaces/IKeyboardInputHandler.h
index 171f44e076a9..f0df6a36f166 100644
--- a/xbmc/input/keyboard/interfaces/IKeyboardInputHandler.h
+++ b/xbmc/input/keyboard/interfaces/IKeyboardInputHandler.h
@@ -17,53 +17,53 @@ namespace KODI
 {
 namespace KEYBOARD
 {
+/*!
+ * \ingroup keyboard
+ * \brief Interface for handling input events for keyboards
+ *
+ * Input events are an abstraction over driver events. Keys are identified by
+ * the name defined in the keyboard's controller profile.
+ */
+class IKeyboardInputHandler
+{
+public:
+  virtual ~IKeyboardInputHandler() = default;
+
   /*!
-   * \ingroup keyboard
-   * \brief Interface for handling input events for keyboards
+   * \brief The add-on ID of the keyboard's controller profile
    *
-   * Input events are an abstraction over driver events. Keys are identified by
-   * the name defined in the keyboard's controller profile.
+   * \return The ID of the controller profile add-on
    */
-  class IKeyboardInputHandler
-  {
-  public:
-    virtual ~IKeyboardInputHandler() = default;
+  virtual std::string ControllerID() const = 0;
 
-    /*!
-     * \brief The add-on ID of the keyboard's controller profile
-     *
-     * \return The ID of the controller profile add-on
-     */
-    virtual std::string ControllerID() const = 0;
-
-    /*!
-     * \brief Return true if the input handler accepts the given key
-     *
-     * \param key A key belonging to the controller specified by ControllerID()
-     *
-     * \return True if the key is used for input, false otherwise
-     */
-    virtual bool HasKey(const KeyName &key) const = 0;
+  /*!
+   * \brief Return true if the input handler accepts the given key
+   *
+   * \param key A key belonging to the controller specified by ControllerID()
+   *
+   * \return True if the key is used for input, false otherwise
+   */
+  virtual bool HasKey(const KeyName& key) const = 0;
 
-    /*!
-     * \brief A key has been pressed
-     *
-     * \param key A key belonging to the controller specified by ControllerID()
-     * \param mod A combination of modifiers
-     * \param unicode The unicode value associated with the key, or 0 if unknown
-     *
-     * \return True if the event was handled, false otherwise
-     */
-    virtual bool OnKeyPress(const KeyName &key, Modifier mod, uint32_t unicode) = 0;
+  /*!
+   * \brief A key has been pressed
+   *
+   * \param key A key belonging to the controller specified by ControllerID()
+   * \param mod A combination of modifiers
+   * \param unicode The unicode value associated with the key, or 0 if unknown
+   *
+   * \return True if the event was handled, false otherwise
+   */
+  virtual bool OnKeyPress(const KeyName& key, Modifier mod, uint32_t unicode) = 0;
 
-    /*!
-     * \brief A key has been released
-     *
-     * \param key A key belonging to the controller specified by ControllerID()
-     * \param mod A combination of modifiers
-     * \param unicode The unicode value associated with the key, or 0 if unknown
-     */
-    virtual void OnKeyRelease(const KeyName &key, Modifier mod, uint32_t unicode) = 0;
-  };
-}
-}
+  /*!
+   * \brief A key has been released
+   *
+   * \param key A key belonging to the controller specified by ControllerID()
+   * \param mod A combination of modifiers
+   * \param unicode The unicode value associated with the key, or 0 if unknown
+   */
+  virtual void OnKeyRelease(const KeyName& key, Modifier mod, uint32_t unicode) = 0;
+};
+} // namespace KEYBOARD
+} // namespace KODI
diff --git a/xbmc/input/keyboard/interfaces/IKeyboardInputProvider.h b/xbmc/input/keyboard/interfaces/IKeyboardInputProvider.h
index 0d10425b4947..5d964d5c0819 100644
--- a/xbmc/input/keyboard/interfaces/IKeyboardInputProvider.h
+++ b/xbmc/input/keyboard/interfaces/IKeyboardInputProvider.h
@@ -12,32 +12,32 @@ namespace KODI
 {
 namespace KEYBOARD
 {
-  class IKeyboardInputHandler;
+class IKeyboardInputHandler;
+
+/*!
+ * \ingroup mouse
+ * \brief Interface for classes that can provide keyboard input
+ */
+class IKeyboardInputProvider
+{
+public:
+  virtual ~IKeyboardInputProvider() = default;
 
   /*!
-   * \ingroup mouse
-   * \brief Interface for classes that can provide keyboard input
+   * \brief Registers a handler to be called on keyboard input
+   *
+   * \param handler The handler to receive keyboard input provided by this class
+   * \param bPromiscuous True to observe all events without affecting the
+   *        input's destination
    */
-  class IKeyboardInputProvider
-  {
-  public:
-    virtual ~IKeyboardInputProvider() = default;
+  virtual void RegisterKeyboardHandler(IKeyboardInputHandler* handler, bool bPromiscuous) = 0;
 
-    /*!
-     * \brief Registers a handler to be called on keyboard input
-     *
-     * \param handler The handler to receive keyboard input provided by this class
-     * \param bPromiscuous True to observe all events without affecting the
-     *        input's destination
-     */
-    virtual void RegisterKeyboardHandler(IKeyboardInputHandler* handler, bool bPromiscuous) = 0;
-
-    /*!
-     * \brief Unregisters handler from keyboard input
-     *
-     * \param handler The handler that was receiving keyboard input
-     */
-    virtual void UnregisterKeyboardHandler(IKeyboardInputHandler* handler) = 0;
-  };
-}
-}
+  /*!
+   * \brief Unregisters handler from keyboard input
+   *
+   * \param handler The handler that was receiving keyboard input
+   */
+  virtual void UnregisterKeyboardHandler(IKeyboardInputHandler* handler) = 0;
+};
+} // namespace KEYBOARD
+} // namespace KODI
diff --git a/xbmc/input/mouse/MouseStat.cpp b/xbmc/input/mouse/MouseStat.cpp
index f9467a5c0778..f8d3397d0c03 100644
--- a/xbmc/input/mouse/MouseStat.cpp
+++ b/xbmc/input/mouse/MouseStat.cpp
@@ -54,33 +54,51 @@ void CMouseStat::HandleEvent(XBMC_Event& newEvent)
   }
   m_mouseState.dx = dx;
   m_mouseState.dy = dy;
-  m_mouseState.x  = std::max(0, std::min(m_maxX, m_mouseState.x + dx));
-  m_mouseState.y  = std::max(0, std::min(m_maxY, m_mouseState.y + dy));
+  m_mouseState.x = std::max(0, std::min(m_maxX, m_mouseState.x + dx));
+  m_mouseState.y = std::max(0, std::min(m_maxY, m_mouseState.y + dy));
 
   // Fill in the public members
   if (newEvent.type == XBMC_MOUSEBUTTONDOWN)
   {
-    if (newEvent.button.button == XBMC_BUTTON_LEFT) m_mouseState.button[MOUSE_LEFT_BUTTON] = true;
-    if (newEvent.button.button == XBMC_BUTTON_RIGHT) m_mouseState.button[MOUSE_RIGHT_BUTTON] = true;
-    if (newEvent.button.button == XBMC_BUTTON_MIDDLE) m_mouseState.button[MOUSE_MIDDLE_BUTTON] = true;
-    if (newEvent.button.button == XBMC_BUTTON_X1) m_mouseState.button[MOUSE_EXTRA_BUTTON1] = true;
-    if (newEvent.button.button == XBMC_BUTTON_X2) m_mouseState.button[MOUSE_EXTRA_BUTTON2] = true;
-    if (newEvent.button.button == XBMC_BUTTON_X3) m_mouseState.button[MOUSE_EXTRA_BUTTON3] = true;
-    if (newEvent.button.button == XBMC_BUTTON_X4) m_mouseState.button[MOUSE_EXTRA_BUTTON4] = true;
-    if (newEvent.button.button == XBMC_BUTTON_WHEELUP) m_mouseState.dz = 1;
-    if (newEvent.button.button == XBMC_BUTTON_WHEELDOWN) m_mouseState.dz = -1;
+    if (newEvent.button.button == XBMC_BUTTON_LEFT)
+      m_mouseState.button[MOUSE_LEFT_BUTTON] = true;
+    if (newEvent.button.button == XBMC_BUTTON_RIGHT)
+      m_mouseState.button[MOUSE_RIGHT_BUTTON] = true;
+    if (newEvent.button.button == XBMC_BUTTON_MIDDLE)
+      m_mouseState.button[MOUSE_MIDDLE_BUTTON] = true;
+    if (newEvent.button.button == XBMC_BUTTON_X1)
+      m_mouseState.button[MOUSE_EXTRA_BUTTON1] = true;
+    if (newEvent.button.button == XBMC_BUTTON_X2)
+      m_mouseState.button[MOUSE_EXTRA_BUTTON2] = true;
+    if (newEvent.button.button == XBMC_BUTTON_X3)
+      m_mouseState.button[MOUSE_EXTRA_BUTTON3] = true;
+    if (newEvent.button.button == XBMC_BUTTON_X4)
+      m_mouseState.button[MOUSE_EXTRA_BUTTON4] = true;
+    if (newEvent.button.button == XBMC_BUTTON_WHEELUP)
+      m_mouseState.dz = 1;
+    if (newEvent.button.button == XBMC_BUTTON_WHEELDOWN)
+      m_mouseState.dz = -1;
   }
   else if (newEvent.type == XBMC_MOUSEBUTTONUP)
   {
-    if (newEvent.button.button == XBMC_BUTTON_LEFT) m_mouseState.button[MOUSE_LEFT_BUTTON] = false;
-    if (newEvent.button.button == XBMC_BUTTON_RIGHT) m_mouseState.button[MOUSE_RIGHT_BUTTON] = false;
-    if (newEvent.button.button == XBMC_BUTTON_MIDDLE) m_mouseState.button[MOUSE_MIDDLE_BUTTON] = false;
-    if (newEvent.button.button == XBMC_BUTTON_X1) m_mouseState.button[MOUSE_EXTRA_BUTTON1] = false;
-    if (newEvent.button.button == XBMC_BUTTON_X2) m_mouseState.button[MOUSE_EXTRA_BUTTON2] = false;
-    if (newEvent.button.button == XBMC_BUTTON_X3) m_mouseState.button[MOUSE_EXTRA_BUTTON3] = false;
-    if (newEvent.button.button == XBMC_BUTTON_X4) m_mouseState.button[MOUSE_EXTRA_BUTTON4] = false;
-    if (newEvent.button.button == XBMC_BUTTON_WHEELUP) m_mouseState.dz = 0;
-    if (newEvent.button.button == XBMC_BUTTON_WHEELDOWN) m_mouseState.dz = 0;
+    if (newEvent.button.button == XBMC_BUTTON_LEFT)
+      m_mouseState.button[MOUSE_LEFT_BUTTON] = false;
+    if (newEvent.button.button == XBMC_BUTTON_RIGHT)
+      m_mouseState.button[MOUSE_RIGHT_BUTTON] = false;
+    if (newEvent.button.button == XBMC_BUTTON_MIDDLE)
+      m_mouseState.button[MOUSE_MIDDLE_BUTTON] = false;
+    if (newEvent.button.button == XBMC_BUTTON_X1)
+      m_mouseState.button[MOUSE_EXTRA_BUTTON1] = false;
+    if (newEvent.button.button == XBMC_BUTTON_X2)
+      m_mouseState.button[MOUSE_EXTRA_BUTTON2] = false;
+    if (newEvent.button.button == XBMC_BUTTON_X3)
+      m_mouseState.button[MOUSE_EXTRA_BUTTON3] = false;
+    if (newEvent.button.button == XBMC_BUTTON_X4)
+      m_mouseState.button[MOUSE_EXTRA_BUTTON4] = false;
+    if (newEvent.button.button == XBMC_BUTTON_WHEELUP)
+      m_mouseState.dz = 0;
+    if (newEvent.button.button == XBMC_BUTTON_WHEELDOWN)
+      m_mouseState.dz = 0;
   }
 
   // Now check the current message and the previous state to find out if
@@ -97,35 +115,36 @@ void CMouseStat::HandleEvent(XBMC_Event& newEvent)
 
     // CButtonState::Update does the hard work of checking the button state
     // and spotting drags, doubleclicks etc
-    CButtonState::BUTTON_ACTION action = m_buttonState[i].Update(now, m_mouseState.x, m_mouseState.y, m_mouseState.button[i]);
+    CButtonState::BUTTON_ACTION action =
+        m_buttonState[i].Update(now, m_mouseState.x, m_mouseState.y, m_mouseState.button[i]);
     switch (action)
     {
-    case CButtonState::MB_SHORT_CLICK:
-      bClick[i] = true;
-      bNothingDown = false;
-      break;
-    case CButtonState::MB_LONG_CLICK:
-      bLongClick[i] = true;
-      bNothingDown = false;
-      break;
-    case CButtonState::MB_DOUBLE_CLICK:
-      bDoubleClick[i] = true;
-      bNothingDown = false;
-      break;
-    case CButtonState::MB_DRAG_START:
-      bHold[i] = CButtonState::MB_DRAG_START;
-      bNothingDown = false;
-      break;
-    case CButtonState::MB_DRAG:
-      bHold[i] = CButtonState::MB_DRAG;
-      bNothingDown = false;
-      break;
-    case CButtonState::MB_DRAG_END:
-      bHold[i] = CButtonState::MB_DRAG_END;
-      bNothingDown = false;
-      break;
-    default:
-      break;
+      case CButtonState::MB_SHORT_CLICK:
+        bClick[i] = true;
+        bNothingDown = false;
+        break;
+      case CButtonState::MB_LONG_CLICK:
+        bLongClick[i] = true;
+        bNothingDown = false;
+        break;
+      case CButtonState::MB_DOUBLE_CLICK:
+        bDoubleClick[i] = true;
+        bNothingDown = false;
+        break;
+      case CButtonState::MB_DRAG_START:
+        bHold[i] = CButtonState::MB_DRAG_START;
+        bNothingDown = false;
+        break;
+      case CButtonState::MB_DRAG:
+        bHold[i] = CButtonState::MB_DRAG;
+        bNothingDown = false;
+        break;
+      case CButtonState::MB_DRAG_END:
+        bHold[i] = CButtonState::MB_DRAG_END;
+        bNothingDown = false;
+        break;
+      default:
+        break;
     }
   }
 
@@ -134,7 +153,7 @@ void CMouseStat::HandleEvent(XBMC_Event& newEvent)
   // ignore any mouse messages by default
   m_Key = KEY_MOUSE_NOOP;
 
-  for (int button=0; button<MOUSE_MAX_BUTTON; ++button)
+  for (int button = 0; button < MOUSE_MAX_BUTTON; ++button)
   {
     // The bClick array is set true if CButtonState::Update spots a click
     // i.e. a button down followed by a button up.
@@ -173,15 +192,15 @@ void CMouseStat::HandleEvent(XBMC_Event& newEvent)
     {
       switch (bHold[MOUSE_RIGHT_BUTTON])
       {
-      case CButtonState::MB_DRAG:
-        m_Key = KEY_MOUSE_RDRAG;
-        break;
-      case CButtonState::MB_DRAG_START:
-        m_Key = KEY_MOUSE_RDRAG_START;
-        break;
-      case CButtonState::MB_DRAG_END:
-        m_Key = KEY_MOUSE_RDRAG_END;
-        break;
+        case CButtonState::MB_DRAG:
+          m_Key = KEY_MOUSE_RDRAG;
+          break;
+        case CButtonState::MB_DRAG_START:
+          m_Key = KEY_MOUSE_RDRAG_START;
+          break;
+        case CButtonState::MB_DRAG_END:
+          m_Key = KEY_MOUSE_RDRAG_END;
+          break;
       }
     }
 
@@ -226,7 +245,8 @@ void CMouseStat::SetActive(bool active /*=true*/)
   // 3. XBMC is not in fullscreen.
   CWinSystemBase* winSystem = CServiceBroker::GetWinSystem();
   if (winSystem)
-    winSystem->ShowOSMouse(m_mouseState.active && !IsEnabled() && !CServiceBroker::GetWinSystem()->IsFullScreen());
+    winSystem->ShowOSMouse(m_mouseState.active && !IsEnabled() &&
+                           !CServiceBroker::GetWinSystem()->IsFullScreen());
 }
 
 // IsActive - returns true if we have been active in the last MOUSE_ACTIVE_LENGTH period
@@ -251,7 +271,8 @@ bool CMouseStat::IsEnabled() const
 
 bool CMouseStat::MovedPastThreshold() const
 {
-  return (m_mouseState.dx * m_mouseState.dx + m_mouseState.dy * m_mouseState.dy >= MOUSE_MINIMUM_MOVEMENT * MOUSE_MINIMUM_MOVEMENT);
+  return (m_mouseState.dx * m_mouseState.dx + m_mouseState.dy * m_mouseState.dy >=
+          MOUSE_MINIMUM_MOVEMENT * MOUSE_MINIMUM_MOVEMENT);
 }
 
 uint32_t CMouseStat::GetKey() const
@@ -262,7 +283,8 @@ uint32_t CMouseStat::GetKey() const
 int CMouseStat::GetHold(int ButtonID) const
 {
   switch (ButtonID)
-  { case MOUSE_LEFT_BUTTON:
+  {
+    case MOUSE_LEFT_BUTTON:
       return bHold[MOUSE_LEFT_BUTTON];
   }
   return false;
@@ -280,10 +302,13 @@ bool CMouseStat::CButtonState::InClickRange(int x, int y) const
 {
   int dx = x - m_x;
   int dy = y - m_y;
-  return (unsigned int)(dx*dx + dy*dy) <= click_confines*click_confines;
+  return (unsigned int)(dx * dx + dy * dy) <= click_confines * click_confines;
 }
 
-CMouseStat::CButtonState::BUTTON_ACTION CMouseStat::CButtonState::Update(unsigned int time, int x, int y, bool down)
+CMouseStat::CButtonState::BUTTON_ACTION CMouseStat::CButtonState::Update(unsigned int time,
+                                                                         int x,
+                                                                         int y,
+                                                                         bool down)
 {
   if (m_state == STATE_IN_DRAG)
   {
@@ -306,7 +331,7 @@ CMouseStat::CButtonState::BUTTON_ACTION CMouseStat::CButtonState::Update(unsigne
   {
     if (down)
     {
-      if (!InClickRange(x,y))
+      if (!InClickRange(x, y))
       { // beginning a drag
         m_state = STATE_IN_DRAG;
         return MB_DRAG_START;
@@ -318,7 +343,7 @@ CMouseStat::CButtonState::BUTTON_ACTION CMouseStat::CButtonState::Update(unsigne
       { // single click
         m_state = STATE_IN_DOUBLE_CLICK;
         m_time = time; // double click time and positioning is measured from the
-        m_x = x;       // end of a single click
+        m_x = x; // end of a single click
         m_y = y;
         return MB_SHORT_CLICK;
       }
@@ -331,8 +356,9 @@ CMouseStat::CButtonState::BUTTON_ACTION CMouseStat::CButtonState::Update(unsigne
   }
   else if (m_state == STATE_IN_DOUBLE_CLICK)
   {
-    if (time - m_time > double_click_time || !InClickRange(x,y))
-    { // too long, or moved to much - reset to released state and re-update, as we may be starting a new click
+    if (time - m_time > double_click_time || !InClickRange(x, y))
+    { // too long, or moved to much - reset to released state and re-update, as we may be starting a
+      // new click
       m_state = STATE_RELEASED;
       return Update(time, x, y, down);
     }
@@ -350,4 +376,3 @@ CMouseStat::CButtonState::BUTTON_ACTION CMouseStat::CButtonState::Update(unsigne
 
   return MB_NONE;
 }
-
diff --git a/xbmc/input/mouse/MouseStat.h b/xbmc/input/mouse/MouseStat.h
index ab3a45ce438b..e44fd3eb6971 100644
--- a/xbmc/input/mouse/MouseStat.h
+++ b/xbmc/input/mouse/MouseStat.h
@@ -10,36 +10,36 @@
 
 #include "windowing/XBMC_events.h"
 
-#define XBMC_BUTTON(X)		(1 << ((X)-1))
-#define XBMC_BUTTON_LEFT		1
-#define XBMC_BUTTON_MIDDLE	2
-#define XBMC_BUTTON_RIGHT	3
-#define XBMC_BUTTON_WHEELUP	4
-#define XBMC_BUTTON_WHEELDOWN	5
-#define XBMC_BUTTON_X1		6
-#define XBMC_BUTTON_X2		7
-#define XBMC_BUTTON_X3		8
-#define XBMC_BUTTON_X4		9
-#define XBMC_BUTTON_LMASK	XBMC_BUTTON(XBMC_BUTTON_LEFT)
-#define XBMC_BUTTON_MMASK	XBMC_BUTTON(XBMC_BUTTON_MIDDLE)
-#define XBMC_BUTTON_RMASK	XBMC_BUTTON(XBMC_BUTTON_RIGHT)
-#define XBMC_BUTTON_X1MASK	XBMC_BUTTON(XBMC_BUTTON_X1)
-#define XBMC_BUTTON_X2MASK	XBMC_BUTTON(XBMC_BUTTON_X2)
-#define XBMC_BUTTON_X3MASK	XBMC_BUTTON(XBMC_BUTTON_X3)
-#define XBMC_BUTTON_X4MASK	XBMC_BUTTON(XBMC_BUTTON_X4)
+#define XBMC_BUTTON(X) (1 << ((X)-1))
+#define XBMC_BUTTON_LEFT 1
+#define XBMC_BUTTON_MIDDLE 2
+#define XBMC_BUTTON_RIGHT 3
+#define XBMC_BUTTON_WHEELUP 4
+#define XBMC_BUTTON_WHEELDOWN 5
+#define XBMC_BUTTON_X1 6
+#define XBMC_BUTTON_X2 7
+#define XBMC_BUTTON_X3 8
+#define XBMC_BUTTON_X4 9
+#define XBMC_BUTTON_LMASK XBMC_BUTTON(XBMC_BUTTON_LEFT)
+#define XBMC_BUTTON_MMASK XBMC_BUTTON(XBMC_BUTTON_MIDDLE)
+#define XBMC_BUTTON_RMASK XBMC_BUTTON(XBMC_BUTTON_RIGHT)
+#define XBMC_BUTTON_X1MASK XBMC_BUTTON(XBMC_BUTTON_X1)
+#define XBMC_BUTTON_X2MASK XBMC_BUTTON(XBMC_BUTTON_X2)
+#define XBMC_BUTTON_X3MASK XBMC_BUTTON(XBMC_BUTTON_X3)
+#define XBMC_BUTTON_X4MASK XBMC_BUTTON(XBMC_BUTTON_X4)
 
 #define MOUSE_MINIMUM_MOVEMENT 2
 #define MOUSE_DOUBLE_CLICK_LENGTH 500L
-#define MOUSE_ACTIVE_LENGTH   5000L
+#define MOUSE_ACTIVE_LENGTH 5000L
 
 #define MOUSE_MAX_BUTTON 7
 
 enum MOUSE_STATE
 {
   MOUSE_STATE_NORMAL = 1, /*! < Normal state */
-  MOUSE_STATE_FOCUS,      /*! < Control below the mouse is currently in focus */
-  MOUSE_STATE_DRAG,       /*! < A drag operation is being performed */
-  MOUSE_STATE_CLICK       /*! < A mousebutton is being clicked */
+  MOUSE_STATE_FOCUS, /*! < Control below the mouse is currently in focus */
+  MOUSE_STATE_DRAG, /*! < A drag operation is being performed */
+  MOUSE_STATE_CLICK /*! < A mousebutton is being clicked */
 };
 
 enum MOUSE_BUTTON
@@ -56,13 +56,13 @@ enum MOUSE_BUTTON
 // this holds everything we know about the current state of the mouse
 struct MouseState
 {
-  int x;              // x location
-  int y;              // y location
-  int16_t dx;         // change in x
-  int16_t dy;         // change in y
-  int8_t dz;          // change in z (wheel)
-  bool button[MOUSE_MAX_BUTTON];     // current state of the buttons
-  bool active;        // true if the mouse is active
+  int x; // x location
+  int y; // y location
+  int16_t dx; // change in x
+  int16_t dy; // change in y
+  int8_t dz; // change in z (wheel)
+  bool button[MOUSE_MAX_BUTTON]; // current state of the buttons
+  bool active; // true if the mouse is active
 };
 
 struct MousePosition
@@ -96,7 +96,7 @@ class CMouseStat
   inline int GetY(void) const { return m_mouseState.y; }
   inline int GetDX(void) const { return m_mouseState.dx; }
   inline int GetDY(void) const { return m_mouseState.dy; }
-  MousePosition GetPosition() { return MousePosition{ m_mouseState.x, m_mouseState.y }; }
+  MousePosition GetPosition() { return MousePosition{m_mouseState.x, m_mouseState.y}; }
 
 private:
   /*! \brief Holds information regarding a particular mouse button state
@@ -106,9 +106,12 @@ class CMouseStat
    is handled by the Update() function.
 
    The actions we detect are:
-    * short clicks - down/up press of the mouse within short_click_time ms, where the pointer stays within click_confines pixels
-    * long clicks - down/up press of the mouse greater than short_click_time ms, where the pointers stays within click_confines pixels
-    * double clicks - a further down press of the mouse within double_click_time of the up press of a short click, where the pointer stays within click_confines pixels
+    * short clicks - down/up press of the mouse within short_click_time ms, where the pointer stays
+   within click_confines pixels
+    * long clicks - down/up press of the mouse greater than short_click_time ms, where the pointers
+   stays within click_confines pixels
+    * double clicks - a further down press of the mouse within double_click_time of the up press of
+   a short click, where the pointer stays within click_confines pixels
     * drag - the mouse is down and has been moved more than click_confines pixels
 
    \sa CMouseStat
@@ -118,17 +121,21 @@ class CMouseStat
   public:
     /*! \brief enum for the actions to perform as a result of an Update function
      */
-    enum BUTTON_ACTION { MB_NONE = 0,      ///< no action should occur
-                         MB_SHORT_CLICK,   ///< a short click has occurred (a double click may be in process)
-                         MB_LONG_CLICK,    ///< a long click has occurred
-                         MB_DOUBLE_CLICK,  ///< a double click has occurred
-                         MB_DRAG_START,    ///< a drag action has started
-                         MB_DRAG,          ///< a drag action is in progress
-                         MB_DRAG_END };    ///< a drag action has finished
+    enum BUTTON_ACTION
+    {
+      MB_NONE = 0, ///< no action should occur
+      MB_SHORT_CLICK, ///< a short click has occurred (a double click may be in process)
+      MB_LONG_CLICK, ///< a long click has occurred
+      MB_DOUBLE_CLICK, ///< a double click has occurred
+      MB_DRAG_START, ///< a drag action has started
+      MB_DRAG, ///< a drag action is in progress
+      MB_DRAG_END
+    }; ///< a drag action has finished
 
     CButtonState();
 
-    /*! \brief Update the button state, with where the mouse is, and whether the button is down or not
+    /*! \brief Update the button state, with where the mouse is, and whether the button is down or
+     not
 
      \param time frame time in ms
      \param x horizontal coordinate of the mouse
@@ -137,18 +144,25 @@ class CMouseStat
      \return action that should be performed
      */
     BUTTON_ACTION Update(unsigned int time, int x, int y, bool down);
+
   private:
-    static const unsigned int click_confines = 5;        ///< number of pixels that the pointer may move while the button is down to trigger a click
-    static const unsigned int short_click_time = 1000;   ///< time for mouse down/up to trigger a short click rather than a long click
-    static const unsigned int double_click_time = 500;   ///< time for mouse down following a short click to trigger a double click
+    static const unsigned int click_confines = 5; ///< number of pixels that the pointer may move
+                                                  ///< while the button is down to trigger a click
+    static const unsigned int short_click_time =
+        1000; ///< time for mouse down/up to trigger a short click rather than a long click
+    static const unsigned int double_click_time =
+        500; ///< time for mouse down following a short click to trigger a double click
 
     bool InClickRange(int x, int y) const;
 
-    enum BUTTON_STATE { STATE_RELEASED = 0,       ///< mouse button is released, no events pending
-                        STATE_IN_CLICK,           ///< mouse button is down, a click is pending
-                        STATE_IN_DOUBLE_CLICK,    ///< mouse button is released, pending double click
-                        STATE_IN_DOUBLE_IGNORE,   ///< mouse button is down following double click
-                        STATE_IN_DRAG };          ///< mouse button is down during a drag
+    enum BUTTON_STATE
+    {
+      STATE_RELEASED = 0, ///< mouse button is released, no events pending
+      STATE_IN_CLICK, ///< mouse button is down, a click is pending
+      STATE_IN_DOUBLE_CLICK, ///< mouse button is released, pending double click
+      STATE_IN_DOUBLE_IGNORE, ///< mouse button is down following double click
+      STATE_IN_DRAG
+    }; ///< mouse button is down during a drag
 
     BUTTON_STATE m_state;
     unsigned int m_time;
@@ -180,9 +194,8 @@ class CMouseStat
 
   bool bClick[MOUSE_MAX_BUTTON];
   bool bDoubleClick[MOUSE_MAX_BUTTON];
-  int  bHold[MOUSE_MAX_BUTTON];
+  int bHold[MOUSE_MAX_BUTTON];
   bool bLongClick[MOUSE_MAX_BUTTON];
 
   uint32_t m_Key;
 };
-
diff --git a/xbmc/input/mouse/MouseTranslator.cpp b/xbmc/input/mouse/MouseTranslator.cpp
index 9fad2c2f107c..501cec72b712 100644
--- a/xbmc/input/mouse/MouseTranslator.cpp
+++ b/xbmc/input/mouse/MouseTranslator.cpp
@@ -26,28 +26,25 @@ namespace
 using ActionName = std::string;
 using KeyID = uint32_t;
 
-static const std::map<ActionName, KeyID> MouseKeys =
-{
-    { "click"                    , KEY_MOUSE_CLICK },
-    { "leftclick"                , KEY_MOUSE_CLICK },
-    { "rightclick"               , KEY_MOUSE_RIGHTCLICK },
-    { "middleclick"              , KEY_MOUSE_MIDDLECLICK },
-    { "doubleclick"              , KEY_MOUSE_DOUBLE_CLICK },
-    { "longclick"                , KEY_MOUSE_LONG_CLICK },
-    { "wheelup"                  , KEY_MOUSE_WHEEL_UP },
-    { "wheeldown"                , KEY_MOUSE_WHEEL_DOWN },
-    { "mousemove"                , KEY_MOUSE_MOVE },
-    { "mousedrag"                , KEY_MOUSE_DRAG },
-    { "mousedragstart"           , KEY_MOUSE_DRAG_START },
-    { "mousedragend"             , KEY_MOUSE_DRAG_END },
-    { "mouserdrag"               , KEY_MOUSE_RDRAG },
-    { "mouserdragstart"          , KEY_MOUSE_RDRAG_START },
-    { "mouserdragend"            , KEY_MOUSE_RDRAG_END }
-};
+static const std::map<ActionName, KeyID> MouseKeys = {{"click", KEY_MOUSE_CLICK},
+                                                      {"leftclick", KEY_MOUSE_CLICK},
+                                                      {"rightclick", KEY_MOUSE_RIGHTCLICK},
+                                                      {"middleclick", KEY_MOUSE_MIDDLECLICK},
+                                                      {"doubleclick", KEY_MOUSE_DOUBLE_CLICK},
+                                                      {"longclick", KEY_MOUSE_LONG_CLICK},
+                                                      {"wheelup", KEY_MOUSE_WHEEL_UP},
+                                                      {"wheeldown", KEY_MOUSE_WHEEL_DOWN},
+                                                      {"mousemove", KEY_MOUSE_MOVE},
+                                                      {"mousedrag", KEY_MOUSE_DRAG},
+                                                      {"mousedragstart", KEY_MOUSE_DRAG_START},
+                                                      {"mousedragend", KEY_MOUSE_DRAG_END},
+                                                      {"mouserdrag", KEY_MOUSE_RDRAG},
+                                                      {"mouserdragstart", KEY_MOUSE_RDRAG_START},
+                                                      {"mouserdragend", KEY_MOUSE_RDRAG_END}};
 
 } // anonymous namespace
 
-uint32_t CMouseTranslator::TranslateCommand(const TiXmlElement *pButton)
+uint32_t CMouseTranslator::TranslateCommand(const TiXmlElement* pButton)
 {
   uint32_t buttonId = 0;
 
@@ -81,57 +78,57 @@ uint32_t CMouseTranslator::TranslateCommand(const TiXmlElement *pButton)
   return buttonId;
 }
 
-bool CMouseTranslator::TranslateEventID(unsigned int eventId, BUTTON_ID &buttonId)
+bool CMouseTranslator::TranslateEventID(unsigned int eventId, BUTTON_ID& buttonId)
 {
   switch (eventId)
   {
-  case XBMC_BUTTON_LEFT:
-  {
-    buttonId = BUTTON_ID::LEFT;
-    return true;
-  }
-  case XBMC_BUTTON_MIDDLE:
-  {
-    buttonId = BUTTON_ID::MIDDLE;
-    return true;
-  }
-  case XBMC_BUTTON_RIGHT:
-  {
-    buttonId = BUTTON_ID::RIGHT;
-    return true;
-  }
-  case XBMC_BUTTON_WHEELUP:
-  {
-    buttonId = BUTTON_ID::WHEEL_UP;
-    return true;
-  }
-  case XBMC_BUTTON_WHEELDOWN:
-  {
-    buttonId = BUTTON_ID::WHEEL_DOWN;
-    return true;
-  }
-  case XBMC_BUTTON_X1:
-  {
-    buttonId = BUTTON_ID::BUTTON4;
-    return true;
-  }
-  case XBMC_BUTTON_X2:
-  {
-    buttonId = BUTTON_ID::BUTTON5;
-    return true;
-  }
-  case XBMC_BUTTON_X3:
-  {
-    buttonId = BUTTON_ID::HORIZ_WHEEL_LEFT;
-    return true;
-  }
-  case XBMC_BUTTON_X4:
-  {
-    buttonId = BUTTON_ID::HORIZ_WHEEL_RIGHT;
-    return true;
-  }
-  default:
-    break;
+    case XBMC_BUTTON_LEFT:
+    {
+      buttonId = BUTTON_ID::LEFT;
+      return true;
+    }
+    case XBMC_BUTTON_MIDDLE:
+    {
+      buttonId = BUTTON_ID::MIDDLE;
+      return true;
+    }
+    case XBMC_BUTTON_RIGHT:
+    {
+      buttonId = BUTTON_ID::RIGHT;
+      return true;
+    }
+    case XBMC_BUTTON_WHEELUP:
+    {
+      buttonId = BUTTON_ID::WHEEL_UP;
+      return true;
+    }
+    case XBMC_BUTTON_WHEELDOWN:
+    {
+      buttonId = BUTTON_ID::WHEEL_DOWN;
+      return true;
+    }
+    case XBMC_BUTTON_X1:
+    {
+      buttonId = BUTTON_ID::BUTTON4;
+      return true;
+    }
+    case XBMC_BUTTON_X2:
+    {
+      buttonId = BUTTON_ID::BUTTON5;
+      return true;
+    }
+    case XBMC_BUTTON_X3:
+    {
+      buttonId = BUTTON_ID::HORIZ_WHEEL_LEFT;
+      return true;
+    }
+    case XBMC_BUTTON_X4:
+    {
+      buttonId = BUTTON_ID::HORIZ_WHEEL_RIGHT;
+      return true;
+    }
+    default:
+      break;
   }
 
   return false;
diff --git a/xbmc/input/mouse/MouseTranslator.h b/xbmc/input/mouse/MouseTranslator.h
index 22af5a118ecc..e3d4d4b906dc 100644
--- a/xbmc/input/mouse/MouseTranslator.h
+++ b/xbmc/input/mouse/MouseTranslator.h
@@ -20,7 +20,7 @@ class CMouseTranslator
   /*!
    * \brief Translate a keymap element to a key ID
    */
-  static uint32_t TranslateCommand(const TiXmlElement *pButton);
+  static uint32_t TranslateCommand(const TiXmlElement* pButton);
 
   /*!
    * \brief Translate a mouse event ID to a mouse button index
@@ -30,5 +30,5 @@ class CMouseTranslator
    *
    * \return True if successful, false otherwise
    */
-  static bool TranslateEventID(unsigned int eventId, KODI::MOUSE::BUTTON_ID &buttonId);
+  static bool TranslateEventID(unsigned int eventId, KODI::MOUSE::BUTTON_ID& buttonId);
 };
diff --git a/xbmc/input/mouse/MouseTypes.h b/xbmc/input/mouse/MouseTypes.h
index a12221b05609..f11f7ea1edb3 100644
--- a/xbmc/input/mouse/MouseTypes.h
+++ b/xbmc/input/mouse/MouseTypes.h
@@ -16,40 +16,40 @@ namespace KODI
 {
 namespace MOUSE
 {
-  /*!
-   * \brief Buttons on a mouse
-   */
-  enum class BUTTON_ID
-  {
-    UNKNOWN,
-    LEFT,
-    RIGHT,
-    MIDDLE,
-    BUTTON4,
-    BUTTON5,
-    WHEEL_UP,
-    WHEEL_DOWN,
-    HORIZ_WHEEL_LEFT,
-    HORIZ_WHEEL_RIGHT,
-  };
+/*!
+ * \brief Buttons on a mouse
+ */
+enum class BUTTON_ID
+{
+  UNKNOWN,
+  LEFT,
+  RIGHT,
+  MIDDLE,
+  BUTTON4,
+  BUTTON5,
+  WHEEL_UP,
+  WHEEL_DOWN,
+  HORIZ_WHEEL_LEFT,
+  HORIZ_WHEEL_RIGHT,
+};
 
-  /*!
-   * \brief Name of a mouse button
-   *
-   * Names are defined in the mouse's controller profile.
-   */
-  using ButtonName = std::string;
+/*!
+ * \brief Name of a mouse button
+ *
+ * Names are defined in the mouse's controller profile.
+ */
+using ButtonName = std::string;
 
-  /*!
-   * \brief Directions of motion for a mouse pointer
-   */
-  using POINTER_DIRECTION = INPUT::CARDINAL_DIRECTION;
+/*!
+ * \brief Directions of motion for a mouse pointer
+ */
+using POINTER_DIRECTION = INPUT::CARDINAL_DIRECTION;
 
-  /*!
-   * \brief Name of the mouse pointer
-   *
-   * Names are defined in the mouse's controller profile.
-   */
-  using PointerName = std::string;
-}
-}
+/*!
+ * \brief Name of the mouse pointer
+ *
+ * Names are defined in the mouse's controller profile.
+ */
+using PointerName = std::string;
+} // namespace MOUSE
+} // namespace KODI
diff --git a/xbmc/input/mouse/generic/MouseInputHandling.cpp b/xbmc/input/mouse/generic/MouseInputHandling.cpp
index 54170c5d5d49..0f51edeedb3a 100644
--- a/xbmc/input/mouse/generic/MouseInputHandling.cpp
+++ b/xbmc/input/mouse/generic/MouseInputHandling.cpp
@@ -15,9 +15,9 @@
 using namespace KODI;
 using namespace MOUSE;
 
-CMouseInputHandling::CMouseInputHandling(IMouseInputHandler* handler, JOYSTICK::IButtonMap* buttonMap) :
-  m_handler(handler),
-  m_buttonMap(buttonMap)
+CMouseInputHandling::CMouseInputHandling(IMouseInputHandler* handler,
+                                         JOYSTICK::IButtonMap* buttonMap)
+  : m_handler(handler), m_buttonMap(buttonMap)
 {
 }
 
@@ -64,7 +64,7 @@ bool CMouseInputHandling::OnPosition(int x, int y)
         dy *= -1;
 
         // Perform rotation
-        int rotation[2][2] = { {1, 0}, {0, 1} };
+        int rotation[2][2] = {{1, 0}, {0, 1}};
 
         GetRotation(dir, target.PointerDirection(), rotation);
 
@@ -74,7 +74,7 @@ bool CMouseInputHandling::OnPosition(int x, int y)
         if (targetCCW.IsValid())
         {
           // Perform reflection
-          int reflection[2][2] = { {1, 0}, {0, 1} };
+          int reflection[2][2] = {{1, 0}, {0, 1}};
 
           GetReflectionCCW(target.PointerDirection(), targetCCW.PointerDirection(), reflection);
 
@@ -134,185 +134,193 @@ POINTER_DIRECTION CMouseInputHandling::GetOrthogonalDirectionCCW(POINTER_DIRECTI
 {
   switch (direction)
   {
-  case POINTER_DIRECTION::RIGHT: return POINTER_DIRECTION::UP;
-  case POINTER_DIRECTION::UP: return POINTER_DIRECTION::LEFT;
-  case POINTER_DIRECTION::LEFT: return POINTER_DIRECTION::DOWN;
-  case POINTER_DIRECTION::DOWN: return POINTER_DIRECTION::RIGHT;
+    case POINTER_DIRECTION::RIGHT:
+      return POINTER_DIRECTION::UP;
+    case POINTER_DIRECTION::UP:
+      return POINTER_DIRECTION::LEFT;
+    case POINTER_DIRECTION::LEFT:
+      return POINTER_DIRECTION::DOWN;
+    case POINTER_DIRECTION::DOWN:
+      return POINTER_DIRECTION::RIGHT;
     default:
-    break;
+      break;
   }
 
   return POINTER_DIRECTION::NONE;
 }
 
-void CMouseInputHandling::GetRotation(POINTER_DIRECTION source, POINTER_DIRECTION target, int (&rotation)[2][2])
+void CMouseInputHandling::GetRotation(POINTER_DIRECTION source,
+                                      POINTER_DIRECTION target,
+                                      int (&rotation)[2][2])
 {
   switch (source)
   {
-  case POINTER_DIRECTION::RIGHT:
-  {
-    switch (target)
+    case POINTER_DIRECTION::RIGHT:
     {
+      switch (target)
+      {
+        case POINTER_DIRECTION::UP:
+          GetRotation(90, rotation);
+          break;
+        case POINTER_DIRECTION::LEFT:
+          GetRotation(180, rotation);
+          break;
+        case POINTER_DIRECTION::DOWN:
+          GetRotation(270, rotation);
+          break;
+        default:
+          break;
+      }
+      break;
+    }
     case POINTER_DIRECTION::UP:
-      GetRotation(90, rotation);
+    {
+      switch (target)
+      {
+        case POINTER_DIRECTION::LEFT:
+          GetRotation(90, rotation);
+          break;
+        case POINTER_DIRECTION::DOWN:
+          GetRotation(180, rotation);
+          break;
+        case POINTER_DIRECTION::RIGHT:
+          GetRotation(270, rotation);
+          break;
+        default:
+          break;
+      }
       break;
+    }
     case POINTER_DIRECTION::LEFT:
-      GetRotation(180, rotation);
+    {
+      switch (target)
+      {
+        case POINTER_DIRECTION::DOWN:
+          GetRotation(90, rotation);
+          break;
+        case POINTER_DIRECTION::RIGHT:
+          GetRotation(180, rotation);
+          break;
+        case POINTER_DIRECTION::UP:
+          GetRotation(270, rotation);
+          break;
+        default:
+          break;
+      }
       break;
+    }
     case POINTER_DIRECTION::DOWN:
-      GetRotation(270, rotation);
+    {
+      switch (target)
+      {
+        case POINTER_DIRECTION::RIGHT:
+          GetRotation(90, rotation);
+          break;
+        case POINTER_DIRECTION::UP:
+          GetRotation(180, rotation);
+          break;
+        case POINTER_DIRECTION::LEFT:
+          GetRotation(270, rotation);
+          break;
+        default:
+          break;
+      }
       break;
+    }
     default:
       break;
-    }
-    break;
   }
-  case POINTER_DIRECTION::UP:
+}
+
+void CMouseInputHandling::GetRotation(int deg, int (&rotation)[2][2])
+{
+  switch (deg)
   {
-    switch (target)
+    case 90:
     {
-    case POINTER_DIRECTION::LEFT:
-      GetRotation(90, rotation);
-      break;
-    case POINTER_DIRECTION::DOWN:
-      GetRotation(180, rotation);
-      break;
-    case POINTER_DIRECTION::RIGHT:
-      GetRotation(270, rotation);
-      break;
-    default:
+      rotation[0][0] = 0;
+      rotation[0][1] = -1;
+      rotation[1][0] = 1;
+      rotation[1][1] = 0;
       break;
     }
-    break;
-  }
-  case POINTER_DIRECTION::LEFT:
-  {
-    switch (target)
+    case 180:
     {
-    case POINTER_DIRECTION::DOWN:
-      GetRotation(90, rotation);
-      break;
-    case POINTER_DIRECTION::RIGHT:
-      GetRotation(180, rotation);
-      break;
-    case POINTER_DIRECTION::UP:
-      GetRotation(270, rotation);
-      break;
-    default:
+      rotation[0][0] = -1;
+      rotation[0][1] = 0;
+      rotation[1][0] = 0;
+      rotation[1][1] = -1;
       break;
     }
-    break;
-  }
-  case POINTER_DIRECTION::DOWN:
-  {
-    switch (target)
+    case 270:
     {
-    case POINTER_DIRECTION::RIGHT:
-      GetRotation(90, rotation);
-      break;
-    case POINTER_DIRECTION::UP:
-      GetRotation(180, rotation);
-      break;
-    case POINTER_DIRECTION::LEFT:
-      GetRotation(270, rotation);
+      rotation[0][0] = 0;
+      rotation[0][1] = 1;
+      rotation[1][0] = -1;
+      rotation[1][1] = 0;
       break;
+    }
     default:
       break;
-    }
-    break;
-  }
-  default:
-    break;
-  }
-}
-
-void CMouseInputHandling::GetRotation(int deg, int (&rotation)[2][2])
-{
-  switch (deg)
-  {
-  case 90:
-  {
-    rotation[0][0] = 0;
-    rotation[0][1] = -1;
-    rotation[1][0] = 1;
-    rotation[1][1] = 0;
-    break;
-  }
-  case 180:
-  {
-    rotation[0][0] = -1;
-    rotation[0][1] = 0;
-    rotation[1][0] = 0;
-    rotation[1][1] = -1;
-    break;
-  }
-  case 270:
-  {
-    rotation[0][0] = 0;
-    rotation[0][1] = 1;
-    rotation[1][0] = -1;
-    rotation[1][1] = 0;
-    break;
-  }
-  default:
-    break;
   }
 }
 
-void CMouseInputHandling::GetReflectionCCW(POINTER_DIRECTION source, POINTER_DIRECTION target, int (&rotation)[2][2])
+void CMouseInputHandling::GetReflectionCCW(POINTER_DIRECTION source,
+                                           POINTER_DIRECTION target,
+                                           int (&rotation)[2][2])
 {
   switch (source)
   {
-  case POINTER_DIRECTION::RIGHT:
-  {
-    switch (target)
+    case POINTER_DIRECTION::RIGHT:
     {
-    case POINTER_DIRECTION::DOWN:
-      GetReflection(0, rotation);
-      break;
-    default:
+      switch (target)
+      {
+        case POINTER_DIRECTION::DOWN:
+          GetReflection(0, rotation);
+          break;
+        default:
+          break;
+      }
       break;
     }
-    break;
-  }
-  case POINTER_DIRECTION::UP:
-  {
-    switch (target)
+    case POINTER_DIRECTION::UP:
     {
-    case POINTER_DIRECTION::RIGHT:
-      GetReflection(90, rotation);
-      break;
-    default:
+      switch (target)
+      {
+        case POINTER_DIRECTION::RIGHT:
+          GetReflection(90, rotation);
+          break;
+        default:
+          break;
+      }
       break;
     }
-    break;
-  }
-  case POINTER_DIRECTION::LEFT:
-  {
-    switch (target)
+    case POINTER_DIRECTION::LEFT:
     {
-    case POINTER_DIRECTION::UP:
-      GetReflection(180, rotation);
-      break;
-    default:
+      switch (target)
+      {
+        case POINTER_DIRECTION::UP:
+          GetReflection(180, rotation);
+          break;
+        default:
+          break;
+      }
       break;
     }
-    break;
-  }
-  case POINTER_DIRECTION::DOWN:
-  {
-    switch (target)
+    case POINTER_DIRECTION::DOWN:
     {
-    case POINTER_DIRECTION::LEFT:
-      GetReflection(270, rotation);
+      switch (target)
+      {
+        case POINTER_DIRECTION::LEFT:
+          GetReflection(270, rotation);
+          break;
+        default:
+          break;
+      }
       break;
+    }
     default:
       break;
-    }
-    break;
-  }
-  default:
-    break;
   }
 }
 
@@ -320,25 +328,25 @@ void CMouseInputHandling::GetReflection(int deg, int (&reflection)[2][2])
 {
   switch (deg)
   {
-  case 0:
-  case 180:
-  {
-    reflection[0][0] = 1;
-    reflection[0][1] = 0;
-    reflection[1][0] = 0;
-    reflection[1][1] = -1;
-    break;
-  }
-  case 90:
-  case 270:
-  {
-    reflection[0][0] = -1;
-    reflection[0][1] = 0;
-    reflection[1][0] = 0;
-    reflection[1][1] = 1;
-    break;
-  }
-  default:
-    break;
+    case 0:
+    case 180:
+    {
+      reflection[0][0] = 1;
+      reflection[0][1] = 0;
+      reflection[1][0] = 0;
+      reflection[1][1] = -1;
+      break;
+    }
+    case 90:
+    case 270:
+    {
+      reflection[0][0] = -1;
+      reflection[0][1] = 0;
+      reflection[1][0] = 0;
+      reflection[1][1] = 1;
+      break;
+    }
+    default:
+      break;
   }
 }
diff --git a/xbmc/input/mouse/generic/MouseInputHandling.h b/xbmc/input/mouse/generic/MouseInputHandling.h
index 18deeb7ebac0..6d19da906589 100644
--- a/xbmc/input/mouse/generic/MouseInputHandling.h
+++ b/xbmc/input/mouse/generic/MouseInputHandling.h
@@ -15,48 +15,52 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IButtonMap;
+class IButtonMap;
 }
 
 namespace MOUSE
 {
-  class IMouseInputHandler;
-
-  /*!
-   * \ingroup mouse
-   * \brief Class to translate input from driver info to higher-level features
-   */
-  class CMouseInputHandling : public IMouseDriverHandler
-  {
-  public:
-    CMouseInputHandling(IMouseInputHandler* handler, JOYSTICK::IButtonMap* buttonMap);
-
-    ~CMouseInputHandling(void) override = default;
-
-    // implementation of IMouseDriverHandler
-    bool OnPosition(int x, int y) override;
-    bool OnButtonPress(BUTTON_ID button) override;
-    void OnButtonRelease(BUTTON_ID button) override;
-
-  private:
-    // Utility functions
-    static POINTER_DIRECTION GetPointerDirection(int x, int y);
-    static POINTER_DIRECTION GetOrthogonalDirectionCCW(POINTER_DIRECTION direction);
-
-    static void GetRotation(POINTER_DIRECTION source, POINTER_DIRECTION target, int (&rotation)[2][2]);
-    static void GetRotation(int deg, int (&rotation)[2][2]);
-
-    static void GetReflectionCCW(POINTER_DIRECTION source, POINTER_DIRECTION target, int (&reflection)[2][2]);
-    static void GetReflection(int deg, int (&reflection)[2][2]);
-
-    // Construction parameters
-    IMouseInputHandler* const m_handler;
-    JOYSTICK::IButtonMap* const m_buttonMap;
-
-    // Mouse parameters
-    bool m_bHasPosition = false;
-    int m_x = 0;
-    int m_y = 0;
-  };
-}
-}
+class IMouseInputHandler;
+
+/*!
+ * \ingroup mouse
+ * \brief Class to translate input from driver info to higher-level features
+ */
+class CMouseInputHandling : public IMouseDriverHandler
+{
+public:
+  CMouseInputHandling(IMouseInputHandler* handler, JOYSTICK::IButtonMap* buttonMap);
+
+  ~CMouseInputHandling(void) override = default;
+
+  // implementation of IMouseDriverHandler
+  bool OnPosition(int x, int y) override;
+  bool OnButtonPress(BUTTON_ID button) override;
+  void OnButtonRelease(BUTTON_ID button) override;
+
+private:
+  // Utility functions
+  static POINTER_DIRECTION GetPointerDirection(int x, int y);
+  static POINTER_DIRECTION GetOrthogonalDirectionCCW(POINTER_DIRECTION direction);
+
+  static void GetRotation(POINTER_DIRECTION source,
+                          POINTER_DIRECTION target,
+                          int (&rotation)[2][2]);
+  static void GetRotation(int deg, int (&rotation)[2][2]);
+
+  static void GetReflectionCCW(POINTER_DIRECTION source,
+                               POINTER_DIRECTION target,
+                               int (&reflection)[2][2]);
+  static void GetReflection(int deg, int (&reflection)[2][2]);
+
+  // Construction parameters
+  IMouseInputHandler* const m_handler;
+  JOYSTICK::IButtonMap* const m_buttonMap;
+
+  // Mouse parameters
+  bool m_bHasPosition = false;
+  int m_x = 0;
+  int m_y = 0;
+};
+} // namespace MOUSE
+} // namespace KODI
diff --git a/xbmc/input/mouse/interfaces/IMouseDriverHandler.h b/xbmc/input/mouse/interfaces/IMouseDriverHandler.h
index fdd6b4c58e9b..7989e39465ad 100644
--- a/xbmc/input/mouse/interfaces/IMouseDriverHandler.h
+++ b/xbmc/input/mouse/interfaces/IMouseDriverHandler.h
@@ -14,43 +14,43 @@ namespace KODI
 {
 namespace MOUSE
 {
+/*!
+ * \ingroup mouse
+ * \brief Interface for handling mouse driver events
+ */
+class IMouseDriverHandler
+{
+public:
+  virtual ~IMouseDriverHandler(void) = default;
+
   /*!
-   * \ingroup mouse
-   * \brief Interface for handling mouse driver events
+   * \brief Handle mouse position updates
+   *
+   * \param x  The new x coordinate of the pointer
+   * \param y  The new y coordinate of the pointer
+   *
+   * The mouse uses a left-handed (graphics) cartesian coordinate system.
+   * Positive X is right, positive Y is down.
+   *
+   * \return True if the event was handled, false otherwise
    */
-  class IMouseDriverHandler
-  {
-  public:
-    virtual ~IMouseDriverHandler(void) = default;
-
-    /*!
-     * \brief Handle mouse position updates
-     *
-     * \param x  The new x coordinate of the pointer
-     * \param y  The new y coordinate of the pointer
-     *
-     * The mouse uses a left-handed (graphics) cartesian coordinate system.
-     * Positive X is right, positive Y is down.
-     *
-     * \return True if the event was handled, false otherwise
-     */
-    virtual bool OnPosition(int x, int y) = 0;
+  virtual bool OnPosition(int x, int y) = 0;
 
-    /*!
-     * \brief A mouse button has been pressed
-     *
-     * \param button   The index of the pressed button
-     *
-     * \return True if the event was handled, otherwise false
-     */
-    virtual bool OnButtonPress(BUTTON_ID button) = 0;
+  /*!
+   * \brief A mouse button has been pressed
+   *
+   * \param button   The index of the pressed button
+   *
+   * \return True if the event was handled, otherwise false
+   */
+  virtual bool OnButtonPress(BUTTON_ID button) = 0;
 
-    /*!
-     * \brief A mouse button has been released
-     *
-     * \param button   The index of the released button
-     */
-    virtual void OnButtonRelease(BUTTON_ID button) = 0;
-  };
-}
-}
+  /*!
+   * \brief A mouse button has been released
+   *
+   * \param button   The index of the released button
+   */
+  virtual void OnButtonRelease(BUTTON_ID button) = 0;
+};
+} // namespace MOUSE
+} // namespace KODI
diff --git a/xbmc/input/mouse/interfaces/IMouseInputHandler.h b/xbmc/input/mouse/interfaces/IMouseInputHandler.h
index 4083eb5ff256..910ddd4c1dd6 100644
--- a/xbmc/input/mouse/interfaces/IMouseInputHandler.h
+++ b/xbmc/input/mouse/interfaces/IMouseInputHandler.h
@@ -16,51 +16,51 @@ namespace KODI
 {
 namespace MOUSE
 {
+/*!
+ * \ingroup mouse
+ * \brief Interface for handling mouse events
+ */
+class IMouseInputHandler
+{
+public:
+  virtual ~IMouseInputHandler(void) = default;
+
   /*!
-   * \ingroup mouse
-   * \brief Interface for handling mouse events
+   * \brief The controller profile for this mouse input handler
+   *
+   * \return The ID of the add-on extending kodi.game.controller
    */
-  class IMouseInputHandler
-  {
-  public:
-    virtual ~IMouseInputHandler(void) = default;
+  virtual std::string ControllerID(void) const = 0;
 
-    /*!
-     * \brief The controller profile for this mouse input handler
-     *
-     * \return The ID of the add-on extending kodi.game.controller
-     */
-    virtual std::string ControllerID(void) const = 0;
-
-    /*!
-     * \brief A relative pointer has moved
-     *
-     * \param relpointer   The name of the relative pointer being moved
-     * \param dx           The relative x coordinate of motion
-     * \param dy           The relative y coordinate of motion
-     *
-     * The mouse uses a left-handed (graphics) cartesian coordinate system.
-     * Positive X is right, positive Y is down.
-     *
-     * \return True if the event was handled, otherwise false
-     */
-    virtual bool OnMotion(const PointerName& relpointer, int dx, int dy) = 0;
+  /*!
+   * \brief A relative pointer has moved
+   *
+   * \param relpointer   The name of the relative pointer being moved
+   * \param dx           The relative x coordinate of motion
+   * \param dy           The relative y coordinate of motion
+   *
+   * The mouse uses a left-handed (graphics) cartesian coordinate system.
+   * Positive X is right, positive Y is down.
+   *
+   * \return True if the event was handled, otherwise false
+   */
+  virtual bool OnMotion(const PointerName& relpointer, int dx, int dy) = 0;
 
-    /*!
-     * \brief A mouse button has been pressed
-     *
-     * \param button      The name of the feature being pressed
-     *
-     * \return True if the event was handled, otherwise false
-     */
-    virtual bool OnButtonPress(const ButtonName& button) = 0;
+  /*!
+   * \brief A mouse button has been pressed
+   *
+   * \param button      The name of the feature being pressed
+   *
+   * \return True if the event was handled, otherwise false
+   */
+  virtual bool OnButtonPress(const ButtonName& button) = 0;
 
-    /*!
-     * \brief A mouse button has been released
-     *
-     * \param button      The name of the feature being released
-     */
-    virtual void OnButtonRelease(const ButtonName& button) = 0;
-  };
-}
-}
+  /*!
+   * \brief A mouse button has been released
+   *
+   * \param button      The name of the feature being released
+   */
+  virtual void OnButtonRelease(const ButtonName& button) = 0;
+};
+} // namespace MOUSE
+} // namespace KODI
diff --git a/xbmc/input/mouse/interfaces/IMouseInputProvider.h b/xbmc/input/mouse/interfaces/IMouseInputProvider.h
index 7a734531d05a..f2890704dc91 100644
--- a/xbmc/input/mouse/interfaces/IMouseInputProvider.h
+++ b/xbmc/input/mouse/interfaces/IMouseInputProvider.h
@@ -12,32 +12,32 @@ namespace KODI
 {
 namespace MOUSE
 {
-  class IMouseInputHandler;
+class IMouseInputHandler;
+
+/*!
+ * \ingroup mouse
+ * \brief Interface for classes that can provide mouse input
+ */
+class IMouseInputProvider
+{
+public:
+  virtual ~IMouseInputProvider() = default;
 
   /*!
-   * \ingroup mouse
-   * \brief Interface for classes that can provide mouse input
+   * \brief Registers a handler to be called on mouse input
+   *
+   * \param handler The handler to receive mouse input provided by this class
+   * \param bPromiscuous True to observe all events without affecting
+   *        subsequent handlers
    */
-  class IMouseInputProvider
-  {
-  public:
-    virtual ~IMouseInputProvider() = default;
+  virtual void RegisterMouseHandler(IMouseInputHandler* handler, bool bPromiscuous) = 0;
 
-    /*!
-     * \brief Registers a handler to be called on mouse input
-     *
-     * \param handler The handler to receive mouse input provided by this class
-     * \param bPromiscuous True to observe all events without affecting
-     *        subsequent handlers
-     */
-    virtual void RegisterMouseHandler(IMouseInputHandler* handler, bool bPromiscuous) = 0;
-
-    /*!
-     * \brief Unregisters handler from mouse input
-     *
-     * \param handler The handler that was receiving mouse input
-     */
-    virtual void UnregisterMouseHandler(IMouseInputHandler* handler) = 0;
-  };
-}
-}
+  /*!
+   * \brief Unregisters handler from mouse input
+   *
+   * \param handler The handler that was receiving mouse input
+   */
+  virtual void UnregisterMouseHandler(IMouseInputHandler* handler) = 0;
+};
+} // namespace MOUSE
+} // namespace KODI
diff --git a/xbmc/input/remote/IRRemote.h b/xbmc/input/remote/IRRemote.h
index 7159f180f0c2..10eb52476b1c 100644
--- a/xbmc/input/remote/IRRemote.h
+++ b/xbmc/input/remote/IRRemote.h
@@ -8,83 +8,83 @@
 
 #pragma once
 
-#define XINPUT_IR_REMOTE_DISPLAY      213
-#define XINPUT_IR_REMOTE_REVERSE      226
-#define XINPUT_IR_REMOTE_PLAY         234
-#define XINPUT_IR_REMOTE_FORWARD      227
-#define XINPUT_IR_REMOTE_SKIP_MINUS   221
-#define XINPUT_IR_REMOTE_STOP         224
-#define XINPUT_IR_REMOTE_PAUSE        230
-#define XINPUT_IR_REMOTE_SKIP_PLUS    223
-#define XINPUT_IR_REMOTE_TITLE        229
-#define XINPUT_IR_REMOTE_INFO         195
-
-#define XINPUT_IR_REMOTE_UP           166
-#define XINPUT_IR_REMOTE_DOWN         167
-#define XINPUT_IR_REMOTE_LEFT         169
-#define XINPUT_IR_REMOTE_RIGHT        168
-
-#define XINPUT_IR_REMOTE_SELECT       11
-#define XINPUT_IR_REMOTE_ENTER        22
-
-#define XINPUT_IR_REMOTE_SUBTITLE     44
-#define XINPUT_IR_REMOTE_LANGUAGE     45
-
-#define XINPUT_IR_REMOTE_MENU         247
-#define XINPUT_IR_REMOTE_BACK         216
-
-#define XINPUT_IR_REMOTE_1            206
-#define XINPUT_IR_REMOTE_2            205
-#define XINPUT_IR_REMOTE_3            204
-#define XINPUT_IR_REMOTE_4            203
-#define XINPUT_IR_REMOTE_5            202
-#define XINPUT_IR_REMOTE_6            201
-#define XINPUT_IR_REMOTE_7            200
-#define XINPUT_IR_REMOTE_8            199
-#define XINPUT_IR_REMOTE_9            198
-#define XINPUT_IR_REMOTE_0            207
+#define XINPUT_IR_REMOTE_DISPLAY 213
+#define XINPUT_IR_REMOTE_REVERSE 226
+#define XINPUT_IR_REMOTE_PLAY 234
+#define XINPUT_IR_REMOTE_FORWARD 227
+#define XINPUT_IR_REMOTE_SKIP_MINUS 221
+#define XINPUT_IR_REMOTE_STOP 224
+#define XINPUT_IR_REMOTE_PAUSE 230
+#define XINPUT_IR_REMOTE_SKIP_PLUS 223
+#define XINPUT_IR_REMOTE_TITLE 229
+#define XINPUT_IR_REMOTE_INFO 195
+
+#define XINPUT_IR_REMOTE_UP 166
+#define XINPUT_IR_REMOTE_DOWN 167
+#define XINPUT_IR_REMOTE_LEFT 169
+#define XINPUT_IR_REMOTE_RIGHT 168
+
+#define XINPUT_IR_REMOTE_SELECT 11
+#define XINPUT_IR_REMOTE_ENTER 22
+
+#define XINPUT_IR_REMOTE_SUBTITLE 44
+#define XINPUT_IR_REMOTE_LANGUAGE 45
+
+#define XINPUT_IR_REMOTE_MENU 247
+#define XINPUT_IR_REMOTE_BACK 216
+
+#define XINPUT_IR_REMOTE_1 206
+#define XINPUT_IR_REMOTE_2 205
+#define XINPUT_IR_REMOTE_3 204
+#define XINPUT_IR_REMOTE_4 203
+#define XINPUT_IR_REMOTE_5 202
+#define XINPUT_IR_REMOTE_6 201
+#define XINPUT_IR_REMOTE_7 200
+#define XINPUT_IR_REMOTE_8 199
+#define XINPUT_IR_REMOTE_9 198
+#define XINPUT_IR_REMOTE_0 207
 
 // additional keys from the media center extender for xbox remote
-#define XINPUT_IR_REMOTE_POWER          196
-#define XINPUT_IR_REMOTE_MY_TV          49
-#define XINPUT_IR_REMOTE_MY_MUSIC       9
-#define XINPUT_IR_REMOTE_MY_PICTURES    6
-#define XINPUT_IR_REMOTE_MY_VIDEOS      7
-
-#define XINPUT_IR_REMOTE_RECORD         232
-
-#define XINPUT_IR_REMOTE_START          37
-#define XINPUT_IR_REMOTE_VOLUME_PLUS    208
-#define XINPUT_IR_REMOTE_VOLUME_MINUS   209
-#define XINPUT_IR_REMOTE_CHANNEL_PLUS   210
-#define XINPUT_IR_REMOTE_CHANNEL_MINUS  211
-#define XINPUT_IR_REMOTE_MUTE           192
-
-#define XINPUT_IR_REMOTE_RECORDED_TV    101
-#define XINPUT_IR_REMOTE_LIVE_TV        24
-#define XINPUT_IR_REMOTE_STAR           40
-#define XINPUT_IR_REMOTE_HASH           41
-#define XINPUT_IR_REMOTE_CLEAR          249
+#define XINPUT_IR_REMOTE_POWER 196
+#define XINPUT_IR_REMOTE_MY_TV 49
+#define XINPUT_IR_REMOTE_MY_MUSIC 9
+#define XINPUT_IR_REMOTE_MY_PICTURES 6
+#define XINPUT_IR_REMOTE_MY_VIDEOS 7
+
+#define XINPUT_IR_REMOTE_RECORD 232
+
+#define XINPUT_IR_REMOTE_START 37
+#define XINPUT_IR_REMOTE_VOLUME_PLUS 208
+#define XINPUT_IR_REMOTE_VOLUME_MINUS 209
+#define XINPUT_IR_REMOTE_CHANNEL_PLUS 210
+#define XINPUT_IR_REMOTE_CHANNEL_MINUS 211
+#define XINPUT_IR_REMOTE_MUTE 192
+
+#define XINPUT_IR_REMOTE_RECORDED_TV 101
+#define XINPUT_IR_REMOTE_LIVE_TV 24
+#define XINPUT_IR_REMOTE_STAR 40
+#define XINPUT_IR_REMOTE_HASH 41
+#define XINPUT_IR_REMOTE_CLEAR 249
 
 // additional keys not defined by xbox remotes but present on generic remotes
-#define XINPUT_IR_REMOTE_TELETEXT       250
-#define XINPUT_IR_REMOTE_RED            251
-#define XINPUT_IR_REMOTE_GREEN          252
-#define XINPUT_IR_REMOTE_YELLOW         253
-#define XINPUT_IR_REMOTE_BLUE           254
-#define XINPUT_IR_REMOTE_PLAYLIST       255
-#define XINPUT_IR_REMOTE_GUIDE          50
+#define XINPUT_IR_REMOTE_TELETEXT 250
+#define XINPUT_IR_REMOTE_RED 251
+#define XINPUT_IR_REMOTE_GREEN 252
+#define XINPUT_IR_REMOTE_YELLOW 253
+#define XINPUT_IR_REMOTE_BLUE 254
+#define XINPUT_IR_REMOTE_PLAYLIST 255
+#define XINPUT_IR_REMOTE_GUIDE 50
 
-#define XINPUT_IR_REMOTE_LIVE_RADIO     248
-#define XINPUT_IR_REMOTE_EPG_SEARCH     246
+#define XINPUT_IR_REMOTE_LIVE_RADIO 248
+#define XINPUT_IR_REMOTE_EPG_SEARCH 246
 
-#define XINPUT_IR_REMOTE_EJECT          235
-#define XINPUT_IR_REMOTE_CONTENTS_MENU  236
-#define XINPUT_IR_REMOTE_ROOT_MENU      237
-#define XINPUT_IR_REMOTE_TOP_MENU       238
-#define XINPUT_IR_REMOTE_DVD_MENU       239
+#define XINPUT_IR_REMOTE_EJECT 235
+#define XINPUT_IR_REMOTE_CONTENTS_MENU 236
+#define XINPUT_IR_REMOTE_ROOT_MENU 237
+#define XINPUT_IR_REMOTE_TOP_MENU 238
+#define XINPUT_IR_REMOTE_DVD_MENU 239
 
-#define XINPUT_IR_REMOTE_PRINT          240
+#define XINPUT_IR_REMOTE_PRINT 240
 
 // Reserved 256 -> ...
 // Key.h
@@ -93,9 +93,9 @@
 typedef struct _XINPUT_IR_REMOTE
 {
   unsigned char wButtons;
-  unsigned char region;   // just a guess
-  unsigned char counter;  // some value that is changing while a button is pressed... could be the state of the buffer
-  unsigned char firstEvent;  // > 0 - first event triggered after a button was pressed on the remote; 0 - not first event
-}
-XINPUT_IR_REMOTE, *PIR_REMOTE;
-
+  unsigned char region; // just a guess
+  unsigned char counter; // some value that is changing while a button is pressed... could be the
+                         // state of the buffer
+  unsigned char firstEvent; // > 0 - first event triggered after a button was pressed on the remote;
+                            // 0 - not first event
+} XINPUT_IR_REMOTE, *PIR_REMOTE;
diff --git a/xbmc/input/touch/ITouchActionHandler.h b/xbmc/input/touch/ITouchActionHandler.h
index 13e474f47586..156f9817f811 100644
--- a/xbmc/input/touch/ITouchActionHandler.h
+++ b/xbmc/input/touch/ITouchActionHandler.h
@@ -16,12 +16,13 @@
  *
  * These values can be combined (bitwise OR) to specify multiple directions.
  */
-typedef enum {
-  TouchMoveDirectionNone   = 0x0,
-  TouchMoveDirectionLeft   = 0x1,
-  TouchMoveDirectionRight  = 0x2,
-  TouchMoveDirectionUp     = 0x4,
-  TouchMoveDirectionDown   = 0x8
+typedef enum
+{
+  TouchMoveDirectionNone = 0x0,
+  TouchMoveDirectionLeft = 0x1,
+  TouchMoveDirectionRight = 0x2,
+  TouchMoveDirectionUp = 0x4,
+  TouchMoveDirectionDown = 0x8
 } TouchMoveDirection;
 
 /*!
@@ -36,7 +37,7 @@ class ITouchActionHandler
   /*!
    * \brief A touch action has been aborted
    */
-  virtual void OnTouchAbort() { };
+  virtual void OnTouchAbort(){};
 
   /*!
    * \brief A single touch has started
@@ -74,7 +75,11 @@ class ITouchActionHandler
    *
    * \sa OnTouchGesturePan
    */
-  virtual bool OnSingleTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) { return true; }
+  virtual bool OnSingleTouchMove(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+  {
+    return true;
+  }
   /*!
    * \brief A single touch has been lifted
    *
@@ -120,7 +125,16 @@ class ITouchActionHandler
    *
    * \return True if the event was handled otherwise false
    */
-  virtual bool OnMultiTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY, int32_t pointer) { return true; }
+  virtual bool OnMultiTouchMove(float x,
+                                float y,
+                                float offsetX,
+                                float offsetY,
+                                float velocityX,
+                                float velocityY,
+                                int32_t pointer)
+  {
+    return true;
+  }
   /*!
    * \brief A touch has been lifted (but there are still active touches)
    *
@@ -153,7 +167,11 @@ class ITouchActionHandler
    *
    * \return True if the event was handled otherwise false
    */
-  virtual bool OnTouchGesturePan(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) { return true; }
+  virtual bool OnTouchGesturePan(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+  {
+    return true;
+  }
   /*!
    * \brief A pan gesture with a single touch has ended
    *
@@ -166,7 +184,11 @@ class ITouchActionHandler
    *
    * \return True if the event was handled otherwise false
    */
-  virtual bool OnTouchGestureEnd(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) { return true; }
+  virtual bool OnTouchGestureEnd(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+  {
+    return true;
+  }
 
   // convenience events
   /*!
@@ -178,7 +200,7 @@ class ITouchActionHandler
    *
    * \return True if the event was handled otherwise false
    */
-  virtual void OnTap(float x, float y, int32_t pointers = 1) { }
+  virtual void OnTap(float x, float y, int32_t pointers = 1) {}
   /*!
    * \brief One or more touches have been held down for a certain amount of time
    *
@@ -190,7 +212,7 @@ class ITouchActionHandler
    *
    * \sa OnSingleTouchHold
    */
-  virtual void OnLongPress(float x, float y, int32_t pointers = 1) { }
+  virtual void OnLongPress(float x, float y, int32_t pointers = 1) {}
   /*!
    * \brief One or more touches has been moved quickly in a single direction in a short time
    *
@@ -205,9 +227,19 @@ class ITouchActionHandler
    *
    * \return True if the event was handled otherwise false
    */
-  virtual void OnSwipe(TouchMoveDirection direction, float xDown, float yDown, float xUp, float yUp, float velocityX, float velocityY, int32_t pointers = 1) { }
+  virtual void OnSwipe(TouchMoveDirection direction,
+                       float xDown,
+                       float yDown,
+                       float xUp,
+                       float yUp,
+                       float velocityX,
+                       float velocityY,
+                       int32_t pointers = 1)
+  {
+  }
   /*!
-   * \brief Two simultaneous touches have been held down and moved to perform a zooming/pinching gesture
+   * \brief Two simultaneous touches have been held down and moved to perform a zooming/pinching
+   * gesture
    *
    * \param centerX       The x coordinate (with sub-pixel) of the center of the two touches
    * \param centerY       The y coordinate (with sub-pixel) of the center of the two touches
@@ -215,7 +247,7 @@ class ITouchActionHandler
    *
    * \return True if the event was handled otherwise false
    */
-  virtual void OnZoomPinch(float centerX, float centerY, float zoomFactor) { }
+  virtual void OnZoomPinch(float centerX, float centerY, float zoomFactor) {}
   /*!
    * \brief Two simultaneous touches have been held down and moved to perform a rotating gesture
    *
@@ -225,5 +257,5 @@ class ITouchActionHandler
    *
    * \return True if the event was handled otherwise false
    */
-  virtual void OnRotate(float centerX, float centerY, float angle) { }
+  virtual void OnRotate(float centerX, float centerY, float angle) {}
 };
diff --git a/xbmc/input/touch/ITouchInputHandler.h b/xbmc/input/touch/ITouchInputHandler.h
index 9ff5179499dc..15ca0f0e8f7f 100644
--- a/xbmc/input/touch/ITouchInputHandler.h
+++ b/xbmc/input/touch/ITouchInputHandler.h
@@ -17,7 +17,8 @@
  * \ingroup touch
  * \brief Touch input event
  */
-typedef enum {
+typedef enum
+{
   TouchInputUnchanged = 0,
   TouchInputAbort,
   TouchInputDown,
@@ -37,9 +38,7 @@ typedef enum {
 class ITouchInputHandler : public ITouchInputHandling
 {
 public:
-  ITouchInputHandler()
-    : m_dpi(160.0f)
-  { }
+  ITouchInputHandler() : m_dpi(160.0f) {}
   ~ITouchInputHandler() override = default;
 
   /*!
@@ -61,7 +60,8 @@ class ITouchInputHandler : public ITouchInputHandling
    *
    * \sa Update
    */
-  virtual bool HandleTouchInput(TouchInput event, float x, float y, int64_t time, int32_t pointer = 0, float size = 0.0f) = 0;
+  virtual bool HandleTouchInput(
+      TouchInput event, float x, float y, int64_t time, int32_t pointer = 0, float size = 0.0f) = 0;
 
   /*!
    * \brief Update the coordinates of a pointer
@@ -83,9 +83,17 @@ class ITouchInputHandler : public ITouchInputHandling
    *
    * \sa Handle
    */
-  virtual bool UpdateTouchPointer(int32_t pointer, float x, float y, int64_t time, float size = 0.0f) { return false; }
+  virtual bool UpdateTouchPointer(
+      int32_t pointer, float x, float y, int64_t time, float size = 0.0f)
+  {
+    return false;
+  }
 
-  void SetScreenDPI(float dpi) { if (dpi > 0.0f) m_dpi = dpi; }
+  void SetScreenDPI(float dpi)
+  {
+    if (dpi > 0.0f)
+      m_dpi = dpi;
+  }
   float GetScreenDPI() { return m_dpi; }
 
 protected:
diff --git a/xbmc/input/touch/ITouchInputHandling.cpp b/xbmc/input/touch/ITouchInputHandling.cpp
index 99b4d912bcb1..e799f72467fc 100644
--- a/xbmc/input/touch/ITouchInputHandling.cpp
+++ b/xbmc/input/touch/ITouchInputHandling.cpp
@@ -8,7 +8,7 @@
 
 #include "ITouchInputHandling.h"
 
-void ITouchInputHandling::RegisterHandler(ITouchActionHandler *touchHandler)
+void ITouchInputHandling::RegisterHandler(ITouchActionHandler* touchHandler)
 {
   m_handler = touchHandler;
 }
@@ -40,7 +40,8 @@ bool ITouchInputHandling::OnSingleTouchHold(float x, float y)
   return true;
 }
 
-bool ITouchInputHandling::OnSingleTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+bool ITouchInputHandling::OnSingleTouchMove(
+    float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
 {
   if (m_handler)
     return m_handler->OnSingleTouchMove(x, y, offsetX, offsetY, velocityX, velocityY);
@@ -72,7 +73,13 @@ bool ITouchInputHandling::OnMultiTouchHold(float x, float y, int32_t pointers /*
   return true;
 }
 
-bool ITouchInputHandling::OnMultiTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY, int32_t pointer)
+bool ITouchInputHandling::OnMultiTouchMove(float x,
+                                           float y,
+                                           float offsetX,
+                                           float offsetY,
+                                           float velocityX,
+                                           float velocityY,
+                                           int32_t pointer)
 {
   if (m_handler)
     return m_handler->OnMultiTouchMove(x, y, offsetX, offsetY, velocityX, velocityY, pointer);
@@ -96,7 +103,8 @@ bool ITouchInputHandling::OnTouchGestureStart(float x, float y)
   return true;
 }
 
-bool ITouchInputHandling::OnTouchGesturePan(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+bool ITouchInputHandling::OnTouchGesturePan(
+    float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
 {
   if (m_handler)
     return m_handler->OnTouchGesturePan(x, y, offsetX, offsetY, velocityX, velocityY);
@@ -104,7 +112,8 @@ bool ITouchInputHandling::OnTouchGesturePan(float x, float y, float offsetX, flo
   return true;
 }
 
-bool ITouchInputHandling::OnTouchGestureEnd(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+bool ITouchInputHandling::OnTouchGestureEnd(
+    float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
 {
   if (m_handler)
     return m_handler->OnTouchGestureEnd(x, y, offsetX, offsetY, velocityX, velocityY);
@@ -124,7 +133,14 @@ void ITouchInputHandling::OnLongPress(float x, float y, int32_t pointers /* = 1
     m_handler->OnLongPress(x, y, pointers);
 }
 
-void ITouchInputHandling::OnSwipe(TouchMoveDirection direction, float xDown, float yDown, float xUp, float yUp, float velocityX, float velocityY, int32_t pointers /* = 1 */)
+void ITouchInputHandling::OnSwipe(TouchMoveDirection direction,
+                                  float xDown,
+                                  float yDown,
+                                  float xUp,
+                                  float yUp,
+                                  float velocityX,
+                                  float velocityY,
+                                  int32_t pointers /* = 1 */)
 {
   if (m_handler)
     m_handler->OnSwipe(direction, xDown, yDown, xUp, yUp, velocityX, velocityY, pointers);
diff --git a/xbmc/input/touch/ITouchInputHandling.h b/xbmc/input/touch/ITouchInputHandling.h
index 3d94cd482729..cabbf47e8503 100644
--- a/xbmc/input/touch/ITouchInputHandling.h
+++ b/xbmc/input/touch/ITouchInputHandling.h
@@ -23,9 +23,7 @@
 class ITouchInputHandling : protected ITouchActionHandler
 {
 public:
-  ITouchInputHandling()
-    : m_handler(NULL)
-  { }
+  ITouchInputHandling() : m_handler(NULL) {}
   ~ITouchInputHandling() override = default;
 
   /*!
@@ -38,7 +36,7 @@ class ITouchInputHandling : protected ITouchActionHandler
    *
    * \sa UnregisterHandler
    */
-  void RegisterHandler(ITouchActionHandler *touchHandler);
+  void RegisterHandler(ITouchActionHandler* touchHandler);
   /*!
    * \brief Unregister the previously registered touch handler
    *
@@ -52,25 +50,41 @@ class ITouchInputHandling : protected ITouchActionHandler
 
   bool OnSingleTouchStart(float x, float y) override;
   bool OnSingleTouchHold(float x, float y) override;
-  bool OnSingleTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
+  bool OnSingleTouchMove(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
   bool OnSingleTouchEnd(float x, float y) override;
 
   bool OnMultiTouchDown(float x, float y, int32_t pointer) override;
   bool OnMultiTouchHold(float x, float y, int32_t pointers = 2) override;
-  bool OnMultiTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY, int32_t pointer) override;
+  bool OnMultiTouchMove(float x,
+                        float y,
+                        float offsetX,
+                        float offsetY,
+                        float velocityX,
+                        float velocityY,
+                        int32_t pointer) override;
   bool OnMultiTouchUp(float x, float y, int32_t pointer) override;
 
   bool OnTouchGestureStart(float x, float y) override;
-  bool OnTouchGesturePan(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
-  bool OnTouchGestureEnd(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
+  bool OnTouchGesturePan(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
+  bool OnTouchGestureEnd(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
 
   // convenience events
   void OnTap(float x, float y, int32_t pointers = 1) override;
   void OnLongPress(float x, float y, int32_t pointers = 1) override;
-  void OnSwipe(TouchMoveDirection direction, float xDown, float yDown, float xUp, float yUp, float velocityX, float velocityY, int32_t pointers = 1) override;
+  void OnSwipe(TouchMoveDirection direction,
+               float xDown,
+               float yDown,
+               float xUp,
+               float yUp,
+               float velocityX,
+               float velocityY,
+               int32_t pointers = 1) override;
   void OnZoomPinch(float centerX, float centerY, float zoomFactor) override;
   void OnRotate(float centerX, float centerY, float angle) override;
 
 private:
-  ITouchActionHandler *m_handler;
+  ITouchActionHandler* m_handler;
 };
diff --git a/xbmc/input/touch/TouchTypes.h b/xbmc/input/touch/TouchTypes.h
index 5fe728f9e631..b3450c422ef3 100644
--- a/xbmc/input/touch/TouchTypes.h
+++ b/xbmc/input/touch/TouchTypes.h
@@ -31,7 +31,12 @@ class Touch : public CVector
    *
    * \param other Touch to copy x/y coordinates and time from
    */
-  void copy(const Touch &other) { x = other.x; y = other.y; time = other.time; }
+  void copy(const Touch& other)
+  {
+    x = other.x;
+    y = other.y;
+    time = other.time;
+  }
 
   int64_t time = -1; // in nanoseconds
 };
@@ -49,7 +54,13 @@ class Pointer
   /*!
    * \brief Resets the pointer and all its touches
    */
-  void reset() { down = {}; last = {}; moving = false; size = 0.0f; }
+  void reset()
+  {
+    down = {};
+    last = {};
+    moving = false;
+    size = 0.0f;
+  }
 
   /*!
    * \brief Checks if the "down" touch is valid
@@ -69,7 +80,7 @@ class Pointer
    *
    * \return True if the velocity is valid otherwise false
    */
-  bool velocity(float &velocityX, float &velocityY, bool fromLast = true) const
+  bool velocity(float& velocityX, float& velocityY, bool fromLast = true) const
   {
     int64_t fromTime = last.time;
     float fromX = last.x;
diff --git a/xbmc/input/touch/generic/GenericTouchActionHandler.cpp b/xbmc/input/touch/generic/GenericTouchActionHandler.cpp
index 47b2340055b4..c940a9ccf7ed 100644
--- a/xbmc/input/touch/generic/GenericTouchActionHandler.cpp
+++ b/xbmc/input/touch/generic/GenericTouchActionHandler.cpp
@@ -18,7 +18,7 @@
 
 using namespace KODI::MESSAGING;
 
-CGenericTouchActionHandler &CGenericTouchActionHandler::GetInstance()
+CGenericTouchActionHandler& CGenericTouchActionHandler::GetInstance()
 {
   static CGenericTouchActionHandler sTouchAction;
   return sTouchAction;
@@ -41,7 +41,8 @@ bool CGenericTouchActionHandler::OnSingleTouchHold(float x, float y)
   return true;
 }
 
-bool CGenericTouchActionHandler::OnSingleTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+bool CGenericTouchActionHandler::OnSingleTouchMove(
+    float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
 {
   return true;
 }
@@ -61,7 +62,13 @@ bool CGenericTouchActionHandler::OnMultiTouchHold(float x, float y, int32_t poin
   return true;
 }
 
-bool CGenericTouchActionHandler::OnMultiTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY, int32_t pointer)
+bool CGenericTouchActionHandler::OnMultiTouchMove(float x,
+                                                  float y,
+                                                  float offsetX,
+                                                  float offsetY,
+                                                  float velocityX,
+                                                  float velocityY,
+                                                  int32_t pointer)
 {
   return true;
 }
@@ -78,14 +85,16 @@ bool CGenericTouchActionHandler::OnTouchGestureStart(float x, float y)
   return true;
 }
 
-bool CGenericTouchActionHandler::OnTouchGesturePan(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+bool CGenericTouchActionHandler::OnTouchGesturePan(
+    float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
 {
   sendEvent(ACTION_GESTURE_PAN, x, y, offsetX, offsetY, velocityX, velocityY);
 
   return true;
 }
 
-bool CGenericTouchActionHandler::OnTouchGestureEnd(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
+bool CGenericTouchActionHandler::OnTouchGestureEnd(
+    float x, float y, float offsetX, float offsetY, float velocityX, float velocityY)
 {
   sendEvent(ACTION_GESTURE_END, velocityX, velocityY, x, y, offsetX, offsetY);
 
@@ -108,7 +117,14 @@ void CGenericTouchActionHandler::OnLongPress(float x, float y, int32_t pointers
   sendEvent(ACTION_TOUCH_LONGPRESS, x, y, 0.0f, 0.0f, 0.0f, 0.0f, pointers);
 }
 
-void CGenericTouchActionHandler::OnSwipe(TouchMoveDirection direction, float xDown, float yDown, float xUp, float yUp, float velocityX, float velocityY, int32_t pointers /* = 1 */)
+void CGenericTouchActionHandler::OnSwipe(TouchMoveDirection direction,
+                                         float xDown,
+                                         float yDown,
+                                         float xUp,
+                                         float yUp,
+                                         float velocityX,
+                                         float velocityY,
+                                         int32_t pointers /* = 1 */)
 {
   if (pointers <= 0 || pointers > 10)
     return;
@@ -140,14 +156,15 @@ void CGenericTouchActionHandler::OnRotate(float centerX, float centerY, float an
 
 int CGenericTouchActionHandler::QuerySupportedGestures(float x, float y)
 {
-  CGUIMessage msg(GUI_MSG_GESTURE_NOTIFY, 0, 0, static_cast<int> (std::round(x)), static_cast<int> (std::round(y)));
+  CGUIMessage msg(GUI_MSG_GESTURE_NOTIFY, 0, 0, static_cast<int>(std::round(x)),
+                  static_cast<int>(std::round(y)));
   if (!CServiceBroker::GetGUI()->GetWindowManager().SendMessage(msg))
     return 0;
 
   int result = 0;
   if (msg.GetPointer())
   {
-    int *p = static_cast<int*>(msg.GetPointer());
+    int* p = static_cast<int*>(msg.GetPointer());
     msg.SetPointer(nullptr);
     result = *p;
     delete p;
@@ -155,7 +172,14 @@ int CGenericTouchActionHandler::QuerySupportedGestures(float x, float y)
   return result;
 }
 
-void CGenericTouchActionHandler::sendEvent(int actionId, float x, float y, float x2 /* = 0.0f */, float y2 /* = 0.0f */, float x3, float y3, int pointers /* = 1 */)
+void CGenericTouchActionHandler::sendEvent(int actionId,
+                                           float x,
+                                           float y,
+                                           float x2 /* = 0.0f */,
+                                           float y2 /* = 0.0f */,
+                                           float x3,
+                                           float y3,
+                                           int pointers /* = 1 */)
 {
   XBMC_Event newEvent{XBMC_TOUCH};
 
@@ -177,8 +201,8 @@ void CGenericTouchActionHandler::focusControl(float x, float y)
 {
   XBMC_Event newEvent{XBMC_SETFOCUS};
 
-  newEvent.focus.x = static_cast<int> (std::round(x));
-  newEvent.focus.y = static_cast<int> (std::round(y));
+  newEvent.focus.x = static_cast<int>(std::round(x));
+  newEvent.focus.y = static_cast<int>(std::round(y));
 
   std::shared_ptr<CAppInboundProtocol> appPort = CServiceBroker::GetAppPort();
   if (appPort)
diff --git a/xbmc/input/touch/generic/GenericTouchActionHandler.h b/xbmc/input/touch/generic/GenericTouchActionHandler.h
index bf66fad56bf5..e8697cef6c4c 100644
--- a/xbmc/input/touch/generic/GenericTouchActionHandler.h
+++ b/xbmc/input/touch/generic/GenericTouchActionHandler.h
@@ -23,29 +23,45 @@ class CGenericTouchActionHandler : public ITouchActionHandler
   /*!
    \brief Get an instance of the touch input manager
    */
-  static CGenericTouchActionHandler &GetInstance();
+  static CGenericTouchActionHandler& GetInstance();
 
   // implementation of ITouchActionHandler
   void OnTouchAbort() override;
 
   bool OnSingleTouchStart(float x, float y) override;
   bool OnSingleTouchHold(float x, float y) override;
-  bool OnSingleTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
+  bool OnSingleTouchMove(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
   bool OnSingleTouchEnd(float x, float y) override;
 
   bool OnMultiTouchDown(float x, float y, int32_t pointer) override;
   bool OnMultiTouchHold(float x, float y, int32_t pointers = 2) override;
-  bool OnMultiTouchMove(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY, int32_t pointer) override;
+  bool OnMultiTouchMove(float x,
+                        float y,
+                        float offsetX,
+                        float offsetY,
+                        float velocityX,
+                        float velocityY,
+                        int32_t pointer) override;
   bool OnMultiTouchUp(float x, float y, int32_t pointer) override;
 
   bool OnTouchGestureStart(float x, float y) override;
-  bool OnTouchGesturePan(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
-  bool OnTouchGestureEnd(float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
+  bool OnTouchGesturePan(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
+  bool OnTouchGestureEnd(
+      float x, float y, float offsetX, float offsetY, float velocityX, float velocityY) override;
 
   // convenience events
   void OnTap(float x, float y, int32_t pointers = 1) override;
   void OnLongPress(float x, float y, int32_t pointers = 1) override;
-  void OnSwipe(TouchMoveDirection direction, float xDown, float yDown, float xUp, float yUp, float velocityX, float velocityY, int32_t pointers = 1) override;
+  void OnSwipe(TouchMoveDirection direction,
+               float xDown,
+               float yDown,
+               float xUp,
+               float yUp,
+               float velocityX,
+               float velocityY,
+               int32_t pointers = 1) override;
   void OnZoomPinch(float centerX, float centerY, float zoomFactor) override;
   void OnRotate(float centerX, float centerY, float angle) override;
 
@@ -66,6 +82,13 @@ class CGenericTouchActionHandler : public ITouchActionHandler
   CGenericTouchActionHandler const& operator=(CGenericTouchActionHandler const&) = delete;
   ~CGenericTouchActionHandler() override = default;
 
-  void sendEvent(int actionId, float x, float y, float x2 = 0.0f, float y2 = 0.0f, float x3 = 0.0f, float y3 = 0.0f, int pointers = 1);
+  void sendEvent(int actionId,
+                 float x,
+                 float y,
+                 float x2 = 0.0f,
+                 float y2 = 0.0f,
+                 float x3 = 0.0f,
+                 float y3 = 0.0f,
+                 int pointers = 1);
   void focusControl(float x, float y);
 };
diff --git a/xbmc/input/touch/generic/GenericTouchInputHandler.cpp b/xbmc/input/touch/generic/GenericTouchInputHandler.cpp
index 93cca98aa177..91fa970cc347 100644
--- a/xbmc/input/touch/generic/GenericTouchInputHandler.cpp
+++ b/xbmc/input/touch/generic/GenericTouchInputHandler.cpp
@@ -22,14 +22,13 @@ namespace
 constexpr int TOUCH_HOLD_TIMEOUT = 500;
 }
 
-CGenericTouchInputHandler::CGenericTouchInputHandler()
-     : m_holdTimer(new CTimer(this))
+CGenericTouchInputHandler::CGenericTouchInputHandler() : m_holdTimer(new CTimer(this))
 {
 }
 
 CGenericTouchInputHandler::~CGenericTouchInputHandler() = default;
 
-CGenericTouchInputHandler &CGenericTouchInputHandler::GetInstance()
+CGenericTouchInputHandler& CGenericTouchInputHandler::GetInstance()
 {
   static CGenericTouchInputHandler sTouchInput;
   return sTouchInput;
@@ -46,7 +45,12 @@ float CGenericTouchInputHandler::AdjustPointerSize(float size)
 }
 
 
-bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, float y, int64_t time, int32_t pointer /* = 0 */, float size /* = 0.0f */)
+bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event,
+                                                 float x,
+                                                 float y,
+                                                 int64_t time,
+                                                 int32_t pointer /* = 0 */,
+                                                 float size /* = 0.0f */)
 {
   if (time < 0 || pointer < 0 || pointer >= MAX_POINTERS)
     return false;
@@ -103,13 +107,15 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
 
         // If we so far assumed single touch or still have the primary
         // pointer of a previous multi touch pressed down, we can update to multi touch
-        if (m_gestureState == TouchGestureSingleTouch || m_gestureState == TouchGestureSingleTouchHold ||
+        if (m_gestureState == TouchGestureSingleTouch ||
+            m_gestureState == TouchGestureSingleTouchHold ||
             m_gestureState == TouchGestureMultiTouchDone)
         {
           result = OnMultiTouchDown(x, y, pointer);
           m_holdTimer->Stop(true);
 
-          if (m_gestureState == TouchGestureSingleTouch || m_gestureState == TouchGestureSingleTouchHold)
+          if (m_gestureState == TouchGestureSingleTouch ||
+              m_gestureState == TouchGestureSingleTouchHold)
             m_holdTimer->Start(TOUCH_HOLD_TIMEOUT);
 
           setGestureState(TouchGestureMultiTouchStart);
@@ -127,8 +133,7 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
     case TouchInputUp:
     {
       // unexpected event => abort
-      if (!m_pointers[pointer].valid() ||
-          m_gestureState == TouchGestureUnknown)
+      if (!m_pointers[pointer].valid() || m_gestureState == TouchGestureUnknown)
         break;
 
       triggerDetectors(event, pointer);
@@ -136,7 +141,8 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
       m_holdTimer->Stop(false);
 
       // Just a single tap with a pointer
-      if (m_gestureState == TouchGestureSingleTouch || m_gestureState == TouchGestureSingleTouchHold)
+      if (m_gestureState == TouchGestureSingleTouch ||
+          m_gestureState == TouchGestureSingleTouchHold)
       {
         result = OnSingleTouchEnd(x, y);
 
@@ -150,9 +156,8 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
         float velocityY = 0.0f; // number of pixels per second
         m_pointers[pointer].velocity(velocityX, velocityY, false);
 
-        result = OnTouchGestureEnd(x, y,
-                                   x - m_pointers[pointer].down.x, y - m_pointers[pointer].down.y,
-                                   velocityX, velocityY);
+        result = OnTouchGestureEnd(x, y, x - m_pointers[pointer].down.x,
+                                   y - m_pointers[pointer].down.y, velocityX, velocityY);
       }
       // we are in multi-touch
       else
@@ -161,7 +166,8 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
       // If we were in multi touch mode and lifted one pointer
       // we can go into the TouchGestureMultiTouchDone state which will allow
       // the user to go back into multi touch mode without lifting the primary pointer
-      if (m_gestureState == TouchGestureMultiTouchStart || m_gestureState == TouchGestureMultiTouchHold || m_gestureState == TouchGestureMultiTouch)
+      if (m_gestureState == TouchGestureMultiTouchStart ||
+          m_gestureState == TouchGestureMultiTouchHold || m_gestureState == TouchGestureMultiTouch)
       {
         setGestureState(TouchGestureMultiTouchDone);
 
@@ -182,15 +188,14 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
           float velocityY = 0.0f; // number of pixels per second
           m_pointers[pointer].velocity(velocityX, velocityY, false);
 
-          result = OnTouchGestureEnd(x, y,
-                                     x - m_pointers[pointer].down.x, y - m_pointers[pointer].down.y,
-                                     velocityX, velocityY);
+          result = OnTouchGestureEnd(x, y, x - m_pointers[pointer].down.x,
+                                     y - m_pointers[pointer].down.y, velocityX, velocityY);
 
           // if neither of the two pointers moved we have a single tap with multiple pointers
-          if (m_gestureStateOld != TouchGestureMultiTouchHold && m_gestureStateOld != TouchGestureMultiTouch)
+          if (m_gestureStateOld != TouchGestureMultiTouchHold &&
+              m_gestureStateOld != TouchGestureMultiTouch)
             OnTap(std::abs((m_pointers[0].down.x + m_pointers[1].down.x) / 2),
-                  std::abs((m_pointers[0].down.y + m_pointers[1].down.y) / 2),
-                  2);
+                  std::abs((m_pointers[0].down.y + m_pointers[1].down.y) / 2), 2);
         }
 
         setGestureState(TouchGestureUnknown);
@@ -203,26 +208,29 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
     case TouchInputMove:
     {
       // unexpected event => abort
-      if (!m_pointers[pointer].valid() ||
-          m_gestureState == TouchGestureUnknown ||
+      if (!m_pointers[pointer].valid() || m_gestureState == TouchGestureUnknown ||
           m_gestureState == TouchGestureMultiTouchDone)
         break;
 
-      bool moving = std::any_of(m_pointers.cbegin(), m_pointers.cend(), [](Pointer const& p) { return p.valid() && p.moving; });
+      bool moving = std::any_of(m_pointers.cbegin(), m_pointers.cend(),
+                                [](Pointer const& p) { return p.valid() && p.moving; });
 
       if (moving)
       {
         m_holdTimer->Stop();
 
         // the touch is moving so we start a gesture
-        if (m_gestureState == TouchGestureSingleTouch || m_gestureState == TouchGestureMultiTouchStart)
+        if (m_gestureState == TouchGestureSingleTouch ||
+            m_gestureState == TouchGestureMultiTouchStart)
           result = OnTouchGestureStart(m_pointers[pointer].down.x, m_pointers[pointer].down.y);
       }
 
       triggerDetectors(event, pointer);
 
       // Check if the touch has moved far enough to count as movement
-      if ((m_gestureState == TouchGestureSingleTouch || m_gestureState == TouchGestureMultiTouchStart) && !m_pointers[pointer].moving)
+      if ((m_gestureState == TouchGestureSingleTouch ||
+           m_gestureState == TouchGestureMultiTouchStart) &&
+          !m_pointers[pointer].moving)
         break;
 
       if (m_gestureState == TouchGestureSingleTouch)
@@ -245,7 +253,8 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
       m_pointers[pointer].velocity(velocityX, velocityY);
 
       if (m_pointers[pointer].moving &&
-         (m_gestureState == TouchGestureSingleTouch || m_gestureState == TouchGestureSingleTouchHold || m_gestureState == TouchGesturePan))
+          (m_gestureState == TouchGestureSingleTouch ||
+           m_gestureState == TouchGestureSingleTouchHold || m_gestureState == TouchGesturePan))
         result = OnSingleTouchMove(x, y, offsetX, offsetY, velocityX, velocityY);
 
       // Let's see if we have a pan gesture (i.e. the primary and only pointer moving)
@@ -259,7 +268,7 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
       else if (m_gestureState == TouchGestureMultiTouch)
       {
         if (moving)
-          result = OnMultiTouchMove(x, y,offsetX, offsetY, velocityX, velocityY, pointer);
+          result = OnMultiTouchMove(x, y, offsetX, offsetY, velocityX, velocityY, pointer);
       }
       else
         break;
@@ -275,7 +284,8 @@ bool CGenericTouchInputHandler::HandleTouchInput(TouchInput event, float x, floa
   return false;
 }
 
-bool CGenericTouchInputHandler::UpdateTouchPointer(int32_t pointer, float x, float y, int64_t time, float size /* = 0.0f */)
+bool CGenericTouchInputHandler::UpdateTouchPointer(
+    int32_t pointer, float x, float y, int64_t time, float size /* = 0.0f */)
 {
   if (pointer < 0 || pointer >= MAX_POINTERS)
     return false;
@@ -332,8 +342,7 @@ void CGenericTouchInputHandler::OnTimeout()
 
         OnMultiTouchHold(m_pointers[0].down.x, m_pointers[0].down.y);
         OnLongPress(std::abs((m_pointers[0].down.x + m_pointers[1].down.x) / 2),
-                    std::abs((m_pointers[0].down.y + m_pointers[1].down.y) / 2),
-                    2);
+                    std::abs((m_pointers[0].down.y + m_pointers[1].down.y) / 2), 2);
       }
       break;
 
@@ -377,7 +386,7 @@ void CGenericTouchInputHandler::triggerDetectors(TouchInput event, int32_t point
       return;
   }
 
-  for (auto it = m_detectors.begin(); it != m_detectors.end(); )
+  for (auto it = m_detectors.begin(); it != m_detectors.end();)
   {
     if ((*it)->IsDone())
       it = m_detectors.erase(it);
diff --git a/xbmc/input/touch/generic/GenericTouchInputHandler.h b/xbmc/input/touch/generic/GenericTouchInputHandler.h
index 2d0b1dedb957..154f5f294227 100644
--- a/xbmc/input/touch/generic/GenericTouchInputHandler.h
+++ b/xbmc/input/touch/generic/GenericTouchInputHandler.h
@@ -37,12 +37,18 @@ class CGenericTouchInputHandler : public ITouchInputHandler, private ITimerCallb
   /*!
    \brief Get an instance of the touch input manager
    */
-  static CGenericTouchInputHandler &GetInstance();
+  static CGenericTouchInputHandler& GetInstance();
   static constexpr int MAX_POINTERS = 2;
 
   // implementation of ITouchInputHandler
-  bool HandleTouchInput(TouchInput event, float x, float y, int64_t time, int32_t pointer = 0, float size = 0.0f) override;
-  bool UpdateTouchPointer(int32_t pointer, float x, float y, int64_t time, float size = 0.0f) override;
+  bool HandleTouchInput(TouchInput event,
+                        float x,
+                        float y,
+                        int64_t time,
+                        int32_t pointer = 0,
+                        float size = 0.0f) override;
+  bool UpdateTouchPointer(
+      int32_t pointer, float x, float y, int64_t time, float size = 0.0f) override;
 
 private:
   // private construction, and no assignments; use the provided singleton methods
@@ -51,7 +57,8 @@ class CGenericTouchInputHandler : public ITouchInputHandler, private ITimerCallb
   CGenericTouchInputHandler(const CGenericTouchInputHandler&) = delete;
   CGenericTouchInputHandler const& operator=(CGenericTouchInputHandler const&) = delete;
 
-  typedef enum {
+  typedef enum
+  {
     TouchGestureUnknown = 0,
     // only primary pointer active but stationary so far
     TouchGestureSingleTouch,
@@ -73,7 +80,11 @@ class CGenericTouchInputHandler : public ITouchInputHandler, private ITimerCallb
   void OnTimeout() override;
 
   void saveLastTouch();
-  void setGestureState(TouchGestureState gestureState) { m_gestureStateOld = m_gestureState; m_gestureState = gestureState; }
+  void setGestureState(TouchGestureState gestureState)
+  {
+    m_gestureStateOld = m_gestureState;
+    m_gestureState = gestureState;
+  }
   void triggerDetectors(TouchInput event, int32_t pointer);
   float AdjustPointerSize(float size);
 
diff --git a/xbmc/input/touch/generic/GenericTouchPinchDetector.cpp b/xbmc/input/touch/generic/GenericTouchPinchDetector.cpp
index 399755461c1a..ca61bcf6b782 100644
--- a/xbmc/input/touch/generic/GenericTouchPinchDetector.cpp
+++ b/xbmc/input/touch/generic/GenericTouchPinchDetector.cpp
@@ -8,7 +8,7 @@
 
 #include "GenericTouchPinchDetector.h"
 
-bool CGenericTouchPinchDetector::OnTouchDown(unsigned int index, const Pointer &pointer)
+bool CGenericTouchPinchDetector::OnTouchDown(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -20,7 +20,7 @@ bool CGenericTouchPinchDetector::OnTouchDown(unsigned int index, const Pointer &
   return true;
 }
 
-bool CGenericTouchPinchDetector::OnTouchUp(unsigned int index, const Pointer &pointer)
+bool CGenericTouchPinchDetector::OnTouchUp(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -44,7 +44,7 @@ bool CGenericTouchPinchDetector::OnTouchUp(unsigned int index, const Pointer &po
   return true;
 }
 
-bool CGenericTouchPinchDetector::OnTouchMove(unsigned int index, const Pointer &pointer)
+bool CGenericTouchPinchDetector::OnTouchMove(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -59,7 +59,7 @@ bool CGenericTouchPinchDetector::OnTouchMove(unsigned int index, const Pointer &
   Pointer& secondaryPointer = m_pointers[1];
 
   if (!primaryPointer.valid() || !secondaryPointer.valid() ||
-     (!primaryPointer.moving && !secondaryPointer.moving))
+      (!primaryPointer.moving && !secondaryPointer.moving))
     return false;
 
   // calculate zoom/pinch
diff --git a/xbmc/input/touch/generic/GenericTouchPinchDetector.h b/xbmc/input/touch/generic/GenericTouchPinchDetector.h
index c7b1e0f1bf69..191e95028a93 100644
--- a/xbmc/input/touch/generic/GenericTouchPinchDetector.h
+++ b/xbmc/input/touch/generic/GenericTouchPinchDetector.h
@@ -20,12 +20,13 @@
 class CGenericTouchPinchDetector : public IGenericTouchGestureDetector
 {
 public:
-  CGenericTouchPinchDetector(ITouchActionHandler *handler, float dpi)
+  CGenericTouchPinchDetector(ITouchActionHandler* handler, float dpi)
     : IGenericTouchGestureDetector(handler, dpi)
-  { }
+  {
+  }
   ~CGenericTouchPinchDetector() override = default;
 
-  bool OnTouchDown(unsigned int index, const Pointer &pointer) override;
-  bool OnTouchUp(unsigned int index, const Pointer &pointer) override;
-  bool OnTouchMove(unsigned int index, const Pointer &pointer) override;
+  bool OnTouchDown(unsigned int index, const Pointer& pointer) override;
+  bool OnTouchUp(unsigned int index, const Pointer& pointer) override;
+  bool OnTouchMove(unsigned int index, const Pointer& pointer) override;
 };
diff --git a/xbmc/input/touch/generic/GenericTouchRotateDetector.cpp b/xbmc/input/touch/generic/GenericTouchRotateDetector.cpp
index 198c28a6021e..79db638e2c1f 100644
--- a/xbmc/input/touch/generic/GenericTouchRotateDetector.cpp
+++ b/xbmc/input/touch/generic/GenericTouchRotateDetector.cpp
@@ -14,12 +14,12 @@
 #define M_PI 3.1415926535897932384626433832795028842
 #endif
 
-CGenericTouchRotateDetector::CGenericTouchRotateDetector(ITouchActionHandler *handler, float dpi)
-  : IGenericTouchGestureDetector(handler, dpi),
-    m_angle(0.0f)
-{ }
+CGenericTouchRotateDetector::CGenericTouchRotateDetector(ITouchActionHandler* handler, float dpi)
+  : IGenericTouchGestureDetector(handler, dpi), m_angle(0.0f)
+{
+}
 
-bool CGenericTouchRotateDetector::OnTouchDown(unsigned int index, const Pointer &pointer)
+bool CGenericTouchRotateDetector::OnTouchDown(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -32,7 +32,7 @@ bool CGenericTouchRotateDetector::OnTouchDown(unsigned int index, const Pointer
   return true;
 }
 
-bool CGenericTouchRotateDetector::OnTouchUp(unsigned int index, const Pointer &pointer)
+bool CGenericTouchRotateDetector::OnTouchUp(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -56,7 +56,7 @@ bool CGenericTouchRotateDetector::OnTouchUp(unsigned int index, const Pointer &p
   return true;
 }
 
-bool CGenericTouchRotateDetector::OnTouchMove(unsigned int index, const Pointer &pointer)
+bool CGenericTouchRotateDetector::OnTouchMove(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -71,7 +71,7 @@ bool CGenericTouchRotateDetector::OnTouchMove(unsigned int index, const Pointer
   Pointer& secondaryPointer = m_pointers[1];
 
   if (!primaryPointer.valid() || !secondaryPointer.valid() ||
-     (!primaryPointer.moving && !secondaryPointer.moving))
+      (!primaryPointer.moving && !secondaryPointer.moving))
     return false;
 
   CVector last = primaryPointer.last - secondaryPointer.last;
@@ -103,7 +103,7 @@ bool CGenericTouchRotateDetector::OnTouchMove(unsigned int index, const Pointer
   return true;
 }
 
-bool CGenericTouchRotateDetector::OnTouchUpdate(unsigned int index, const Pointer &pointer)
+bool CGenericTouchRotateDetector::OnTouchUpdate(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
diff --git a/xbmc/input/touch/generic/GenericTouchRotateDetector.h b/xbmc/input/touch/generic/GenericTouchRotateDetector.h
index 9809f1d7bf18..695879ae665b 100644
--- a/xbmc/input/touch/generic/GenericTouchRotateDetector.h
+++ b/xbmc/input/touch/generic/GenericTouchRotateDetector.h
@@ -20,13 +20,13 @@
 class CGenericTouchRotateDetector : public IGenericTouchGestureDetector
 {
 public:
-  CGenericTouchRotateDetector(ITouchActionHandler *handler, float dpi);
+  CGenericTouchRotateDetector(ITouchActionHandler* handler, float dpi);
   ~CGenericTouchRotateDetector() override = default;
 
-  bool OnTouchDown(unsigned int index, const Pointer &pointer) override;
-  bool OnTouchUp(unsigned int index, const Pointer &pointer) override;
-  bool OnTouchMove(unsigned int index, const Pointer &pointer) override;
-  bool OnTouchUpdate(unsigned int index, const Pointer &pointer) override;
+  bool OnTouchDown(unsigned int index, const Pointer& pointer) override;
+  bool OnTouchUp(unsigned int index, const Pointer& pointer) override;
+  bool OnTouchMove(unsigned int index, const Pointer& pointer) override;
+  bool OnTouchUpdate(unsigned int index, const Pointer& pointer) override;
 
 private:
   /*!
diff --git a/xbmc/input/touch/generic/GenericTouchSwipeDetector.cpp b/xbmc/input/touch/generic/GenericTouchSwipeDetector.cpp
index 83999b2909aa..7d772b59278f 100644
--- a/xbmc/input/touch/generic/GenericTouchSwipeDetector.cpp
+++ b/xbmc/input/touch/generic/GenericTouchSwipeDetector.cpp
@@ -9,29 +9,32 @@
 #ifndef _USE_MATH_DEFINES
 #define _USE_MATH_DEFINES
 #endif
+#include "GenericTouchSwipeDetector.h"
+
 #include <math.h>
 #include <stdlib.h>
 
-#include "GenericTouchSwipeDetector.h"
-
 // maximum time between touch down and up (in nanoseconds)
-#define SWIPE_MAX_TIME            500000000
+#define SWIPE_MAX_TIME 500000000
 // maximum swipe distance between touch down and up (in multiples of screen DPI)
-#define SWIPE_MIN_DISTANCE        0.5f
+#define SWIPE_MIN_DISTANCE 0.5f
 // original maximum variance of the touch movement
-#define SWIPE_MAX_VARIANCE        0.2f
+#define SWIPE_MAX_VARIANCE 0.2f
 // tangents of the maximum angle (20 degrees) the touch movement may vary in a
 // direction perpendicular to the swipe direction (in radians)
 // => tan(20 deg) = tan(20 * M_PI / 180)
-#define SWIPE_MAX_VARIANCE_ANGLE  0.36397023f
+#define SWIPE_MAX_VARIANCE_ANGLE 0.36397023f
 
-CGenericTouchSwipeDetector::CGenericTouchSwipeDetector(ITouchActionHandler *handler, float dpi)
+CGenericTouchSwipeDetector::CGenericTouchSwipeDetector(ITouchActionHandler* handler, float dpi)
   : IGenericTouchGestureDetector(handler, dpi),
-    m_directions(TouchMoveDirectionLeft | TouchMoveDirectionRight | TouchMoveDirectionUp | TouchMoveDirectionDown),
-    m_swipeDetected(false), m_size(0)
-{ }
+    m_directions(TouchMoveDirectionLeft | TouchMoveDirectionRight | TouchMoveDirectionUp |
+                 TouchMoveDirectionDown),
+    m_swipeDetected(false),
+    m_size(0)
+{
+}
 
-bool CGenericTouchSwipeDetector::OnTouchDown(unsigned int index, const Pointer &pointer)
+bool CGenericTouchSwipeDetector::OnTouchDown(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -43,12 +46,13 @@ bool CGenericTouchSwipeDetector::OnTouchDown(unsigned int index, const Pointer &
   // reset all values
   m_done = false;
   m_swipeDetected = false;
-  m_directions = TouchMoveDirectionLeft | TouchMoveDirectionRight | TouchMoveDirectionUp | TouchMoveDirectionDown;
+  m_directions = TouchMoveDirectionLeft | TouchMoveDirectionRight | TouchMoveDirectionUp |
+                 TouchMoveDirectionDown;
 
   return true;
 }
 
-bool CGenericTouchSwipeDetector::OnTouchUp(unsigned int index, const Pointer &pointer)
+bool CGenericTouchSwipeDetector::OnTouchUp(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -73,11 +77,12 @@ bool CGenericTouchSwipeDetector::OnTouchUp(unsigned int index, const Pointer &po
   pointer.velocity(velocityX, velocityY, false);
 
   // call the OnSwipe() callback
-  OnSwipe((TouchMoveDirection)m_directions, pointer.down.x, pointer.down.y, pointer.current.x, pointer.current.y, velocityX, velocityY, m_size + 1);
+  OnSwipe((TouchMoveDirection)m_directions, pointer.down.x, pointer.down.y, pointer.current.x,
+          pointer.current.y, velocityX, velocityY, m_size + 1);
   return true;
 }
 
-bool CGenericTouchSwipeDetector::OnTouchMove(unsigned int index, const Pointer &pointer)
+bool CGenericTouchSwipeDetector::OnTouchMove(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
@@ -159,7 +164,7 @@ bool CGenericTouchSwipeDetector::OnTouchMove(unsigned int index, const Pointer &
   return true;
 }
 
-bool CGenericTouchSwipeDetector::OnTouchUpdate(unsigned int index, const Pointer &pointer)
+bool CGenericTouchSwipeDetector::OnTouchUpdate(unsigned int index, const Pointer& pointer)
 {
   if (index >= MAX_POINTERS)
     return false;
diff --git a/xbmc/input/touch/generic/GenericTouchSwipeDetector.h b/xbmc/input/touch/generic/GenericTouchSwipeDetector.h
index 0b79680d4a7c..7fe88b1f3adf 100644
--- a/xbmc/input/touch/generic/GenericTouchSwipeDetector.h
+++ b/xbmc/input/touch/generic/GenericTouchSwipeDetector.h
@@ -20,13 +20,13 @@
 class CGenericTouchSwipeDetector : public IGenericTouchGestureDetector
 {
 public:
-  CGenericTouchSwipeDetector(ITouchActionHandler *handler, float dpi);
+  CGenericTouchSwipeDetector(ITouchActionHandler* handler, float dpi);
   ~CGenericTouchSwipeDetector() override = default;
 
-  bool OnTouchDown(unsigned int index, const Pointer &pointer) override;
-  bool OnTouchUp(unsigned int index, const Pointer &pointer) override;
-  bool OnTouchMove(unsigned int index, const Pointer &pointer) override;
-  bool OnTouchUpdate(unsigned int index, const Pointer &pointer) override;
+  bool OnTouchDown(unsigned int index, const Pointer& pointer) override;
+  bool OnTouchUp(unsigned int index, const Pointer& pointer) override;
+  bool OnTouchMove(unsigned int index, const Pointer& pointer) override;
+  bool OnTouchUpdate(unsigned int index, const Pointer& pointer) override;
 
 private:
   /*!
diff --git a/xbmc/input/touch/generic/IGenericTouchGestureDetector.h b/xbmc/input/touch/generic/IGenericTouchGestureDetector.h
index 45dab85e898e..da9d86869ee8 100644
--- a/xbmc/input/touch/generic/IGenericTouchGestureDetector.h
+++ b/xbmc/input/touch/generic/IGenericTouchGestureDetector.h
@@ -20,9 +20,7 @@
 class IGenericTouchGestureDetector : public ITouchInputHandling
 {
 public:
-  IGenericTouchGestureDetector(ITouchActionHandler *handler, float dpi)
-    : m_done(false),
-      m_dpi(dpi)
+  IGenericTouchGestureDetector(ITouchActionHandler* handler, float dpi) : m_done(false), m_dpi(dpi)
   {
     RegisterHandler(handler);
   }
@@ -44,7 +42,7 @@ class IGenericTouchGestureDetector : public ITouchInputHandling
    *
    * \return True if the event was handled otherwise false
    */
-  virtual bool OnTouchDown(unsigned int index, const Pointer &pointer) = 0;
+  virtual bool OnTouchDown(unsigned int index, const Pointer& pointer) = 0;
   /*!
    * \brief An active touch pointer has vanished.
    *
@@ -56,7 +54,7 @@ class IGenericTouchGestureDetector : public ITouchInputHandling
    *
    * \return True if the event was handled otherwise false
    */
-  virtual bool OnTouchUp(unsigned int index, const Pointer &pointer) { return false; }
+  virtual bool OnTouchUp(unsigned int index, const Pointer& pointer) { return false; }
   /*!
    * \brief An active touch pointer has moved.
    *
@@ -65,7 +63,7 @@ class IGenericTouchGestureDetector : public ITouchInputHandling
    *
    * \return True if the event was handled otherwise false
    */
-  virtual bool OnTouchMove(unsigned int index, const Pointer &pointer) { return false; }
+  virtual bool OnTouchMove(unsigned int index, const Pointer& pointer) { return false; }
   /*!
    * \brief An active touch pointer's values have been updated but no event has
    *        occured.
@@ -75,7 +73,7 @@ class IGenericTouchGestureDetector : public ITouchInputHandling
    *
    * \return True if the event was handled otherwise false
    */
-  virtual bool OnTouchUpdate(unsigned int index, const Pointer &pointer) { return false; }
+  virtual bool OnTouchUpdate(unsigned int index, const Pointer& pointer) { return false; }
 
 protected:
   /*!

From 71a2c6b734420f540b0d06f6e3334ffe5a9e8225 Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Tue, 26 May 2020 17:42:24 -0700
Subject: [PATCH 5/7] Peripherals: Clang-format files

---
 xbmc/peripherals/EventLockHandle.cpp          |    3 +-
 xbmc/peripherals/EventLockHandle.h            |   58 +-
 xbmc/peripherals/EventPollHandle.cpp          |    3 +-
 xbmc/peripherals/EventPollHandle.h            |   92 +-
 xbmc/peripherals/EventScanner.cpp             |   17 +-
 xbmc/peripherals/EventScanner.h               |   88 +-
 xbmc/peripherals/IEventScannerCallback.h      |   14 +-
 xbmc/peripherals/PeripheralTypes.h            |  481 ++++---
 xbmc/peripherals/Peripherals.cpp              |  317 +++--
 xbmc/peripherals/Peripherals.h                |  608 ++++-----
 xbmc/peripherals/addons/AddonButtonMap.cpp    |  178 ++-
 xbmc/peripherals/addons/AddonButtonMap.h      |  256 ++--
 .../peripherals/addons/AddonButtonMapping.cpp |   11 +-
 xbmc/peripherals/addons/AddonButtonMapping.h  |   77 +-
 .../peripherals/addons/AddonInputHandling.cpp |   18 +-
 xbmc/peripherals/addons/AddonInputHandling.h  |  117 +-
 xbmc/peripherals/addons/PeripheralAddon.cpp   |  271 ++--
 xbmc/peripherals/addons/PeripheralAddon.h     |  296 +++--
 .../addons/PeripheralAddonTranslator.cpp      |  253 ++--
 .../addons/PeripheralAddonTranslator.h        |   56 +-
 xbmc/peripherals/bus/PeripheralBus.cpp        |   52 +-
 xbmc/peripherals/bus/PeripheralBus.h          |  348 ++---
 xbmc/peripherals/bus/PeripheralBusUSB.h       |    2 +-
 .../bus/virtual/PeripheralBusAddon.cpp        |  108 +-
 .../bus/virtual/PeripheralBusAddon.h          |  114 +-
 .../bus/virtual/PeripheralBusApplication.cpp  |   33 +-
 .../bus/virtual/PeripheralBusApplication.h    |   46 +-
 .../bus/virtual/PeripheralBusCEC.cpp          |   36 +-
 .../bus/virtual/PeripheralBusCEC.h            |   38 +-
 xbmc/peripherals/devices/Peripheral.cpp       |  219 +--
 xbmc/peripherals/devices/Peripheral.h         |  471 +++----
 .../devices/PeripheralBluetooth.cpp           |    6 +-
 .../peripherals/devices/PeripheralBluetooth.h |   16 +-
 .../devices/PeripheralCecAdapter.cpp          | 1175 +++++++++--------
 .../devices/PeripheralCecAdapter.h            |  340 ++---
 xbmc/peripherals/devices/PeripheralDisk.cpp   |    9 +-
 xbmc/peripherals/devices/PeripheralDisk.h     |   16 +-
 xbmc/peripherals/devices/PeripheralHID.cpp    |   19 +-
 xbmc/peripherals/devices/PeripheralHID.h      |   27 +-
 xbmc/peripherals/devices/PeripheralImon.cpp   |   17 +-
 xbmc/peripherals/devices/PeripheralImon.h     |   41 +-
 .../devices/PeripheralJoystick.cpp            |   81 +-
 xbmc/peripherals/devices/PeripheralJoystick.h |  209 +--
 .../devices/PeripheralKeyboard.cpp            |   28 +-
 xbmc/peripherals/devices/PeripheralKeyboard.h |   58 +-
 xbmc/peripherals/devices/PeripheralMouse.cpp  |   29 +-
 xbmc/peripherals/devices/PeripheralMouse.h    |   60 +-
 xbmc/peripherals/devices/PeripheralNIC.cpp    |    9 +-
 xbmc/peripherals/devices/PeripheralNIC.h      |   16 +-
 .../devices/PeripheralNyxboard.cpp            |   16 +-
 xbmc/peripherals/devices/PeripheralNyxboard.h |   18 +-
 xbmc/peripherals/devices/PeripheralTuner.cpp  |    6 +-
 xbmc/peripherals/devices/PeripheralTuner.h    |   16 +-
 .../dialogs/GUIDialogPeripheralSettings.cpp   |   24 +-
 .../dialogs/GUIDialogPeripheralSettings.h     |    8 +-
 .../dialogs/GUIDialogPeripherals.cpp          |   28 +-
 .../dialogs/GUIDialogPeripherals.h            |   13 +-
 57 files changed, 3715 insertions(+), 3251 deletions(-)

diff --git a/xbmc/peripherals/EventLockHandle.cpp b/xbmc/peripherals/EventLockHandle.cpp
index c674cd3eef70..b6d2a6d8a55d 100644
--- a/xbmc/peripherals/EventLockHandle.cpp
+++ b/xbmc/peripherals/EventLockHandle.cpp
@@ -10,8 +10,7 @@
 
 using namespace PERIPHERALS;
 
-CEventLockHandle::CEventLockHandle(IEventLockCallback &callback) :
-  m_callback(callback)
+CEventLockHandle::CEventLockHandle(IEventLockCallback& callback) : m_callback(callback)
 {
 }
 
diff --git a/xbmc/peripherals/EventLockHandle.h b/xbmc/peripherals/EventLockHandle.h
index 6aa2bf961c73..7012ea8d98cd 100644
--- a/xbmc/peripherals/EventLockHandle.h
+++ b/xbmc/peripherals/EventLockHandle.h
@@ -10,39 +10,39 @@
 
 namespace PERIPHERALS
 {
-  class CEventLockHandle;
+class CEventLockHandle;
 
-  /*!
-   * \brief Callback implemented by event scanner
-   */
-  class IEventLockCallback
-  {
-  public:
-    virtual ~IEventLockCallback(void) = default;
+/*!
+ * \brief Callback implemented by event scanner
+ */
+class IEventLockCallback
+{
+public:
+  virtual ~IEventLockCallback(void) = default;
 
-    virtual void ReleaseLock(CEventLockHandle &handle) = 0;
-  };
+  virtual void ReleaseLock(CEventLockHandle& handle) = 0;
+};
 
+/*!
+ * \brief Handle returned by the event scanner to disable event processing
+ *
+ * When held, this disables event processing.
+ */
+class CEventLockHandle
+{
+public:
   /*!
-   * \brief Handle returned by the event scanner to disable event processing
-   *
-   * When held, this disables event processing.
+   * \brief Create an event lock handle
    */
-  class CEventLockHandle
-  {
-  public:
-    /*!
-     * \brief Create an event lock handle
-     */
-    CEventLockHandle(IEventLockCallback &callback);
+  CEventLockHandle(IEventLockCallback& callback);
 
-    /*!
-     * \brief Handle is automatically released when this class is destructed
-     */
-    ~CEventLockHandle(void);
+  /*!
+   * \brief Handle is automatically released when this class is destructed
+   */
+  ~CEventLockHandle(void);
 
-  private:
-    // Construction parameters
-    IEventLockCallback &m_callback;
-  };
-}
+private:
+  // Construction parameters
+  IEventLockCallback& m_callback;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/EventPollHandle.cpp b/xbmc/peripherals/EventPollHandle.cpp
index 1b2022f11b0c..39a2e1aa546c 100644
--- a/xbmc/peripherals/EventPollHandle.cpp
+++ b/xbmc/peripherals/EventPollHandle.cpp
@@ -10,8 +10,7 @@
 
 using namespace PERIPHERALS;
 
-CEventPollHandle::CEventPollHandle(IEventPollCallback &callback) :
-  m_callback(callback)
+CEventPollHandle::CEventPollHandle(IEventPollCallback& callback) : m_callback(callback)
 {
 }
 
diff --git a/xbmc/peripherals/EventPollHandle.h b/xbmc/peripherals/EventPollHandle.h
index af194c9ca947..5d99e1ed97d6 100644
--- a/xbmc/peripherals/EventPollHandle.h
+++ b/xbmc/peripherals/EventPollHandle.h
@@ -10,59 +10,59 @@
 
 namespace PERIPHERALS
 {
-  class CEventPollHandle;
+class CEventPollHandle;
 
-  /*!
-   * \brief Callback implemented by event scanner
-   */
-  class IEventPollCallback
-  {
-  public:
-    virtual ~IEventPollCallback(void) = default;
+/*!
+ * \brief Callback implemented by event scanner
+ */
+class IEventPollCallback
+{
+public:
+  virtual ~IEventPollCallback(void) = default;
 
-    virtual void Activate(CEventPollHandle &handle) = 0;
-    virtual void Deactivate(CEventPollHandle &handle) = 0;
-    virtual void HandleEvents(bool bWait) = 0;
-    virtual void Release(CEventPollHandle &handle) = 0;
-  };
+  virtual void Activate(CEventPollHandle& handle) = 0;
+  virtual void Deactivate(CEventPollHandle& handle) = 0;
+  virtual void HandleEvents(bool bWait) = 0;
+  virtual void Release(CEventPollHandle& handle) = 0;
+};
 
+/*!
+ * \brief Handle returned by the event scanner to control scan timing
+ *
+ * When held, this allows one to control the timing of when events are
+ * handled.
+ */
+class CEventPollHandle
+{
+public:
   /*!
-   * \brief Handle returned by the event scanner to control scan timing
-   *
-   * When held, this allows one to control the timing of when events are
-   * handled.
+   * \brief Create an active polling handle
    */
-  class CEventPollHandle
-  {
-  public:
-    /*!
-     * \brief Create an active polling handle
-     */
-    CEventPollHandle(IEventPollCallback &callback);
+  CEventPollHandle(IEventPollCallback& callback);
 
-    /*!
-     * \brief Handle is automatically released when this class is destructed
-     */
-    ~CEventPollHandle();
+  /*!
+   * \brief Handle is automatically released when this class is destructed
+   */
+  ~CEventPollHandle();
 
-    /*!
-     * \brief Activate handle
-     */
-    void Activate();
+  /*!
+   * \brief Activate handle
+   */
+  void Activate();
 
-    /*!
-     * \brief Deactivate handle
-     */
-    void Deactivate();
+  /*!
+   * \brief Deactivate handle
+   */
+  void Deactivate();
 
-    /*!
-     * \brief Trigger a scan for events
-     *
-     * \param bWait If true, this blocks until all events are handled
-     */
-    void HandleEvents(bool bWait);
+  /*!
+   * \brief Trigger a scan for events
+   *
+   * \param bWait If true, this blocks until all events are handled
+   */
+  void HandleEvents(bool bWait);
 
-  private:
-    IEventPollCallback &m_callback;
-  };
-}
+private:
+  IEventPollCallback& m_callback;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/EventScanner.cpp b/xbmc/peripherals/EventScanner.cpp
index bdea0711264a..b095f3eaa811 100644
--- a/xbmc/peripherals/EventScanner.cpp
+++ b/xbmc/peripherals/EventScanner.cpp
@@ -19,15 +19,14 @@ using namespace PERIPHERALS;
 using namespace XbmcThreads;
 
 // Default event scan rate when no polling handles are held
-#define DEFAULT_SCAN_RATE_HZ  60
+#define DEFAULT_SCAN_RATE_HZ 60
 
 // Timeout when a polling handle is held but doesn't trigger scan. This reduces
 // input latency when the game is running at < 1/4 speed.
-#define WATCHDOG_TIMEOUT_MS   80
+#define WATCHDOG_TIMEOUT_MS 80
 
-CEventScanner::CEventScanner(IEventScannerCallback &callback) :
-  CThread("PeripEventScanner"),
-  m_callback(callback)
+CEventScanner::CEventScanner(IEventScannerCallback& callback)
+  : CThread("PeripEventScanner"), m_callback(callback)
 {
 }
 
@@ -57,7 +56,7 @@ EventPollHandlePtr CEventScanner::RegisterPollHandle()
   return handle;
 }
 
-void CEventScanner::Activate(CEventPollHandle &handle)
+void CEventScanner::Activate(CEventPollHandle& handle)
 {
   {
     CSingleLock lock(m_handleMutex);
@@ -67,7 +66,7 @@ void CEventScanner::Activate(CEventPollHandle &handle)
   CLog::Log(LOGDEBUG, "PERIPHERALS: Event poll handle activated");
 }
 
-void CEventScanner::Deactivate(CEventPollHandle &handle)
+void CEventScanner::Deactivate(CEventPollHandle& handle)
 {
   {
     CSingleLock lock(m_handleMutex);
@@ -93,7 +92,7 @@ void CEventScanner::HandleEvents(bool bWait)
   }
 }
 
-void CEventScanner::Release(CEventPollHandle &handle)
+void CEventScanner::Release(CEventPollHandle& handle)
 {
   {
     CSingleLock lock(m_handleMutex);
@@ -117,7 +116,7 @@ EventLockHandlePtr CEventScanner::RegisterLock()
   return handle;
 }
 
-void CEventScanner::ReleaseLock(CEventLockHandle &handle)
+void CEventScanner::ReleaseLock(CEventLockHandle& handle)
 {
   {
     CSingleLock lock(m_lockMutex);
diff --git a/xbmc/peripherals/EventScanner.h b/xbmc/peripherals/EventScanner.h
index db4ffe7508c2..26625f32418f 100644
--- a/xbmc/peripherals/EventScanner.h
+++ b/xbmc/peripherals/EventScanner.h
@@ -19,59 +19,57 @@
 
 namespace PERIPHERALS
 {
-  class IEventScannerCallback;
+class IEventScannerCallback;
 
-  /*!
-   * \brief Class to scan for peripheral events
-   *
-   * By default, a rate of 60 Hz is used. A client can obtain control over when
-   * input is handled by registering for a polling handle.
-   */
-  class CEventScanner : public IEventPollCallback,
-                        public IEventLockCallback,
-                        protected CThread
-  {
-  public:
-    explicit CEventScanner(IEventScannerCallback &callback);
+/*!
+ * \brief Class to scan for peripheral events
+ *
+ * By default, a rate of 60 Hz is used. A client can obtain control over when
+ * input is handled by registering for a polling handle.
+ */
+class CEventScanner : public IEventPollCallback, public IEventLockCallback, protected CThread
+{
+public:
+  explicit CEventScanner(IEventScannerCallback& callback);
 
-    ~CEventScanner() override = default;
+  ~CEventScanner() override = default;
 
-    void Start();
-    void Stop();
+  void Start();
+  void Stop();
 
-    EventPollHandlePtr RegisterPollHandle();
+  EventPollHandlePtr RegisterPollHandle();
 
-    /*!
-     * \brief Acquire a lock that prevents event processing while held
-     */
-    EventLockHandlePtr RegisterLock();
+  /*!
+   * \brief Acquire a lock that prevents event processing while held
+   */
+  EventLockHandlePtr RegisterLock();
 
-    // implementation of IEventPollCallback
-    void Activate(CEventPollHandle &handle) override;
-    void Deactivate(CEventPollHandle &handle) override;
-    void HandleEvents(bool bWait) override;
-    void Release(CEventPollHandle &handle) override;
+  // implementation of IEventPollCallback
+  void Activate(CEventPollHandle& handle) override;
+  void Deactivate(CEventPollHandle& handle) override;
+  void HandleEvents(bool bWait) override;
+  void Release(CEventPollHandle& handle) override;
 
-    // implementation of IEventLockCallback
-    void ReleaseLock(CEventLockHandle &handle) override;
+  // implementation of IEventLockCallback
+  void ReleaseLock(CEventLockHandle& handle) override;
 
-  protected:
-    // implementation of CThread
-    void Process() override;
+protected:
+  // implementation of CThread
+  void Process() override;
 
-  private:
-    double GetScanIntervalMs() const;
+private:
+  double GetScanIntervalMs() const;
 
-    // Construction parameters
-    IEventScannerCallback &m_callback;
+  // Construction parameters
+  IEventScannerCallback& m_callback;
 
-    // Event parameters
-    std::set<void*> m_activeHandles;
-    std::set<void*> m_activeLocks;
-    CEvent m_scanEvent;
-    CEvent m_scanFinishedEvent;
-    mutable CCriticalSection m_handleMutex;
-    CCriticalSection m_lockMutex;
-    CCriticalSection m_pollMutex; // Prevent two poll handles from polling at once
-  };
-}
+  // Event parameters
+  std::set<void*> m_activeHandles;
+  std::set<void*> m_activeLocks;
+  CEvent m_scanEvent;
+  CEvent m_scanFinishedEvent;
+  mutable CCriticalSection m_handleMutex;
+  CCriticalSection m_lockMutex;
+  CCriticalSection m_pollMutex; // Prevent two poll handles from polling at once
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/IEventScannerCallback.h b/xbmc/peripherals/IEventScannerCallback.h
index 83fe65e5f4b0..d017273cadb3 100644
--- a/xbmc/peripherals/IEventScannerCallback.h
+++ b/xbmc/peripherals/IEventScannerCallback.h
@@ -10,11 +10,11 @@
 
 namespace PERIPHERALS
 {
-  class IEventScannerCallback
-  {
-  public:
-    virtual ~IEventScannerCallback(void) = default;
+class IEventScannerCallback
+{
+public:
+  virtual ~IEventScannerCallback(void) = default;
 
-    virtual void ProcessEvents(void) = 0;
-  };
-}
+  virtual void ProcessEvents(void) = 0;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/PeripheralTypes.h b/xbmc/peripherals/PeripheralTypes.h
index 0852a24c58cb..fa1a8a15dedf 100644
--- a/xbmc/peripherals/PeripheralTypes.h
+++ b/xbmc/peripherals/PeripheralTypes.h
@@ -11,8 +11,8 @@
 #include <algorithm>
 #include <map>
 #include <memory>
-#include <string>
 #include <stdio.h>
+#include <string>
 #include <vector>
 #ifdef TARGET_WINDOWS
 #include "PlatformDefs.h"
@@ -23,97 +23,97 @@ class CSetting;
 
 namespace PERIPHERALS
 {
-  enum PeripheralBusType
-  {
-    PERIPHERAL_BUS_UNKNOWN = 0,
-    PERIPHERAL_BUS_USB,
-    PERIPHERAL_BUS_PCI,
-    PERIPHERAL_BUS_RPI,
-    PERIPHERAL_BUS_CEC,
-    PERIPHERAL_BUS_ADDON,
+enum PeripheralBusType
+{
+  PERIPHERAL_BUS_UNKNOWN = 0,
+  PERIPHERAL_BUS_USB,
+  PERIPHERAL_BUS_PCI,
+  PERIPHERAL_BUS_RPI,
+  PERIPHERAL_BUS_CEC,
+  PERIPHERAL_BUS_ADDON,
 #ifdef TARGET_ANDROID
-    PERIPHERAL_BUS_ANDROID,
+  PERIPHERAL_BUS_ANDROID,
 #endif
-    PERIPHERAL_BUS_APPLICATION,
-  };
-
-  enum PeripheralFeature
-  {
-    FEATURE_UNKNOWN = 0,
-    FEATURE_HID,
-    FEATURE_NIC,
-    FEATURE_DISK,
-    FEATURE_NYXBOARD,
-    FEATURE_CEC,
-    FEATURE_BLUETOOTH,
-    FEATURE_TUNER,
-    FEATURE_IMON,
-    FEATURE_JOYSTICK,
-    FEATURE_RUMBLE,
-    FEATURE_POWER_OFF,
-    FEATURE_KEYBOARD,
-    FEATURE_MOUSE,
-  };
-
-  enum PeripheralType
-  {
-    PERIPHERAL_UNKNOWN = 0,
-    PERIPHERAL_HID,
-    PERIPHERAL_NIC,
-    PERIPHERAL_DISK,
-    PERIPHERAL_NYXBOARD,
-    PERIPHERAL_CEC,
-    PERIPHERAL_BLUETOOTH,
-    PERIPHERAL_TUNER,
-    PERIPHERAL_IMON,
-    PERIPHERAL_JOYSTICK,
-    PERIPHERAL_KEYBOARD,
-    PERIPHERAL_MOUSE,
-  };
-
-  class CPeripheral;
-  using PeripheralPtr = std::shared_ptr<CPeripheral>;
-  using PeripheralVector = std::vector<PeripheralPtr>;
-
-  class CPeripheralAddon;
-  using PeripheralAddonPtr = std::shared_ptr<CPeripheralAddon>;
-  using PeripheralAddonVector = std::vector<PeripheralAddonPtr>;
-
-  class CEventPollHandle;
-  using EventPollHandlePtr = std::unique_ptr<CEventPollHandle>;
-
-  class CEventLockHandle;
-  using EventLockHandlePtr = std::unique_ptr<CEventLockHandle>;
-
-  struct PeripheralID
-  {
-    int m_iVendorId;
-    int m_iProductId;
-  };
+  PERIPHERAL_BUS_APPLICATION,
+};
 
-  struct PeripheralDeviceSetting
-  {
-    std::shared_ptr<CSetting> m_setting;
-    int m_order;
-  };
+enum PeripheralFeature
+{
+  FEATURE_UNKNOWN = 0,
+  FEATURE_HID,
+  FEATURE_NIC,
+  FEATURE_DISK,
+  FEATURE_NYXBOARD,
+  FEATURE_CEC,
+  FEATURE_BLUETOOTH,
+  FEATURE_TUNER,
+  FEATURE_IMON,
+  FEATURE_JOYSTICK,
+  FEATURE_RUMBLE,
+  FEATURE_POWER_OFF,
+  FEATURE_KEYBOARD,
+  FEATURE_MOUSE,
+};
+
+enum PeripheralType
+{
+  PERIPHERAL_UNKNOWN = 0,
+  PERIPHERAL_HID,
+  PERIPHERAL_NIC,
+  PERIPHERAL_DISK,
+  PERIPHERAL_NYXBOARD,
+  PERIPHERAL_CEC,
+  PERIPHERAL_BLUETOOTH,
+  PERIPHERAL_TUNER,
+  PERIPHERAL_IMON,
+  PERIPHERAL_JOYSTICK,
+  PERIPHERAL_KEYBOARD,
+  PERIPHERAL_MOUSE,
+};
+
+class CPeripheral;
+using PeripheralPtr = std::shared_ptr<CPeripheral>;
+using PeripheralVector = std::vector<PeripheralPtr>;
+
+class CPeripheralAddon;
+using PeripheralAddonPtr = std::shared_ptr<CPeripheralAddon>;
+using PeripheralAddonVector = std::vector<PeripheralAddonPtr>;
+
+class CEventPollHandle;
+using EventPollHandlePtr = std::unique_ptr<CEventPollHandle>;
+
+class CEventLockHandle;
+using EventLockHandlePtr = std::unique_ptr<CEventLockHandle>;
+
+struct PeripheralID
+{
+  int m_iVendorId;
+  int m_iProductId;
+};
 
-  struct PeripheralDeviceMapping
-  {
-    std::vector<PeripheralID>                     m_PeripheralID;
-    PeripheralBusType                             m_busType;
-    PeripheralType                                m_class;
-    std::string                                    m_strDeviceName;
-    PeripheralType                                m_mappedTo;
-    std::map<std::string, PeripheralDeviceSetting> m_settings;
-  };
+struct PeripheralDeviceSetting
+{
+  std::shared_ptr<CSetting> m_setting;
+  int m_order;
+};
 
-  class PeripheralTypeTranslator
+struct PeripheralDeviceMapping
+{
+  std::vector<PeripheralID> m_PeripheralID;
+  PeripheralBusType m_busType;
+  PeripheralType m_class;
+  std::string m_strDeviceName;
+  PeripheralType m_mappedTo;
+  std::map<std::string, PeripheralDeviceSetting> m_settings;
+};
+
+class PeripheralTypeTranslator
+{
+public:
+  static const char* TypeToString(const PeripheralType type)
   {
-  public:
-    static const char *TypeToString(const PeripheralType type)
+    switch (type)
     {
-      switch (type)
-      {
       case PERIPHERAL_BLUETOOTH:
         return "bluetooth";
       case PERIPHERAL_CEC:
@@ -138,44 +138,44 @@ namespace PERIPHERALS
         return "mouse";
       default:
         return "unknown";
-      }
-    };
+    }
+  };
 
-    static PeripheralType GetTypeFromString(const std::string &strType)
-    {
-      std::string strTypeLowerCase(strType);
-      StringUtils::ToLower(strTypeLowerCase);
-
-      if (strTypeLowerCase == "bluetooth")
-        return PERIPHERAL_BLUETOOTH;
-      else if (strTypeLowerCase == "cec")
-        return PERIPHERAL_CEC;
-      else if (strTypeLowerCase == "disk")
-          return PERIPHERAL_DISK;
-      else if (strTypeLowerCase == "hid")
-        return PERIPHERAL_HID;
-      else if (strTypeLowerCase == "nic")
-        return PERIPHERAL_NIC;
-      else if (strTypeLowerCase == "nyxboard")
-        return PERIPHERAL_NYXBOARD;
-      else if (strTypeLowerCase == "tuner")
-        return PERIPHERAL_TUNER;
-      else if (strTypeLowerCase == "imon")
-        return PERIPHERAL_IMON;
-      else if (strTypeLowerCase == "joystick")
-        return PERIPHERAL_JOYSTICK;
-      else if (strTypeLowerCase == "keyboard")
-        return PERIPHERAL_KEYBOARD;
-      else if (strTypeLowerCase == "mouse")
-        return PERIPHERAL_MOUSE;
-
-      return PERIPHERAL_UNKNOWN;
-    };
-
-    static const char *BusTypeToString(const PeripheralBusType type)
+  static PeripheralType GetTypeFromString(const std::string& strType)
+  {
+    std::string strTypeLowerCase(strType);
+    StringUtils::ToLower(strTypeLowerCase);
+
+    if (strTypeLowerCase == "bluetooth")
+      return PERIPHERAL_BLUETOOTH;
+    else if (strTypeLowerCase == "cec")
+      return PERIPHERAL_CEC;
+    else if (strTypeLowerCase == "disk")
+      return PERIPHERAL_DISK;
+    else if (strTypeLowerCase == "hid")
+      return PERIPHERAL_HID;
+    else if (strTypeLowerCase == "nic")
+      return PERIPHERAL_NIC;
+    else if (strTypeLowerCase == "nyxboard")
+      return PERIPHERAL_NYXBOARD;
+    else if (strTypeLowerCase == "tuner")
+      return PERIPHERAL_TUNER;
+    else if (strTypeLowerCase == "imon")
+      return PERIPHERAL_IMON;
+    else if (strTypeLowerCase == "joystick")
+      return PERIPHERAL_JOYSTICK;
+    else if (strTypeLowerCase == "keyboard")
+      return PERIPHERAL_KEYBOARD;
+    else if (strTypeLowerCase == "mouse")
+      return PERIPHERAL_MOUSE;
+
+    return PERIPHERAL_UNKNOWN;
+  };
+
+  static const char* BusTypeToString(const PeripheralBusType type)
+  {
+    switch (type)
     {
-      switch(type)
-      {
       case PERIPHERAL_BUS_USB:
         return "usb";
       case PERIPHERAL_BUS_PCI:
@@ -194,38 +194,38 @@ namespace PERIPHERALS
         return "application";
       default:
         return "unknown";
-      }
-    };
+    }
+  };
 
-    static PeripheralBusType GetBusTypeFromString(const std::string &strType)
-    {
-      std::string strTypeLowerCase(strType);
-      StringUtils::ToLower(strTypeLowerCase);
-
-      if (strTypeLowerCase == "usb")
-        return PERIPHERAL_BUS_USB;
-      else if (strTypeLowerCase == "pci")
-        return PERIPHERAL_BUS_PCI;
-      else if (strTypeLowerCase == "rpi")
-        return PERIPHERAL_BUS_RPI;
-      else if (strTypeLowerCase == "cec")
-        return PERIPHERAL_BUS_CEC;
-      else if (strTypeLowerCase == "addon")
-        return PERIPHERAL_BUS_ADDON;
+  static PeripheralBusType GetBusTypeFromString(const std::string& strType)
+  {
+    std::string strTypeLowerCase(strType);
+    StringUtils::ToLower(strTypeLowerCase);
+
+    if (strTypeLowerCase == "usb")
+      return PERIPHERAL_BUS_USB;
+    else if (strTypeLowerCase == "pci")
+      return PERIPHERAL_BUS_PCI;
+    else if (strTypeLowerCase == "rpi")
+      return PERIPHERAL_BUS_RPI;
+    else if (strTypeLowerCase == "cec")
+      return PERIPHERAL_BUS_CEC;
+    else if (strTypeLowerCase == "addon")
+      return PERIPHERAL_BUS_ADDON;
 #ifdef TARGET_ANDROID
-      else if (strTypeLowerCase == "android")
-        return PERIPHERAL_BUS_ANDROID;
+    else if (strTypeLowerCase == "android")
+      return PERIPHERAL_BUS_ANDROID;
 #endif
-      else if (strTypeLowerCase == "application")
-        return PERIPHERAL_BUS_APPLICATION;
+    else if (strTypeLowerCase == "application")
+      return PERIPHERAL_BUS_APPLICATION;
 
-      return PERIPHERAL_BUS_UNKNOWN;
-    };
+    return PERIPHERAL_BUS_UNKNOWN;
+  };
 
-    static const char *FeatureToString(const PeripheralFeature type)
+  static const char* FeatureToString(const PeripheralFeature type)
+  {
+    switch (type)
     {
-      switch (type)
-      {
       case FEATURE_HID:
         return "HID";
       case FEATURE_NIC:
@@ -255,115 +255,110 @@ namespace PERIPHERALS
       case FEATURE_UNKNOWN:
       default:
         return "unknown";
-      }
-    };
-
-    static PeripheralFeature GetFeatureTypeFromString(const std::string &strType)
-    {
-      std::string strTypeLowerCase(strType);
-      StringUtils::ToLower(strTypeLowerCase);
-
-      if (strTypeLowerCase == "hid")
-        return FEATURE_HID;
-      else if (strTypeLowerCase == "cec")
-        return FEATURE_CEC;
-      else if (strTypeLowerCase == "disk")
-        return FEATURE_DISK;
-      else if (strTypeLowerCase == "nyxboard")
-        return FEATURE_NYXBOARD;
-      else if (strTypeLowerCase == "bluetooth")
-        return FEATURE_BLUETOOTH;
-      else if (strTypeLowerCase == "tuner")
-        return FEATURE_TUNER;
-      else if (strTypeLowerCase == "imon")
-        return FEATURE_IMON;
-      else if (strTypeLowerCase == "joystick")
-        return FEATURE_JOYSTICK;
-      else if (strTypeLowerCase == "rumble")
-        return FEATURE_RUMBLE;
-      else if (strTypeLowerCase == "poweroff")
-        return FEATURE_POWER_OFF;
-      else if (strTypeLowerCase == "keyboard")
-        return FEATURE_KEYBOARD;
-      else if (strTypeLowerCase == "mouse")
-        return FEATURE_MOUSE;
-
-      return FEATURE_UNKNOWN;
-    };
-
-    static int HexStringToInt(const char *strHex)
-    {
-      int iVal;
-      sscanf(strHex, "%x", &iVal);
-      return iVal;
-    };
-
-    static void FormatHexString(int iVal, std::string &strHexString)
-    {
-      if (iVal < 0)
-        iVal = 0;
-      if (iVal > 65536)
-        iVal = 65536;
+    }
+  };
 
-      strHexString = StringUtils::Format("%04X", iVal);
-    };
+  static PeripheralFeature GetFeatureTypeFromString(const std::string& strType)
+  {
+    std::string strTypeLowerCase(strType);
+    StringUtils::ToLower(strTypeLowerCase);
+
+    if (strTypeLowerCase == "hid")
+      return FEATURE_HID;
+    else if (strTypeLowerCase == "cec")
+      return FEATURE_CEC;
+    else if (strTypeLowerCase == "disk")
+      return FEATURE_DISK;
+    else if (strTypeLowerCase == "nyxboard")
+      return FEATURE_NYXBOARD;
+    else if (strTypeLowerCase == "bluetooth")
+      return FEATURE_BLUETOOTH;
+    else if (strTypeLowerCase == "tuner")
+      return FEATURE_TUNER;
+    else if (strTypeLowerCase == "imon")
+      return FEATURE_IMON;
+    else if (strTypeLowerCase == "joystick")
+      return FEATURE_JOYSTICK;
+    else if (strTypeLowerCase == "rumble")
+      return FEATURE_RUMBLE;
+    else if (strTypeLowerCase == "poweroff")
+      return FEATURE_POWER_OFF;
+    else if (strTypeLowerCase == "keyboard")
+      return FEATURE_KEYBOARD;
+    else if (strTypeLowerCase == "mouse")
+      return FEATURE_MOUSE;
+
+    return FEATURE_UNKNOWN;
   };
 
-  class PeripheralScanResult
+  static int HexStringToInt(const char* strHex)
   {
-  public:
-    explicit PeripheralScanResult(const PeripheralBusType busType) :
-      m_busType(busType),
-      m_mappedBusType(busType)
-      {}
+    int iVal;
+    sscanf(strHex, "%x", &iVal);
+    return iVal;
+  };
 
-    PeripheralScanResult(void) = default;
+  static void FormatHexString(int iVal, std::string& strHexString)
+  {
+    if (iVal < 0)
+      iVal = 0;
+    if (iVal > 65536)
+      iVal = 65536;
 
-    bool operator ==(const PeripheralScanResult& right) const
-    {
-      return m_iVendorId  == right.m_iVendorId &&
-             m_iProductId == right.m_iProductId &&
-             m_type       == right.m_type &&
-             m_busType    == right.m_busType &&
-             StringUtils::EqualsNoCase(m_strLocation, right.m_strLocation);
-    }
+    strHexString = StringUtils::Format("%04X", iVal);
+  };
+};
 
-    bool operator !=(const PeripheralScanResult& right) const
-    {
-      return !(*this == right);
-    }
+class PeripheralScanResult
+{
+public:
+  explicit PeripheralScanResult(const PeripheralBusType busType)
+    : m_busType(busType), m_mappedBusType(busType)
+  {
+  }
 
-    PeripheralType    m_type = PERIPHERAL_UNKNOWN;
-    std::string        m_strLocation;
-    int               m_iVendorId = 0;
-    int               m_iProductId = 0;
-    PeripheralType    m_mappedType = PERIPHERAL_UNKNOWN;
-    std::string        m_strDeviceName;
-    PeripheralBusType m_busType = PERIPHERAL_BUS_UNKNOWN;
-    PeripheralBusType m_mappedBusType = PERIPHERAL_BUS_UNKNOWN;
-    unsigned int      m_iSequence = 0; // when more than one adapter of the same type is found
-  };
+  PeripheralScanResult(void) = default;
 
-  struct PeripheralScanResults
+  bool operator==(const PeripheralScanResult& right) const
+  {
+    return m_iVendorId == right.m_iVendorId && m_iProductId == right.m_iProductId &&
+           m_type == right.m_type && m_busType == right.m_busType &&
+           StringUtils::EqualsNoCase(m_strLocation, right.m_strLocation);
+  }
+
+  bool operator!=(const PeripheralScanResult& right) const { return !(*this == right); }
+
+  PeripheralType m_type = PERIPHERAL_UNKNOWN;
+  std::string m_strLocation;
+  int m_iVendorId = 0;
+  int m_iProductId = 0;
+  PeripheralType m_mappedType = PERIPHERAL_UNKNOWN;
+  std::string m_strDeviceName;
+  PeripheralBusType m_busType = PERIPHERAL_BUS_UNKNOWN;
+  PeripheralBusType m_mappedBusType = PERIPHERAL_BUS_UNKNOWN;
+  unsigned int m_iSequence = 0; // when more than one adapter of the same type is found
+};
+
+struct PeripheralScanResults
+{
+  bool GetDeviceOnLocation(const std::string& strLocation, PeripheralScanResult* result) const
   {
-    bool GetDeviceOnLocation(const std::string& strLocation, PeripheralScanResult* result) const
+    for (const auto& it : m_results)
     {
-      for (const auto& it : m_results)
+      if (it.m_strLocation == strLocation)
       {
-        if (it.m_strLocation == strLocation)
-        {
-          *result = it;
-          return true;
-        }
+        *result = it;
+        return true;
       }
-      return false;
     }
+    return false;
+  }
 
-    bool ContainsResult(const PeripheralScanResult& result) const
-    {
-      return std::find(m_results.begin(), m_results.end(), result) != m_results.end();
-    }
+  bool ContainsResult(const PeripheralScanResult& result) const
+  {
+    return std::find(m_results.begin(), m_results.end(), result) != m_results.end();
+  }
 
-    std::vector<PeripheralScanResult> m_results;
-  };
-}
+  std::vector<PeripheralScanResult> m_results;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/Peripherals.cpp b/xbmc/peripherals/Peripherals.cpp
index 7963e7b0382f..07db9f970ad6 100644
--- a/xbmc/peripherals/Peripherals.cpp
+++ b/xbmc/peripherals/Peripherals.cpp
@@ -8,19 +8,24 @@
 
 #include "Peripherals.h"
 
-#include <utility>
-
 #include "EventScanner.h"
 #include "addons/AddonButtonMap.h"
 #include "addons/AddonManager.h"
-#include "addons/settings/GUIDialogAddonSettings.h"
 #include "addons/GUIWindowAddonBrowser.h"
+#include "addons/settings/GUIDialogAddonSettings.h"
 #include "bus/PeripheralBus.h"
 #include "bus/PeripheralBusUSB.h"
+
+#include <utility>
 #if defined(TARGET_ANDROID)
 #include "platform/android/peripherals/PeripheralBusAndroid.h"
 #endif
+#include "FileItem.h"
+#include "GUIUserMessages.h"
+#include "ServiceBroker.h"
+#include "Util.h"
 #include "bus/virtual/PeripheralBusAddon.h"
+#include "bus/virtual/PeripheralBusApplication.h"
 #include "devices/PeripheralBluetooth.h"
 #include "devices/PeripheralCecAdapter.h"
 #include "devices/PeripheralDisk.h"
@@ -32,29 +37,24 @@
 #include "devices/PeripheralNIC.h"
 #include "devices/PeripheralNyxboard.h"
 #include "devices/PeripheralTuner.h"
-#include "FileItem.h"
-#include "bus/virtual/PeripheralBusApplication.h"
-#include "input/joysticks/interfaces/IButtonMapper.h"
-#include "interfaces/AnnouncementManager.h"
 #include "filesystem/Directory.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIWindowManager.h"
 #include "guilib/WindowIDs.h"
-#include "GUIUserMessages.h"
 #include "input/Key.h"
+#include "input/joysticks/interfaces/IButtonMapper.h"
+#include "interfaces/AnnouncementManager.h"
 #include "messaging/ApplicationMessenger.h"
 #include "messaging/ThreadMessage.h"
 #include "peripherals/dialogs/GUIDialogPeripherals.h"
-#include "settings/lib/Setting.h"
 #include "settings/Settings.h"
 #include "settings/SettingsComponent.h"
+#include "settings/lib/Setting.h"
 #include "threads/SingleLock.h"
-#include "Util.h"
-#include "utils/log.h"
 #include "utils/StringUtils.h"
 #include "utils/XBMCTinyXML.h"
 #include "utils/XMLUtils.h"
-#include "ServiceBroker.h"
+#include "utils/log.h"
 
 #if defined(HAVE_LIBCEC)
 #include "bus/virtual/PeripheralBusCEC.h"
@@ -69,11 +69,11 @@ using namespace PERIPHERALS;
 using namespace XFILE;
 using namespace KODI::MESSAGING;
 
-CPeripherals::CPeripherals(CInputManager &inputManager,
-                           GAME::CControllerManager &controllerProfiles) :
-  m_inputManager(inputManager),
-  m_controllerProfiles(controllerProfiles),
-  m_eventScanner(new CEventScanner(*this))
+CPeripherals::CPeripherals(CInputManager& inputManager,
+                           GAME::CControllerManager& controllerProfiles)
+  : m_inputManager(inputManager),
+    m_controllerProfiles(controllerProfiles),
+    m_eventScanner(new CEventScanner(*this))
 {
   // Register settings
   std::set<std::string> settingSet;
@@ -193,17 +193,17 @@ PeripheralBusPtr CPeripherals::GetBusByType(const PeripheralBusType type) const
 {
   CSingleLock lock(m_critSectionBusses);
 
-  const auto& bus = std::find_if(m_busses.cbegin(), m_busses.cend(),
-    [type](const PeripheralBusPtr& bus) {
-      return bus->Type() == type;
-    });
+  const auto& bus =
+      std::find_if(m_busses.cbegin(), m_busses.cend(),
+                   [type](const PeripheralBusPtr& bus) { return bus->Type() == type; });
   if (bus != m_busses.cend())
     return *bus;
 
   return nullptr;
 }
 
-PeripheralPtr CPeripherals::GetPeripheralAtLocation(const std::string &strLocation, PeripheralBusType busType /* = PERIPHERAL_BUS_UNKNOWN */) const
+PeripheralPtr CPeripherals::GetPeripheralAtLocation(
+    const std::string& strLocation, PeripheralBusType busType /* = PERIPHERAL_BUS_UNKNOWN */) const
 {
   PeripheralPtr result;
 
@@ -226,19 +226,20 @@ PeripheralPtr CPeripherals::GetPeripheralAtLocation(const std::string &strLocati
   return result;
 }
 
-bool CPeripherals::HasPeripheralAtLocation(const std::string &strLocation, PeripheralBusType busType /* = PERIPHERAL_BUS_UNKNOWN */) const
+bool CPeripherals::HasPeripheralAtLocation(
+    const std::string& strLocation, PeripheralBusType busType /* = PERIPHERAL_BUS_UNKNOWN */) const
 {
   return (GetPeripheralAtLocation(strLocation, busType) != nullptr);
 }
 
-PeripheralBusPtr CPeripherals::GetBusWithDevice(const std::string &strLocation) const
+PeripheralBusPtr CPeripherals::GetBusWithDevice(const std::string& strLocation) const
 {
   CSingleLock lock(m_critSectionBusses);
 
-  const auto& bus = std::find_if(m_busses.cbegin(), m_busses.cend(),
-    [&strLocation](const PeripheralBusPtr& bus) {
-    return bus->HasPeripheral(strLocation);
-  });
+  const auto& bus =
+      std::find_if(m_busses.cbegin(), m_busses.cend(), [&strLocation](const PeripheralBusPtr& bus) {
+        return bus->HasPeripheral(strLocation);
+      });
   if (bus != m_busses.cend())
     return *bus;
 
@@ -256,7 +257,10 @@ bool CPeripherals::SupportsFeature(PeripheralFeature feature) const
   return bSupportsFeature;
 }
 
-int CPeripherals::GetPeripheralsWithFeature(PeripheralVector &results, const PeripheralFeature feature, PeripheralBusType busType /* = PERIPHERAL_BUS_UNKNOWN */) const
+int CPeripherals::GetPeripheralsWithFeature(
+    PeripheralVector& results,
+    const PeripheralFeature feature,
+    PeripheralBusType busType /* = PERIPHERAL_BUS_UNKNOWN */) const
 {
   CSingleLock lock(m_critSectionBusses);
   int iReturn(0);
@@ -282,13 +286,14 @@ size_t CPeripherals::GetNumberOfPeripherals() const
   return iReturn;
 }
 
-bool CPeripherals::HasPeripheralWithFeature(const PeripheralFeature feature, PeripheralBusType busType /* = PERIPHERAL_BUS_UNKNOWN */) const
+bool CPeripherals::HasPeripheralWithFeature(
+    const PeripheralFeature feature, PeripheralBusType busType /* = PERIPHERAL_BUS_UNKNOWN */) const
 {
   PeripheralVector dummy;
   return (GetPeripheralsWithFeature(dummy, feature, busType) > 0);
 }
 
-void CPeripherals::CreatePeripheral(CPeripheralBus &bus, const PeripheralScanResult& result)
+void CPeripherals::CreatePeripheral(CPeripheralBus& bus, const PeripheralScanResult& result)
 {
   PeripheralPtr peripheral;
   PeripheralScanResult mappedResult = result;
@@ -298,64 +303,69 @@ void CPeripherals::CreatePeripheral(CPeripheralBus &bus, const PeripheralScanRes
   /* check whether there's something mapped in peripherals.xml */
   GetMappingForDevice(bus, mappedResult);
 
-  switch(mappedResult.m_mappedType)
+  switch (mappedResult.m_mappedType)
   {
-  case PERIPHERAL_HID:
-    peripheral = PeripheralPtr(new CPeripheralHID(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_HID:
+      peripheral = PeripheralPtr(new CPeripheralHID(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_NIC:
-    peripheral = PeripheralPtr(new CPeripheralNIC(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_NIC:
+      peripheral = PeripheralPtr(new CPeripheralNIC(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_DISK:
-    peripheral = PeripheralPtr(new CPeripheralDisk(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_DISK:
+      peripheral = PeripheralPtr(new CPeripheralDisk(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_NYXBOARD:
-    peripheral = PeripheralPtr(new CPeripheralNyxboard(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_NYXBOARD:
+      peripheral = PeripheralPtr(new CPeripheralNyxboard(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_TUNER:
-    peripheral = PeripheralPtr(new CPeripheralTuner(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_TUNER:
+      peripheral = PeripheralPtr(new CPeripheralTuner(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_BLUETOOTH:
-    peripheral = PeripheralPtr(new CPeripheralBluetooth(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_BLUETOOTH:
+      peripheral = PeripheralPtr(new CPeripheralBluetooth(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_CEC:
+    case PERIPHERAL_CEC:
 #if defined(HAVE_LIBCEC)
-    if (bus.Type() == PERIPHERAL_BUS_CEC)
-      peripheral = PeripheralPtr(new CPeripheralCecAdapter(*this, mappedResult, &bus));
+      if (bus.Type() == PERIPHERAL_BUS_CEC)
+        peripheral = PeripheralPtr(new CPeripheralCecAdapter(*this, mappedResult, &bus));
 #else
-    if (!m_bMissingLibCecWarningDisplayed)
-    {
-      m_bMissingLibCecWarningDisplayed = true;
-      CLog::Log(LOGWARNING, "%s - libCEC support has not been compiled in, so the CEC adapter cannot be used.", __FUNCTION__);
-      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Warning, g_localizeStrings.Get(36000), g_localizeStrings.Get(36017));
-    }
+      if (!m_bMissingLibCecWarningDisplayed)
+      {
+        m_bMissingLibCecWarningDisplayed = true;
+        CLog::Log(
+            LOGWARNING,
+            "%s - libCEC support has not been compiled in, so the CEC adapter cannot be used.",
+            __FUNCTION__);
+        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Warning,
+                                              g_localizeStrings.Get(36000),
+                                              g_localizeStrings.Get(36017));
+      }
 #endif
-    break;
+      break;
 
-  case PERIPHERAL_IMON:
-    peripheral = PeripheralPtr(new CPeripheralImon(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_IMON:
+      peripheral = PeripheralPtr(new CPeripheralImon(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_JOYSTICK:
-    peripheral = PeripheralPtr(new CPeripheralJoystick(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_JOYSTICK:
+      peripheral = PeripheralPtr(new CPeripheralJoystick(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_KEYBOARD:
-    peripheral = PeripheralPtr(new CPeripheralKeyboard(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_KEYBOARD:
+      peripheral = PeripheralPtr(new CPeripheralKeyboard(*this, mappedResult, &bus));
+      break;
 
-  case PERIPHERAL_MOUSE:
-    peripheral = PeripheralPtr(new CPeripheralMouse(*this, mappedResult, &bus));
-    break;
+    case PERIPHERAL_MOUSE:
+      peripheral = PeripheralPtr(new CPeripheralMouse(*this, mappedResult, &bus));
+      break;
 
-  default:
-    break;
+    default:
+      break;
   }
 
   if (peripheral)
@@ -366,12 +376,13 @@ void CPeripherals::CreatePeripheral(CPeripheralBus &bus, const PeripheralScanRes
       bus.Register(peripheral);
     else
     {
-      CLog::Log(LOGDEBUG, "%s - failed to initialise peripheral on '%s'", __FUNCTION__, mappedResult.m_strLocation.c_str());
+      CLog::Log(LOGDEBUG, "%s - failed to initialise peripheral on '%s'", __FUNCTION__,
+                mappedResult.m_strLocation.c_str());
     }
   }
 }
 
-void CPeripherals::OnDeviceAdded(const CPeripheralBus &bus, const CPeripheral &peripheral)
+void CPeripherals::OnDeviceAdded(const CPeripheralBus& bus, const CPeripheral& peripheral)
 {
   OnDeviceChanged();
 
@@ -388,7 +399,7 @@ void CPeripherals::OnDeviceAdded(const CPeripheralBus &bus, const CPeripheral &p
 #endif
 }
 
-void CPeripherals::OnDeviceDeleted(const CPeripheralBus &bus, const CPeripheral &peripheral)
+void CPeripherals::OnDeviceDeleted(const CPeripheralBus& bus, const CPeripheral& peripheral)
 {
   OnDeviceChanged();
 
@@ -405,12 +416,14 @@ void CPeripherals::OnDeviceChanged()
 {
   // refresh settings (peripherals manager could be enabled/disabled now)
   CGUIMessage msgSettings(GUI_MSG_UPDATE, WINDOW_SETTINGS_SYSTEM, 0);
-  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msgSettings, WINDOW_SETTINGS_SYSTEM);
+  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msgSettings,
+                                                                 WINDOW_SETTINGS_SYSTEM);
 
   SetChanged();
 }
 
-bool CPeripherals::GetMappingForDevice(const CPeripheralBus &bus, PeripheralScanResult& result) const
+bool CPeripherals::GetMappingForDevice(const CPeripheralBus& bus,
+                                       PeripheralScanResult& result) const
 {
   CSingleLock lock(m_critSectionMappings);
 
@@ -423,11 +436,13 @@ bool CPeripherals::GetMappingForDevice(const CPeripheralBus &bus, PeripheralScan
     else
     {
       for (const auto& peripheralID : mapping.m_PeripheralID)
-        if (peripheralID.m_iVendorId == result.m_iVendorId && peripheralID.m_iProductId == result.m_iProductId)
+        if (peripheralID.m_iVendorId == result.m_iVendorId &&
+            peripheralID.m_iProductId == result.m_iProductId)
           bProductMatch = true;
     }
 
-    bool bBusMatch = (mapping.m_busType == PERIPHERAL_BUS_UNKNOWN || mapping.m_busType == bus.Type());
+    bool bBusMatch =
+        (mapping.m_busType == PERIPHERAL_BUS_UNKNOWN || mapping.m_busType == bus.Type());
     bool bClassMatch = (mapping.m_class == PERIPHERAL_UNKNOWN || mapping.m_class == result.m_type);
 
     if (bProductMatch && bBusMatch && bClassMatch)
@@ -435,8 +450,10 @@ bool CPeripherals::GetMappingForDevice(const CPeripheralBus &bus, PeripheralScan
       std::string strVendorId, strProductId;
       PeripheralTypeTranslator::FormatHexString(result.m_iVendorId, strVendorId);
       PeripheralTypeTranslator::FormatHexString(result.m_iProductId, strProductId);
-      CLog::Log(LOGDEBUG, "%s - device (%s:%s) mapped to %s (type = %s)", __FUNCTION__, strVendorId.c_str(), strProductId.c_str(), mapping.m_strDeviceName.c_str(), PeripheralTypeTranslator::TypeToString(mapping.m_mappedTo));
-      result.m_mappedType    = mapping.m_mappedTo;
+      CLog::Log(LOGDEBUG, "%s - device (%s:%s) mapped to %s (type = %s)", __FUNCTION__,
+                strVendorId.c_str(), strProductId.c_str(), mapping.m_strDeviceName.c_str(),
+                PeripheralTypeTranslator::TypeToString(mapping.m_mappedTo));
+      result.m_mappedType = mapping.m_mappedTo;
       if (!mapping.m_strDeviceName.empty())
         result.m_strDeviceName = mapping.m_strDeviceName;
       return true;
@@ -446,7 +463,7 @@ bool CPeripherals::GetMappingForDevice(const CPeripheralBus &bus, PeripheralScan
   return false;
 }
 
-void CPeripherals::GetSettingsFromMapping(CPeripheral &peripheral) const
+void CPeripherals::GetSettingsFromMapping(CPeripheral& peripheral) const
 {
   CSingleLock lock(m_critSectionMappings);
 
@@ -459,12 +476,15 @@ void CPeripherals::GetSettingsFromMapping(CPeripheral &peripheral) const
     else
     {
       for (const auto& peripheralID : mapping.m_PeripheralID)
-        if (peripheralID.m_iVendorId == peripheral.VendorId() && peripheralID.m_iProductId == peripheral.ProductId())
+        if (peripheralID.m_iVendorId == peripheral.VendorId() &&
+            peripheralID.m_iProductId == peripheral.ProductId())
           bProductMatch = true;
     }
 
-    bool bBusMatch = (mapping.m_busType == PERIPHERAL_BUS_UNKNOWN || mapping.m_busType == peripheral.GetBusType());
-    bool bClassMatch = (mapping.m_class == PERIPHERAL_UNKNOWN || mapping.m_class == peripheral.Type());
+    bool bBusMatch = (mapping.m_busType == PERIPHERAL_BUS_UNKNOWN ||
+                      mapping.m_busType == peripheral.GetBusType());
+    bool bClassMatch =
+        (mapping.m_class == PERIPHERAL_UNKNOWN || mapping.m_class == peripheral.Type());
 
     if (bBusMatch && bProductMatch && bClassMatch)
     {
@@ -486,14 +506,15 @@ bool CPeripherals::LoadMappings()
     return true;
   }
 
-  TiXmlElement *pRootElement = xmlDoc.RootElement();
+  TiXmlElement* pRootElement = xmlDoc.RootElement();
   if (!pRootElement || StringUtils::CompareNoCase(pRootElement->Value(), "peripherals") != 0)
   {
     CLog::Log(LOGERROR, "%s - peripherals.xml does not contain <peripherals>", __FUNCTION__);
     return false;
   }
 
-  for (TiXmlElement *currentNode = pRootElement->FirstChildElement("peripheral"); currentNode; currentNode = currentNode->NextSiblingElement("peripheral"))
+  for (TiXmlElement* currentNode = pRootElement->FirstChildElement("peripheral"); currentNode;
+       currentNode = currentNode->NextSiblingElement("peripheral"))
   {
     PeripheralID id;
     PeripheralDeviceMapping mapping;
@@ -504,13 +525,15 @@ bool CPeripherals::LoadMappings()
     if (currentNode->Attribute("vendor_product"))
     {
       // The vendor_product attribute is a list of comma separated vendor:product pairs
-      std::vector<std::string> vpArray = StringUtils::Split(currentNode->Attribute("vendor_product"), ",");
+      std::vector<std::string> vpArray =
+          StringUtils::Split(currentNode->Attribute("vendor_product"), ",");
       for (const auto& i : vpArray)
       {
         std::vector<std::string> idArray = StringUtils::Split(i, ":");
         if (idArray.size() != 2)
         {
-          CLog::Log(LOGERROR, "%s - ignoring node \"%s\" with invalid vendor_product attribute", __FUNCTION__, mapping.m_strDeviceName.c_str());
+          CLog::Log(LOGERROR, "%s - ignoring node \"%s\" with invalid vendor_product attribute",
+                    __FUNCTION__, mapping.m_strDeviceName.c_str());
           continue;
         }
 
@@ -520,9 +543,12 @@ bool CPeripherals::LoadMappings()
       }
     }
 
-    mapping.m_busType       = PeripheralTypeTranslator::GetBusTypeFromString(XMLUtils::GetAttribute(currentNode, "bus"));
-    mapping.m_class         = PeripheralTypeTranslator::GetTypeFromString(XMLUtils::GetAttribute(currentNode, "class"));
-    mapping.m_mappedTo      = PeripheralTypeTranslator::GetTypeFromString(XMLUtils::GetAttribute(currentNode, "mapTo"));
+    mapping.m_busType =
+        PeripheralTypeTranslator::GetBusTypeFromString(XMLUtils::GetAttribute(currentNode, "bus"));
+    mapping.m_class =
+        PeripheralTypeTranslator::GetTypeFromString(XMLUtils::GetAttribute(currentNode, "class"));
+    mapping.m_mappedTo =
+        PeripheralTypeTranslator::GetTypeFromString(XMLUtils::GetAttribute(currentNode, "mapTo"));
     GetSettingsFromMappingsFile(currentNode, mapping.m_settings);
 
     m_mappings.push_back(mapping);
@@ -532,9 +558,10 @@ bool CPeripherals::LoadMappings()
   return true;
 }
 
-void CPeripherals::GetSettingsFromMappingsFile(TiXmlElement *xmlNode, std::map<std::string, PeripheralDeviceSetting> &settings)
+void CPeripherals::GetSettingsFromMappingsFile(
+    TiXmlElement* xmlNode, std::map<std::string, PeripheralDeviceSetting>& settings)
 {
-  TiXmlElement *currentNode = xmlNode->FirstChildElement("setting");
+  TiXmlElement* currentNode = xmlNode->FirstChildElement("setting");
   int iMaxOrder = 0;
 
   while (currentNode)
@@ -557,17 +584,19 @@ void CPeripherals::GetSettingsFromMappingsFile(TiXmlElement *xmlNode, std::map<s
     else if (strSettingsType == "int")
     {
       int iValue = currentNode->Attribute("value") ? atoi(currentNode->Attribute("value")) : 0;
-      int iMin   = currentNode->Attribute("min") ? atoi(currentNode->Attribute("min")) : 0;
-      int iStep  = currentNode->Attribute("step") ? atoi(currentNode->Attribute("step")) : 1;
-      int iMax   = currentNode->Attribute("max") ? atoi(currentNode->Attribute("max")) : 255;
+      int iMin = currentNode->Attribute("min") ? atoi(currentNode->Attribute("min")) : 0;
+      int iStep = currentNode->Attribute("step") ? atoi(currentNode->Attribute("step")) : 1;
+      int iMax = currentNode->Attribute("max") ? atoi(currentNode->Attribute("max")) : 255;
       setting = std::make_shared<CSettingInt>(strKey, iLabelId, iValue, iMin, iStep, iMax);
     }
     else if (strSettingsType == "float")
     {
-      float fValue = currentNode->Attribute("value") ? (float) atof(currentNode->Attribute("value")) : 0;
-      float fMin   = currentNode->Attribute("min") ? (float) atof(currentNode->Attribute("min")) : 0;
-      float fStep  = currentNode->Attribute("step") ? (float) atof(currentNode->Attribute("step")) : 0;
-      float fMax   = currentNode->Attribute("max") ? (float) atof(currentNode->Attribute("max")) : 0;
+      float fValue =
+          currentNode->Attribute("value") ? (float)atof(currentNode->Attribute("value")) : 0;
+      float fMin = currentNode->Attribute("min") ? (float)atof(currentNode->Attribute("min")) : 0;
+      float fStep =
+          currentNode->Attribute("step") ? (float)atof(currentNode->Attribute("step")) : 0;
+      float fMax = currentNode->Attribute("max") ? (float)atof(currentNode->Attribute("max")) : 0;
       setting = std::make_shared<CSettingNumber>(strKey, iLabelId, fValue, fMin, fStep, fMax);
     }
     else if (StringUtils::EqualsNoCase(strSettingsType, "enum"))
@@ -604,10 +633,10 @@ void CPeripherals::GetSettingsFromMappingsFile(TiXmlElement *xmlNode, std::map<s
       if (iOrder < 0)
         iOrder = 0;
       if (iOrder > iMaxOrder)
-       iMaxOrder = iOrder;
+        iMaxOrder = iOrder;
 
       /* and add this new setting */
-      PeripheralDeviceSetting deviceSetting = { setting, iOrder };
+      PeripheralDeviceSetting deviceSetting = {setting, iOrder};
       settings[strKey] = deviceSetting;
     }
 
@@ -622,7 +651,7 @@ void CPeripherals::GetSettingsFromMappingsFile(TiXmlElement *xmlNode, std::map<s
   }
 }
 
-void CPeripherals::GetDirectory(const std::string &strPath, CFileItemList &items) const
+void CPeripherals::GetDirectory(const std::string& strPath, CFileItemList& items) const
 {
   if (!StringUtils::StartsWithNoCase(strPath, "peripherals://"))
     return;
@@ -639,7 +668,7 @@ void CPeripherals::GetDirectory(const std::string &strPath, CFileItemList &items
   }
 }
 
-PeripheralPtr CPeripherals::GetByPath(const std::string &strPath) const
+PeripheralPtr CPeripherals::GetByPath(const std::string& strPath) const
 {
   PeripheralPtr result;
 
@@ -662,21 +691,23 @@ PeripheralPtr CPeripherals::GetByPath(const std::string &strPath) const
   return result;
 }
 
-bool CPeripherals::OnAction(const CAction &action)
+bool CPeripherals::OnAction(const CAction& action)
 {
   if (action.GetID() == ACTION_MUTE)
   {
     return ToggleMute();
   }
 
-  if (SupportsCEC() && action.GetAmount() && (action.GetID() == ACTION_VOLUME_UP || action.GetID() == ACTION_VOLUME_DOWN))
+  if (SupportsCEC() && action.GetAmount() &&
+      (action.GetID() == ACTION_VOLUME_UP || action.GetID() == ACTION_VOLUME_DOWN))
   {
     PeripheralVector peripherals;
     if (GetPeripheralsWithFeature(peripherals, FEATURE_CEC))
     {
       for (auto& peripheral : peripherals)
       {
-        std::shared_ptr<CPeripheralCecAdapter> cecDevice = std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
+        std::shared_ptr<CPeripheralCecAdapter> cecDevice =
+            std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
         if (cecDevice->HasAudioControl())
         {
           if (action.GetID() == ACTION_VOLUME_UP)
@@ -699,7 +730,8 @@ bool CPeripherals::IsMuted()
   {
     for (const auto& peripheral : peripherals)
     {
-      std::shared_ptr<CPeripheralCecAdapter> cecDevice = std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
+      std::shared_ptr<CPeripheralCecAdapter> cecDevice =
+          std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
       if (cecDevice->IsMuted())
         return true;
     }
@@ -715,7 +747,8 @@ bool CPeripherals::ToggleMute()
   {
     for (auto& peripheral : peripherals)
     {
-      std::shared_ptr<CPeripheralCecAdapter> cecDevice = std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
+      std::shared_ptr<CPeripheralCecAdapter> cecDevice =
+          std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
       if (cecDevice->HasAudioControl())
       {
         cecDevice->ToggleMute();
@@ -736,7 +769,8 @@ bool CPeripherals::ToggleDeviceState(CecStateChange mode /*= STATE_SWITCH_TOGGLE
   {
     for (auto& peripheral : peripherals)
     {
-      std::shared_ptr<CPeripheralCecAdapter> cecDevice = std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
+      std::shared_ptr<CPeripheralCecAdapter> cecDevice =
+          std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
       ret |= cecDevice->ToggleDeviceState(mode);
     }
   }
@@ -744,14 +778,15 @@ bool CPeripherals::ToggleDeviceState(CecStateChange mode /*= STATE_SWITCH_TOGGLE
   return ret;
 }
 
-bool CPeripherals::GetNextKeypress(float frameTime, CKey &key)
+bool CPeripherals::GetNextKeypress(float frameTime, CKey& key)
 {
   PeripheralVector peripherals;
   if (SupportsCEC() && GetPeripheralsWithFeature(peripherals, FEATURE_CEC))
   {
     for (auto& peripheral : peripherals)
     {
-      std::shared_ptr<CPeripheralCecAdapter> cecDevice = std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
+      std::shared_ptr<CPeripheralCecAdapter> cecDevice =
+          std::static_pointer_cast<CPeripheralCecAdapter>(peripheral);
       if (cecDevice->GetButton())
       {
         CKey newKey(cecDevice->GetButton(), cecDevice->GetHoldTime());
@@ -777,7 +812,8 @@ EventLockHandlePtr CPeripherals::RegisterEventLock()
 
 void CPeripherals::OnUserNotification()
 {
-  if (!CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_INPUT_RUMBLENOTIFY))
+  if (!CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+          CSettings::SETTING_INPUT_RUMBLENOTIFY))
     return;
 
   PeripheralVector peripherals;
@@ -797,16 +833,19 @@ void CPeripherals::TestFeature(PeripheralFeature feature)
     if (peripheral->TestFeature(feature))
     {
       CLog::Log(LOGDEBUG, "PERIPHERALS: Device \"%s\" tested %s feature",
-          peripheral->DeviceName().c_str(), PeripheralTypeTranslator::FeatureToString(feature));
+                peripheral->DeviceName().c_str(),
+                PeripheralTypeTranslator::FeatureToString(feature));
     }
     else
     {
       if (peripheral->HasFeature(feature))
         CLog::Log(LOGDEBUG, "PERIPHERALS: Device \"%s\" failed to test %s feature",
-            peripheral->DeviceName().c_str(), PeripheralTypeTranslator::FeatureToString(feature));
+                  peripheral->DeviceName().c_str(),
+                  PeripheralTypeTranslator::FeatureToString(feature));
       else
         CLog::Log(LOGDEBUG, "PERIPHERALS: Device \"%s\" doesn't support %s feature",
-            peripheral->DeviceName().c_str(), PeripheralTypeTranslator::FeatureToString(feature));
+                  peripheral->DeviceName().c_str(),
+                  PeripheralTypeTranslator::FeatureToString(feature));
     }
   }
 }
@@ -842,7 +881,8 @@ void CPeripherals::EnableButtonMapping()
 
 PeripheralAddonPtr CPeripherals::GetAddonWithButtonMap(const CPeripheral* device)
 {
-  PeripheralBusAddonPtr addonBus = std::static_pointer_cast<CPeripheralBusAddon>(GetBusByType(PERIPHERAL_BUS_ADDON));
+  PeripheralBusAddonPtr addonBus =
+      std::static_pointer_cast<CPeripheralBusAddon>(GetBusByType(PERIPHERAL_BUS_ADDON));
 
   PeripheralAddonPtr addon;
 
@@ -855,7 +895,8 @@ PeripheralAddonPtr CPeripherals::GetAddonWithButtonMap(const CPeripheral* device
 
 void CPeripherals::ResetButtonMaps(const std::string& controllerId)
 {
-  PeripheralBusAddonPtr addonBus = std::static_pointer_cast<CPeripheralBusAddon>(GetBusByType(PERIPHERAL_BUS_ADDON));
+  PeripheralBusAddonPtr addonBus =
+      std::static_pointer_cast<CPeripheralBusAddon>(GetBusByType(PERIPHERAL_BUS_ADDON));
 
   PeripheralVector peripherals;
   GetPeripheralsWithFeature(peripherals, FEATURE_JOYSTICK);
@@ -900,7 +941,7 @@ void CPeripherals::OnSettingChanged(std::shared_ptr<const CSetting> setting)
   if (setting == nullptr)
     return;
 
-  const std::string &settingId = setting->GetId();
+  const std::string& settingId = setting->GetId();
   if (settingId == CSettings::SETTING_LOCALE_LANGUAGE)
   {
     // user set language, no longer use the TV's language
@@ -918,7 +959,7 @@ void CPeripherals::OnSettingAction(std::shared_ptr<const CSetting> setting)
   if (setting == nullptr)
     return;
 
-  const std::string &settingId = setting->GetId();
+  const std::string& settingId = setting->GetId();
   if (settingId == CSettings::SETTING_INPUT_PERIPHERALS)
     CGUIDialogPeripherals::Show(*this);
   else if (settingId == CSettings::SETTING_INPUT_CONTROLLERCONFIG)
@@ -928,7 +969,9 @@ void CPeripherals::OnSettingAction(std::shared_ptr<const CSetting> setting)
   else if (settingId == CSettings::SETTING_INPUT_PERIPHERALLIBRARIES)
   {
     std::string strAddonId;
-    if (CGUIWindowAddonBrowser::SelectAddonID(ADDON::ADDON_PERIPHERALDLL, strAddonId, false, true, true, false, true) == 1 && !strAddonId.empty())
+    if (CGUIWindowAddonBrowser::SelectAddonID(ADDON::ADDON_PERIPHERALDLL, strAddonId, false, true,
+                                              true, false, true) == 1 &&
+        !strAddonId.empty())
     {
       ADDON::AddonPtr addon;
       if (CServiceBroker::GetAddonMgr().GetAddon(strAddonId, addon))
@@ -941,17 +984,17 @@ void CPeripherals::OnApplicationMessage(MESSAGING::ThreadMessage* pMsg)
 {
   switch (pMsg->dwMessage)
   {
-  case TMSG_CECTOGGLESTATE:
-    *static_cast<bool*>(pMsg->lpVoid) = ToggleDeviceState(STATE_SWITCH_TOGGLE);
-    break;
+    case TMSG_CECTOGGLESTATE:
+      *static_cast<bool*>(pMsg->lpVoid) = ToggleDeviceState(STATE_SWITCH_TOGGLE);
+      break;
 
-  case TMSG_CECACTIVATESOURCE:
-    ToggleDeviceState(STATE_ACTIVATE_SOURCE);
-    break;
+    case TMSG_CECACTIVATESOURCE:
+      ToggleDeviceState(STATE_ACTIVATE_SOURCE);
+      break;
 
-  case TMSG_CECSTANDBY:
-    ToggleDeviceState(STATE_STANDBY);
-    break;
+    case TMSG_CECSTANDBY:
+      ToggleDeviceState(STATE_STANDBY);
+      break;
   }
 }
 
@@ -960,13 +1003,17 @@ int CPeripherals::GetMessageMask()
   return TMSG_MASK_PERIPHERALS;
 }
 
-void CPeripherals::Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data)
+void CPeripherals::Announce(ANNOUNCEMENT::AnnouncementFlag flag,
+                            const char* sender,
+                            const char* message,
+                            const CVariant& data)
 {
   if (flag == ANNOUNCEMENT::Player && strcmp(sender, "xbmc") == 0)
   {
     if (strcmp(message, "OnQuit") == 0)
     {
-      if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_INPUT_CONTROLLERPOWEROFF))
+      if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+              CSettings::SETTING_INPUT_CONTROLLERPOWEROFF))
         PowerOffDevices();
     }
   }
diff --git a/xbmc/peripherals/Peripherals.h b/xbmc/peripherals/Peripherals.h
index 5835725f1fe8..b9fac5649814 100644
--- a/xbmc/peripherals/Peripherals.h
+++ b/xbmc/peripherals/Peripherals.h
@@ -33,313 +33,333 @@ namespace KODI
 {
 namespace GAME
 {
-  class CControllerManager;
+class CControllerManager;
 }
 
 namespace JOYSTICK
 {
-  class IButtonMapper;
-}
+class IButtonMapper;
 }
+} // namespace KODI
 
 namespace PERIPHERALS
 {
-  class CEventScanner;
+class CEventScanner;
 
-  class CPeripherals :  public ISettingCallback,
-                        public Observable,
-                        public KODI::MESSAGING::IMessageTarget,
-                        public IEventScannerCallback,
-                        public ANNOUNCEMENT::IAnnouncer
+class CPeripherals : public ISettingCallback,
+                     public Observable,
+                     public KODI::MESSAGING::IMessageTarget,
+                     public IEventScannerCallback,
+                     public ANNOUNCEMENT::IAnnouncer
+{
+public:
+  explicit CPeripherals(CInputManager& inputManager,
+                        KODI::GAME::CControllerManager& controllerProfiles);
+
+  ~CPeripherals() override;
+
+  /*!
+   * @brief Initialise the peripherals manager.
+   */
+  void Initialise();
+
+  /*!
+   * @brief Clear all data known by the peripherals manager.
+   */
+  void Clear();
+
+  /*!
+   * @brief Get the instance of the peripheral at the given location.
+   * @param strLocation The location.
+   * @param busType The bus to query. Default (PERIPHERAL_BUS_UNKNOWN) searches all busses.
+   * @return The peripheral or NULL if it wasn't found.
+   */
+  PeripheralPtr GetPeripheralAtLocation(const std::string& strLocation,
+                                        PeripheralBusType busType = PERIPHERAL_BUS_UNKNOWN) const;
+
+  /*!
+   * @brief Check whether a peripheral is present at the given location.
+   * @param strLocation The location.
+   * @param busType The bus to query. Default (PERIPHERAL_BUS_UNKNOWN) searches all busses.
+   * @return True when a peripheral was found, false otherwise.
+   */
+  bool HasPeripheralAtLocation(const std::string& strLocation,
+                               PeripheralBusType busType = PERIPHERAL_BUS_UNKNOWN) const;
+
+  /*!
+   * @brief Get the bus that holds the device with the given location.
+   * @param strLocation The location.
+   * @return The bus or NULL if no device was found.
+   */
+  PeripheralBusPtr GetBusWithDevice(const std::string& strLocation) const;
+
+  /*!
+   * @brief Check if any busses support the given feature
+   * @param feature The feature to check for
+   * @return True if a bus supports the feature, false otherwise
+   */
+  bool SupportsFeature(PeripheralFeature feature) const;
+
+  /*!
+   * @brief Get all peripheral instances that have the given feature.
+   * @param results The list of results.
+   * @param feature The feature to search for.
+   * @param busType The bus to query. Default (PERIPHERAL_BUS_UNKNOWN) searches all busses.
+   * @return The number of devices that have been found.
+   */
+  int GetPeripheralsWithFeature(PeripheralVector& results,
+                                const PeripheralFeature feature,
+                                PeripheralBusType busType = PERIPHERAL_BUS_UNKNOWN) const;
+
+  size_t GetNumberOfPeripherals() const;
+
+  /*!
+   * @brief Check whether there is at least one device present with the given feature.
+   * @param feature The feature to check for.
+   * @param busType The bus to query. Default (PERIPHERAL_BUS_UNKNOWN) searches all busses.
+   * @return True when at least one device was found with this feature, false otherwise.
+   */
+  bool HasPeripheralWithFeature(const PeripheralFeature feature,
+                                PeripheralBusType busType = PERIPHERAL_BUS_UNKNOWN) const;
+
+  /*!
+   * @brief Called when a device has been added to a bus.
+   * @param bus The bus the device was added to.
+   * @param peripheral The peripheral that has been added.
+   */
+  void OnDeviceAdded(const CPeripheralBus& bus, const CPeripheral& peripheral);
+
+  /*!
+   * @brief Called when a device has been deleted from a bus.
+   * @param bus The bus from which the device removed.
+   * @param peripheral The peripheral that has been removed.
+   */
+  void OnDeviceDeleted(const CPeripheralBus& bus, const CPeripheral& peripheral);
+
+  /*!
+   * @brief Creates a new instance of a peripheral.
+   * @param bus The bus on which this peripheral is present.
+   * @param result The scan result from the device scanning code.
+   * @return The new peripheral or NULL if it could not be created.
+   */
+  void CreatePeripheral(CPeripheralBus& bus, const PeripheralScanResult& result);
+
+  /*!
+   * @brief Add the settings that are defined in the mappings file to the peripheral (if there is
+   * anything defined).
+   * @param peripheral The peripheral to get the settings for.
+   */
+  void GetSettingsFromMapping(CPeripheral& peripheral) const;
+
+  /*!
+   * @brief Trigger a device scan on all known busses
+   */
+  void TriggerDeviceScan(const PeripheralBusType type = PERIPHERAL_BUS_UNKNOWN);
+
+  /*!
+   * @brief Get the instance of a bus given it's type.
+   * @param type The bus type.
+   * @return The bus or NULL if it wasn't found.
+   */
+  PeripheralBusPtr GetBusByType(const PeripheralBusType type) const;
+
+  /*!
+   * @brief Get all fileitems for a path.
+   * @param strPath The path to the directory to get the items from.
+   * @param items The item list.
+   */
+  void GetDirectory(const std::string& strPath, CFileItemList& items) const;
+
+  /*!
+   * @brief Get the instance of a peripheral given it's path.
+   * @param strPath The path to the peripheral.
+   * @return The peripheral or NULL if it wasn't found.
+   */
+  PeripheralPtr GetByPath(const std::string& strPath) const;
+
+  /*!
+   * @brief Try to let one of the peripherals handle an action.
+   * @param action The change to handle.
+   * @return True when this change was handled by a peripheral (and should not be handled by
+   * anything else), false otherwise.
+   */
+  bool OnAction(const CAction& action);
+
+  /*!
+   * @brief Check whether there's a peripheral that reports to be muted.
+   * @return True when at least one peripheral reports to be muted, false otherwise.
+   */
+  bool IsMuted();
+
+  /*!
+   * @brief Try to toggle the mute status via a peripheral.
+   * @return True when this change was handled by a peripheral (and should not be handled by
+   * anything else), false otherwise.
+   */
+  bool ToggleMute();
+
+  /*!
+   * @brief Try to toggle the playing device state via a peripheral.
+   * @param mode Whether to activate, put on standby or toggle the source.
+   * @return True when the playing device has been switched on, false otherwise.
+   */
+  bool ToggleDeviceState(const CecStateChange mode = STATE_SWITCH_TOGGLE);
+
+  /*!
+   * @brief Try to mute the audio via a peripheral.
+   * @return True when this change was handled by a peripheral (and should not be handled by
+   * anything else), false otherwise.
+   */
+  bool Mute()
+  {
+    return ToggleMute();
+  } //! @todo CEC only supports toggling the mute status at this time
+
+  /*!
+   * @brief Try to unmute the audio via a peripheral.
+   * @return True when this change was handled by a peripheral (and should not be handled by
+   * anything else), false otherwise.
+   */
+  bool UnMute()
+  {
+    return ToggleMute();
+  } //! @todo CEC only supports toggling the mute status at this time
+
+  /*!
+   * @brief Try to get a keypress from a peripheral.
+   * @param frameTime The current frametime.
+   * @param key The fetched key.
+   * @return True when a keypress was fetched, false otherwise.
+   */
+  bool GetNextKeypress(float frameTime, CKey& key);
+
+  /*!
+   * @brief Register with the event scanner to control scan timing
+   * @return A handle that unregisters itself when expired
+   */
+  EventPollHandlePtr RegisterEventPoller();
+
+  /*!
+   * @brief Register with the event scanner to disable event processing
+   * @return A handle that unregisters itself when expired
+   */
+  EventLockHandlePtr RegisterEventLock();
+
+  /*!
+   *
+   */
+  void OnUserNotification();
+
+  /*!
+   * @brief Request peripherals with the specified feature to perform a quick test
+   * @return true if any peripherals support the feature, false otherwise
+   */
+  void TestFeature(PeripheralFeature feature);
+
+  /*!
+   * \brief Request all devices with power-off support to power down
+   */
+  void PowerOffDevices();
+
+  bool SupportsCEC() const
   {
-  public:
-    explicit CPeripherals(CInputManager &inputManager,
-                          KODI::GAME::CControllerManager &controllerProfiles);
-
-    ~CPeripherals() override;
-
-    /*!
-     * @brief Initialise the peripherals manager.
-     */
-    void Initialise();
-
-    /*!
-     * @brief Clear all data known by the peripherals manager.
-     */
-    void Clear();
-
-    /*!
-     * @brief Get the instance of the peripheral at the given location.
-     * @param strLocation The location.
-     * @param busType The bus to query. Default (PERIPHERAL_BUS_UNKNOWN) searches all busses.
-     * @return The peripheral or NULL if it wasn't found.
-     */
-    PeripheralPtr GetPeripheralAtLocation(const std::string &strLocation, PeripheralBusType busType = PERIPHERAL_BUS_UNKNOWN) const;
-
-    /*!
-     * @brief Check whether a peripheral is present at the given location.
-     * @param strLocation The location.
-     * @param busType The bus to query. Default (PERIPHERAL_BUS_UNKNOWN) searches all busses.
-     * @return True when a peripheral was found, false otherwise.
-     */
-    bool HasPeripheralAtLocation(const std::string &strLocation, PeripheralBusType busType = PERIPHERAL_BUS_UNKNOWN) const;
-
-    /*!
-     * @brief Get the bus that holds the device with the given location.
-     * @param strLocation The location.
-     * @return The bus or NULL if no device was found.
-     */
-    PeripheralBusPtr GetBusWithDevice(const std::string &strLocation) const;
-
-    /*!
-     * @brief Check if any busses support the given feature
-     * @param feature The feature to check for
-     * @return True if a bus supports the feature, false otherwise
-     */
-    bool SupportsFeature(PeripheralFeature feature) const;
-
-    /*!
-     * @brief Get all peripheral instances that have the given feature.
-     * @param results The list of results.
-     * @param feature The feature to search for.
-     * @param busType The bus to query. Default (PERIPHERAL_BUS_UNKNOWN) searches all busses.
-     * @return The number of devices that have been found.
-     */
-    int GetPeripheralsWithFeature(PeripheralVector &results, const PeripheralFeature feature, PeripheralBusType busType = PERIPHERAL_BUS_UNKNOWN) const;
-
-    size_t GetNumberOfPeripherals() const;
-
-    /*!
-     * @brief Check whether there is at least one device present with the given feature.
-     * @param feature The feature to check for.
-     * @param busType The bus to query. Default (PERIPHERAL_BUS_UNKNOWN) searches all busses.
-     * @return True when at least one device was found with this feature, false otherwise.
-     */
-    bool HasPeripheralWithFeature(const PeripheralFeature feature, PeripheralBusType busType = PERIPHERAL_BUS_UNKNOWN) const;
-
-    /*!
-     * @brief Called when a device has been added to a bus.
-     * @param bus The bus the device was added to.
-     * @param peripheral The peripheral that has been added.
-     */
-    void OnDeviceAdded(const CPeripheralBus &bus, const CPeripheral &peripheral);
-
-    /*!
-     * @brief Called when a device has been deleted from a bus.
-     * @param bus The bus from which the device removed.
-     * @param peripheral The peripheral that has been removed.
-     */
-    void OnDeviceDeleted(const CPeripheralBus &bus, const CPeripheral &peripheral);
-
-    /*!
-     * @brief Creates a new instance of a peripheral.
-     * @param bus The bus on which this peripheral is present.
-     * @param result The scan result from the device scanning code.
-     * @return The new peripheral or NULL if it could not be created.
-     */
-    void CreatePeripheral(CPeripheralBus &bus, const PeripheralScanResult& result);
-
-    /*!
-     * @brief Add the settings that are defined in the mappings file to the peripheral (if there is anything defined).
-     * @param peripheral The peripheral to get the settings for.
-     */
-    void GetSettingsFromMapping(CPeripheral &peripheral) const;
-
-    /*!
-     * @brief Trigger a device scan on all known busses
-     */
-    void TriggerDeviceScan(const PeripheralBusType type = PERIPHERAL_BUS_UNKNOWN);
-
-    /*!
-     * @brief Get the instance of a bus given it's type.
-     * @param type The bus type.
-     * @return The bus or NULL if it wasn't found.
-     */
-    PeripheralBusPtr GetBusByType(const PeripheralBusType type) const;
-
-    /*!
-     * @brief Get all fileitems for a path.
-     * @param strPath The path to the directory to get the items from.
-     * @param items The item list.
-     */
-    void GetDirectory(const std::string &strPath, CFileItemList &items) const;
-
-    /*!
-     * @brief Get the instance of a peripheral given it's path.
-     * @param strPath The path to the peripheral.
-     * @return The peripheral or NULL if it wasn't found.
-     */
-    PeripheralPtr GetByPath(const std::string &strPath) const;
-
-    /*!
-     * @brief Try to let one of the peripherals handle an action.
-     * @param action The change to handle.
-     * @return True when this change was handled by a peripheral (and should not be handled by anything else), false otherwise.
-     */
-    bool OnAction(const CAction &action);
-
-    /*!
-     * @brief Check whether there's a peripheral that reports to be muted.
-     * @return True when at least one peripheral reports to be muted, false otherwise.
-     */
-    bool IsMuted();
-
-    /*!
-     * @brief Try to toggle the mute status via a peripheral.
-     * @return True when this change was handled by a peripheral (and should not be handled by anything else), false otherwise.
-     */
-    bool ToggleMute();
-
-    /*!
-     * @brief Try to toggle the playing device state via a peripheral.
-     * @param mode Whether to activate, put on standby or toggle the source.
-     * @return True when the playing device has been switched on, false otherwise.
-     */
-    bool ToggleDeviceState(const CecStateChange mode = STATE_SWITCH_TOGGLE);
-
-    /*!
-     * @brief Try to mute the audio via a peripheral.
-     * @return True when this change was handled by a peripheral (and should not be handled by anything else), false otherwise.
-     */
-    bool Mute() { return ToggleMute(); } //! @todo CEC only supports toggling the mute status at this time
-
-    /*!
-     * @brief Try to unmute the audio via a peripheral.
-     * @return True when this change was handled by a peripheral (and should not be handled by anything else), false otherwise.
-     */
-    bool UnMute() { return ToggleMute(); } //! @todo CEC only supports toggling the mute status at this time
-
-    /*!
-     * @brief Try to get a keypress from a peripheral.
-     * @param frameTime The current frametime.
-     * @param key The fetched key.
-     * @return True when a keypress was fetched, false otherwise.
-     */
-    bool GetNextKeypress(float frameTime, CKey &key);
-
-    /*!
-     * @brief Register with the event scanner to control scan timing
-     * @return A handle that unregisters itself when expired
-     */
-    EventPollHandlePtr RegisterEventPoller();
-
-    /*!
-     * @brief Register with the event scanner to disable event processing
-     * @return A handle that unregisters itself when expired
-     */
-    EventLockHandlePtr RegisterEventLock();
-
-    /*!
-     *
-     */
-    void OnUserNotification();
-
-    /*!
-     * @brief Request peripherals with the specified feature to perform a quick test
-     * @return true if any peripherals support the feature, false otherwise
-     */
-    void TestFeature(PeripheralFeature feature);
-
-    /*!
-     * \brief Request all devices with power-off support to power down
-     */
-    void PowerOffDevices();
-
-    bool SupportsCEC() const
-    {
 #if defined(HAVE_LIBCEC)
-      return true;
+    return true;
 #else
-      return false;
+    return false;
 #endif
-    }
-
-    // implementation of IEventScannerCallback
-    void ProcessEvents(void) override;
-
-    /*!
-     * \brief Initialize button mapping
-     *
-     * This command enables button mapping on all busses. Button maps allow
-     * connect events from the driver to the higher-level features used by
-     * controller profiles.
-     *
-     * If user input is required, a blocking dialog may be shown.
-     */
-    void EnableButtonMapping();
-
-    /*!
-     * \brief Get an add-on that can provide button maps for a device
-     * \return An add-on that provides button maps, or empty if no add-on is found
-     */
-    PeripheralAddonPtr GetAddonWithButtonMap(const CPeripheral* device);
-
-    /*!
-     * \brief Reset all button maps to the defaults for all devices and the given controller
-     * \param controllerId The controller profile to reset
-     * @todo Add a device parameter to allow resetting button maps per-device
-     */
-    void ResetButtonMaps(const std::string& controllerId);
-
-    /*!
-     * \brief Register a button mapper interface
-     * \param mapper The button mapper
-     *
-     * Clients implementing the IButtonMapper interface call
-     * \ref CPeripherals::RegisterJoystickButtonMapper to register themselves
-     * as eligible for button mapping commands.
-     *
-     * When registering the mapper is forwarded to all peripherals. See
-     * \ref CPeripheral::RegisterJoystickButtonMapper for what is done to the
-     * mapper after being given to the peripheral.
-     */
-    void RegisterJoystickButtonMapper(KODI::JOYSTICK::IButtonMapper* mapper);
-
-    /*!
-     * \brief Unregister a button mapper interface
-     * \param mapper The button mapper
-     */
-    void UnregisterJoystickButtonMapper(KODI::JOYSTICK::IButtonMapper* mapper);
-
-    // implementation of ISettingCallback
-    void OnSettingChanged(std::shared_ptr<const CSetting> setting) override;
-    void OnSettingAction(std::shared_ptr<const CSetting> setting) override;
-
-    // implementation of IMessageTarget
-    void OnApplicationMessage(KODI::MESSAGING::ThreadMessage* pMsg) override;
-    int GetMessageMask() override;
-
-    // implementation of IAnnouncer
-    void Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data) override;
-
-    /*!
-     * \brief Access the input manager passed to the constructor
-     */
-    CInputManager &GetInputManager() { return m_inputManager; }
-
-    /*!
-     * \brief Access controller profiles through the construction parameter
-     */
-    KODI::GAME::CControllerManager &GetControllerProfiles() { return m_controllerProfiles; }
-
-  private:
-    bool LoadMappings();
-    bool GetMappingForDevice(const CPeripheralBus &bus, PeripheralScanResult& result) const;
-    static void GetSettingsFromMappingsFile(TiXmlElement *xmlNode, std::map<std::string, PeripheralDeviceSetting> &m_settings);
-
-    void OnDeviceChanged();
-
-    // Construction parameters
-    CInputManager &m_inputManager;
-    KODI::GAME::CControllerManager &m_controllerProfiles;
+  }
+
+  // implementation of IEventScannerCallback
+  void ProcessEvents(void) override;
+
+  /*!
+   * \brief Initialize button mapping
+   *
+   * This command enables button mapping on all busses. Button maps allow
+   * connect events from the driver to the higher-level features used by
+   * controller profiles.
+   *
+   * If user input is required, a blocking dialog may be shown.
+   */
+  void EnableButtonMapping();
+
+  /*!
+   * \brief Get an add-on that can provide button maps for a device
+   * \return An add-on that provides button maps, or empty if no add-on is found
+   */
+  PeripheralAddonPtr GetAddonWithButtonMap(const CPeripheral* device);
+
+  /*!
+   * \brief Reset all button maps to the defaults for all devices and the given controller
+   * \param controllerId The controller profile to reset
+   * @todo Add a device parameter to allow resetting button maps per-device
+   */
+  void ResetButtonMaps(const std::string& controllerId);
+
+  /*!
+   * \brief Register a button mapper interface
+   * \param mapper The button mapper
+   *
+   * Clients implementing the IButtonMapper interface call
+   * \ref CPeripherals::RegisterJoystickButtonMapper to register themselves
+   * as eligible for button mapping commands.
+   *
+   * When registering the mapper is forwarded to all peripherals. See
+   * \ref CPeripheral::RegisterJoystickButtonMapper for what is done to the
+   * mapper after being given to the peripheral.
+   */
+  void RegisterJoystickButtonMapper(KODI::JOYSTICK::IButtonMapper* mapper);
+
+  /*!
+   * \brief Unregister a button mapper interface
+   * \param mapper The button mapper
+   */
+  void UnregisterJoystickButtonMapper(KODI::JOYSTICK::IButtonMapper* mapper);
+
+  // implementation of ISettingCallback
+  void OnSettingChanged(std::shared_ptr<const CSetting> setting) override;
+  void OnSettingAction(std::shared_ptr<const CSetting> setting) override;
+
+  // implementation of IMessageTarget
+  void OnApplicationMessage(KODI::MESSAGING::ThreadMessage* pMsg) override;
+  int GetMessageMask() override;
+
+  // implementation of IAnnouncer
+  void Announce(ANNOUNCEMENT::AnnouncementFlag flag,
+                const char* sender,
+                const char* message,
+                const CVariant& data) override;
+
+  /*!
+   * \brief Access the input manager passed to the constructor
+   */
+  CInputManager& GetInputManager() { return m_inputManager; }
+
+  /*!
+   * \brief Access controller profiles through the construction parameter
+   */
+  KODI::GAME::CControllerManager& GetControllerProfiles() { return m_controllerProfiles; }
+
+private:
+  bool LoadMappings();
+  bool GetMappingForDevice(const CPeripheralBus& bus, PeripheralScanResult& result) const;
+  static void GetSettingsFromMappingsFile(
+      TiXmlElement* xmlNode, std::map<std::string, PeripheralDeviceSetting>& m_settings);
+
+  void OnDeviceChanged();
+
+  // Construction parameters
+  CInputManager& m_inputManager;
+  KODI::GAME::CControllerManager& m_controllerProfiles;
 
 #if !defined(HAVE_LIBCEC)
-    bool m_bMissingLibCecWarningDisplayed = false;
+  bool m_bMissingLibCecWarningDisplayed = false;
 #endif
-    std::vector<PeripheralBusPtr> m_busses;
-    std::vector<PeripheralDeviceMapping> m_mappings;
-    std::unique_ptr<CEventScanner> m_eventScanner;
-    mutable CCriticalSection m_critSectionBusses;
-    mutable CCriticalSection m_critSectionMappings;
-  };
-}
+  std::vector<PeripheralBusPtr> m_busses;
+  std::vector<PeripheralDeviceMapping> m_mappings;
+  std::unique_ptr<CEventScanner> m_eventScanner;
+  mutable CCriticalSection m_critSectionBusses;
+  mutable CCriticalSection m_critSectionMappings;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/addons/AddonButtonMap.cpp b/xbmc/peripherals/addons/AddonButtonMap.cpp
index 448f3c0e0104..07d740ddc46b 100644
--- a/xbmc/peripherals/addons/AddonButtonMap.cpp
+++ b/xbmc/peripherals/addons/AddonButtonMap.cpp
@@ -21,10 +21,10 @@ using namespace KODI;
 using namespace JOYSTICK;
 using namespace PERIPHERALS;
 
-CAddonButtonMap::CAddonButtonMap(CPeripheral* device, const std::weak_ptr<CPeripheralAddon>& addon, const std::string& strControllerId)
-  : m_device(device),
-    m_addon(addon),
-    m_strControllerId(strControllerId)
+CAddonButtonMap::CAddonButtonMap(CPeripheral* device,
+                                 const std::weak_ptr<CPeripheralAddon>& addon,
+                                 const std::string& strControllerId)
+  : m_device(device), m_addon(addon), m_strControllerId(strControllerId)
 {
   auto peripheralAddon = m_addon.lock();
   assert(peripheralAddon != nullptr);
@@ -131,7 +131,8 @@ bool CAddonButtonMap::GetScalar(const FeatureName& feature, CDriverPrimitive& pr
     if (addonFeature.Type() == JOYSTICK_FEATURE_TYPE_SCALAR ||
         addonFeature.Type() == JOYSTICK_FEATURE_TYPE_MOTOR)
     {
-      primitive = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(JOYSTICK_SCALAR_PRIMITIVE));
+      primitive = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(JOYSTICK_SCALAR_PRIMITIVE));
       retVal = true;
     }
   }
@@ -143,8 +144,10 @@ void CAddonButtonMap::AddScalar(const FeatureName& feature, const CDriverPrimiti
 {
   const bool bMotor = (primitive.Type() == PRIMITIVE_TYPE::MOTOR);
 
-  kodi::addon::JoystickFeature scalar(feature, bMotor ? JOYSTICK_FEATURE_TYPE_MOTOR : JOYSTICK_FEATURE_TYPE_SCALAR);
-  scalar.SetPrimitive(JOYSTICK_SCALAR_PRIMITIVE, CPeripheralAddonTranslator::TranslatePrimitive(primitive));
+  kodi::addon::JoystickFeature scalar(feature, bMotor ? JOYSTICK_FEATURE_TYPE_MOTOR
+                                                      : JOYSTICK_FEATURE_TYPE_SCALAR);
+  scalar.SetPrimitive(JOYSTICK_SCALAR_PRIMITIVE,
+                      CPeripheralAddonTranslator::TranslatePrimitive(primitive));
 
   if (auto addon = m_addon.lock())
     addon->MapFeature(m_device, m_strControllerId, scalar);
@@ -165,7 +168,8 @@ bool CAddonButtonMap::GetAnalogStick(const FeatureName& feature,
 
     if (addonFeature.Type() == JOYSTICK_FEATURE_TYPE_ANALOG_STICK)
     {
-      primitive = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(GetAnalogStickIndex(direction)));
+      primitive = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(GetAnalogStickIndex(direction)));
       retVal = primitive.IsValid();
     }
   }
@@ -180,7 +184,8 @@ void CAddonButtonMap::AddAnalogStick(const FeatureName& feature,
   using namespace JOYSTICK;
 
   JOYSTICK_FEATURE_PRIMITIVE primitiveIndex = GetAnalogStickIndex(direction);
-  kodi::addon::DriverPrimitive addonPrimitive = CPeripheralAddonTranslator::TranslatePrimitive(primitive);
+  kodi::addon::DriverPrimitive addonPrimitive =
+      CPeripheralAddonTranslator::TranslatePrimitive(primitive);
 
   kodi::addon::JoystickFeature analogStick(feature, JOYSTICK_FEATURE_TYPE_ANALOG_STICK);
 
@@ -191,7 +196,8 @@ void CAddonButtonMap::AddAnalogStick(const FeatureName& feature,
       analogStick = it->second;
   }
 
-  const bool bModified = (primitive != CPeripheralAddonTranslator::TranslatePrimitive(analogStick.Primitive(primitiveIndex)));
+  const bool bModified = (primitive != CPeripheralAddonTranslator::TranslatePrimitive(
+                                           analogStick.Primitive(primitiveIndex)));
   if (bModified)
     analogStick.SetPrimitive(primitiveIndex, addonPrimitive);
 
@@ -219,7 +225,8 @@ bool CAddonButtonMap::GetRelativePointer(const FeatureName& feature,
 
     if (addonFeature.Type() == JOYSTICK_FEATURE_TYPE_RELPOINTER)
     {
-      primitive = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(GetRelativePointerIndex(direction)));
+      primitive = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(GetRelativePointerIndex(direction)));
       retVal = primitive.IsValid();
     }
   }
@@ -234,7 +241,8 @@ void CAddonButtonMap::AddRelativePointer(const FeatureName& feature,
   using namespace JOYSTICK;
 
   JOYSTICK_FEATURE_PRIMITIVE primitiveIndex = GetRelativePointerIndex(direction);
-  kodi::addon::DriverPrimitive addonPrimitive = CPeripheralAddonTranslator::TranslatePrimitive(primitive);
+  kodi::addon::DriverPrimitive addonPrimitive =
+      CPeripheralAddonTranslator::TranslatePrimitive(primitive);
 
   kodi::addon::JoystickFeature relPointer(feature, JOYSTICK_FEATURE_TYPE_RELPOINTER);
 
@@ -245,7 +253,8 @@ void CAddonButtonMap::AddRelativePointer(const FeatureName& feature,
       relPointer = it->second;
   }
 
-  const bool bModified = (primitive != CPeripheralAddonTranslator::TranslatePrimitive(relPointer.Primitive(primitiveIndex)));
+  const bool bModified = (primitive != CPeripheralAddonTranslator::TranslatePrimitive(
+                                           relPointer.Primitive(primitiveIndex)));
   if (bModified)
     relPointer.SetPrimitive(primitiveIndex, addonPrimitive);
 
@@ -274,10 +283,13 @@ bool CAddonButtonMap::GetAccelerometer(const FeatureName& feature,
 
     if (addonFeature.Type() == JOYSTICK_FEATURE_TYPE_ACCELEROMETER)
     {
-      positiveX = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(JOYSTICK_ACCELEROMETER_POSITIVE_X));
-      positiveY = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(JOYSTICK_ACCELEROMETER_POSITIVE_Y));
-      positiveZ = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(JOYSTICK_ACCELEROMETER_POSITIVE_Z));
-      retVal    = true;
+      positiveX = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(JOYSTICK_ACCELEROMETER_POSITIVE_X));
+      positiveY = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(JOYSTICK_ACCELEROMETER_POSITIVE_Y));
+      positiveZ = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(JOYSTICK_ACCELEROMETER_POSITIVE_Z));
+      retVal = true;
     }
   }
 
@@ -293,9 +305,12 @@ void CAddonButtonMap::AddAccelerometer(const FeatureName& feature,
 
   kodi::addon::JoystickFeature accelerometer(feature, JOYSTICK_FEATURE_TYPE_ACCELEROMETER);
 
-  accelerometer.SetPrimitive(JOYSTICK_ACCELEROMETER_POSITIVE_X, CPeripheralAddonTranslator::TranslatePrimitive(positiveX));
-  accelerometer.SetPrimitive(JOYSTICK_ACCELEROMETER_POSITIVE_Y, CPeripheralAddonTranslator::TranslatePrimitive(positiveY));
-  accelerometer.SetPrimitive(JOYSTICK_ACCELEROMETER_POSITIVE_Z, CPeripheralAddonTranslator::TranslatePrimitive(positiveZ));
+  accelerometer.SetPrimitive(JOYSTICK_ACCELEROMETER_POSITIVE_X,
+                             CPeripheralAddonTranslator::TranslatePrimitive(positiveX));
+  accelerometer.SetPrimitive(JOYSTICK_ACCELEROMETER_POSITIVE_Y,
+                             CPeripheralAddonTranslator::TranslatePrimitive(positiveY));
+  accelerometer.SetPrimitive(JOYSTICK_ACCELEROMETER_POSITIVE_Z,
+                             CPeripheralAddonTranslator::TranslatePrimitive(positiveZ));
 
   if (auto addon = m_addon.lock())
     addon->MapFeature(m_device, m_strControllerId, accelerometer);
@@ -316,7 +331,8 @@ bool CAddonButtonMap::GetWheel(const KODI::JOYSTICK::FeatureName& feature,
 
     if (addonFeature.Type() == JOYSTICK_FEATURE_TYPE_WHEEL)
     {
-      primitive = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(GetPrimitiveIndex(direction)));
+      primitive = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(GetPrimitiveIndex(direction)));
       retVal = primitive.IsValid();
     }
   }
@@ -331,7 +347,8 @@ void CAddonButtonMap::AddWheel(const KODI::JOYSTICK::FeatureName& feature,
   using namespace JOYSTICK;
 
   JOYSTICK_FEATURE_PRIMITIVE primitiveIndex = GetPrimitiveIndex(direction);
-  kodi::addon::DriverPrimitive addonPrimitive = CPeripheralAddonTranslator::TranslatePrimitive(primitive);
+  kodi::addon::DriverPrimitive addonPrimitive =
+      CPeripheralAddonTranslator::TranslatePrimitive(primitive);
 
   kodi::addon::JoystickFeature joystickFeature(feature, JOYSTICK_FEATURE_TYPE_WHEEL);
 
@@ -342,7 +359,8 @@ void CAddonButtonMap::AddWheel(const KODI::JOYSTICK::FeatureName& feature,
       joystickFeature = it->second;
   }
 
-  const bool bModified = (primitive != CPeripheralAddonTranslator::TranslatePrimitive(joystickFeature.Primitive(primitiveIndex)));
+  const bool bModified = (primitive != CPeripheralAddonTranslator::TranslatePrimitive(
+                                           joystickFeature.Primitive(primitiveIndex)));
   if (bModified)
     joystickFeature.SetPrimitive(primitiveIndex, addonPrimitive);
 
@@ -370,7 +388,8 @@ bool CAddonButtonMap::GetThrottle(const KODI::JOYSTICK::FeatureName& feature,
 
     if (addonFeature.Type() == JOYSTICK_FEATURE_TYPE_THROTTLE)
     {
-      primitive = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(GetPrimitiveIndex(direction)));
+      primitive = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(GetPrimitiveIndex(direction)));
       retVal = primitive.IsValid();
     }
   }
@@ -385,7 +404,8 @@ void CAddonButtonMap::AddThrottle(const KODI::JOYSTICK::FeatureName& feature,
   using namespace JOYSTICK;
 
   JOYSTICK_FEATURE_PRIMITIVE primitiveIndex = GetPrimitiveIndex(direction);
-  kodi::addon::DriverPrimitive addonPrimitive = CPeripheralAddonTranslator::TranslatePrimitive(primitive);
+  kodi::addon::DriverPrimitive addonPrimitive =
+      CPeripheralAddonTranslator::TranslatePrimitive(primitive);
 
   kodi::addon::JoystickFeature joystickFeature(feature, JOYSTICK_FEATURE_TYPE_THROTTLE);
 
@@ -396,7 +416,8 @@ void CAddonButtonMap::AddThrottle(const KODI::JOYSTICK::FeatureName& feature,
       joystickFeature = it->second;
   }
 
-  const bool bModified = (primitive != CPeripheralAddonTranslator::TranslatePrimitive(joystickFeature.Primitive(primitiveIndex)));
+  const bool bModified = (primitive != CPeripheralAddonTranslator::TranslatePrimitive(
+                                           joystickFeature.Primitive(primitiveIndex)));
   if (bModified)
     joystickFeature.SetPrimitive(primitiveIndex, addonPrimitive);
 
@@ -422,7 +443,8 @@ bool CAddonButtonMap::GetKey(const FeatureName& feature, CDriverPrimitive& primi
 
     if (addonFeature.Type() == JOYSTICK_FEATURE_TYPE_KEY)
     {
-      primitive = CPeripheralAddonTranslator::TranslatePrimitive(addonFeature.Primitive(JOYSTICK_SCALAR_PRIMITIVE));
+      primitive = CPeripheralAddonTranslator::TranslatePrimitive(
+          addonFeature.Primitive(JOYSTICK_SCALAR_PRIMITIVE));
       retVal = true;
     }
   }
@@ -433,21 +455,25 @@ bool CAddonButtonMap::GetKey(const FeatureName& feature, CDriverPrimitive& primi
 void CAddonButtonMap::AddKey(const FeatureName& feature, const CDriverPrimitive& primitive)
 {
   kodi::addon::JoystickFeature scalar(feature, JOYSTICK_FEATURE_TYPE_KEY);
-  scalar.SetPrimitive(JOYSTICK_SCALAR_PRIMITIVE, CPeripheralAddonTranslator::TranslatePrimitive(primitive));
+  scalar.SetPrimitive(JOYSTICK_SCALAR_PRIMITIVE,
+                      CPeripheralAddonTranslator::TranslatePrimitive(primitive));
 
   if (auto addon = m_addon.lock())
     addon->MapFeature(m_device, m_strControllerId, scalar);
 }
 
-void CAddonButtonMap::SetIgnoredPrimitives(const std::vector<JOYSTICK::CDriverPrimitive>& primitives)
+void CAddonButtonMap::SetIgnoredPrimitives(
+    const std::vector<JOYSTICK::CDriverPrimitive>& primitives)
 {
   if (auto addon = m_addon.lock())
-    addon->SetIgnoredPrimitives(m_device, CPeripheralAddonTranslator::TranslatePrimitives(primitives));
+    addon->SetIgnoredPrimitives(m_device,
+                                CPeripheralAddonTranslator::TranslatePrimitives(primitives));
 }
 
 bool CAddonButtonMap::IsIgnored(const JOYSTICK::CDriverPrimitive& primitive)
 {
-  return std::find(m_ignoredPrimitives.begin(), m_ignoredPrimitives.end(), primitive) != m_ignoredPrimitives.end();
+  return std::find(m_ignoredPrimitives.begin(), m_ignoredPrimitives.end(), primitive) !=
+         m_ignoredPrimitives.end();
 }
 
 bool CAddonButtonMap::GetAxisProperties(unsigned int axisIndex, int& center, unsigned int& range)
@@ -507,10 +533,10 @@ CAddonButtonMap::DriverMap CAddonButtonMap::CreateLookupTable(const FeatureMap&
       case JOYSTICK_FEATURE_TYPE_ANALOG_STICK:
       {
         std::vector<JOYSTICK_FEATURE_PRIMITIVE> primitives = {
-          JOYSTICK_ANALOG_STICK_UP,
-          JOYSTICK_ANALOG_STICK_DOWN,
-          JOYSTICK_ANALOG_STICK_RIGHT,
-          JOYSTICK_ANALOG_STICK_LEFT,
+            JOYSTICK_ANALOG_STICK_UP,
+            JOYSTICK_ANALOG_STICK_DOWN,
+            JOYSTICK_ANALOG_STICK_RIGHT,
+            JOYSTICK_ANALOG_STICK_LEFT,
         };
 
         for (auto primitive : primitives)
@@ -522,18 +548,20 @@ CAddonButtonMap::DriverMap CAddonButtonMap::CreateLookupTable(const FeatureMap&
       case JOYSTICK_FEATURE_TYPE_ACCELEROMETER:
       {
         std::vector<JOYSTICK_FEATURE_PRIMITIVE> primitives = {
-          JOYSTICK_ACCELEROMETER_POSITIVE_X,
-          JOYSTICK_ACCELEROMETER_POSITIVE_Y,
-          JOYSTICK_ACCELEROMETER_POSITIVE_Z,
+            JOYSTICK_ACCELEROMETER_POSITIVE_X,
+            JOYSTICK_ACCELEROMETER_POSITIVE_Y,
+            JOYSTICK_ACCELEROMETER_POSITIVE_Z,
         };
 
         for (auto primitive : primitives)
         {
-          CDriverPrimitive translatedPrimitive = CPeripheralAddonTranslator::TranslatePrimitive(feature.Primitive(primitive));
+          CDriverPrimitive translatedPrimitive =
+              CPeripheralAddonTranslator::TranslatePrimitive(feature.Primitive(primitive));
           driverMap[translatedPrimitive] = it.first;
 
           // Map opposite semiaxis
-          CDriverPrimitive oppositePrimitive = CDriverPrimitive(translatedPrimitive.Index(), 0, translatedPrimitive.SemiAxisDirection() * -1, 1);
+          CDriverPrimitive oppositePrimitive = CDriverPrimitive(
+              translatedPrimitive.Index(), 0, translatedPrimitive.SemiAxisDirection() * -1, 1);
           driverMap[oppositePrimitive] = it.first;
         }
         break;
@@ -542,8 +570,8 @@ CAddonButtonMap::DriverMap CAddonButtonMap::CreateLookupTable(const FeatureMap&
       case JOYSTICK_FEATURE_TYPE_WHEEL:
       {
         std::vector<JOYSTICK_FEATURE_PRIMITIVE> primitives = {
-          JOYSTICK_WHEEL_LEFT,
-          JOYSTICK_WHEEL_RIGHT,
+            JOYSTICK_WHEEL_LEFT,
+            JOYSTICK_WHEEL_RIGHT,
         };
 
         for (auto primitive : primitives)
@@ -555,8 +583,8 @@ CAddonButtonMap::DriverMap CAddonButtonMap::CreateLookupTable(const FeatureMap&
       case JOYSTICK_FEATURE_TYPE_THROTTLE:
       {
         std::vector<JOYSTICK_FEATURE_PRIMITIVE> primitives = {
-          JOYSTICK_THROTTLE_UP,
-          JOYSTICK_THROTTLE_DOWN,
+            JOYSTICK_THROTTLE_UP,
+            JOYSTICK_THROTTLE_DOWN,
         };
 
         for (auto primitive : primitives)
@@ -568,10 +596,10 @@ CAddonButtonMap::DriverMap CAddonButtonMap::CreateLookupTable(const FeatureMap&
       case JOYSTICK_FEATURE_TYPE_RELPOINTER:
       {
         std::vector<JOYSTICK_FEATURE_PRIMITIVE> primitives = {
-          JOYSTICK_RELPOINTER_UP,
-          JOYSTICK_RELPOINTER_DOWN,
-          JOYSTICK_RELPOINTER_RIGHT,
-          JOYSTICK_RELPOINTER_LEFT,
+            JOYSTICK_RELPOINTER_UP,
+            JOYSTICK_RELPOINTER_DOWN,
+            JOYSTICK_RELPOINTER_RIGHT,
+            JOYSTICK_RELPOINTER_LEFT,
         };
 
         for (auto primitive : primitives)
@@ -588,33 +616,45 @@ CAddonButtonMap::DriverMap CAddonButtonMap::CreateLookupTable(const FeatureMap&
   return driverMap;
 }
 
-JOYSTICK_FEATURE_PRIMITIVE CAddonButtonMap::GetAnalogStickIndex(JOYSTICK::ANALOG_STICK_DIRECTION dir)
+JOYSTICK_FEATURE_PRIMITIVE CAddonButtonMap::GetAnalogStickIndex(
+    JOYSTICK::ANALOG_STICK_DIRECTION dir)
 {
   using namespace JOYSTICK;
 
   switch (dir)
   {
-  case ANALOG_STICK_DIRECTION::UP:    return JOYSTICK_ANALOG_STICK_UP;
-  case ANALOG_STICK_DIRECTION::DOWN:  return JOYSTICK_ANALOG_STICK_DOWN;
-  case ANALOG_STICK_DIRECTION::RIGHT: return JOYSTICK_ANALOG_STICK_RIGHT;
-  case ANALOG_STICK_DIRECTION::LEFT:  return JOYSTICK_ANALOG_STICK_LEFT;
-  default: break;
+    case ANALOG_STICK_DIRECTION::UP:
+      return JOYSTICK_ANALOG_STICK_UP;
+    case ANALOG_STICK_DIRECTION::DOWN:
+      return JOYSTICK_ANALOG_STICK_DOWN;
+    case ANALOG_STICK_DIRECTION::RIGHT:
+      return JOYSTICK_ANALOG_STICK_RIGHT;
+    case ANALOG_STICK_DIRECTION::LEFT:
+      return JOYSTICK_ANALOG_STICK_LEFT;
+    default:
+      break;
   }
 
   return static_cast<JOYSTICK_FEATURE_PRIMITIVE>(0);
 }
 
-JOYSTICK_FEATURE_PRIMITIVE CAddonButtonMap::GetRelativePointerIndex(JOYSTICK::RELATIVE_POINTER_DIRECTION dir)
+JOYSTICK_FEATURE_PRIMITIVE CAddonButtonMap::GetRelativePointerIndex(
+    JOYSTICK::RELATIVE_POINTER_DIRECTION dir)
 {
   using namespace JOYSTICK;
 
   switch (dir)
   {
-    case RELATIVE_POINTER_DIRECTION::UP:    return JOYSTICK_RELPOINTER_UP;
-    case RELATIVE_POINTER_DIRECTION::DOWN:  return JOYSTICK_RELPOINTER_DOWN;
-    case RELATIVE_POINTER_DIRECTION::RIGHT: return JOYSTICK_RELPOINTER_RIGHT;
-    case RELATIVE_POINTER_DIRECTION::LEFT:  return JOYSTICK_RELPOINTER_LEFT;
-    default: break;
+    case RELATIVE_POINTER_DIRECTION::UP:
+      return JOYSTICK_RELPOINTER_UP;
+    case RELATIVE_POINTER_DIRECTION::DOWN:
+      return JOYSTICK_RELPOINTER_DOWN;
+    case RELATIVE_POINTER_DIRECTION::RIGHT:
+      return JOYSTICK_RELPOINTER_RIGHT;
+    case RELATIVE_POINTER_DIRECTION::LEFT:
+      return JOYSTICK_RELPOINTER_LEFT;
+    default:
+      break;
   }
 
   return static_cast<JOYSTICK_FEATURE_PRIMITIVE>(0);
@@ -626,9 +666,12 @@ JOYSTICK_FEATURE_PRIMITIVE CAddonButtonMap::GetPrimitiveIndex(JOYSTICK::WHEEL_DI
 
   switch (dir)
   {
-    case WHEEL_DIRECTION::RIGHT: return JOYSTICK_WHEEL_RIGHT;
-    case WHEEL_DIRECTION::LEFT:  return JOYSTICK_WHEEL_LEFT;
-    default: break;
+    case WHEEL_DIRECTION::RIGHT:
+      return JOYSTICK_WHEEL_RIGHT;
+    case WHEEL_DIRECTION::LEFT:
+      return JOYSTICK_WHEEL_LEFT;
+    default:
+      break;
   }
 
   return static_cast<JOYSTICK_FEATURE_PRIMITIVE>(0);
@@ -640,9 +683,12 @@ JOYSTICK_FEATURE_PRIMITIVE CAddonButtonMap::GetPrimitiveIndex(JOYSTICK::THROTTLE
 
   switch (dir)
   {
-    case THROTTLE_DIRECTION::UP:    return JOYSTICK_THROTTLE_UP;
-    case THROTTLE_DIRECTION::DOWN:  return JOYSTICK_THROTTLE_DOWN;
-    default: break;
+    case THROTTLE_DIRECTION::UP:
+      return JOYSTICK_THROTTLE_UP;
+    case THROTTLE_DIRECTION::DOWN:
+      return JOYSTICK_THROTTLE_DOWN;
+    default:
+      break;
   }
 
   return static_cast<JOYSTICK_FEATURE_PRIMITIVE>(0);
diff --git a/xbmc/peripherals/addons/AddonButtonMap.h b/xbmc/peripherals/addons/AddonButtonMap.h
index 16603abf9942..35ad3f3aa2d5 100644
--- a/xbmc/peripherals/addons/AddonButtonMap.h
+++ b/xbmc/peripherals/addons/AddonButtonMap.h
@@ -18,145 +18,117 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheral;
-
-  class CAddonButtonMap : public KODI::JOYSTICK::IButtonMap
-  {
-  public:
-    CAddonButtonMap(CPeripheral* device, const std::weak_ptr<CPeripheralAddon>& addon, const std::string& strControllerId);
-
-    ~CAddonButtonMap(void) override;
-
-    // Implementation of IButtonMap
-    std::string ControllerID(void) const override { return m_strControllerId; }
-
-    std::string DeviceName(void) const override;
-
-    bool Load(void) override;
-
-    void Reset(void) override;
-
-    bool IsEmpty(void) const override;
-
-    bool GetFeature(
-      const KODI::JOYSTICK::CDriverPrimitive& primitive,
-      KODI::JOYSTICK::FeatureName& feature
-    ) override;
-
-    KODI::JOYSTICK::FEATURE_TYPE GetFeatureType(
-      const KODI::JOYSTICK::FeatureName& feature
-    ) override;
-
-    bool GetScalar(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    void AddScalar(
-      const KODI::JOYSTICK::FeatureName& feature,
-      const KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    bool GetAnalogStick(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::ANALOG_STICK_DIRECTION direction,
-      KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    void AddAnalogStick(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::ANALOG_STICK_DIRECTION direction,
-      const KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    bool GetRelativePointer(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION direction,
-      KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    void AddRelativePointer(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION direction,
-      const KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    bool GetAccelerometer(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::CDriverPrimitive& positiveX,
-      KODI::JOYSTICK::CDriverPrimitive& positiveY,
-      KODI::JOYSTICK::CDriverPrimitive& positiveZ
-    ) override;
-
-    void AddAccelerometer(
-      const KODI::JOYSTICK::FeatureName& feature,
-      const KODI::JOYSTICK::CDriverPrimitive& positiveX,
-      const KODI::JOYSTICK::CDriverPrimitive& positiveY,
-      const KODI::JOYSTICK::CDriverPrimitive& positiveZ
-    ) override;
-
-    bool GetWheel(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::WHEEL_DIRECTION direction,
-      KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    void AddWheel(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::WHEEL_DIRECTION direction,
-      const KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    bool GetThrottle(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::THROTTLE_DIRECTION direction,
-      KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    void AddThrottle(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::THROTTLE_DIRECTION direction,
-      const KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    bool GetKey(
-      const KODI::JOYSTICK::FeatureName& feature,
-      KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    void AddKey(
-      const KODI::JOYSTICK::FeatureName& feature,
-      const KODI::JOYSTICK::CDriverPrimitive& primitive
-    ) override;
-
-    void SetIgnoredPrimitives(const std::vector<KODI::JOYSTICK::CDriverPrimitive>& primitives) override;
-
-    bool IsIgnored(const KODI::JOYSTICK::CDriverPrimitive& primitive) override;
-
-    bool GetAxisProperties(unsigned int axisIndex, int& center, unsigned int& range) override;
-
-    void SaveButtonMap() override;
-
-    void RevertButtonMap() override;
-
-  private:
-    typedef std::map<KODI::JOYSTICK::CDriverPrimitive, KODI::JOYSTICK::FeatureName> DriverMap;
-    typedef std::vector<KODI::JOYSTICK::CDriverPrimitive> JoystickPrimitiveVector;
-
-    // Utility functions
-    static DriverMap CreateLookupTable(const FeatureMap& features);
-
-    static JOYSTICK_FEATURE_PRIMITIVE GetAnalogStickIndex(KODI::JOYSTICK::ANALOG_STICK_DIRECTION dir);
-    static JOYSTICK_FEATURE_PRIMITIVE GetRelativePointerIndex(KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION dir);
-    static JOYSTICK_FEATURE_PRIMITIVE GetPrimitiveIndex(KODI::JOYSTICK::WHEEL_DIRECTION dir);
-    static JOYSTICK_FEATURE_PRIMITIVE GetPrimitiveIndex(KODI::JOYSTICK::THROTTLE_DIRECTION dir);
-
-    CPeripheral* const  m_device;
-    std::weak_ptr<CPeripheralAddon>  m_addon;
-    const std::string   m_strControllerId;
-    FeatureMap          m_features;
-    DriverMap           m_driverMap;
-    JoystickPrimitiveVector m_ignoredPrimitives;
-    mutable CCriticalSection m_mutex;
-  };
-}
+class CPeripheral;
+
+class CAddonButtonMap : public KODI::JOYSTICK::IButtonMap
+{
+public:
+  CAddonButtonMap(CPeripheral* device,
+                  const std::weak_ptr<CPeripheralAddon>& addon,
+                  const std::string& strControllerId);
+
+  ~CAddonButtonMap(void) override;
+
+  // Implementation of IButtonMap
+  std::string ControllerID(void) const override { return m_strControllerId; }
+
+  std::string DeviceName(void) const override;
+
+  bool Load(void) override;
+
+  void Reset(void) override;
+
+  bool IsEmpty(void) const override;
+
+  bool GetFeature(const KODI::JOYSTICK::CDriverPrimitive& primitive,
+                  KODI::JOYSTICK::FeatureName& feature) override;
+
+  KODI::JOYSTICK::FEATURE_TYPE GetFeatureType(const KODI::JOYSTICK::FeatureName& feature) override;
+
+  bool GetScalar(const KODI::JOYSTICK::FeatureName& feature,
+                 KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  void AddScalar(const KODI::JOYSTICK::FeatureName& feature,
+                 const KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  bool GetAnalogStick(const KODI::JOYSTICK::FeatureName& feature,
+                      KODI::JOYSTICK::ANALOG_STICK_DIRECTION direction,
+                      KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  void AddAnalogStick(const KODI::JOYSTICK::FeatureName& feature,
+                      KODI::JOYSTICK::ANALOG_STICK_DIRECTION direction,
+                      const KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  bool GetRelativePointer(const KODI::JOYSTICK::FeatureName& feature,
+                          KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION direction,
+                          KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  void AddRelativePointer(const KODI::JOYSTICK::FeatureName& feature,
+                          KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION direction,
+                          const KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  bool GetAccelerometer(const KODI::JOYSTICK::FeatureName& feature,
+                        KODI::JOYSTICK::CDriverPrimitive& positiveX,
+                        KODI::JOYSTICK::CDriverPrimitive& positiveY,
+                        KODI::JOYSTICK::CDriverPrimitive& positiveZ) override;
+
+  void AddAccelerometer(const KODI::JOYSTICK::FeatureName& feature,
+                        const KODI::JOYSTICK::CDriverPrimitive& positiveX,
+                        const KODI::JOYSTICK::CDriverPrimitive& positiveY,
+                        const KODI::JOYSTICK::CDriverPrimitive& positiveZ) override;
+
+  bool GetWheel(const KODI::JOYSTICK::FeatureName& feature,
+                KODI::JOYSTICK::WHEEL_DIRECTION direction,
+                KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  void AddWheel(const KODI::JOYSTICK::FeatureName& feature,
+                KODI::JOYSTICK::WHEEL_DIRECTION direction,
+                const KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  bool GetThrottle(const KODI::JOYSTICK::FeatureName& feature,
+                   KODI::JOYSTICK::THROTTLE_DIRECTION direction,
+                   KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  void AddThrottle(const KODI::JOYSTICK::FeatureName& feature,
+                   KODI::JOYSTICK::THROTTLE_DIRECTION direction,
+                   const KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  bool GetKey(const KODI::JOYSTICK::FeatureName& feature,
+              KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  void AddKey(const KODI::JOYSTICK::FeatureName& feature,
+              const KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  void SetIgnoredPrimitives(
+      const std::vector<KODI::JOYSTICK::CDriverPrimitive>& primitives) override;
+
+  bool IsIgnored(const KODI::JOYSTICK::CDriverPrimitive& primitive) override;
+
+  bool GetAxisProperties(unsigned int axisIndex, int& center, unsigned int& range) override;
+
+  void SaveButtonMap() override;
+
+  void RevertButtonMap() override;
+
+private:
+  typedef std::map<KODI::JOYSTICK::CDriverPrimitive, KODI::JOYSTICK::FeatureName> DriverMap;
+  typedef std::vector<KODI::JOYSTICK::CDriverPrimitive> JoystickPrimitiveVector;
+
+  // Utility functions
+  static DriverMap CreateLookupTable(const FeatureMap& features);
+
+  static JOYSTICK_FEATURE_PRIMITIVE GetAnalogStickIndex(KODI::JOYSTICK::ANALOG_STICK_DIRECTION dir);
+  static JOYSTICK_FEATURE_PRIMITIVE GetRelativePointerIndex(
+      KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION dir);
+  static JOYSTICK_FEATURE_PRIMITIVE GetPrimitiveIndex(KODI::JOYSTICK::WHEEL_DIRECTION dir);
+  static JOYSTICK_FEATURE_PRIMITIVE GetPrimitiveIndex(KODI::JOYSTICK::THROTTLE_DIRECTION dir);
+
+  CPeripheral* const m_device;
+  std::weak_ptr<CPeripheralAddon> m_addon;
+  const std::string m_strControllerId;
+  FeatureMap m_features;
+  DriverMap m_driverMap;
+  JoystickPrimitiveVector m_ignoredPrimitives;
+  mutable CCriticalSection m_mutex;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/addons/AddonButtonMapping.cpp b/xbmc/peripherals/addons/AddonButtonMapping.cpp
index 7b8b05f34b0d..12c1f9f05524 100644
--- a/xbmc/peripherals/addons/AddonButtonMapping.cpp
+++ b/xbmc/peripherals/addons/AddonButtonMapping.cpp
@@ -18,7 +18,9 @@ using namespace KODI;
 using namespace JOYSTICK;
 using namespace PERIPHERALS;
 
-CAddonButtonMapping::CAddonButtonMapping(CPeripherals& manager, CPeripheral* peripheral, IButtonMapper* mapper)
+CAddonButtonMapping::CAddonButtonMapping(CPeripherals& manager,
+                                         CPeripheral* peripheral,
+                                         IButtonMapper* mapper)
 {
   PeripheralAddonPtr addon = manager.GetAddonWithButtonMap(peripheral);
 
@@ -32,7 +34,7 @@ CAddonButtonMapping::CAddonButtonMapping(CPeripherals& manager, CPeripheral* per
     m_buttonMap.reset(new CAddonButtonMap(peripheral, addon, controllerId));
     if (m_buttonMap->Load())
     {
-      IKeymap *keymap = peripheral->GetKeymap(controllerId);
+      IKeymap* keymap = peripheral->GetKeymap(controllerId);
       m_buttonMapping.reset(new CButtonMapping(mapper, m_buttonMap.get(), keymap));
 
       // Allow the mapper to save our button map
@@ -65,7 +67,10 @@ bool CAddonButtonMapping::OnHatMotion(unsigned int hatIndex, HAT_STATE state)
   return false;
 }
 
-bool CAddonButtonMapping::OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range)
+bool CAddonButtonMapping::OnAxisMotion(unsigned int axisIndex,
+                                       float position,
+                                       int center,
+                                       unsigned int range)
 {
   if (m_buttonMapping)
     return m_buttonMapping->OnAxisMotion(axisIndex, position, center, range);
diff --git a/xbmc/peripherals/addons/AddonButtonMapping.h b/xbmc/peripherals/addons/AddonButtonMapping.h
index 5335d1d1150f..7d6f841bd20c 100644
--- a/xbmc/peripherals/addons/AddonButtonMapping.h
+++ b/xbmc/peripherals/addons/AddonButtonMapping.h
@@ -19,49 +19,54 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class CButtonMapping;
-  class IButtonMap;
-  class IButtonMapper;
-}
-}
+class CButtonMapping;
+class IButtonMap;
+class IButtonMapper;
+} // namespace JOYSTICK
+} // namespace KODI
 
 namespace PERIPHERALS
 {
-  class CPeripheral;
-  class CPeripherals;
+class CPeripheral;
+class CPeripherals;
 
-  class CAddonButtonMapping : public KODI::JOYSTICK::IDriverHandler,
-                              public KODI::KEYBOARD::IKeyboardDriverHandler,
-                              public KODI::MOUSE::IMouseDriverHandler,
-                              public KODI::JOYSTICK::IButtonMapCallback
-  {
-  public:
-    CAddonButtonMapping(CPeripherals& manager, CPeripheral* peripheral, KODI::JOYSTICK::IButtonMapper* mapper);
+class CAddonButtonMapping : public KODI::JOYSTICK::IDriverHandler,
+                            public KODI::KEYBOARD::IKeyboardDriverHandler,
+                            public KODI::MOUSE::IMouseDriverHandler,
+                            public KODI::JOYSTICK::IButtonMapCallback
+{
+public:
+  CAddonButtonMapping(CPeripherals& manager,
+                      CPeripheral* peripheral,
+                      KODI::JOYSTICK::IButtonMapper* mapper);
 
-    ~CAddonButtonMapping(void) override;
+  ~CAddonButtonMapping(void) override;
 
-    // implementation of IDriverHandler
-    bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) override;
-    bool OnHatMotion(unsigned int hatIndex, KODI::JOYSTICK::HAT_STATE state) override;
-    bool OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range) override;
-    void ProcessAxisMotions(void) override;
+  // implementation of IDriverHandler
+  bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) override;
+  bool OnHatMotion(unsigned int hatIndex, KODI::JOYSTICK::HAT_STATE state) override;
+  bool OnAxisMotion(unsigned int axisIndex,
+                    float position,
+                    int center,
+                    unsigned int range) override;
+  void ProcessAxisMotions(void) override;
 
-    // implementation of IKeyboardDriverHandler
-    bool OnKeyPress(const CKey& key) override;
-    void OnKeyRelease(const CKey& key) override;
+  // implementation of IKeyboardDriverHandler
+  bool OnKeyPress(const CKey& key) override;
+  void OnKeyRelease(const CKey& key) override;
 
-    // implementation of IMouseDriverHandler
-    bool OnPosition(int x, int y) override;
-    bool OnButtonPress(KODI::MOUSE::BUTTON_ID button) override;
-    void OnButtonRelease(KODI::MOUSE::BUTTON_ID button) override;
+  // implementation of IMouseDriverHandler
+  bool OnPosition(int x, int y) override;
+  bool OnButtonPress(KODI::MOUSE::BUTTON_ID button) override;
+  void OnButtonRelease(KODI::MOUSE::BUTTON_ID button) override;
 
-    // implementation of IButtonMapCallback
-    void SaveButtonMap() override;
-    void ResetIgnoredPrimitives() override;
-    void RevertButtonMap() override;
+  // implementation of IButtonMapCallback
+  void SaveButtonMap() override;
+  void ResetIgnoredPrimitives() override;
+  void RevertButtonMap() override;
 
-  private:
-    std::unique_ptr<KODI::JOYSTICK::CButtonMapping> m_buttonMapping;
-    std::unique_ptr<KODI::JOYSTICK::IButtonMap>     m_buttonMap;
-  };
-}
+private:
+  std::unique_ptr<KODI::JOYSTICK::CButtonMapping> m_buttonMapping;
+  std::unique_ptr<KODI::JOYSTICK::IButtonMap> m_buttonMap;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/addons/AddonInputHandling.cpp b/xbmc/peripherals/addons/AddonInputHandling.cpp
index 05149d31476a..2a9d42b66d69 100644
--- a/xbmc/peripherals/addons/AddonInputHandling.cpp
+++ b/xbmc/peripherals/addons/AddonInputHandling.cpp
@@ -24,7 +24,10 @@ using namespace KODI;
 using namespace JOYSTICK;
 using namespace PERIPHERALS;
 
-CAddonInputHandling::CAddonInputHandling(CPeripherals& manager, CPeripheral* peripheral, IInputHandler* handler, IDriverReceiver* receiver)
+CAddonInputHandling::CAddonInputHandling(CPeripherals& manager,
+                                         CPeripheral* peripheral,
+                                         IInputHandler* handler,
+                                         IDriverReceiver* receiver)
 {
   PeripheralAddonPtr addon = manager.GetAddonWithButtonMap(peripheral);
 
@@ -54,7 +57,9 @@ CAddonInputHandling::CAddonInputHandling(CPeripherals& manager, CPeripheral* per
   }
 }
 
-CAddonInputHandling::CAddonInputHandling(CPeripherals& manager, CPeripheral* peripheral, KEYBOARD::IKeyboardInputHandler* handler)
+CAddonInputHandling::CAddonInputHandling(CPeripherals& manager,
+                                         CPeripheral* peripheral,
+                                         KEYBOARD::IKeyboardInputHandler* handler)
 {
   PeripheralAddonPtr addon = manager.GetAddonWithButtonMap(peripheral);
 
@@ -76,7 +81,9 @@ CAddonInputHandling::CAddonInputHandling(CPeripherals& manager, CPeripheral* per
   }
 }
 
-CAddonInputHandling::CAddonInputHandling(CPeripherals& manager, CPeripheral* peripheral, MOUSE::IMouseInputHandler* handler)
+CAddonInputHandling::CAddonInputHandling(CPeripherals& manager,
+                                         CPeripheral* peripheral,
+                                         MOUSE::IMouseInputHandler* handler)
 {
   PeripheralAddonPtr addon = manager.GetAddonWithButtonMap(peripheral);
 
@@ -122,7 +129,10 @@ bool CAddonInputHandling::OnHatMotion(unsigned int hatIndex, HAT_STATE state)
   return false;
 }
 
-bool CAddonInputHandling::OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range)
+bool CAddonInputHandling::OnAxisMotion(unsigned int axisIndex,
+                                       float position,
+                                       int center,
+                                       unsigned int range)
 {
   if (m_driverHandler)
     return m_driverHandler->OnAxisMotion(axisIndex, position, center, range);
diff --git a/xbmc/peripherals/addons/AddonInputHandling.h b/xbmc/peripherals/addons/AddonInputHandling.h
index c4443b0fd4e6..54322993e65a 100644
--- a/xbmc/peripherals/addons/AddonInputHandling.h
+++ b/xbmc/peripherals/addons/AddonInputHandling.h
@@ -19,71 +19,74 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IButtonMap;
-  class IDriverReceiver;
-  class IInputHandler;
-}
+class IButtonMap;
+class IDriverReceiver;
+class IInputHandler;
+} // namespace JOYSTICK
 
 namespace KEYBOARD
 {
-  class IKeyboardInputHandler;
+class IKeyboardInputHandler;
 }
 
 namespace MOUSE
 {
-  class IMouseInputHandler;
-}
+class IMouseInputHandler;
 }
+} // namespace KODI
 
 namespace PERIPHERALS
 {
-  class CPeripheral;
-  class CPeripherals;
-
-  class CAddonInputHandling : public KODI::JOYSTICK::IDriverHandler,
-                              public KODI::JOYSTICK::IInputReceiver,
-                              public KODI::KEYBOARD::IKeyboardDriverHandler,
-                              public KODI::MOUSE::IMouseDriverHandler
-  {
-  public:
-    CAddonInputHandling(CPeripherals& manager,
-                        CPeripheral* peripheral,
-                        KODI::JOYSTICK::IInputHandler* handler,
-                        KODI::JOYSTICK::IDriverReceiver* receiver);
-
-    CAddonInputHandling(CPeripherals& manager,
-                        CPeripheral* peripheral,
-                        KODI::KEYBOARD::IKeyboardInputHandler* handler);
-
-    CAddonInputHandling(CPeripherals& manager,
-                        CPeripheral* peripheral,
-                        KODI::MOUSE::IMouseInputHandler* handler);
-
-    ~CAddonInputHandling(void) override;
-
-    // implementation of IDriverHandler
-    bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) override;
-    bool OnHatMotion(unsigned int hatIndex, KODI::JOYSTICK::HAT_STATE state) override;
-    bool OnAxisMotion(unsigned int axisIndex, float position, int center, unsigned int range) override;
-    void ProcessAxisMotions(void) override;
-
-    // implementation of IKeyboardDriverHandler
-    bool OnKeyPress(const CKey& key) override;
-    void OnKeyRelease(const CKey& key) override;
-
-    // implementation of IMouseDriverHandler
-    bool OnPosition(int x, int y) override;
-    bool OnButtonPress(KODI::MOUSE::BUTTON_ID button) override;
-    void OnButtonRelease(KODI::MOUSE::BUTTON_ID button) override;
-
-    // implementation of IInputReceiver
-    bool SetRumbleState(const KODI::JOYSTICK::FeatureName& feature, float magnitude) override;
-
-  private:
-    std::unique_ptr<KODI::JOYSTICK::IDriverHandler> m_driverHandler;
-    std::unique_ptr<KODI::JOYSTICK::IInputReceiver> m_inputReceiver;
-    std::unique_ptr<KODI::KEYBOARD::IKeyboardDriverHandler> m_keyboardHandler;
-    std::unique_ptr<KODI::MOUSE::IMouseDriverHandler> m_mouseHandler;
-    std::unique_ptr<KODI::JOYSTICK::IButtonMap>     m_buttonMap;
-  };
-}
+class CPeripheral;
+class CPeripherals;
+
+class CAddonInputHandling : public KODI::JOYSTICK::IDriverHandler,
+                            public KODI::JOYSTICK::IInputReceiver,
+                            public KODI::KEYBOARD::IKeyboardDriverHandler,
+                            public KODI::MOUSE::IMouseDriverHandler
+{
+public:
+  CAddonInputHandling(CPeripherals& manager,
+                      CPeripheral* peripheral,
+                      KODI::JOYSTICK::IInputHandler* handler,
+                      KODI::JOYSTICK::IDriverReceiver* receiver);
+
+  CAddonInputHandling(CPeripherals& manager,
+                      CPeripheral* peripheral,
+                      KODI::KEYBOARD::IKeyboardInputHandler* handler);
+
+  CAddonInputHandling(CPeripherals& manager,
+                      CPeripheral* peripheral,
+                      KODI::MOUSE::IMouseInputHandler* handler);
+
+  ~CAddonInputHandling(void) override;
+
+  // implementation of IDriverHandler
+  bool OnButtonMotion(unsigned int buttonIndex, bool bPressed) override;
+  bool OnHatMotion(unsigned int hatIndex, KODI::JOYSTICK::HAT_STATE state) override;
+  bool OnAxisMotion(unsigned int axisIndex,
+                    float position,
+                    int center,
+                    unsigned int range) override;
+  void ProcessAxisMotions(void) override;
+
+  // implementation of IKeyboardDriverHandler
+  bool OnKeyPress(const CKey& key) override;
+  void OnKeyRelease(const CKey& key) override;
+
+  // implementation of IMouseDriverHandler
+  bool OnPosition(int x, int y) override;
+  bool OnButtonPress(KODI::MOUSE::BUTTON_ID button) override;
+  void OnButtonRelease(KODI::MOUSE::BUTTON_ID button) override;
+
+  // implementation of IInputReceiver
+  bool SetRumbleState(const KODI::JOYSTICK::FeatureName& feature, float magnitude) override;
+
+private:
+  std::unique_ptr<KODI::JOYSTICK::IDriverHandler> m_driverHandler;
+  std::unique_ptr<KODI::JOYSTICK::IInputReceiver> m_inputReceiver;
+  std::unique_ptr<KODI::KEYBOARD::IKeyboardDriverHandler> m_keyboardHandler;
+  std::unique_ptr<KODI::MOUSE::IMouseDriverHandler> m_mouseHandler;
+  std::unique_ptr<KODI::JOYSTICK::IButtonMap> m_buttonMap;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/addons/PeripheralAddon.cpp b/xbmc/peripherals/addons/PeripheralAddon.cpp
index 3a3cc800fc16..3e43b174334b 100644
--- a/xbmc/peripherals/addons/PeripheralAddon.cpp
+++ b/xbmc/peripherals/addons/PeripheralAddon.cpp
@@ -32,24 +32,32 @@ using namespace JOYSTICK;
 using namespace PERIPHERALS;
 using namespace XFILE;
 
-#define KEYBOARD_BUTTON_MAP_NAME  "Keyboard"
-#define KEYBOARD_PROVIDER         "application"
+#define KEYBOARD_BUTTON_MAP_NAME "Keyboard"
+#define KEYBOARD_PROVIDER "application"
 
-#define MOUSE_BUTTON_MAP_NAME     "Mouse"
-#define MOUSE_PROVIDER            "application"
+#define MOUSE_BUTTON_MAP_NAME "Mouse"
+#define MOUSE_PROVIDER "application"
 
 #ifndef SAFE_DELETE
-  #define SAFE_DELETE(p)  do { delete (p); (p) = NULL; } while (0)
+#define SAFE_DELETE(p) \
+  do \
+  { \
+    delete (p); \
+    (p) = NULL; \
+  } while (0)
 #endif
 
-CPeripheralAddon::CPeripheralAddon(const ADDON::BinaryAddonBasePtr& addonInfo, CPeripherals &manager)
+CPeripheralAddon::CPeripheralAddon(const ADDON::BinaryAddonBasePtr& addonInfo,
+                                   CPeripherals& manager)
   : IAddonInstanceHandler(ADDON_INSTANCE_PERIPHERAL, addonInfo),
     m_manager(manager),
     m_bSupportsJoystickRumble(false),
     m_bSupportsJoystickPowerOff(false)
 {
-  m_bProvidesJoysticks = addonInfo->Type(ADDON::ADDON_PERIPHERALDLL)->GetValue("@provides_joysticks").asBoolean();
-  m_bProvidesButtonMaps = addonInfo->Type(ADDON::ADDON_PERIPHERALDLL)->GetValue("@provides_buttonmaps").asBoolean();
+  m_bProvidesJoysticks =
+      addonInfo->Type(ADDON::ADDON_PERIPHERALDLL)->GetValue("@provides_joysticks").asBoolean();
+  m_bProvidesButtonMaps =
+      addonInfo->Type(ADDON::ADDON_PERIPHERALDLL)->GetValue("@provides_buttonmaps").asBoolean();
 
   ResetProperties();
 }
@@ -65,7 +73,7 @@ void CPeripheralAddon::ResetProperties(void)
   m_strUserPath = CSpecialProtocol::TranslatePath(Profile());
   m_strClientPath = CSpecialProtocol::TranslatePath(Path());
 
-  m_struct = {{ 0 }};
+  m_struct = {{0}};
   m_struct.props.user_path = m_strUserPath.c_str();
   m_struct.props.addon_path = m_strClientPath.c_str();
 
@@ -88,7 +96,8 @@ bool CPeripheralAddon::CreateAddon(void)
     CDirectory::Create(m_strUserPath);
 
   // Initialise the add-on
-  CLog::Log(LOGDEBUG, "PERIPHERAL - %s - creating peripheral add-on instance '%s'", __FUNCTION__, Name().c_str());
+  CLog::Log(LOGDEBUG, "PERIPHERAL - %s - creating peripheral add-on instance '%s'", __FUNCTION__,
+            Name().c_str());
 
   if (CreateInstance(&m_struct) != ADDON_STATUS_OK)
     return false;
@@ -111,7 +120,8 @@ void CPeripheralAddon::DestroyAddon()
 
   {
     CSingleLock lock(m_buttonMapMutex);
-    // only clear buttonMaps but don't delete them as they are owned by a CAddonJoystickInputHandling instance
+    // only clear buttonMaps but don't delete them as they are owned by a
+    // CAddonJoystickInputHandling instance
     m_buttonMaps.clear();
   }
 
@@ -123,7 +133,7 @@ void CPeripheralAddon::DestroyAddon()
 
 bool CPeripheralAddon::GetAddonProperties(void)
 {
-  PERIPHERAL_CAPABILITIES addonCapabilities = { };
+  PERIPHERAL_CAPABILITIES addonCapabilities = {};
 
   // Get the capabilities
   m_struct.toAddon.get_capabilities(&m_struct, &addonCapabilities);
@@ -131,14 +141,20 @@ bool CPeripheralAddon::GetAddonProperties(void)
   // Verify capabilities against addon.xml
   if (m_bProvidesJoysticks != addonCapabilities.provides_joysticks)
   {
-    CLog::Log(LOGERROR, "PERIPHERAL - Add-on '%s': provides_joysticks'(%s) in add-on DLL  doesn't match 'provides_joysticks'(%s) in addon.xml. Please contact the developer of this add-on: %s",
+    CLog::Log(
+        LOGERROR,
+        "PERIPHERAL - Add-on '%s': provides_joysticks'(%s) in add-on DLL  doesn't match "
+        "'provides_joysticks'(%s) in addon.xml. Please contact the developer of this add-on: %s",
         Name().c_str(), addonCapabilities.provides_joysticks ? "true" : "false",
         m_bProvidesJoysticks ? "true" : "false", Author().c_str());
     return false;
   }
   if (m_bProvidesButtonMaps != addonCapabilities.provides_buttonmaps)
   {
-    CLog::Log(LOGERROR, "PERIPHERAL - Add-on '%s': provides_buttonmaps' (%s) in add-on DLL  doesn't match 'provides_buttonmaps' (%s) in addon.xml. Please contact the developer of this add-on: %s",
+    CLog::Log(
+        LOGERROR,
+        "PERIPHERAL - Add-on '%s': provides_buttonmaps' (%s) in add-on DLL  doesn't match "
+        "'provides_buttonmaps' (%s) in addon.xml. Please contact the developer of this add-on: %s",
         Name().c_str(), addonCapabilities.provides_buttonmaps ? "true" : "false",
         m_bProvidesButtonMaps ? "true" : "false", Author().c_str());
     return false;
@@ -174,7 +190,8 @@ bool CPeripheralAddon::Register(unsigned int peripheralIndex, const PeripheralPt
   return false;
 }
 
-void CPeripheralAddon::UnregisterRemovedDevices(const PeripheralScanResults &results, PeripheralVector& removedPeripherals)
+void CPeripheralAddon::UnregisterRemovedDevices(const PeripheralScanResults& results,
+                                                PeripheralVector& removedPeripherals)
 {
   std::vector<unsigned int> removedIndexes;
 
@@ -185,7 +202,7 @@ void CPeripheralAddon::UnregisterRemovedDevices(const PeripheralScanResults &res
       const PeripheralPtr& peripheral = it.second;
       PeripheralScanResult updatedDevice(PERIPHERAL_BUS_ADDON);
       if (!results.GetDeviceOnLocation(peripheral->Location(), &updatedDevice) ||
-        *peripheral != updatedDevice)
+          *peripheral != updatedDevice)
       {
         // Device removed
         removedIndexes.push_back(it.first);
@@ -216,9 +233,10 @@ bool CPeripheralAddon::HasFeature(const PeripheralFeature feature) const
   return false;
 }
 
-void CPeripheralAddon::GetFeatures(std::vector<PeripheralFeature> &features) const
+void CPeripheralAddon::GetFeatures(std::vector<PeripheralFeature>& features) const
 {
-  if (m_bProvidesJoysticks && std::find(features.begin(), features.end(), FEATURE_JOYSTICK) == features.end())
+  if (m_bProvidesJoysticks &&
+      std::find(features.begin(), features.end(), FEATURE_JOYSTICK) == features.end())
     features.push_back(FEATURE_JOYSTICK);
 }
 
@@ -232,7 +250,7 @@ PeripheralPtr CPeripheralAddon::GetPeripheral(unsigned int index) const
   return peripheral;
 }
 
-PeripheralPtr CPeripheralAddon::GetByPath(const std::string &strPath) const
+PeripheralPtr CPeripheralAddon::GetByPath(const std::string& strPath) const
 {
   PeripheralPtr result;
 
@@ -264,7 +282,8 @@ bool CPeripheralAddon::SupportsFeature(PeripheralFeature feature) const
   return false;
 }
 
-unsigned int CPeripheralAddon::GetPeripheralsWithFeature(PeripheralVector &results, const PeripheralFeature feature) const
+unsigned int CPeripheralAddon::GetPeripheralsWithFeature(PeripheralVector& results,
+                                                         const PeripheralFeature feature) const
 {
   unsigned int iReturn = 0;
   CSingleLock lock(m_critSection);
@@ -285,21 +304,21 @@ unsigned int CPeripheralAddon::GetNumberOfPeripherals(void) const
   return static_cast<unsigned int>(m_peripherals.size());
 }
 
-unsigned int CPeripheralAddon::GetNumberOfPeripheralsWithId(const int iVendorId, const int iProductId) const
+unsigned int CPeripheralAddon::GetNumberOfPeripheralsWithId(const int iVendorId,
+                                                            const int iProductId) const
 {
   unsigned int iReturn = 0;
   CSingleLock lock(m_critSection);
   for (auto it : m_peripherals)
   {
-    if (it.second->VendorId() == iVendorId &&
-        it.second->ProductId() == iProductId)
+    if (it.second->VendorId() == iVendorId && it.second->ProductId() == iProductId)
       iReturn++;
   }
 
   return iReturn;
 }
 
-void CPeripheralAddon::GetDirectory(const std::string &strPath, CFileItemList &items) const
+void CPeripheralAddon::GetDirectory(const std::string& strPath, CFileItemList& items) const
 {
   CSingleLock lock(m_critSection);
   for (auto it : m_peripherals)
@@ -312,27 +331,31 @@ void CPeripheralAddon::GetDirectory(const std::string &strPath, CFileItemList &i
     peripheralFile->SetPath(peripheral->FileLocation());
     peripheralFile->SetProperty("vendor", peripheral->VendorIdAsString());
     peripheralFile->SetProperty("product", peripheral->ProductIdAsString());
-    peripheralFile->SetProperty("bus", PeripheralTypeTranslator::BusTypeToString(peripheral->GetBusType()));
+    peripheralFile->SetProperty(
+        "bus", PeripheralTypeTranslator::BusTypeToString(peripheral->GetBusType()));
     peripheralFile->SetProperty("location", peripheral->Location());
-    peripheralFile->SetProperty("class", PeripheralTypeTranslator::TypeToString(peripheral->Type()));
+    peripheralFile->SetProperty("class",
+                                PeripheralTypeTranslator::TypeToString(peripheral->Type()));
     peripheralFile->SetProperty("version", peripheral->GetVersionInfo());
     peripheralFile->SetArt("icon", peripheral->GetIcon());
     items.Add(peripheralFile);
   }
 }
 
-bool CPeripheralAddon::PerformDeviceScan(PeripheralScanResults &results)
+bool CPeripheralAddon::PerformDeviceScan(PeripheralScanResults& results)
 {
-  unsigned int      peripheralCount;
-  PERIPHERAL_INFO*  pScanResults;
-  PERIPHERAL_ERROR  retVal;
+  unsigned int peripheralCount;
+  PERIPHERAL_INFO* pScanResults;
+  PERIPHERAL_ERROR retVal;
 
   CSharedLock lock(m_dllSection);
 
   if (!m_struct.toAddon.perform_device_scan)
     return false;
 
-  LogError(retVal = m_struct.toAddon.perform_device_scan(&m_struct, &peripheralCount, &pScanResults), "PerformDeviceScan()");
+  LogError(retVal =
+               m_struct.toAddon.perform_device_scan(&m_struct, &peripheralCount, &pScanResults),
+           "PerformDeviceScan()");
 
   if (retVal == PERIPHERAL_NO_ERROR)
   {
@@ -342,20 +365,20 @@ bool CPeripheralAddon::PerformDeviceScan(PeripheralScanResults &results)
       PeripheralScanResult result(PERIPHERAL_BUS_ADDON);
       switch (peripheral.Type())
       {
-      case PERIPHERAL_TYPE_JOYSTICK:
-        result.m_type = PERIPHERAL_JOYSTICK;
-        break;
-      default:
-        continue;
+        case PERIPHERAL_TYPE_JOYSTICK:
+          result.m_type = PERIPHERAL_JOYSTICK;
+          break;
+        default:
+          continue;
       }
 
       result.m_strDeviceName = peripheral.Name();
-      result.m_strLocation   = StringUtils::Format("%s/%d", ID().c_str(), peripheral.Index());
-      result.m_iVendorId     = peripheral.VendorID();
-      result.m_iProductId    = peripheral.ProductID();
-      result.m_mappedType    = PERIPHERAL_JOYSTICK;
+      result.m_strLocation = StringUtils::Format("%s/%d", ID().c_str(), peripheral.Index());
+      result.m_iVendorId = peripheral.VendorID();
+      result.m_iProductId = peripheral.ProductID();
+      result.m_mappedType = PERIPHERAL_JOYSTICK;
       result.m_mappedBusType = PERIPHERAL_BUS_ADDON;
-      result.m_iSequence     = 0;
+      result.m_iSequence = 0;
 
       if (!results.ContainsResult(result))
         results.m_results.push_back(result);
@@ -381,7 +404,7 @@ bool CPeripheralAddon::ProcessEvents(void)
 
   PERIPHERAL_ERROR retVal;
 
-  unsigned int      eventCount = 0;
+  unsigned int eventCount = 0;
   PERIPHERAL_EVENT* pEvents = nullptr;
 
   LogError(retVal = m_struct.toAddon.get_events(&m_struct, &eventCount, &pEvents), "GetEvents()");
@@ -396,36 +419,38 @@ bool CPeripheralAddon::ProcessEvents(void)
 
       switch (device->Type())
       {
-      case PERIPHERAL_JOYSTICK:
-      {
-        std::shared_ptr<CPeripheralJoystick> joystickDevice = std::static_pointer_cast<CPeripheralJoystick>(device);
-
-        switch (event.Type())
+        case PERIPHERAL_JOYSTICK:
         {
-          case PERIPHERAL_EVENT_TYPE_DRIVER_BUTTON:
-          {
-            const bool bPressed = (event.ButtonState() == JOYSTICK_STATE_BUTTON_PRESSED);
-            joystickDevice->OnButtonMotion(event.DriverIndex(), bPressed);
-            break;
-          }
-          case PERIPHERAL_EVENT_TYPE_DRIVER_HAT:
-          {
-            const HAT_STATE state = CPeripheralAddonTranslator::TranslateHatState(event.HatState());
-            joystickDevice->OnHatMotion(event.DriverIndex(), state);
-            break;
-          }
-          case PERIPHERAL_EVENT_TYPE_DRIVER_AXIS:
+          std::shared_ptr<CPeripheralJoystick> joystickDevice =
+              std::static_pointer_cast<CPeripheralJoystick>(device);
+
+          switch (event.Type())
           {
-            joystickDevice->OnAxisMotion(event.DriverIndex(), event.AxisState());
-            break;
+            case PERIPHERAL_EVENT_TYPE_DRIVER_BUTTON:
+            {
+              const bool bPressed = (event.ButtonState() == JOYSTICK_STATE_BUTTON_PRESSED);
+              joystickDevice->OnButtonMotion(event.DriverIndex(), bPressed);
+              break;
+            }
+            case PERIPHERAL_EVENT_TYPE_DRIVER_HAT:
+            {
+              const HAT_STATE state =
+                  CPeripheralAddonTranslator::TranslateHatState(event.HatState());
+              joystickDevice->OnHatMotion(event.DriverIndex(), state);
+              break;
+            }
+            case PERIPHERAL_EVENT_TYPE_DRIVER_AXIS:
+            {
+              joystickDevice->OnAxisMotion(event.DriverIndex(), event.AxisState());
+              break;
+            }
+            default:
+              break;
           }
-          default:
-            break;
+          break;
         }
-        break;
-      }
-      default:
-        break;
+        default:
+          break;
       }
     }
 
@@ -443,7 +468,9 @@ bool CPeripheralAddon::ProcessEvents(void)
   return false;
 }
 
-bool CPeripheralAddon::SendRumbleEvent(unsigned int peripheralIndex, unsigned int driverIndex, float magnitude)
+bool CPeripheralAddon::SendRumbleEvent(unsigned int peripheralIndex,
+                                       unsigned int driverIndex,
+                                       float magnitude)
 {
   if (!m_bProvidesJoysticks)
     return false;
@@ -453,12 +480,12 @@ bool CPeripheralAddon::SendRumbleEvent(unsigned int peripheralIndex, unsigned in
   if (!m_struct.toAddon.send_event)
     return false;
 
-  PERIPHERAL_EVENT eventStruct = { };
+  PERIPHERAL_EVENT eventStruct = {};
 
   eventStruct.peripheral_index = peripheralIndex;
-  eventStruct.type             = PERIPHERAL_EVENT_TYPE_SET_MOTOR;
-  eventStruct.driver_index     = driverIndex;
-  eventStruct.motor_state      = magnitude;
+  eventStruct.type = PERIPHERAL_EVENT_TYPE_SET_MOTOR;
+  eventStruct.driver_index = driverIndex;
+  eventStruct.motor_state = magnitude;
 
   return m_struct.toAddon.send_event(&m_struct, &eventStruct);
 }
@@ -477,7 +504,8 @@ bool CPeripheralAddon::GetJoystickProperties(unsigned int index, CPeripheralJoys
 
   JOYSTICK_INFO joystickStruct;
 
-  LogError(retVal = m_struct.toAddon.get_joystick_info(&m_struct, index, &joystickStruct), "GetJoystickInfo()");
+  LogError(retVal = m_struct.toAddon.get_joystick_info(&m_struct, index, &joystickStruct),
+           "GetJoystickInfo()");
   if (retVal == PERIPHERAL_NO_ERROR)
   {
     kodi::addon::Joystick addonJoystick(joystickStruct);
@@ -511,11 +539,12 @@ bool CPeripheralAddon::GetFeatures(const CPeripheral* device,
   JOYSTICK_INFO joystickStruct;
   joystickInfo.ToStruct(joystickStruct);
 
-  unsigned int      featureCount = 0;
+  unsigned int featureCount = 0;
   JOYSTICK_FEATURE* pFeatures = nullptr;
 
-  LogError(retVal = m_struct.toAddon.get_features(&m_struct, &joystickStruct, strControllerId.c_str(),
-                                                  &featureCount, &pFeatures), "GetFeatures()");
+  LogError(retVal = m_struct.toAddon.get_features(
+               &m_struct, &joystickStruct, strControllerId.c_str(), &featureCount, &pFeatures),
+           "GetFeatures()");
 
   kodi::addon::Joystick::FreeStruct(joystickStruct);
 
@@ -559,8 +588,9 @@ bool CPeripheralAddon::MapFeature(const CPeripheral* device,
   JOYSTICK_FEATURE addonFeature;
   feature.ToStruct(addonFeature);
 
-  LogError(retVal = m_struct.toAddon.map_features(&m_struct, &joystickStruct, strControllerId.c_str(),
-                                                  1, &addonFeature), "MapFeatures()");
+  LogError(retVal = m_struct.toAddon.map_features(&m_struct, &joystickStruct,
+                                                  strControllerId.c_str(), 1, &addonFeature),
+           "MapFeatures()");
 
   kodi::addon::Joystick::FreeStruct(joystickStruct);
   kodi::addon::JoystickFeature::FreeStruct(addonFeature);
@@ -589,8 +619,9 @@ bool CPeripheralAddon::GetIgnoredPrimitives(const CPeripheral* device, Primitive
   unsigned int primitiveCount = 0;
   JOYSTICK_DRIVER_PRIMITIVE* pPrimitives = nullptr;
 
-  LogError(retVal = m_struct.toAddon.get_ignored_primitives(&m_struct, &joystickStruct, &primitiveCount,
-                                                            &pPrimitives), "GetIgnoredPrimitives()");
+  LogError(retVal = m_struct.toAddon.get_ignored_primitives(&m_struct, &joystickStruct,
+                                                            &primitiveCount, &pPrimitives),
+           "GetIgnoredPrimitives()");
 
   kodi::addon::Joystick::FreeStruct(joystickStruct);
 
@@ -605,10 +636,10 @@ bool CPeripheralAddon::GetIgnoredPrimitives(const CPeripheral* device, Primitive
   }
 
   return false;
-
 }
 
-bool CPeripheralAddon::SetIgnoredPrimitives(const CPeripheral* device, const PrimitiveVector& primitives)
+bool CPeripheralAddon::SetIgnoredPrimitives(const CPeripheral* device,
+                                            const PrimitiveVector& primitives)
 {
   if (!m_bProvidesButtonMaps)
     return false;
@@ -631,7 +662,8 @@ bool CPeripheralAddon::SetIgnoredPrimitives(const CPeripheral* device, const Pri
   const unsigned int primitiveCount = static_cast<unsigned int>(primitives.size());
 
   LogError(retVal = m_struct.toAddon.set_ignored_primitives(&m_struct, &joystickStruct,
-    primitiveCount, addonPrimitives), "SetIgnoredPrimitives()");
+                                                            primitiveCount, addonPrimitives),
+           "SetIgnoredPrimitives()");
 
   kodi::addon::Joystick::FreeStruct(joystickStruct);
   kodi::addon::DriverPrimitives::FreeStructs(primitiveCount, addonPrimitives);
@@ -745,11 +777,12 @@ void CPeripheralAddon::UnregisterButtonMap(CPeripheral* device)
 {
   CSingleLock lock(m_buttonMapMutex);
 
-  m_buttonMaps.erase(std::remove_if(m_buttonMaps.begin(), m_buttonMaps.end(),
-    [device](const std::pair<CPeripheral*, JOYSTICK::IButtonMap*>& buttonMap)
-    {
-      return buttonMap.first == device;
-    }), m_buttonMaps.end());
+  m_buttonMaps.erase(
+      std::remove_if(m_buttonMaps.begin(), m_buttonMaps.end(),
+                     [device](const std::pair<CPeripheral*, JOYSTICK::IButtonMap*>& buttonMap) {
+                       return buttonMap.first == device;
+                     }),
+      m_buttonMaps.end());
 }
 
 void CPeripheralAddon::RefreshButtonMaps(const std::string& strDeviceName /* = "" */)
@@ -768,7 +801,8 @@ void CPeripheralAddon::TriggerDeviceScan()
   m_manager.TriggerDeviceScan(PERIPHERAL_BUS_ADDON);
 }
 
-unsigned int CPeripheralAddon::FeatureCount(const std::string &controllerId, JOYSTICK_FEATURE_TYPE type) const
+unsigned int CPeripheralAddon::FeatureCount(const std::string& controllerId,
+                                            JOYSTICK_FEATURE_TYPE type) const
 {
   using namespace GAME;
 
@@ -782,7 +816,8 @@ unsigned int CPeripheralAddon::FeatureCount(const std::string &controllerId, JOY
   return count;
 }
 
-JOYSTICK_FEATURE_TYPE CPeripheralAddon::FeatureType(const std::string &controllerId, const std::string &featureName) const
+JOYSTICK_FEATURE_TYPE CPeripheralAddon::FeatureType(const std::string& controllerId,
+                                                    const std::string& featureName) const
 {
   using namespace GAME;
 
@@ -796,7 +831,8 @@ JOYSTICK_FEATURE_TYPE CPeripheralAddon::FeatureType(const std::string &controlle
   return type;
 }
 
-void CPeripheralAddon::GetPeripheralInfo(const CPeripheral* device, kodi::addon::Peripheral& peripheralInfo)
+void CPeripheralAddon::GetPeripheralInfo(const CPeripheral* device,
+                                         kodi::addon::Peripheral& peripheralInfo)
 {
   peripheralInfo.SetType(CPeripheralAddonTranslator::TranslateType(device->Type()));
   peripheralInfo.SetName(device->DeviceName());
@@ -804,7 +840,8 @@ void CPeripheralAddon::GetPeripheralInfo(const CPeripheral* device, kodi::addon:
   peripheralInfo.SetProductID(device->ProductId());
 }
 
-void CPeripheralAddon::GetJoystickInfo(const CPeripheral* device, kodi::addon::Joystick& joystickInfo)
+void CPeripheralAddon::GetJoystickInfo(const CPeripheral* device,
+                                       kodi::addon::Joystick& joystickInfo)
 {
   GetPeripheralInfo(device, joystickInfo);
 
@@ -818,15 +855,15 @@ void CPeripheralAddon::GetJoystickInfo(const CPeripheral* device, kodi::addon::J
     joystickInfo.SetMotorCount(joystick->MotorCount());
     joystickInfo.SetSupportsPowerOff(joystick->SupportsPowerOff());
   }
-  else if (device->Type() == PERIPHERAL_KEYBOARD ||
-           device->Type() == PERIPHERAL_MOUSE)
+  else if (device->Type() == PERIPHERAL_KEYBOARD || device->Type() == PERIPHERAL_MOUSE)
   {
     joystickInfo.SetName(GetDeviceName(device->Type())); // Override name with non-localized version
     joystickInfo.SetProvider(GetProvider(device->Type()));
   }
 }
 
-void CPeripheralAddon::SetJoystickInfo(CPeripheralJoystick& joystick, const kodi::addon::Joystick& joystickInfo)
+void CPeripheralAddon::SetJoystickInfo(CPeripheralJoystick& joystick,
+                                       const kodi::addon::Joystick& joystickInfo)
 {
   joystick.SetProvider(joystickInfo.Provider());
   joystick.SetRequestedPort(joystickInfo.RequestedPort());
@@ -837,12 +874,12 @@ void CPeripheralAddon::SetJoystickInfo(CPeripheralJoystick& joystick, const kodi
   joystick.SetSupportsPowerOff(joystickInfo.SupportsPowerOff());
 }
 
-bool CPeripheralAddon::LogError(const PERIPHERAL_ERROR error, const char *strMethod) const
+bool CPeripheralAddon::LogError(const PERIPHERAL_ERROR error, const char* strMethod) const
 {
   if (error != PERIPHERAL_NO_ERROR)
   {
-    CLog::Log(LOGERROR, "PERIPHERAL - %s - addon '%s' returned an error: %s",
-        strMethod, Name().c_str(), CPeripheralAddonTranslator::TranslateError(error));
+    CLog::Log(LOGERROR, "PERIPHERAL - %s - addon '%s' returned an error: %s", strMethod,
+              Name().c_str(), CPeripheralAddonTranslator::TranslateError(error));
     return false;
   }
   return true;
@@ -852,12 +889,12 @@ std::string CPeripheralAddon::GetDeviceName(PeripheralType type)
 {
   switch (type)
   {
-  case PERIPHERAL_KEYBOARD:
-    return KEYBOARD_BUTTON_MAP_NAME;
-  case PERIPHERAL_MOUSE:
-    return MOUSE_BUTTON_MAP_NAME;
-  default:
-    break;
+    case PERIPHERAL_KEYBOARD:
+      return KEYBOARD_BUTTON_MAP_NAME;
+    case PERIPHERAL_MOUSE:
+      return MOUSE_BUTTON_MAP_NAME;
+    default:
+      break;
   }
 
   return "";
@@ -867,12 +904,12 @@ std::string CPeripheralAddon::GetProvider(PeripheralType type)
 {
   switch (type)
   {
-  case PERIPHERAL_KEYBOARD:
-    return KEYBOARD_PROVIDER;
-  case PERIPHERAL_MOUSE:
-    return MOUSE_PROVIDER;
-  default:
-    break;
+    case PERIPHERAL_KEYBOARD:
+      return KEYBOARD_PROVIDER;
+    case PERIPHERAL_MOUSE:
+      return MOUSE_PROVIDER;
+    default:
+      break;
   }
 
   return "";
@@ -886,7 +923,9 @@ void CPeripheralAddon::cb_trigger_scan(void* kodiInstance)
   static_cast<CPeripheralAddon*>(kodiInstance)->TriggerDeviceScan();
 }
 
-void CPeripheralAddon::cb_refresh_button_maps(void* kodiInstance, const char* deviceName, const char* controllerId)
+void CPeripheralAddon::cb_refresh_button_maps(void* kodiInstance,
+                                              const char* deviceName,
+                                              const char* controllerId)
 {
   if (!kodiInstance)
     return;
@@ -894,7 +933,9 @@ void CPeripheralAddon::cb_refresh_button_maps(void* kodiInstance, const char* de
   static_cast<CPeripheralAddon*>(kodiInstance)->RefreshButtonMaps(deviceName ? deviceName : "");
 }
 
-unsigned int CPeripheralAddon::cb_feature_count(void* kodiInstance, const char* controllerId, JOYSTICK_FEATURE_TYPE type)
+unsigned int CPeripheralAddon::cb_feature_count(void* kodiInstance,
+                                                const char* controllerId,
+                                                JOYSTICK_FEATURE_TYPE type)
 {
   if (kodiInstance == nullptr || controllerId == nullptr)
     return 0;
@@ -902,7 +943,9 @@ unsigned int CPeripheralAddon::cb_feature_count(void* kodiInstance, const char*
   return static_cast<CPeripheralAddon*>(kodiInstance)->FeatureCount(controllerId, type);
 }
 
-JOYSTICK_FEATURE_TYPE CPeripheralAddon::cb_feature_type(void* kodiInstance, const char* controllerId, const char* featureName)
+JOYSTICK_FEATURE_TYPE CPeripheralAddon::cb_feature_type(void* kodiInstance,
+                                                        const char* controllerId,
+                                                        const char* featureName)
 {
   if (kodiInstance == nullptr || controllerId == nullptr || featureName == nullptr)
     return JOYSTICK_FEATURE_TYPE_UNKNOWN;
diff --git a/xbmc/peripherals/addons/PeripheralAddon.h b/xbmc/peripherals/addons/PeripheralAddon.h
index 8ca0af83f5dd..4eaafcfb9be2 100644
--- a/xbmc/peripherals/addons/PeripheralAddon.h
+++ b/xbmc/peripherals/addons/PeripheralAddon.h
@@ -25,149 +25,165 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IButtonMap;
-  class IDriverHandler;
-}
-}
+class IButtonMap;
+class IDriverHandler;
+} // namespace JOYSTICK
+} // namespace KODI
 
 namespace PERIPHERALS
 {
-  class CPeripheral;
-  class CPeripheralJoystick;
-  class CPeripherals;
+class CPeripheral;
+class CPeripheralJoystick;
+class CPeripherals;
 
-  typedef std::vector<kodi::addon::DriverPrimitive> PrimitiveVector;
-  typedef std::map<KODI::JOYSTICK::FeatureName, kodi::addon::JoystickFeature> FeatureMap;
+typedef std::vector<kodi::addon::DriverPrimitive> PrimitiveVector;
+typedef std::map<KODI::JOYSTICK::FeatureName, kodi::addon::JoystickFeature> FeatureMap;
 
-  class CPeripheralAddon : public ADDON::IAddonInstanceHandler
+class CPeripheralAddon : public ADDON::IAddonInstanceHandler
+{
+public:
+  explicit CPeripheralAddon(const ADDON::BinaryAddonBasePtr& addonInfo, CPeripherals& manager);
+  ~CPeripheralAddon(void) override;
+
+  /*!
+   * @brief Initialise the instance of this add-on
+   */
+  bool CreateAddon(void);
+
+  /*!
+   * \brief Deinitialize the instance of this add-on
+   */
+  void DestroyAddon();
+
+  bool Register(unsigned int peripheralIndex, const PeripheralPtr& peripheral);
+  void UnregisterRemovedDevices(const PeripheralScanResults& results,
+                                PeripheralVector& removedPeripherals);
+  void GetFeatures(std::vector<PeripheralFeature>& features) const;
+  bool HasFeature(const PeripheralFeature feature) const;
+  PeripheralPtr GetPeripheral(unsigned int index) const;
+  PeripheralPtr GetByPath(const std::string& strPath) const;
+  bool SupportsFeature(PeripheralFeature feature) const;
+  unsigned int GetPeripheralsWithFeature(PeripheralVector& results,
+                                         const PeripheralFeature feature) const;
+  unsigned int GetNumberOfPeripherals(void) const;
+  unsigned int GetNumberOfPeripheralsWithId(const int iVendorId, const int iProductId) const;
+  void GetDirectory(const std::string& strPath, CFileItemList& items) const;
+
+  /** @name Peripheral add-on methods */
+  //@{
+  bool PerformDeviceScan(PeripheralScanResults& results);
+  bool ProcessEvents(void);
+  bool SendRumbleEvent(unsigned int index, unsigned int driverIndex, float magnitude);
+  //@}
+
+  /** @name Joystick methods */
+  //@{
+  bool GetJoystickProperties(unsigned int index, CPeripheralJoystick& joystick);
+  bool HasButtonMaps(void) const { return m_bProvidesButtonMaps; }
+  bool GetFeatures(const CPeripheral* device,
+                   const std::string& strControllerId,
+                   FeatureMap& features);
+  bool MapFeature(const CPeripheral* device,
+                  const std::string& strControllerId,
+                  const kodi::addon::JoystickFeature& feature);
+  bool GetIgnoredPrimitives(const CPeripheral* device, PrimitiveVector& primitives);
+  bool SetIgnoredPrimitives(const CPeripheral* device, const PrimitiveVector& primitives);
+  void SaveButtonMap(const CPeripheral* device);
+  void RevertButtonMap(const CPeripheral* device);
+  void ResetButtonMap(const CPeripheral* device, const std::string& strControllerId);
+  void PowerOffJoystick(unsigned int index);
+  //@}
+
+  void RegisterButtonMap(CPeripheral* device, KODI::JOYSTICK::IButtonMap* buttonMap);
+  void UnregisterButtonMap(KODI::JOYSTICK::IButtonMap* buttonMap);
+
+  static inline bool ProvidesJoysticks(const ADDON::BinaryAddonBasePtr& addonInfo)
+  {
+    return addonInfo->Type(ADDON::ADDON_PERIPHERALDLL)->GetValue("@provides_joysticks").asBoolean();
+  }
+
+  static inline bool ProvidesButtonMaps(const ADDON::BinaryAddonBasePtr& addonInfo)
   {
-  public:
-    explicit CPeripheralAddon(const ADDON::BinaryAddonBasePtr& addonInfo, CPeripherals &manager);
-    ~CPeripheralAddon(void) override;
-
-    /*!
-     * @brief Initialise the instance of this add-on
-     */
-    bool CreateAddon(void);
-
-    /*!
-     * \brief Deinitialize the instance of this add-on
-     */
-    void DestroyAddon();
-
-    bool         Register(unsigned int peripheralIndex, const PeripheralPtr& peripheral);
-    void         UnregisterRemovedDevices(const PeripheralScanResults &results, PeripheralVector& removedPeripherals);
-    void         GetFeatures(std::vector<PeripheralFeature> &features) const;
-    bool         HasFeature(const PeripheralFeature feature) const;
-    PeripheralPtr GetPeripheral(unsigned int index) const;
-    PeripheralPtr GetByPath(const std::string &strPath) const;
-    bool         SupportsFeature(PeripheralFeature feature) const;
-    unsigned int GetPeripheralsWithFeature(PeripheralVector &results, const PeripheralFeature feature) const;
-    unsigned int GetNumberOfPeripherals(void) const;
-    unsigned int GetNumberOfPeripheralsWithId(const int iVendorId, const int iProductId) const;
-    void         GetDirectory(const std::string &strPath, CFileItemList &items) const;
-
-    /** @name Peripheral add-on methods */
-    //@{
-    bool PerformDeviceScan(PeripheralScanResults &results);
-    bool ProcessEvents(void);
-    bool SendRumbleEvent(unsigned int index, unsigned int driverIndex, float magnitude);
-    //@}
-
-    /** @name Joystick methods */
-    //@{
-    bool GetJoystickProperties(unsigned int index, CPeripheralJoystick& joystick);
-    bool HasButtonMaps(void) const { return m_bProvidesButtonMaps; }
-    bool GetFeatures(const CPeripheral* device, const std::string& strControllerId, FeatureMap& features);
-    bool MapFeature(const CPeripheral* device, const std::string& strControllerId, const kodi::addon::JoystickFeature& feature);
-    bool GetIgnoredPrimitives(const CPeripheral* device, PrimitiveVector& primitives);
-    bool SetIgnoredPrimitives(const CPeripheral* device, const PrimitiveVector& primitives);
-    void SaveButtonMap(const CPeripheral* device);
-    void RevertButtonMap(const CPeripheral* device);
-    void ResetButtonMap(const CPeripheral* device, const std::string& strControllerId);
-    void PowerOffJoystick(unsigned int index);
-    //@}
-
-    void RegisterButtonMap(CPeripheral* device, KODI::JOYSTICK::IButtonMap* buttonMap);
-    void UnregisterButtonMap(KODI::JOYSTICK::IButtonMap* buttonMap);
-
-    static inline bool ProvidesJoysticks(const ADDON::BinaryAddonBasePtr& addonInfo)
-    {
-      return addonInfo->Type(ADDON::ADDON_PERIPHERALDLL)->GetValue("@provides_joysticks").asBoolean();
-    }
-
-    static inline bool ProvidesButtonMaps(const ADDON::BinaryAddonBasePtr& addonInfo)
-    {
-      return addonInfo->Type(ADDON::ADDON_PERIPHERALDLL)->GetValue("@provides_buttonmaps").asBoolean();
-    }
-
-  private:
-    void UnregisterButtonMap(CPeripheral* device);
-
-    // Binary add-on callbacks
-    void TriggerDeviceScan();
-    void RefreshButtonMaps(const std::string& strDeviceName = "");
-    unsigned int FeatureCount(const std::string &controllerId, JOYSTICK_FEATURE_TYPE type) const;
-    JOYSTICK_FEATURE_TYPE FeatureType(const std::string &controllerId, const std::string &featureName) const;
-
-    /*!
-     * @brief Helper functions
-     */
-    static void GetPeripheralInfo(const CPeripheral* device, kodi::addon::Peripheral& peripheralInfo);
-
-    static void GetJoystickInfo(const CPeripheral* device, kodi::addon::Joystick& joystickInfo);
-    static void SetJoystickInfo(CPeripheralJoystick& joystick, const kodi::addon::Joystick& joystickInfo);
-
-    /*!
-     * @brief Reset all class members to their defaults. Called by the constructors
-     */
-    void ResetProperties(void);
-
-    /*!
-     * @brief Retrieve add-on properties from the add-on
-     */
-    bool GetAddonProperties(void);
-
-    bool LogError(const PERIPHERAL_ERROR error, const char *strMethod) const;
-
-    static std::string GetDeviceName(PeripheralType type);
-    static std::string GetProvider(PeripheralType type);
-
-    // Construction parameters
-    CPeripherals &m_manager;
-
-    /* @brief Cache for const char* members in PERIPHERAL_PROPERTIES */
-    std::string         m_strUserPath;    /*!< @brief translated path to the user profile */
-    std::string         m_strClientPath;  /*!< @brief translated path to this add-on */
-
-    /*!
-     * @brief Callback functions from addon to kodi
-     */
-    //@{
-    static void cb_trigger_scan(void* kodiInstance);
-    static void cb_refresh_button_maps(void* kodiInstance, const char* deviceName, const char* controllerId);
-    static unsigned int cb_feature_count(void* kodiInstance, const char* controllerId, JOYSTICK_FEATURE_TYPE type);
-    static JOYSTICK_FEATURE_TYPE cb_feature_type(void* kodiInstance, const char* controllerId, const char* featureName);
-    //@}
-
-    /* @brief Add-on properties */
-    bool                m_bProvidesJoysticks;
-    bool                m_bSupportsJoystickRumble;
-    bool                m_bSupportsJoystickPowerOff;
-    bool                m_bProvidesButtonMaps;
-
-    /* @brief Map of peripherals belonging to the add-on */
-    std::map<unsigned int, PeripheralPtr>  m_peripherals;
-
-    /* @brief Button map observers */
-    std::vector<std::pair<CPeripheral*, KODI::JOYSTICK::IButtonMap*> > m_buttonMaps;
-    CCriticalSection m_buttonMapMutex;
-
-    /* @brief Thread synchronization */
-    mutable CCriticalSection m_critSection;
-
-    AddonInstance_Peripheral m_struct;
-
-    CSharedSection      m_dllSection;
-  };
-}
+    return addonInfo->Type(ADDON::ADDON_PERIPHERALDLL)
+        ->GetValue("@provides_buttonmaps")
+        .asBoolean();
+  }
+
+private:
+  void UnregisterButtonMap(CPeripheral* device);
+
+  // Binary add-on callbacks
+  void TriggerDeviceScan();
+  void RefreshButtonMaps(const std::string& strDeviceName = "");
+  unsigned int FeatureCount(const std::string& controllerId, JOYSTICK_FEATURE_TYPE type) const;
+  JOYSTICK_FEATURE_TYPE FeatureType(const std::string& controllerId,
+                                    const std::string& featureName) const;
+
+  /*!
+   * @brief Helper functions
+   */
+  static void GetPeripheralInfo(const CPeripheral* device, kodi::addon::Peripheral& peripheralInfo);
+
+  static void GetJoystickInfo(const CPeripheral* device, kodi::addon::Joystick& joystickInfo);
+  static void SetJoystickInfo(CPeripheralJoystick& joystick,
+                              const kodi::addon::Joystick& joystickInfo);
+
+  /*!
+   * @brief Reset all class members to their defaults. Called by the constructors
+   */
+  void ResetProperties(void);
+
+  /*!
+   * @brief Retrieve add-on properties from the add-on
+   */
+  bool GetAddonProperties(void);
+
+  bool LogError(const PERIPHERAL_ERROR error, const char* strMethod) const;
+
+  static std::string GetDeviceName(PeripheralType type);
+  static std::string GetProvider(PeripheralType type);
+
+  // Construction parameters
+  CPeripherals& m_manager;
+
+  /* @brief Cache for const char* members in PERIPHERAL_PROPERTIES */
+  std::string m_strUserPath; /*!< @brief translated path to the user profile */
+  std::string m_strClientPath; /*!< @brief translated path to this add-on */
+
+  /*!
+   * @brief Callback functions from addon to kodi
+   */
+  //@{
+  static void cb_trigger_scan(void* kodiInstance);
+  static void cb_refresh_button_maps(void* kodiInstance,
+                                     const char* deviceName,
+                                     const char* controllerId);
+  static unsigned int cb_feature_count(void* kodiInstance,
+                                       const char* controllerId,
+                                       JOYSTICK_FEATURE_TYPE type);
+  static JOYSTICK_FEATURE_TYPE cb_feature_type(void* kodiInstance,
+                                               const char* controllerId,
+                                               const char* featureName);
+  //@}
+
+  /* @brief Add-on properties */
+  bool m_bProvidesJoysticks;
+  bool m_bSupportsJoystickRumble;
+  bool m_bSupportsJoystickPowerOff;
+  bool m_bProvidesButtonMaps;
+
+  /* @brief Map of peripherals belonging to the add-on */
+  std::map<unsigned int, PeripheralPtr> m_peripherals;
+
+  /* @brief Button map observers */
+  std::vector<std::pair<CPeripheral*, KODI::JOYSTICK::IButtonMap*>> m_buttonMaps;
+  CCriticalSection m_buttonMapMutex;
+
+  /* @brief Thread synchronization */
+  mutable CCriticalSection m_critSection;
+
+  AddonInstance_Peripheral m_struct;
+
+  CSharedSection m_dllSection;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/addons/PeripheralAddonTranslator.cpp b/xbmc/peripherals/addons/PeripheralAddonTranslator.cpp
index 0c55c421e9b6..16dd529c0ab2 100644
--- a/xbmc/peripherals/addons/PeripheralAddonTranslator.cpp
+++ b/xbmc/peripherals/addons/PeripheralAddonTranslator.cpp
@@ -73,7 +73,8 @@ PERIPHERAL_TYPE CPeripheralAddonTranslator::TranslateType(PeripheralType type)
   return PERIPHERAL_TYPE_UNKNOWN;
 }
 
-CDriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(const kodi::addon::DriverPrimitive& primitive)
+CDriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(
+    const kodi::addon::DriverPrimitive& primitive)
 {
   CDriverPrimitive retVal;
 
@@ -86,12 +87,15 @@ CDriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(const kodi::addo
     }
     case JOYSTICK_DRIVER_PRIMITIVE_TYPE_HAT_DIRECTION:
     {
-      retVal = CDriverPrimitive(primitive.DriverIndex(), TranslateHatDirection(primitive.HatDirection()));
+      retVal = CDriverPrimitive(primitive.DriverIndex(),
+                                TranslateHatDirection(primitive.HatDirection()));
       break;
     }
     case JOYSTICK_DRIVER_PRIMITIVE_TYPE_SEMIAXIS:
     {
-      retVal = CDriverPrimitive(primitive.DriverIndex(), primitive.Center(), TranslateSemiAxisDirection(primitive.SemiAxisDirection()), primitive.Range());
+      retVal = CDriverPrimitive(primitive.DriverIndex(), primitive.Center(),
+                                TranslateSemiAxisDirection(primitive.SemiAxisDirection()),
+                                primitive.Range());
       break;
     }
     case JOYSTICK_DRIVER_PRIMITIVE_TYPE_MOTOR:
@@ -101,7 +105,8 @@ CDriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(const kodi::addo
     }
     case JOYSTICK_DRIVER_PRIMITIVE_TYPE_KEY:
     {
-      KEYBOARD::KeySymbol keycode = GAME::CControllerTranslator::TranslateKeysym(primitive.Keycode());
+      KEYBOARD::KeySymbol keycode =
+          GAME::CControllerTranslator::TranslateKeysym(primitive.Keycode());
       retVal = CDriverPrimitive(keycode);
       break;
     }
@@ -122,7 +127,8 @@ CDriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(const kodi::addo
   return retVal;
 }
 
-kodi::addon::DriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(const CDriverPrimitive& primitive)
+kodi::addon::DriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(
+    const CDriverPrimitive& primitive)
 {
   kodi::addon::DriverPrimitive retVal;
 
@@ -135,12 +141,15 @@ kodi::addon::DriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(cons
     }
     case PRIMITIVE_TYPE::HAT:
     {
-      retVal = kodi::addon::DriverPrimitive(primitive.Index(), TranslateHatDirection(primitive.HatDirection()));
+      retVal = kodi::addon::DriverPrimitive(primitive.Index(),
+                                            TranslateHatDirection(primitive.HatDirection()));
       break;
     }
     case PRIMITIVE_TYPE::SEMIAXIS:
     {
-      retVal = kodi::addon::DriverPrimitive(primitive.Index(), primitive.Center(), TranslateSemiAxisDirection(primitive.SemiAxisDirection()), primitive.Range());
+      retVal = kodi::addon::DriverPrimitive(
+          primitive.Index(), primitive.Center(),
+          TranslateSemiAxisDirection(primitive.SemiAxisDirection()), primitive.Range());
       break;
     }
     case PRIMITIVE_TYPE::MOTOR:
@@ -156,12 +165,14 @@ kodi::addon::DriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(cons
     }
     case PRIMITIVE_TYPE::MOUSE_BUTTON:
     {
-      retVal = kodi::addon::DriverPrimitive::CreateMouseButton(TranslateMouseButton(primitive.MouseButton()));
+      retVal = kodi::addon::DriverPrimitive::CreateMouseButton(
+          TranslateMouseButton(primitive.MouseButton()));
       break;
     }
     case PRIMITIVE_TYPE::RELATIVE_POINTER:
     {
-      retVal = kodi::addon::DriverPrimitive(TranslateRelPointerDirection(primitive.PointerDirection()));
+      retVal =
+          kodi::addon::DriverPrimitive(TranslateRelPointerDirection(primitive.PointerDirection()));
       break;
     }
     default:
@@ -171,25 +182,25 @@ kodi::addon::DriverPrimitive CPeripheralAddonTranslator::TranslatePrimitive(cons
   return retVal;
 }
 
-std::vector<JOYSTICK::CDriverPrimitive> CPeripheralAddonTranslator::TranslatePrimitives(const std::vector<kodi::addon::DriverPrimitive>& primitives)
+std::vector<JOYSTICK::CDriverPrimitive> CPeripheralAddonTranslator::TranslatePrimitives(
+    const std::vector<kodi::addon::DriverPrimitive>& primitives)
 {
   std::vector<JOYSTICK::CDriverPrimitive> ret;
   std::transform(primitives.begin(), primitives.end(), std::back_inserter(ret),
-    [](const kodi::addon::DriverPrimitive& primitive)
-    {
-      return CPeripheralAddonTranslator::TranslatePrimitive(primitive);
-    });
+                 [](const kodi::addon::DriverPrimitive& primitive) {
+                   return CPeripheralAddonTranslator::TranslatePrimitive(primitive);
+                 });
   return ret;
 }
 
-std::vector<kodi::addon::DriverPrimitive> CPeripheralAddonTranslator::TranslatePrimitives(const std::vector<JOYSTICK::CDriverPrimitive>& primitives)
+std::vector<kodi::addon::DriverPrimitive> CPeripheralAddonTranslator::TranslatePrimitives(
+    const std::vector<JOYSTICK::CDriverPrimitive>& primitives)
 {
   std::vector<kodi::addon::DriverPrimitive> ret;
   std::transform(primitives.begin(), primitives.end(), std::back_inserter(ret),
-    [](const JOYSTICK::CDriverPrimitive& primitive)
-    {
-      return CPeripheralAddonTranslator::TranslatePrimitive(primitive);
-    });
+                 [](const JOYSTICK::CDriverPrimitive& primitive) {
+                   return CPeripheralAddonTranslator::TranslatePrimitive(primitive);
+                 });
   return ret;
 }
 
@@ -197,10 +208,14 @@ HAT_DIRECTION CPeripheralAddonTranslator::TranslateHatDirection(JOYSTICK_DRIVER_
 {
   switch (dir)
   {
-    case JOYSTICK_DRIVER_HAT_LEFT:   return HAT_DIRECTION::LEFT;
-    case JOYSTICK_DRIVER_HAT_RIGHT:  return HAT_DIRECTION::RIGHT;
-    case JOYSTICK_DRIVER_HAT_UP:     return HAT_DIRECTION::UP;
-    case JOYSTICK_DRIVER_HAT_DOWN:   return HAT_DIRECTION::DOWN;
+    case JOYSTICK_DRIVER_HAT_LEFT:
+      return HAT_DIRECTION::LEFT;
+    case JOYSTICK_DRIVER_HAT_RIGHT:
+      return HAT_DIRECTION::RIGHT;
+    case JOYSTICK_DRIVER_HAT_UP:
+      return HAT_DIRECTION::UP;
+    case JOYSTICK_DRIVER_HAT_DOWN:
+      return HAT_DIRECTION::DOWN;
     default:
       break;
   }
@@ -211,10 +226,14 @@ JOYSTICK_DRIVER_HAT_DIRECTION CPeripheralAddonTranslator::TranslateHatDirection(
 {
   switch (dir)
   {
-    case HAT_DIRECTION::UP:     return JOYSTICK_DRIVER_HAT_UP;
-    case HAT_DIRECTION::DOWN:   return JOYSTICK_DRIVER_HAT_DOWN;
-    case HAT_DIRECTION::RIGHT:  return JOYSTICK_DRIVER_HAT_RIGHT;
-    case HAT_DIRECTION::LEFT:   return JOYSTICK_DRIVER_HAT_LEFT;
+    case HAT_DIRECTION::UP:
+      return JOYSTICK_DRIVER_HAT_UP;
+    case HAT_DIRECTION::DOWN:
+      return JOYSTICK_DRIVER_HAT_DOWN;
+    case HAT_DIRECTION::RIGHT:
+      return JOYSTICK_DRIVER_HAT_RIGHT;
+    case HAT_DIRECTION::LEFT:
+      return JOYSTICK_DRIVER_HAT_LEFT;
     default:
       break;
   }
@@ -225,51 +244,71 @@ HAT_STATE CPeripheralAddonTranslator::TranslateHatState(JOYSTICK_STATE_HAT state
 {
   HAT_STATE translatedState = HAT_STATE::NONE;
 
-  if (state & JOYSTICK_STATE_HAT_UP)    translatedState |= HAT_STATE::UP;
-  if (state & JOYSTICK_STATE_HAT_DOWN)  translatedState |= HAT_STATE::DOWN;
-  if (state & JOYSTICK_STATE_HAT_RIGHT) translatedState |= HAT_STATE::RIGHT;
-  if (state & JOYSTICK_STATE_HAT_LEFT)  translatedState |= HAT_STATE::LEFT;
+  if (state & JOYSTICK_STATE_HAT_UP)
+    translatedState |= HAT_STATE::UP;
+  if (state & JOYSTICK_STATE_HAT_DOWN)
+    translatedState |= HAT_STATE::DOWN;
+  if (state & JOYSTICK_STATE_HAT_RIGHT)
+    translatedState |= HAT_STATE::RIGHT;
+  if (state & JOYSTICK_STATE_HAT_LEFT)
+    translatedState |= HAT_STATE::LEFT;
 
   return translatedState;
 }
 
-SEMIAXIS_DIRECTION CPeripheralAddonTranslator::TranslateSemiAxisDirection(JOYSTICK_DRIVER_SEMIAXIS_DIRECTION dir)
+SEMIAXIS_DIRECTION CPeripheralAddonTranslator::TranslateSemiAxisDirection(
+    JOYSTICK_DRIVER_SEMIAXIS_DIRECTION dir)
 {
   switch (dir)
   {
-    case JOYSTICK_DRIVER_SEMIAXIS_POSITIVE: return SEMIAXIS_DIRECTION::POSITIVE;
-    case JOYSTICK_DRIVER_SEMIAXIS_NEGATIVE: return SEMIAXIS_DIRECTION::NEGATIVE;
+    case JOYSTICK_DRIVER_SEMIAXIS_POSITIVE:
+      return SEMIAXIS_DIRECTION::POSITIVE;
+    case JOYSTICK_DRIVER_SEMIAXIS_NEGATIVE:
+      return SEMIAXIS_DIRECTION::NEGATIVE;
     default:
       break;
   }
   return SEMIAXIS_DIRECTION::ZERO;
 }
 
-JOYSTICK_DRIVER_SEMIAXIS_DIRECTION CPeripheralAddonTranslator::TranslateSemiAxisDirection(SEMIAXIS_DIRECTION dir)
+JOYSTICK_DRIVER_SEMIAXIS_DIRECTION CPeripheralAddonTranslator::TranslateSemiAxisDirection(
+    SEMIAXIS_DIRECTION dir)
 {
   switch (dir)
   {
-    case SEMIAXIS_DIRECTION::POSITIVE: return JOYSTICK_DRIVER_SEMIAXIS_POSITIVE;
-    case SEMIAXIS_DIRECTION::NEGATIVE: return JOYSTICK_DRIVER_SEMIAXIS_NEGATIVE;
+    case SEMIAXIS_DIRECTION::POSITIVE:
+      return JOYSTICK_DRIVER_SEMIAXIS_POSITIVE;
+    case SEMIAXIS_DIRECTION::NEGATIVE:
+      return JOYSTICK_DRIVER_SEMIAXIS_NEGATIVE;
     default:
       break;
   }
   return JOYSTICK_DRIVER_SEMIAXIS_UNKNOWN;
 }
 
-MOUSE::BUTTON_ID CPeripheralAddonTranslator::TranslateMouseButton(JOYSTICK_DRIVER_MOUSE_INDEX button)
+MOUSE::BUTTON_ID CPeripheralAddonTranslator::TranslateMouseButton(
+    JOYSTICK_DRIVER_MOUSE_INDEX button)
 {
   switch (button)
   {
-    case JOYSTICK_DRIVER_MOUSE_INDEX_LEFT: return MOUSE::BUTTON_ID::LEFT;
-    case JOYSTICK_DRIVER_MOUSE_INDEX_RIGHT: return MOUSE::BUTTON_ID::RIGHT;
-    case JOYSTICK_DRIVER_MOUSE_INDEX_MIDDLE: return MOUSE::BUTTON_ID::MIDDLE;
-    case JOYSTICK_DRIVER_MOUSE_INDEX_BUTTON4: return MOUSE::BUTTON_ID::BUTTON4;
-    case JOYSTICK_DRIVER_MOUSE_INDEX_BUTTON5: return MOUSE::BUTTON_ID::BUTTON5;
-    case JOYSTICK_DRIVER_MOUSE_INDEX_WHEEL_UP: return MOUSE::BUTTON_ID::WHEEL_UP;
-    case JOYSTICK_DRIVER_MOUSE_INDEX_WHEEL_DOWN: return MOUSE::BUTTON_ID::WHEEL_DOWN;
-    case JOYSTICK_DRIVER_MOUSE_INDEX_HORIZ_WHEEL_LEFT: return MOUSE::BUTTON_ID::HORIZ_WHEEL_LEFT;
-    case JOYSTICK_DRIVER_MOUSE_INDEX_HORIZ_WHEEL_RIGHT: return MOUSE::BUTTON_ID::HORIZ_WHEEL_RIGHT;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_LEFT:
+      return MOUSE::BUTTON_ID::LEFT;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_RIGHT:
+      return MOUSE::BUTTON_ID::RIGHT;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_MIDDLE:
+      return MOUSE::BUTTON_ID::MIDDLE;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_BUTTON4:
+      return MOUSE::BUTTON_ID::BUTTON4;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_BUTTON5:
+      return MOUSE::BUTTON_ID::BUTTON5;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_WHEEL_UP:
+      return MOUSE::BUTTON_ID::WHEEL_UP;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_WHEEL_DOWN:
+      return MOUSE::BUTTON_ID::WHEEL_DOWN;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_HORIZ_WHEEL_LEFT:
+      return MOUSE::BUTTON_ID::HORIZ_WHEEL_LEFT;
+    case JOYSTICK_DRIVER_MOUSE_INDEX_HORIZ_WHEEL_RIGHT:
+      return MOUSE::BUTTON_ID::HORIZ_WHEEL_RIGHT;
     default:
       break;
   }
@@ -277,19 +316,29 @@ MOUSE::BUTTON_ID CPeripheralAddonTranslator::TranslateMouseButton(JOYSTICK_DRIVE
   return MOUSE::BUTTON_ID::UNKNOWN;
 }
 
-JOYSTICK_DRIVER_MOUSE_INDEX CPeripheralAddonTranslator::TranslateMouseButton(MOUSE::BUTTON_ID button)
+JOYSTICK_DRIVER_MOUSE_INDEX CPeripheralAddonTranslator::TranslateMouseButton(
+    MOUSE::BUTTON_ID button)
 {
   switch (button)
   {
-    case MOUSE::BUTTON_ID::LEFT: return JOYSTICK_DRIVER_MOUSE_INDEX_LEFT;
-    case MOUSE::BUTTON_ID::RIGHT: return JOYSTICK_DRIVER_MOUSE_INDEX_RIGHT;
-    case MOUSE::BUTTON_ID::MIDDLE: return JOYSTICK_DRIVER_MOUSE_INDEX_MIDDLE;
-    case MOUSE::BUTTON_ID::BUTTON4: return JOYSTICK_DRIVER_MOUSE_INDEX_BUTTON4;
-    case MOUSE::BUTTON_ID::BUTTON5: return JOYSTICK_DRIVER_MOUSE_INDEX_BUTTON5;
-    case MOUSE::BUTTON_ID::WHEEL_UP: return JOYSTICK_DRIVER_MOUSE_INDEX_WHEEL_UP;
-    case MOUSE::BUTTON_ID::WHEEL_DOWN: return JOYSTICK_DRIVER_MOUSE_INDEX_WHEEL_DOWN;
-    case MOUSE::BUTTON_ID::HORIZ_WHEEL_LEFT: return JOYSTICK_DRIVER_MOUSE_INDEX_HORIZ_WHEEL_LEFT;
-    case MOUSE::BUTTON_ID::HORIZ_WHEEL_RIGHT: return JOYSTICK_DRIVER_MOUSE_INDEX_HORIZ_WHEEL_RIGHT;
+    case MOUSE::BUTTON_ID::LEFT:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_LEFT;
+    case MOUSE::BUTTON_ID::RIGHT:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_RIGHT;
+    case MOUSE::BUTTON_ID::MIDDLE:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_MIDDLE;
+    case MOUSE::BUTTON_ID::BUTTON4:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_BUTTON4;
+    case MOUSE::BUTTON_ID::BUTTON5:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_BUTTON5;
+    case MOUSE::BUTTON_ID::WHEEL_UP:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_WHEEL_UP;
+    case MOUSE::BUTTON_ID::WHEEL_DOWN:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_WHEEL_DOWN;
+    case MOUSE::BUTTON_ID::HORIZ_WHEEL_LEFT:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_HORIZ_WHEEL_LEFT;
+    case MOUSE::BUTTON_ID::HORIZ_WHEEL_RIGHT:
+      return JOYSTICK_DRIVER_MOUSE_INDEX_HORIZ_WHEEL_RIGHT;
     default:
       break;
   }
@@ -297,14 +346,19 @@ JOYSTICK_DRIVER_MOUSE_INDEX CPeripheralAddonTranslator::TranslateMouseButton(MOU
   return JOYSTICK_DRIVER_MOUSE_INDEX_UNKNOWN;
 }
 
-RELATIVE_POINTER_DIRECTION CPeripheralAddonTranslator::TranslateRelPointerDirection(JOYSTICK_DRIVER_RELPOINTER_DIRECTION dir)
+RELATIVE_POINTER_DIRECTION CPeripheralAddonTranslator::TranslateRelPointerDirection(
+    JOYSTICK_DRIVER_RELPOINTER_DIRECTION dir)
 {
   switch (dir)
   {
-    case JOYSTICK_DRIVER_RELPOINTER_LEFT:   return RELATIVE_POINTER_DIRECTION::LEFT;
-    case JOYSTICK_DRIVER_RELPOINTER_RIGHT:  return RELATIVE_POINTER_DIRECTION::RIGHT;
-    case JOYSTICK_DRIVER_RELPOINTER_UP:     return RELATIVE_POINTER_DIRECTION::UP;
-    case JOYSTICK_DRIVER_RELPOINTER_DOWN:   return RELATIVE_POINTER_DIRECTION::DOWN;
+    case JOYSTICK_DRIVER_RELPOINTER_LEFT:
+      return RELATIVE_POINTER_DIRECTION::LEFT;
+    case JOYSTICK_DRIVER_RELPOINTER_RIGHT:
+      return RELATIVE_POINTER_DIRECTION::RIGHT;
+    case JOYSTICK_DRIVER_RELPOINTER_UP:
+      return RELATIVE_POINTER_DIRECTION::UP;
+    case JOYSTICK_DRIVER_RELPOINTER_DOWN:
+      return RELATIVE_POINTER_DIRECTION::DOWN;
     default:
       break;
   }
@@ -312,14 +366,19 @@ RELATIVE_POINTER_DIRECTION CPeripheralAddonTranslator::TranslateRelPointerDirect
   return RELATIVE_POINTER_DIRECTION::NONE;
 }
 
-JOYSTICK_DRIVER_RELPOINTER_DIRECTION CPeripheralAddonTranslator::TranslateRelPointerDirection(RELATIVE_POINTER_DIRECTION dir)
+JOYSTICK_DRIVER_RELPOINTER_DIRECTION CPeripheralAddonTranslator::TranslateRelPointerDirection(
+    RELATIVE_POINTER_DIRECTION dir)
 {
   switch (dir)
   {
-    case RELATIVE_POINTER_DIRECTION::UP:     return JOYSTICK_DRIVER_RELPOINTER_UP;
-    case RELATIVE_POINTER_DIRECTION::DOWN:   return JOYSTICK_DRIVER_RELPOINTER_DOWN;
-    case RELATIVE_POINTER_DIRECTION::RIGHT:  return JOYSTICK_DRIVER_RELPOINTER_RIGHT;
-    case RELATIVE_POINTER_DIRECTION::LEFT:   return JOYSTICK_DRIVER_RELPOINTER_LEFT;
+    case RELATIVE_POINTER_DIRECTION::UP:
+      return JOYSTICK_DRIVER_RELPOINTER_UP;
+    case RELATIVE_POINTER_DIRECTION::DOWN:
+      return JOYSTICK_DRIVER_RELPOINTER_DOWN;
+    case RELATIVE_POINTER_DIRECTION::RIGHT:
+      return JOYSTICK_DRIVER_RELPOINTER_RIGHT;
+    case RELATIVE_POINTER_DIRECTION::LEFT:
+      return JOYSTICK_DRIVER_RELPOINTER_LEFT;
     default:
       break;
   }
@@ -330,15 +389,24 @@ JOYSTICK::FEATURE_TYPE CPeripheralAddonTranslator::TranslateFeatureType(JOYSTICK
 {
   switch (type)
   {
-    case JOYSTICK_FEATURE_TYPE_SCALAR:        return JOYSTICK::FEATURE_TYPE::SCALAR;
-    case JOYSTICK_FEATURE_TYPE_ANALOG_STICK:  return JOYSTICK::FEATURE_TYPE::ANALOG_STICK;
-    case JOYSTICK_FEATURE_TYPE_ACCELEROMETER: return JOYSTICK::FEATURE_TYPE::ACCELEROMETER;
-    case JOYSTICK_FEATURE_TYPE_MOTOR:         return JOYSTICK::FEATURE_TYPE::MOTOR;
-    case JOYSTICK_FEATURE_TYPE_RELPOINTER:    return JOYSTICK::FEATURE_TYPE::RELPOINTER;
-    case JOYSTICK_FEATURE_TYPE_ABSPOINTER:    return JOYSTICK::FEATURE_TYPE::ABSPOINTER;
-    case JOYSTICK_FEATURE_TYPE_WHEEL:         return JOYSTICK::FEATURE_TYPE::WHEEL;
-    case JOYSTICK_FEATURE_TYPE_THROTTLE:      return JOYSTICK::FEATURE_TYPE::THROTTLE;
-    case JOYSTICK_FEATURE_TYPE_KEY:           return JOYSTICK::FEATURE_TYPE::KEY;
+    case JOYSTICK_FEATURE_TYPE_SCALAR:
+      return JOYSTICK::FEATURE_TYPE::SCALAR;
+    case JOYSTICK_FEATURE_TYPE_ANALOG_STICK:
+      return JOYSTICK::FEATURE_TYPE::ANALOG_STICK;
+    case JOYSTICK_FEATURE_TYPE_ACCELEROMETER:
+      return JOYSTICK::FEATURE_TYPE::ACCELEROMETER;
+    case JOYSTICK_FEATURE_TYPE_MOTOR:
+      return JOYSTICK::FEATURE_TYPE::MOTOR;
+    case JOYSTICK_FEATURE_TYPE_RELPOINTER:
+      return JOYSTICK::FEATURE_TYPE::RELPOINTER;
+    case JOYSTICK_FEATURE_TYPE_ABSPOINTER:
+      return JOYSTICK::FEATURE_TYPE::ABSPOINTER;
+    case JOYSTICK_FEATURE_TYPE_WHEEL:
+      return JOYSTICK::FEATURE_TYPE::WHEEL;
+    case JOYSTICK_FEATURE_TYPE_THROTTLE:
+      return JOYSTICK::FEATURE_TYPE::THROTTLE;
+    case JOYSTICK_FEATURE_TYPE_KEY:
+      return JOYSTICK::FEATURE_TYPE::KEY;
     default:
       break;
   }
@@ -349,22 +417,33 @@ JOYSTICK_FEATURE_TYPE CPeripheralAddonTranslator::TranslateFeatureType(JOYSTICK:
 {
   switch (type)
   {
-    case JOYSTICK::FEATURE_TYPE::SCALAR:        return JOYSTICK_FEATURE_TYPE_SCALAR;
-    case JOYSTICK::FEATURE_TYPE::ANALOG_STICK:  return JOYSTICK_FEATURE_TYPE_ANALOG_STICK;
-    case JOYSTICK::FEATURE_TYPE::ACCELEROMETER: return JOYSTICK_FEATURE_TYPE_ACCELEROMETER;
-    case JOYSTICK::FEATURE_TYPE::MOTOR:         return JOYSTICK_FEATURE_TYPE_MOTOR;
-    case JOYSTICK::FEATURE_TYPE::RELPOINTER:    return JOYSTICK_FEATURE_TYPE_RELPOINTER;
-    case JOYSTICK::FEATURE_TYPE::ABSPOINTER:    return JOYSTICK_FEATURE_TYPE_ABSPOINTER;
-    case JOYSTICK::FEATURE_TYPE::WHEEL:         return JOYSTICK_FEATURE_TYPE_WHEEL;
-    case JOYSTICK::FEATURE_TYPE::THROTTLE:      return JOYSTICK_FEATURE_TYPE_THROTTLE;
-    case JOYSTICK::FEATURE_TYPE::KEY:           return JOYSTICK_FEATURE_TYPE_KEY;
+    case JOYSTICK::FEATURE_TYPE::SCALAR:
+      return JOYSTICK_FEATURE_TYPE_SCALAR;
+    case JOYSTICK::FEATURE_TYPE::ANALOG_STICK:
+      return JOYSTICK_FEATURE_TYPE_ANALOG_STICK;
+    case JOYSTICK::FEATURE_TYPE::ACCELEROMETER:
+      return JOYSTICK_FEATURE_TYPE_ACCELEROMETER;
+    case JOYSTICK::FEATURE_TYPE::MOTOR:
+      return JOYSTICK_FEATURE_TYPE_MOTOR;
+    case JOYSTICK::FEATURE_TYPE::RELPOINTER:
+      return JOYSTICK_FEATURE_TYPE_RELPOINTER;
+    case JOYSTICK::FEATURE_TYPE::ABSPOINTER:
+      return JOYSTICK_FEATURE_TYPE_ABSPOINTER;
+    case JOYSTICK::FEATURE_TYPE::WHEEL:
+      return JOYSTICK_FEATURE_TYPE_WHEEL;
+    case JOYSTICK::FEATURE_TYPE::THROTTLE:
+      return JOYSTICK_FEATURE_TYPE_THROTTLE;
+    case JOYSTICK::FEATURE_TYPE::KEY:
+      return JOYSTICK_FEATURE_TYPE_KEY;
     default:
       break;
   }
   return JOYSTICK_FEATURE_TYPE_UNKNOWN;
 }
 
-kodi::addon::DriverPrimitive CPeripheralAddonTranslator::Opposite(const kodi::addon::DriverPrimitive& primitive)
+kodi::addon::DriverPrimitive CPeripheralAddonTranslator::Opposite(
+    const kodi::addon::DriverPrimitive& primitive)
 {
-  return kodi::addon::DriverPrimitive(primitive.DriverIndex(), primitive.Center() * -1, primitive.SemiAxisDirection() * -1, primitive.Range());
+  return kodi::addon::DriverPrimitive(primitive.DriverIndex(), primitive.Center() * -1,
+                                      primitive.SemiAxisDirection() * -1, primitive.Range());
 }
diff --git a/xbmc/peripherals/addons/PeripheralAddonTranslator.h b/xbmc/peripherals/addons/PeripheralAddonTranslator.h
index d9d755d1ce58..ee77fd47a0bd 100644
--- a/xbmc/peripherals/addons/PeripheralAddonTranslator.h
+++ b/xbmc/peripherals/addons/PeripheralAddonTranslator.h
@@ -19,37 +19,45 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralAddonTranslator
-  {
-  public:
-    static const char* TranslateError(PERIPHERAL_ERROR error);
+class CPeripheralAddonTranslator
+{
+public:
+  static const char* TranslateError(PERIPHERAL_ERROR error);
 
-    static PeripheralType  TranslateType(PERIPHERAL_TYPE type);
-    static PERIPHERAL_TYPE TranslateType(PeripheralType type);
+  static PeripheralType TranslateType(PERIPHERAL_TYPE type);
+  static PERIPHERAL_TYPE TranslateType(PeripheralType type);
 
-    static KODI::JOYSTICK::CDriverPrimitive TranslatePrimitive(const kodi::addon::DriverPrimitive& primitive);
-    static kodi::addon::DriverPrimitive     TranslatePrimitive(const KODI::JOYSTICK::CDriverPrimitive& primitive);
+  static KODI::JOYSTICK::CDriverPrimitive TranslatePrimitive(
+      const kodi::addon::DriverPrimitive& primitive);
+  static kodi::addon::DriverPrimitive TranslatePrimitive(
+      const KODI::JOYSTICK::CDriverPrimitive& primitive);
 
-    static std::vector<KODI::JOYSTICK::CDriverPrimitive> TranslatePrimitives(const std::vector<kodi::addon::DriverPrimitive>& primitives);
-    static std::vector<kodi::addon::DriverPrimitive>     TranslatePrimitives(const std::vector<KODI::JOYSTICK::CDriverPrimitive>& primitives);
+  static std::vector<KODI::JOYSTICK::CDriverPrimitive> TranslatePrimitives(
+      const std::vector<kodi::addon::DriverPrimitive>& primitives);
+  static std::vector<kodi::addon::DriverPrimitive> TranslatePrimitives(
+      const std::vector<KODI::JOYSTICK::CDriverPrimitive>& primitives);
 
-    static KODI::JOYSTICK::HAT_DIRECTION TranslateHatDirection(JOYSTICK_DRIVER_HAT_DIRECTION dir);
-    static JOYSTICK_DRIVER_HAT_DIRECTION TranslateHatDirection(KODI::JOYSTICK::HAT_DIRECTION dir);
+  static KODI::JOYSTICK::HAT_DIRECTION TranslateHatDirection(JOYSTICK_DRIVER_HAT_DIRECTION dir);
+  static JOYSTICK_DRIVER_HAT_DIRECTION TranslateHatDirection(KODI::JOYSTICK::HAT_DIRECTION dir);
 
-    static KODI::JOYSTICK::HAT_STATE TranslateHatState(JOYSTICK_STATE_HAT state);
+  static KODI::JOYSTICK::HAT_STATE TranslateHatState(JOYSTICK_STATE_HAT state);
 
-    static KODI::JOYSTICK::SEMIAXIS_DIRECTION TranslateSemiAxisDirection(JOYSTICK_DRIVER_SEMIAXIS_DIRECTION dir);
-    static JOYSTICK_DRIVER_SEMIAXIS_DIRECTION TranslateSemiAxisDirection(KODI::JOYSTICK::SEMIAXIS_DIRECTION dir);
+  static KODI::JOYSTICK::SEMIAXIS_DIRECTION TranslateSemiAxisDirection(
+      JOYSTICK_DRIVER_SEMIAXIS_DIRECTION dir);
+  static JOYSTICK_DRIVER_SEMIAXIS_DIRECTION TranslateSemiAxisDirection(
+      KODI::JOYSTICK::SEMIAXIS_DIRECTION dir);
 
-    static KODI::MOUSE::BUTTON_ID TranslateMouseButton(JOYSTICK_DRIVER_MOUSE_INDEX button);
-    static JOYSTICK_DRIVER_MOUSE_INDEX TranslateMouseButton(KODI::MOUSE::BUTTON_ID button);
+  static KODI::MOUSE::BUTTON_ID TranslateMouseButton(JOYSTICK_DRIVER_MOUSE_INDEX button);
+  static JOYSTICK_DRIVER_MOUSE_INDEX TranslateMouseButton(KODI::MOUSE::BUTTON_ID button);
 
-    static KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION TranslateRelPointerDirection(JOYSTICK_DRIVER_RELPOINTER_DIRECTION dir);
-    static JOYSTICK_DRIVER_RELPOINTER_DIRECTION TranslateRelPointerDirection(KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION dir);
+  static KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION TranslateRelPointerDirection(
+      JOYSTICK_DRIVER_RELPOINTER_DIRECTION dir);
+  static JOYSTICK_DRIVER_RELPOINTER_DIRECTION TranslateRelPointerDirection(
+      KODI::JOYSTICK::RELATIVE_POINTER_DIRECTION dir);
 
-    static KODI::JOYSTICK::FEATURE_TYPE TranslateFeatureType(JOYSTICK_FEATURE_TYPE type);
-    static JOYSTICK_FEATURE_TYPE        TranslateFeatureType(KODI::JOYSTICK::FEATURE_TYPE type);
+  static KODI::JOYSTICK::FEATURE_TYPE TranslateFeatureType(JOYSTICK_FEATURE_TYPE type);
+  static JOYSTICK_FEATURE_TYPE TranslateFeatureType(KODI::JOYSTICK::FEATURE_TYPE type);
 
-    static kodi::addon::DriverPrimitive Opposite(const kodi::addon::DriverPrimitive& semiaxis);
-  };
-}
+  static kodi::addon::DriverPrimitive Opposite(const kodi::addon::DriverPrimitive& semiaxis);
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/bus/PeripheralBus.cpp b/xbmc/peripherals/bus/PeripheralBus.cpp
index 5584ed214e04..6a6f8bea36fe 100644
--- a/xbmc/peripherals/bus/PeripheralBus.cpp
+++ b/xbmc/peripherals/bus/PeripheralBus.cpp
@@ -20,8 +20,10 @@ using namespace PERIPHERALS;
 
 #define PERIPHERAL_DEFAULT_RESCAN_INTERVAL 5000
 
-CPeripheralBus::CPeripheralBus(const std::string &threadname, CPeripherals& manager, PeripheralBusType type) :
-    CThread(threadname.c_str()),
+CPeripheralBus::CPeripheralBus(const std::string& threadname,
+                               CPeripherals& manager,
+                               PeripheralBusType type)
+  : CThread(threadname.c_str()),
     m_iRescanTime(PERIPHERAL_DEFAULT_RESCAN_INTERVAL),
     m_bNeedsPolling(true),
     m_manager(manager),
@@ -35,17 +37,17 @@ bool CPeripheralBus::InitializeProperties(CPeripheral& peripheral)
   return true;
 }
 
-void CPeripheralBus::OnDeviceAdded(const std::string &strLocation)
+void CPeripheralBus::OnDeviceAdded(const std::string& strLocation)
 {
   ScanForDevices();
 }
 
-void CPeripheralBus::OnDeviceChanged(const std::string &strLocation)
+void CPeripheralBus::OnDeviceChanged(const std::string& strLocation)
 {
   ScanForDevices();
 }
 
-void CPeripheralBus::OnDeviceRemoved(const std::string &strLocation)
+void CPeripheralBus::OnDeviceRemoved(const std::string& strLocation)
 {
   ScanForDevices();
 }
@@ -64,13 +66,13 @@ void CPeripheralBus::Clear(void)
   m_peripherals.clear();
 }
 
-void CPeripheralBus::UnregisterRemovedDevices(const PeripheralScanResults &results)
+void CPeripheralBus::UnregisterRemovedDevices(const PeripheralScanResults& results)
 {
   PeripheralVector removedPeripherals;
 
   {
     CSingleLock lock(m_critSection);
-    for (int iDevicePtr = (int) m_peripherals.size() - 1; iDevicePtr >= 0; iDevicePtr--)
+    for (int iDevicePtr = (int)m_peripherals.size() - 1; iDevicePtr >= 0; iDevicePtr--)
     {
       const PeripheralPtr& peripheral = m_peripherals.at(iDevicePtr);
       PeripheralScanResult updatedDevice(m_type);
@@ -88,7 +90,8 @@ void CPeripheralBus::UnregisterRemovedDevices(const PeripheralScanResults &resul
   {
     std::vector<PeripheralFeature> features;
     peripheral->GetFeatures(features);
-    bool peripheralHasFeatures = features.size() > 1 || (features.size() == 1 && features.at(0) != FEATURE_UNKNOWN);
+    bool peripheralHasFeatures =
+        features.size() > 1 || (features.size() == 1 && features.at(0) != FEATURE_UNKNOWN);
     if (peripheral->Type() != PERIPHERAL_UNKNOWN || peripheralHasFeatures)
     {
       CLog::Log(LOGINFO, "%s - device removed from %s/%s: %s (%s:%s)", __FUNCTION__,
@@ -102,7 +105,7 @@ void CPeripheralBus::UnregisterRemovedDevices(const PeripheralScanResults &resul
   }
 }
 
-void CPeripheralBus::RegisterNewDevices(const PeripheralScanResults &results)
+void CPeripheralBus::RegisterNewDevices(const PeripheralScanResults& results)
 {
   for (unsigned int iResultPtr = 0; iResultPtr < results.m_results.size(); iResultPtr++)
   {
@@ -145,14 +148,14 @@ bool CPeripheralBus::HasFeature(const PeripheralFeature feature) const
   return bReturn;
 }
 
-void CPeripheralBus::GetFeatures(std::vector<PeripheralFeature> &features) const
+void CPeripheralBus::GetFeatures(std::vector<PeripheralFeature>& features) const
 {
   CSingleLock lock(m_critSection);
   for (unsigned int iPeripheralPtr = 0; iPeripheralPtr < m_peripherals.size(); iPeripheralPtr++)
     m_peripherals.at(iPeripheralPtr)->GetFeatures(features);
 }
 
-PeripheralPtr CPeripheralBus::GetPeripheral(const std::string &strLocation) const
+PeripheralPtr CPeripheralBus::GetPeripheral(const std::string& strLocation) const
 {
   PeripheralPtr result;
   CSingleLock lock(m_critSection);
@@ -167,7 +170,8 @@ PeripheralPtr CPeripheralBus::GetPeripheral(const std::string &strLocation) cons
   return result;
 }
 
-unsigned int CPeripheralBus::GetPeripheralsWithFeature(PeripheralVector &results, const PeripheralFeature feature) const
+unsigned int CPeripheralBus::GetPeripheralsWithFeature(PeripheralVector& results,
+                                                       const PeripheralFeature feature) const
 {
   unsigned int iReturn = 0;
   CSingleLock lock(m_critSection);
@@ -183,14 +187,14 @@ unsigned int CPeripheralBus::GetPeripheralsWithFeature(PeripheralVector &results
   return iReturn;
 }
 
-unsigned int CPeripheralBus::GetNumberOfPeripheralsWithId(const int iVendorId, const int iProductId) const
+unsigned int CPeripheralBus::GetNumberOfPeripheralsWithId(const int iVendorId,
+                                                          const int iProductId) const
 {
   unsigned int iReturn = 0;
   CSingleLock lock(m_critSection);
   for (const auto& peripheral : m_peripherals)
   {
-    if (peripheral->VendorId() == iVendorId &&
-        peripheral->ProductId() == iProductId)
+    if (peripheral->VendorId() == iVendorId && peripheral->ProductId() == iProductId)
       iReturn++;
   }
 
@@ -278,12 +282,12 @@ void CPeripheralBus::TriggerDeviceScan(void)
     ScanForDevices();
 }
 
-bool CPeripheralBus::HasPeripheral(const std::string &strLocation) const
+bool CPeripheralBus::HasPeripheral(const std::string& strLocation) const
 {
   return (GetPeripheral(strLocation) != NULL);
 }
 
-void CPeripheralBus::GetDirectory(const std::string &strPath, CFileItemList &items) const
+void CPeripheralBus::GetDirectory(const std::string& strPath, CFileItemList& items) const
 {
   std::string strDevPath;
   CSingleLock lock(m_critSection);
@@ -296,17 +300,21 @@ void CPeripheralBus::GetDirectory(const std::string &strPath, CFileItemList &ite
     peripheralFile->SetPath(peripheral->FileLocation());
     peripheralFile->SetProperty("vendor", peripheral->VendorIdAsString());
     peripheralFile->SetProperty("product", peripheral->ProductIdAsString());
-    peripheralFile->SetProperty("bus", PeripheralTypeTranslator::BusTypeToString(peripheral->GetBusType()));
+    peripheralFile->SetProperty(
+        "bus", PeripheralTypeTranslator::BusTypeToString(peripheral->GetBusType()));
     peripheralFile->SetProperty("location", peripheral->Location());
-    peripheralFile->SetProperty("class", PeripheralTypeTranslator::TypeToString(peripheral->Type()));
+    peripheralFile->SetProperty("class",
+                                PeripheralTypeTranslator::TypeToString(peripheral->Type()));
 
     std::string strVersion(peripheral->GetVersionInfo());
     if (strVersion.empty())
       strVersion = g_localizeStrings.Get(13205);
 
-    std::string strDetails = StringUtils::Format("%s %s", g_localizeStrings.Get(24051).c_str(), strVersion.c_str());
+    std::string strDetails =
+        StringUtils::Format("%s %s", g_localizeStrings.Get(24051).c_str(), strVersion.c_str());
     if (peripheral->GetBusType() == PERIPHERAL_BUS_CEC && !peripheral->GetSettingBool("enabled"))
-      strDetails = StringUtils::Format("%s: %s", g_localizeStrings.Get(126).c_str(), g_localizeStrings.Get(13106).c_str());
+      strDetails = StringUtils::Format("%s: %s", g_localizeStrings.Get(126).c_str(),
+                                       g_localizeStrings.Get(13106).c_str());
 
     peripheralFile->SetProperty("version", strVersion);
     peripheralFile->SetLabel2(strDetails);
@@ -315,7 +323,7 @@ void CPeripheralBus::GetDirectory(const std::string &strPath, CFileItemList &ite
   }
 }
 
-PeripheralPtr CPeripheralBus::GetByPath(const std::string &strPath) const
+PeripheralPtr CPeripheralBus::GetByPath(const std::string& strPath) const
 {
   PeripheralPtr result;
 
diff --git a/xbmc/peripherals/bus/PeripheralBus.h b/xbmc/peripherals/bus/PeripheralBus.h
index 1584e1a5b41f..2cfcc862be67 100644
--- a/xbmc/peripherals/bus/PeripheralBus.h
+++ b/xbmc/peripherals/bus/PeripheralBus.h
@@ -18,176 +18,186 @@ class CFileItemList;
 
 namespace PERIPHERALS
 {
-  class CPeripheral;
-  class CPeripherals;
+class CPeripheral;
+class CPeripherals;
+
+/*!
+ * @class CPeripheralBus
+ * This represents a bus on the system. By default, this bus instance will scan for changes every 5
+ * seconds. If this bus only has to be updated after a notification sent by the system, set
+ * m_bNeedsPolling to false in the constructor, and implement the OnDeviceAdded(), OnDeviceChanged()
+ * and OnDeviceRemoved() methods.
+ *
+ * The PerformDeviceScan() method has to be implemented by each specific bus implementation.
+ */
+class CPeripheralBus : protected CThread
+{
+public:
+  CPeripheralBus(const std::string& threadname, CPeripherals& manager, PeripheralBusType type);
+  ~CPeripheralBus(void) override { Clear(); }
 
   /*!
-   * @class CPeripheralBus
-   * This represents a bus on the system. By default, this bus instance will scan for changes every 5 seconds.
-   * If this bus only has to be updated after a notification sent by the system, set m_bNeedsPolling to false
-   * in the constructor, and implement the OnDeviceAdded(), OnDeviceChanged() and OnDeviceRemoved() methods.
-   *
-   * The PerformDeviceScan() method has to be implemented by each specific bus implementation.
+   * @return The bus type
    */
-  class CPeripheralBus : protected CThread
+  PeripheralBusType Type(void) const { return m_type; }
+
+  /*!
+   * @return True if this bus needs to be polled for changes, false if this bus performs updates via
+   * callbacks
+   */
+  bool NeedsPolling(void) const
   {
-  public:
-    CPeripheralBus(const std::string &threadname, CPeripherals& manager, PeripheralBusType type);
-    ~CPeripheralBus(void) override { Clear(); }
-
-    /*!
-     * @return The bus type
-     */
-    PeripheralBusType Type(void) const { return m_type; }
-
-    /*!
-     * @return True if this bus needs to be polled for changes, false if this bus performs updates via callbacks
-     */
-    bool NeedsPolling(void) const { CSingleLock lock(m_critSection); return m_bNeedsPolling; }
-
-    /*!
-    * \brief Initialize the properties of a peripheral with a known location
-    */
-    virtual bool InitializeProperties(CPeripheral& peripheral);
-
-    /*!
-     * @brief Get the instance of the peripheral at the given location.
-     * @param strLocation The location.
-     * @return The peripheral or NULL if it wasn't found.
-     */
-    virtual PeripheralPtr GetPeripheral(const std::string &strLocation) const;
-
-    /*!
-     * @brief Check whether a peripheral is present at the given location.
-     * @param strLocation The location.
-     * @return True when a peripheral was found, false otherwise.
-     */
-    virtual bool HasPeripheral(const std::string &strLocation) const;
-
-    /*!
-     * @brief Check if the bus supports the given feature
-     * @param feature The feature to check for
-     * @return True if the bus supports the feature, false otherwise
-     */
-    virtual bool SupportsFeature(PeripheralFeature feature) const { return false; }
-
-    /*!
-     * @brief Get all peripheral instances that have the given feature.
-     * @param results The list of results.
-     * @param feature The feature to search for.
-     * @return The number of devices that have been found.
-     */
-    virtual unsigned int GetPeripheralsWithFeature(PeripheralVector &results, const PeripheralFeature feature) const;
-
-    virtual unsigned int GetNumberOfPeripherals() const;
-    virtual unsigned int GetNumberOfPeripheralsWithId(const int iVendorId, const int iProductId) const;
-
-    /*!
-     * @brief Get all features that are supported by devices on this bus.
-     * @param features All features.
-     */
-    virtual void GetFeatures(std::vector<PeripheralFeature> &features) const;
-
-    /*!
-     * @brief Check whether there is at least one device present with the given feature.
-     * @param feature The feature to check for.
-     * @return True when at least one device was found with this feature, false otherwise.
-     */
-    virtual bool HasFeature(const PeripheralFeature feature) const;
-
-    /*!
-     * @brief Callback method for when a device has been added. Will perform a device scan.
-     * @param strLocation The location of the device that has been added.
-     */
-    virtual void OnDeviceAdded(const std::string &strLocation);
-
-    /*!
-     * @brief Callback method for when a device has been changed. Will perform a device scan.
-     * @param strLocation The location of the device that has been changed.
-     */
-    virtual void OnDeviceChanged(const std::string &strLocation);
-
-    /*!
-     * @brief Callback method for when a device has been removed. Will perform a device scan.
-     * @param strLocation The location of the device that has been removed.
-     */
-    virtual void OnDeviceRemoved(const std::string &strLocation);
-
-    /*!
-     * @brief Initialise this bus and start a polling thread if this bus needs polling.
-     */
-    virtual void Initialise(void);
-
-    /*!
-     * @brief Stop the polling thread and clear all known devices on this bus.
-     */
-    virtual void Clear(void);
-
-    /*!
-     * @brief Scan for devices.
-     */
-    virtual void TriggerDeviceScan(void);
-
-    /*!
-     * @brief Get all fileitems for a path.
-     * @param strPath The path to the directory to get the items from.
-     * @param items The item list.
-     */
-    virtual void GetDirectory(const std::string &strPath, CFileItemList &items) const;
-
-    /*!
-     * @brief Get the instance of a peripheral given it's path.
-     * @param strPath The path to the peripheral.
-     * @return The peripheral or NULL if it wasn't found.
-     */
-    virtual PeripheralPtr GetByPath(const std::string &strPath) const;
-
-    /*!
-     * @brief Register a new peripheral on this bus.
-     * @param peripheral The peripheral to register.
-     */
-    virtual void Register(const PeripheralPtr& peripheral);
-
-    virtual bool FindComPort(std::string &strLocation) { return false; }
-
-    /*!
-     * \brief Poll for events
-     */
-    virtual void ProcessEvents(void) { }
-
-    /*!
-    * \brief Initialize button mapping
-    * \return True if button mapping is enabled for this bus
-    */
-    virtual void EnableButtonMapping() { }
-
-    /*!
-     * \brief Power off the specified device
-     * \param strLocation The device's location
-     */
-    virtual void PowerOff(const std::string& strLocation) { }
-
-  protected:
-    void Process(void) override;
-    virtual bool ScanForDevices(void);
-    virtual void UnregisterRemovedDevices(const PeripheralScanResults &results);
-    virtual void RegisterNewDevices(const PeripheralScanResults &results);
-
-    /*!
-     * @brief Scan for devices on this bus and add them to the results list. This will have to be implemented for each bus.
-     * @param results The result list.
-     * @return True when the scan was successful, false otherwise.
-     */
-    virtual bool PerformDeviceScan(PeripheralScanResults &results) = 0;
-
-    PeripheralVector           m_peripherals;
-    int                        m_iRescanTime;
-    bool                       m_bNeedsPolling; /*!< true when this bus needs to be polled for new devices, false when it uses callbacks to notify this bus of changed */
-    CPeripherals&              m_manager;
-    const PeripheralBusType    m_type;
-    mutable CCriticalSection   m_critSection;
-    CEvent                     m_triggerEvent;
-  };
-  using PeripheralBusPtr = std::shared_ptr<CPeripheralBus>;
-  using PeripheralBusVector = std::vector<PeripheralBusPtr>;
-}
+    CSingleLock lock(m_critSection);
+    return m_bNeedsPolling;
+  }
+
+  /*!
+   * \brief Initialize the properties of a peripheral with a known location
+   */
+  virtual bool InitializeProperties(CPeripheral& peripheral);
+
+  /*!
+   * @brief Get the instance of the peripheral at the given location.
+   * @param strLocation The location.
+   * @return The peripheral or NULL if it wasn't found.
+   */
+  virtual PeripheralPtr GetPeripheral(const std::string& strLocation) const;
+
+  /*!
+   * @brief Check whether a peripheral is present at the given location.
+   * @param strLocation The location.
+   * @return True when a peripheral was found, false otherwise.
+   */
+  virtual bool HasPeripheral(const std::string& strLocation) const;
+
+  /*!
+   * @brief Check if the bus supports the given feature
+   * @param feature The feature to check for
+   * @return True if the bus supports the feature, false otherwise
+   */
+  virtual bool SupportsFeature(PeripheralFeature feature) const { return false; }
+
+  /*!
+   * @brief Get all peripheral instances that have the given feature.
+   * @param results The list of results.
+   * @param feature The feature to search for.
+   * @return The number of devices that have been found.
+   */
+  virtual unsigned int GetPeripheralsWithFeature(PeripheralVector& results,
+                                                 const PeripheralFeature feature) const;
+
+  virtual unsigned int GetNumberOfPeripherals() const;
+  virtual unsigned int GetNumberOfPeripheralsWithId(const int iVendorId,
+                                                    const int iProductId) const;
+
+  /*!
+   * @brief Get all features that are supported by devices on this bus.
+   * @param features All features.
+   */
+  virtual void GetFeatures(std::vector<PeripheralFeature>& features) const;
+
+  /*!
+   * @brief Check whether there is at least one device present with the given feature.
+   * @param feature The feature to check for.
+   * @return True when at least one device was found with this feature, false otherwise.
+   */
+  virtual bool HasFeature(const PeripheralFeature feature) const;
+
+  /*!
+   * @brief Callback method for when a device has been added. Will perform a device scan.
+   * @param strLocation The location of the device that has been added.
+   */
+  virtual void OnDeviceAdded(const std::string& strLocation);
+
+  /*!
+   * @brief Callback method for when a device has been changed. Will perform a device scan.
+   * @param strLocation The location of the device that has been changed.
+   */
+  virtual void OnDeviceChanged(const std::string& strLocation);
+
+  /*!
+   * @brief Callback method for when a device has been removed. Will perform a device scan.
+   * @param strLocation The location of the device that has been removed.
+   */
+  virtual void OnDeviceRemoved(const std::string& strLocation);
+
+  /*!
+   * @brief Initialise this bus and start a polling thread if this bus needs polling.
+   */
+  virtual void Initialise(void);
+
+  /*!
+   * @brief Stop the polling thread and clear all known devices on this bus.
+   */
+  virtual void Clear(void);
+
+  /*!
+   * @brief Scan for devices.
+   */
+  virtual void TriggerDeviceScan(void);
+
+  /*!
+   * @brief Get all fileitems for a path.
+   * @param strPath The path to the directory to get the items from.
+   * @param items The item list.
+   */
+  virtual void GetDirectory(const std::string& strPath, CFileItemList& items) const;
+
+  /*!
+   * @brief Get the instance of a peripheral given it's path.
+   * @param strPath The path to the peripheral.
+   * @return The peripheral or NULL if it wasn't found.
+   */
+  virtual PeripheralPtr GetByPath(const std::string& strPath) const;
+
+  /*!
+   * @brief Register a new peripheral on this bus.
+   * @param peripheral The peripheral to register.
+   */
+  virtual void Register(const PeripheralPtr& peripheral);
+
+  virtual bool FindComPort(std::string& strLocation) { return false; }
+
+  /*!
+   * \brief Poll for events
+   */
+  virtual void ProcessEvents(void) {}
+
+  /*!
+   * \brief Initialize button mapping
+   * \return True if button mapping is enabled for this bus
+   */
+  virtual void EnableButtonMapping() {}
+
+  /*!
+   * \brief Power off the specified device
+   * \param strLocation The device's location
+   */
+  virtual void PowerOff(const std::string& strLocation) {}
+
+protected:
+  void Process(void) override;
+  virtual bool ScanForDevices(void);
+  virtual void UnregisterRemovedDevices(const PeripheralScanResults& results);
+  virtual void RegisterNewDevices(const PeripheralScanResults& results);
+
+  /*!
+   * @brief Scan for devices on this bus and add them to the results list. This will have to be
+   * implemented for each bus.
+   * @param results The result list.
+   * @return True when the scan was successful, false otherwise.
+   */
+  virtual bool PerformDeviceScan(PeripheralScanResults& results) = 0;
+
+  PeripheralVector m_peripherals;
+  int m_iRescanTime;
+  bool m_bNeedsPolling; /*!< true when this bus needs to be polled for new devices, false when it
+                           uses callbacks to notify this bus of changed */
+  CPeripherals& m_manager;
+  const PeripheralBusType m_type;
+  mutable CCriticalSection m_critSection;
+  CEvent m_triggerEvent;
+};
+using PeripheralBusPtr = std::shared_ptr<CPeripheralBus>;
+using PeripheralBusVector = std::vector<PeripheralBusPtr>;
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/bus/PeripheralBusUSB.h b/xbmc/peripherals/bus/PeripheralBusUSB.h
index c1393b79c72c..dd32ff6e5021 100644
--- a/xbmc/peripherals/bus/PeripheralBusUSB.h
+++ b/xbmc/peripherals/bus/PeripheralBusUSB.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-#if   defined(TARGET_WINDOWS_DESKTOP)
+#if defined(TARGET_WINDOWS_DESKTOP)
 #define HAVE_PERIPHERAL_BUS_USB 1
 #include "platform/win32/peripherals/PeripheralBusUSB.h"
 #elif defined(TARGET_WINDOWS_STORE)
diff --git a/xbmc/peripherals/bus/virtual/PeripheralBusAddon.cpp b/xbmc/peripherals/bus/virtual/PeripheralBusAddon.cpp
index 9339397ca8d4..13536023240f 100644
--- a/xbmc/peripherals/bus/virtual/PeripheralBusAddon.cpp
+++ b/xbmc/peripherals/bus/virtual/PeripheralBusAddon.cpp
@@ -24,8 +24,8 @@
 using namespace KODI;
 using namespace PERIPHERALS;
 
-CPeripheralBusAddon::CPeripheralBusAddon(CPeripherals& manager) :
-    CPeripheralBus("PeripBusAddon", manager, PERIPHERAL_BUS_ADDON)
+CPeripheralBusAddon::CPeripheralBusAddon(CPeripherals& manager)
+  : CPeripheralBus("PeripBusAddon", manager, PERIPHERAL_BUS_ADDON)
 {
   using namespace ADDON;
 
@@ -51,26 +51,24 @@ CPeripheralBusAddon::~CPeripheralBusAddon()
   m_addons.clear();
 }
 
-bool CPeripheralBusAddon::GetAddonWithButtonMap(PeripheralAddonPtr &addon) const
+bool CPeripheralBusAddon::GetAddonWithButtonMap(PeripheralAddonPtr& addon) const
 {
   CSingleLock lock(m_critSection);
 
   auto it = std::find_if(m_addons.begin(), m_addons.end(),
-    [](const PeripheralAddonPtr& addon)
-    {
-      return addon->HasButtonMaps();
-    });
+                         [](const PeripheralAddonPtr& addon) { return addon->HasButtonMaps(); });
 
   if (it != m_addons.end())
   {
     addon = *it;
-    return  true;
+    return true;
   }
 
   return false;
 }
 
-bool CPeripheralBusAddon::GetAddonWithButtonMap(const CPeripheral* device, PeripheralAddonPtr &addon) const
+bool CPeripheralBusAddon::GetAddonWithButtonMap(const CPeripheral* device,
+                                                PeripheralAddonPtr& addon) const
 {
   CSingleLock lock(m_critSection);
 
@@ -84,17 +82,15 @@ bool CPeripheralBusAddon::GetAddonWithButtonMap(const CPeripheral* device, Perip
       if (addonWithButtonMap->HasButtonMaps())
         addon = std::move(addonWithButtonMap);
       else
-        CLog::Log(LOGDEBUG, "Add-on %s doesn't provide button maps for its controllers", addonWithButtonMap->ID().c_str());
+        CLog::Log(LOGDEBUG, "Add-on %s doesn't provide button maps for its controllers",
+                  addonWithButtonMap->ID().c_str());
     }
   }
 
   if (!addon)
   {
     auto it = std::find_if(m_addons.begin(), m_addons.end(),
-      [](const PeripheralAddonPtr& addon)
-      {
-        return addon->HasButtonMaps();
-      });
+                           [](const PeripheralAddonPtr& addon) { return addon->HasButtonMaps(); });
 
     if (it != m_addons.end())
       addon = *it;
@@ -103,7 +99,7 @@ bool CPeripheralBusAddon::GetAddonWithButtonMap(const CPeripheral* device, Perip
   return addon.get() != nullptr;
 }
 
-bool CPeripheralBusAddon::PerformDeviceScan(PeripheralScanResults &results)
+bool CPeripheralBusAddon::PerformDeviceScan(PeripheralScanResults& results)
 {
   PeripheralAddonVector addons;
   {
@@ -133,7 +129,8 @@ bool CPeripheralBusAddon::InitializeProperties(CPeripheral& peripheral)
     switch (peripheral.Type())
     {
       case PERIPHERAL_JOYSTICK:
-        bSuccess = addon->GetJoystickProperties(index, static_cast<CPeripheralJoystick&>(peripheral));
+        bSuccess =
+            addon->GetJoystickProperties(index, static_cast<CPeripheralJoystick&>(peripheral));
         break;
 
       default:
@@ -144,7 +141,9 @@ bool CPeripheralBusAddon::InitializeProperties(CPeripheral& peripheral)
   return bSuccess;
 }
 
-bool CPeripheralBusAddon::SendRumbleEvent(const std::string& strLocation, unsigned int motorIndex, float magnitude)
+bool CPeripheralBusAddon::SendRumbleEvent(const std::string& strLocation,
+                                          unsigned int motorIndex,
+                                          float magnitude)
 {
   bool bHandled = false;
 
@@ -180,7 +179,8 @@ void CPeripheralBusAddon::EnableButtonMapping()
   if (!GetAddonWithButtonMap(dummy))
   {
     BinaryAddonBaseList disabledAddons;
-    CServiceBroker::GetBinaryAddonManager().GetDisabledAddonInfos(disabledAddons, ADDON_PERIPHERALDLL);
+    CServiceBroker::GetBinaryAddonManager().GetDisabledAddonInfos(disabledAddons,
+                                                                  ADDON_PERIPHERALDLL);
     if (!disabledAddons.empty())
       PromptEnableAddons(disabledAddons);
   }
@@ -194,7 +194,7 @@ void CPeripheralBusAddon::PowerOff(const std::string& strLocation)
     addon->PowerOffJoystick(peripheralIndex);
 }
 
-void CPeripheralBusAddon::UnregisterRemovedDevices(const PeripheralScanResults &results)
+void CPeripheralBusAddon::UnregisterRemovedDevices(const PeripheralScanResults& results)
 {
   CSingleLock lock(m_critSection);
 
@@ -213,7 +213,7 @@ void CPeripheralBusAddon::Register(const PeripheralPtr& peripheral)
     return;
 
   PeripheralAddonPtr addon;
-  unsigned int       peripheralIndex;
+  unsigned int peripheralIndex;
 
   CSingleLock lock(m_critSection);
 
@@ -224,7 +224,7 @@ void CPeripheralBusAddon::Register(const PeripheralPtr& peripheral)
   }
 }
 
-void CPeripheralBusAddon::GetFeatures(std::vector<PeripheralFeature> &features) const
+void CPeripheralBusAddon::GetFeatures(std::vector<PeripheralFeature>& features) const
 {
   CSingleLock lock(m_critSection);
   for (const auto& addon : m_addons)
@@ -240,11 +240,11 @@ bool CPeripheralBusAddon::HasFeature(const PeripheralFeature feature) const
   return bReturn;
 }
 
-PeripheralPtr CPeripheralBusAddon::GetPeripheral(const std::string &strLocation) const
+PeripheralPtr CPeripheralBusAddon::GetPeripheral(const std::string& strLocation) const
 {
-  PeripheralPtr      peripheral;
+  PeripheralPtr peripheral;
   PeripheralAddonPtr addon;
-  unsigned int       peripheralIndex;
+  unsigned int peripheralIndex;
 
   CSingleLock lock(m_critSection);
 
@@ -254,7 +254,7 @@ PeripheralPtr CPeripheralBusAddon::GetPeripheral(const std::string &strLocation)
   return peripheral;
 }
 
-PeripheralPtr CPeripheralBusAddon::GetByPath(const std::string &strPath) const
+PeripheralPtr CPeripheralBusAddon::GetByPath(const std::string& strPath) const
 {
   PeripheralPtr result;
 
@@ -284,7 +284,8 @@ bool CPeripheralBusAddon::SupportsFeature(PeripheralFeature feature) const
   return bSupportsFeature;
 }
 
-unsigned int CPeripheralBusAddon::GetPeripheralsWithFeature(PeripheralVector &results, const PeripheralFeature feature) const
+unsigned int CPeripheralBusAddon::GetPeripheralsWithFeature(PeripheralVector& results,
+                                                            const PeripheralFeature feature) const
 {
   unsigned int iReturn = 0;
   CSingleLock lock(m_critSection);
@@ -302,7 +303,8 @@ unsigned int CPeripheralBusAddon::GetNumberOfPeripherals(void) const
   return iReturn;
 }
 
-unsigned int CPeripheralBusAddon::GetNumberOfPeripheralsWithId(const int iVendorId, const int iProductId) const
+unsigned int CPeripheralBusAddon::GetNumberOfPeripheralsWithId(const int iVendorId,
+                                                               const int iProductId) const
 {
   unsigned int iReturn = 0;
   CSingleLock lock(m_critSection);
@@ -311,7 +313,7 @@ unsigned int CPeripheralBusAddon::GetNumberOfPeripheralsWithId(const int iVendor
   return iReturn;
 }
 
-void CPeripheralBusAddon::GetDirectory(const std::string &strPath, CFileItemList &items) const
+void CPeripheralBusAddon::GetDirectory(const std::string& strPath, CFileItemList& items) const
 {
   CSingleLock lock(m_critSection);
   for (const auto& addon : m_addons)
@@ -337,7 +339,9 @@ void CPeripheralBusAddon::OnEvent(const ADDON::AddonEvent& event)
   }
 }
 
-bool CPeripheralBusAddon::SplitLocation(const std::string& strLocation, PeripheralAddonPtr& addon, unsigned int& peripheralIndex) const
+bool CPeripheralBusAddon::SplitLocation(const std::string& strLocation,
+                                        PeripheralAddonPtr& addon,
+                                        unsigned int& peripheralIndex) const
 {
   std::vector<std::string> parts = StringUtils::Split(strLocation, "/");
   if (parts.size() == 2)
@@ -384,17 +388,22 @@ void CPeripheralBusAddon::UpdateAddons(void)
   // Get new add-ons
   BinaryAddonBaseList newAddons;
   CServiceBroker::GetBinaryAddonManager().GetAddonInfos(newAddons, true, ADDON_PERIPHERALDLL);
-  std::transform(newAddons.begin(), newAddons.end(), std::inserter(newIds, newIds.end()), GetAddonID);
+  std::transform(newAddons.begin(), newAddons.end(), std::inserter(newIds, newIds.end()),
+                 GetAddonID);
 
   CSingleLock lock(m_critSection);
 
   // Get current add-ons
-  std::transform(m_addons.begin(), m_addons.end(), std::inserter(currentIds, currentIds.end()), GetPeripheralAddonID);
-  std::transform(m_failedAddons.begin(), m_failedAddons.end(), std::inserter(currentIds, currentIds.end()), GetPeripheralAddonID);
+  std::transform(m_addons.begin(), m_addons.end(), std::inserter(currentIds, currentIds.end()),
+                 GetPeripheralAddonID);
+  std::transform(m_failedAddons.begin(), m_failedAddons.end(),
+                 std::inserter(currentIds, currentIds.end()), GetPeripheralAddonID);
 
   // Differences
-  std::set_difference(newIds.begin(), newIds.end(), currentIds.begin(), currentIds.end(), std::inserter(added, added.end()));
-  std::set_difference(currentIds.begin(), currentIds.end(), newIds.begin(), newIds.end(), std::inserter(removed, removed.end()));
+  std::set_difference(newIds.begin(), newIds.end(), currentIds.begin(), currentIds.end(),
+                      std::inserter(added, added.end()));
+  std::set_difference(currentIds.begin(), currentIds.end(), newIds.begin(), newIds.end(),
+                      std::inserter(removed, removed.end()));
 
   // Register new add-ons
   for (const std::string& addonId : added)
@@ -434,19 +443,21 @@ void CPeripheralBusAddon::UpdateAddons(void)
 void CPeripheralBusAddon::UnRegisterAddon(const std::string& addonId)
 {
   PeripheralAddonPtr erased;
-  auto ErasePeripheralAddon = [&addonId, &erased](const PeripheralAddonPtr& addon)
+  auto ErasePeripheralAddon = [&addonId, &erased](const PeripheralAddonPtr& addon) {
+    if (addon->ID() == addonId)
     {
-      if (addon->ID() == addonId)
-      {
-        erased = addon;
-        return true;
-      }
-      return false;
-    };
+      erased = addon;
+      return true;
+    }
+    return false;
+  };
 
-  m_addons.erase(std::remove_if(m_addons.begin(), m_addons.end(), ErasePeripheralAddon), m_addons.end());
+  m_addons.erase(std::remove_if(m_addons.begin(), m_addons.end(), ErasePeripheralAddon),
+                 m_addons.end());
   if (!erased)
-    m_failedAddons.erase(std::remove_if(m_failedAddons.begin(), m_failedAddons.end(), ErasePeripheralAddon), m_failedAddons.end());
+    m_failedAddons.erase(
+        std::remove_if(m_failedAddons.begin(), m_failedAddons.end(), ErasePeripheralAddon),
+        m_failedAddons.end());
 
   if (erased)
   {
@@ -465,16 +476,15 @@ void CPeripheralBusAddon::PromptEnableAddons(const ADDON::BinaryAddonBaseList& d
   bool bAccepted = false;
 
   auto itAddon = std::find_if(disabledAddons.begin(), disabledAddons.end(),
-    [](const BinaryAddonBasePtr& addonInfo)
-  {
-    return CPeripheralAddon::ProvidesJoysticks(addonInfo);
-  });
+                              [](const BinaryAddonBasePtr& addonInfo) {
+                                return CPeripheralAddon::ProvidesJoysticks(addonInfo);
+                              });
 
   if (itAddon != disabledAddons.end())
   {
     // "Unable to configure controllers"
     // "Controller configuration depends on a disabled add-on. Would you like to enable it?"
-    bAccepted = (ShowYesNoDialogLines(CVariant{ 35017 }, CVariant{ 35018 }) == DialogResponse::YES);
+    bAccepted = (ShowYesNoDialogLines(CVariant{35017}, CVariant{35018}) == DialogResponse::YES);
   }
 
   if (bAccepted)
diff --git a/xbmc/peripherals/bus/virtual/PeripheralBusAddon.h b/xbmc/peripherals/bus/virtual/PeripheralBusAddon.h
index 380a7d8da1ca..a01b4c9ae3e4 100644
--- a/xbmc/peripherals/bus/virtual/PeripheralBusAddon.h
+++ b/xbmc/peripherals/bus/virtual/PeripheralBusAddon.h
@@ -19,68 +19,72 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralBusAddon : public CPeripheralBus
-  {
-  public:
-    explicit CPeripheralBusAddon(CPeripherals& manager);
-    ~CPeripheralBusAddon(void) override;
+class CPeripheralBusAddon : public CPeripheralBus
+{
+public:
+  explicit CPeripheralBusAddon(CPeripherals& manager);
+  ~CPeripheralBusAddon(void) override;
 
-    void UpdateAddons(void);
+  void UpdateAddons(void);
 
-    /*!
-    * \brief Get peripheral add-on that can provide button maps
-    */
-    bool GetAddonWithButtonMap(PeripheralAddonPtr &addon) const;
+  /*!
+   * \brief Get peripheral add-on that can provide button maps
+   */
+  bool GetAddonWithButtonMap(PeripheralAddonPtr& addon) const;
 
-    /*!
-     * \brief Get peripheral add-on that can provide button maps for the given device
-     */
-    bool GetAddonWithButtonMap(const CPeripheral* device, PeripheralAddonPtr &addon) const;
+  /*!
+   * \brief Get peripheral add-on that can provide button maps for the given device
+   */
+  bool GetAddonWithButtonMap(const CPeripheral* device, PeripheralAddonPtr& addon) const;
 
-    /*!
-     * \brief Set the rumble state of a rumble motor
-     *
-     * \param strLocation The location of the peripheral with the motor
-     * \param motorIndex  The index of the motor being rumbled
-     * \param magnitude   The amount of vibration in the closed interval [0.0, 1.0]
-     *
-     * \return true if the rumble motor's state is set, false otherwise
-     *
-     * TODO: Move declaration to parent class
-     */
-    bool SendRumbleEvent(const std::string& strLocation, unsigned int motorIndex, float magnitude);
+  /*!
+   * \brief Set the rumble state of a rumble motor
+   *
+   * \param strLocation The location of the peripheral with the motor
+   * \param motorIndex  The index of the motor being rumbled
+   * \param magnitude   The amount of vibration in the closed interval [0.0, 1.0]
+   *
+   * \return true if the rumble motor's state is set, false otherwise
+   *
+   * TODO: Move declaration to parent class
+   */
+  bool SendRumbleEvent(const std::string& strLocation, unsigned int motorIndex, float magnitude);
 
-    // Inherited from CPeripheralBus
-    bool InitializeProperties(CPeripheral& peripheral) override;
-    void Register(const PeripheralPtr& peripheral) override;
-    void GetFeatures(std::vector<PeripheralFeature> &features) const override;
-    bool HasFeature(const PeripheralFeature feature) const override;
-    PeripheralPtr GetPeripheral(const std::string &strLocation) const override;
-    PeripheralPtr GetByPath(const std::string &strPath) const override;
-    bool SupportsFeature(PeripheralFeature feature) const override;
-    unsigned int GetPeripheralsWithFeature(PeripheralVector &results, const PeripheralFeature feature) const override;
-    unsigned int GetNumberOfPeripherals(void) const override;
-    unsigned int GetNumberOfPeripheralsWithId(const int iVendorId, const int iProductId) const override;
-    void GetDirectory(const std::string &strPath, CFileItemList &items) const override;
-    void ProcessEvents(void) override;
-    void EnableButtonMapping() override;
-    void PowerOff(const std::string& strLocation) override;
+  // Inherited from CPeripheralBus
+  bool InitializeProperties(CPeripheral& peripheral) override;
+  void Register(const PeripheralPtr& peripheral) override;
+  void GetFeatures(std::vector<PeripheralFeature>& features) const override;
+  bool HasFeature(const PeripheralFeature feature) const override;
+  PeripheralPtr GetPeripheral(const std::string& strLocation) const override;
+  PeripheralPtr GetByPath(const std::string& strPath) const override;
+  bool SupportsFeature(PeripheralFeature feature) const override;
+  unsigned int GetPeripheralsWithFeature(PeripheralVector& results,
+                                         const PeripheralFeature feature) const override;
+  unsigned int GetNumberOfPeripherals(void) const override;
+  unsigned int GetNumberOfPeripheralsWithId(const int iVendorId,
+                                            const int iProductId) const override;
+  void GetDirectory(const std::string& strPath, CFileItemList& items) const override;
+  void ProcessEvents(void) override;
+  void EnableButtonMapping() override;
+  void PowerOff(const std::string& strLocation) override;
 
-    bool SplitLocation(const std::string& strLocation, PeripheralAddonPtr& addon, unsigned int& peripheralIndex) const;
+  bool SplitLocation(const std::string& strLocation,
+                     PeripheralAddonPtr& addon,
+                     unsigned int& peripheralIndex) const;
 
-  protected:
-    // Inherited from CPeripheralBus
-    bool PerformDeviceScan(PeripheralScanResults &results) override;
-    void UnregisterRemovedDevices(const PeripheralScanResults &results) override;
+protected:
+  // Inherited from CPeripheralBus
+  bool PerformDeviceScan(PeripheralScanResults& results) override;
+  void UnregisterRemovedDevices(const PeripheralScanResults& results) override;
 
-  private:
-    void OnEvent(const ADDON::AddonEvent& event);
-    void UnRegisterAddon(const std::string& addonId);
+private:
+  void OnEvent(const ADDON::AddonEvent& event);
+  void UnRegisterAddon(const std::string& addonId);
 
-    void PromptEnableAddons(const ADDON::BinaryAddonBaseList& disabledAddons);
+  void PromptEnableAddons(const ADDON::BinaryAddonBaseList& disabledAddons);
 
-    PeripheralAddonVector m_addons;
-    PeripheralAddonVector m_failedAddons;
-  };
-  using PeripheralBusAddonPtr = std::shared_ptr<CPeripheralBusAddon>;
-}
+  PeripheralAddonVector m_addons;
+  PeripheralAddonVector m_failedAddons;
+};
+using PeripheralBusAddonPtr = std::shared_ptr<CPeripheralBusAddon>;
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/bus/virtual/PeripheralBusApplication.cpp b/xbmc/peripherals/bus/virtual/PeripheralBusApplication.cpp
index b2dadba3106e..98bef3b9ae0a 100644
--- a/xbmc/peripherals/bus/virtual/PeripheralBusApplication.cpp
+++ b/xbmc/peripherals/bus/virtual/PeripheralBusApplication.cpp
@@ -16,8 +16,8 @@
 
 using namespace PERIPHERALS;
 
-CPeripheralBusApplication::CPeripheralBusApplication(CPeripherals& manager) :
-    CPeripheralBus("PeripBusApplication", manager, PERIPHERAL_BUS_APPLICATION)
+CPeripheralBusApplication::CPeripheralBusApplication(CPeripherals& manager)
+  : CPeripheralBus("PeripBusApplication", manager, PERIPHERAL_BUS_APPLICATION)
 {
   // Initialize CPeripheralBus
   m_bNeedsPolling = false;
@@ -33,20 +33,21 @@ bool CPeripheralBusApplication::PerformDeviceScan(PeripheralScanResults& results
 {
   {
     PeripheralScanResult result(Type());
-    result.m_type          = PERIPHERAL_KEYBOARD;
+    result.m_type = PERIPHERAL_KEYBOARD;
     result.m_strDeviceName = g_localizeStrings.Get(35150); // "Keyboard"
-    result.m_strLocation   = PeripheralTypeTranslator::TypeToString(PERIPHERAL_KEYBOARD);
-    result.m_iVendorId     = 0;
-    result.m_iProductId    = 0;
-    result.m_mappedType    = PERIPHERAL_KEYBOARD;
+    result.m_strLocation = PeripheralTypeTranslator::TypeToString(PERIPHERAL_KEYBOARD);
+    result.m_iVendorId = 0;
+    result.m_iProductId = 0;
+    result.m_mappedType = PERIPHERAL_KEYBOARD;
     result.m_mappedBusType = Type();
-    result.m_iSequence     = 0;
+    result.m_iSequence = 0;
 
     if (!results.ContainsResult(result))
       results.m_results.push_back(result);
   }
 
-  bool bHasMouse = CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_INPUT_ENABLEMOUSE);
+  bool bHasMouse = CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+      CSettings::SETTING_INPUT_ENABLEMOUSE);
 
   //! @todo Fix game clients to handle mouse disconnecting
   //! For now mouse is always connected
@@ -55,14 +56,14 @@ bool CPeripheralBusApplication::PerformDeviceScan(PeripheralScanResults& results
   if (bHasMouse)
   {
     PeripheralScanResult result(Type());
-    result.m_type          = PERIPHERAL_MOUSE;
+    result.m_type = PERIPHERAL_MOUSE;
     result.m_strDeviceName = g_localizeStrings.Get(35171); // "Mouse"
-    result.m_strLocation   = PeripheralTypeTranslator::TypeToString(PERIPHERAL_MOUSE);
-    result.m_iVendorId     = 0;
-    result.m_iProductId    = 0;
-    result.m_mappedType    = PERIPHERAL_MOUSE;
+    result.m_strLocation = PeripheralTypeTranslator::TypeToString(PERIPHERAL_MOUSE);
+    result.m_iVendorId = 0;
+    result.m_iProductId = 0;
+    result.m_mappedType = PERIPHERAL_MOUSE;
     result.m_mappedBusType = Type();
-    result.m_iSequence     = 0;
+    result.m_iSequence = 0;
 
     if (!results.ContainsResult(result))
       results.m_results.push_back(result);
@@ -71,7 +72,7 @@ bool CPeripheralBusApplication::PerformDeviceScan(PeripheralScanResults& results
   return true;
 }
 
-void CPeripheralBusApplication::GetDirectory(const std::string &strPath, CFileItemList &items) const
+void CPeripheralBusApplication::GetDirectory(const std::string& strPath, CFileItemList& items) const
 {
   // Don't list virtual devices in the GUI
 }
diff --git a/xbmc/peripherals/bus/virtual/PeripheralBusApplication.h b/xbmc/peripherals/bus/virtual/PeripheralBusApplication.h
index 8a175f330cca..4fcc40d93a51 100644
--- a/xbmc/peripherals/bus/virtual/PeripheralBusApplication.h
+++ b/xbmc/peripherals/bus/virtual/PeripheralBusApplication.h
@@ -12,29 +12,29 @@
 
 namespace PERIPHERALS
 {
-  /*!
-   * @class CPeripheralBusApplication
-   *
-   * This exposes peripherals that exist logically at the application level,
-   * such as emulated joysticks.
-   */
-  class CPeripheralBusApplication : public CPeripheralBus
-  {
-  public:
-    explicit CPeripheralBusApplication(CPeripherals& manager);
-    ~CPeripheralBusApplication(void) override = default;
+/*!
+ * @class CPeripheralBusApplication
+ *
+ * This exposes peripherals that exist logically at the application level,
+ * such as emulated joysticks.
+ */
+class CPeripheralBusApplication : public CPeripheralBus
+{
+public:
+  explicit CPeripheralBusApplication(CPeripherals& manager);
+  ~CPeripheralBusApplication(void) override = default;
 
-    // implementation of CPeripheralBus
-    void Initialise(void) override;
-    void GetDirectory(const std::string &strPath, CFileItemList &items) const override;
+  // implementation of CPeripheralBus
+  void Initialise(void) override;
+  void GetDirectory(const std::string& strPath, CFileItemList& items) const override;
 
-    /*!
-     * \brief Get the location for the specified controller index
-     */
-    std::string MakeLocation(unsigned int controllerIndex) const;
+  /*!
+   * \brief Get the location for the specified controller index
+   */
+  std::string MakeLocation(unsigned int controllerIndex) const;
 
-  protected:
-    // implementation of CPeripheralBus
-    bool PerformDeviceScan(PeripheralScanResults& results) override;
-  };
-}
+protected:
+  // implementation of CPeripheralBus
+  bool PerformDeviceScan(PeripheralScanResults& results) override;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/bus/virtual/PeripheralBusCEC.cpp b/xbmc/peripherals/bus/virtual/PeripheralBusCEC.cpp
index ee612328b3c0..0cbcd677852b 100644
--- a/xbmc/peripherals/bus/virtual/PeripheralBusCEC.cpp
+++ b/xbmc/peripherals/bus/virtual/PeripheralBusCEC.cpp
@@ -13,8 +13,8 @@
 using namespace PERIPHERALS;
 using namespace CEC;
 
-CPeripheralBusCEC::CPeripheralBusCEC(CPeripherals& manager) :
-    CPeripheralBus("PeripBusCEC", manager, PERIPHERAL_BUS_CEC)
+CPeripheralBusCEC::CPeripheralBusCEC(CPeripherals& manager)
+  : CPeripheralBus("PeripBusCEC", manager, PERIPHERAL_BUS_CEC)
 {
   m_cecAdapter = CECInitialise(&m_configuration);
 }
@@ -25,7 +25,7 @@ CPeripheralBusCEC::~CPeripheralBusCEC(void)
     CECDestroy(m_cecAdapter);
 }
 
-bool CPeripheralBusCEC::PerformDeviceScan(PeripheralScanResults &results)
+bool CPeripheralBusCEC::PerformDeviceScan(PeripheralScanResults& results)
 {
   cec_adapter_descriptor deviceList[10];
   int8_t iFound = m_cecAdapter->DetectAdapters(deviceList, 10, NULL, true);
@@ -33,25 +33,25 @@ bool CPeripheralBusCEC::PerformDeviceScan(PeripheralScanResults &results)
   for (uint8_t iDevicePtr = 0; iDevicePtr < iFound; iDevicePtr++)
   {
     PeripheralScanResult result(m_type);
-    result.m_iVendorId   = deviceList[iDevicePtr].iVendorId;
-    result.m_iProductId  = deviceList[iDevicePtr].iProductId;
+    result.m_iVendorId = deviceList[iDevicePtr].iVendorId;
+    result.m_iProductId = deviceList[iDevicePtr].iProductId;
     result.m_strLocation = deviceList[iDevicePtr].strComName;
-    result.m_type        = PERIPHERAL_CEC;
+    result.m_type = PERIPHERAL_CEC;
 
     // override the bus type, so users don't have to reconfigure their adapters
-    switch(deviceList[iDevicePtr].adapterType)
+    switch (deviceList[iDevicePtr].adapterType)
     {
-    case ADAPTERTYPE_P8_EXTERNAL:
-    case ADAPTERTYPE_P8_DAUGHTERBOARD:
-      result.m_mappedBusType = PERIPHERAL_BUS_USB;
-      break;
-    case ADAPTERTYPE_RPI:
-      result.m_mappedBusType = PERIPHERAL_BUS_RPI;
-      /** the Pi's adapter cannot be removed, no need to rescan */
-      m_bNeedsPolling = false;
-      break;
-    default:
-      break;
+      case ADAPTERTYPE_P8_EXTERNAL:
+      case ADAPTERTYPE_P8_DAUGHTERBOARD:
+        result.m_mappedBusType = PERIPHERAL_BUS_USB;
+        break;
+      case ADAPTERTYPE_RPI:
+        result.m_mappedBusType = PERIPHERAL_BUS_RPI;
+        /** the Pi's adapter cannot be removed, no need to rescan */
+        m_bNeedsPolling = false;
+        break;
+      default:
+        break;
     }
 
     result.m_iSequence = GetNumberOfPeripheralsWithId(result.m_iVendorId, result.m_iProductId);
diff --git a/xbmc/peripherals/bus/virtual/PeripheralBusCEC.h b/xbmc/peripherals/bus/virtual/PeripheralBusCEC.h
index da27bf44cb39..9aa2643b2293 100644
--- a/xbmc/peripherals/bus/virtual/PeripheralBusCEC.h
+++ b/xbmc/peripherals/bus/virtual/PeripheralBusCEC.h
@@ -18,26 +18,26 @@
 
 namespace CEC
 {
-  class ICECAdapter;
+class ICECAdapter;
 }
 
 namespace PERIPHERALS
 {
-  class CPeripherals;
-
-  class CPeripheralBusCEC : public CPeripheralBus
-  {
-  public:
-    explicit CPeripheralBusCEC(CPeripherals& manager);
-    ~CPeripheralBusCEC(void) override;
-
-    /*!
-     * @see PeripheralBus::PerformDeviceScan()
-     */
-    bool PerformDeviceScan(PeripheralScanResults &results) override;
-
-  private:
-    CEC::ICECAdapter*         m_cecAdapter;
-    CEC::libcec_configuration m_configuration;
-  };
-}
+class CPeripherals;
+
+class CPeripheralBusCEC : public CPeripheralBus
+{
+public:
+  explicit CPeripheralBusCEC(CPeripherals& manager);
+  ~CPeripheralBusCEC(void) override;
+
+  /*!
+   * @see PeripheralBus::PerformDeviceScan()
+   */
+  bool PerformDeviceScan(PeripheralScanResults& results) override;
+
+private:
+  CEC::ICECAdapter* m_cecAdapter;
+  CEC::libcec_configuration m_configuration;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/Peripheral.cpp b/xbmc/peripherals/devices/Peripheral.cpp
index a282d58a14ff..22fe9f509a5b 100644
--- a/xbmc/peripherals/devices/Peripheral.cpp
+++ b/xbmc/peripherals/devices/Peripheral.cpp
@@ -32,41 +32,43 @@ using namespace PERIPHERALS;
 
 struct SortBySettingsOrder
 {
-  bool operator()(const PeripheralDeviceSetting &left, const PeripheralDeviceSetting& right)
+  bool operator()(const PeripheralDeviceSetting& left, const PeripheralDeviceSetting& right)
   {
     return left.m_order < right.m_order;
   }
 };
 
-CPeripheral::CPeripheral(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  m_manager(manager),
-  m_type(scanResult.m_mappedType),
-  m_busType(scanResult.m_busType),
-  m_mappedBusType(scanResult.m_mappedBusType),
-  m_strLocation(scanResult.m_strLocation),
-  m_strDeviceName(scanResult.m_strDeviceName),
-  m_iVendorId(scanResult.m_iVendorId),
-  m_iProductId(scanResult.m_iProductId),
-  m_strVersionInfo(g_localizeStrings.Get(13205)), // "unknown"
-  m_bInitialised(false),
-  m_bHidden(false),
-  m_bError(false),
-  m_bus(bus)
+CPeripheral::CPeripheral(CPeripherals& manager,
+                         const PeripheralScanResult& scanResult,
+                         CPeripheralBus* bus)
+  : m_manager(manager),
+    m_type(scanResult.m_mappedType),
+    m_busType(scanResult.m_busType),
+    m_mappedBusType(scanResult.m_mappedBusType),
+    m_strLocation(scanResult.m_strLocation),
+    m_strDeviceName(scanResult.m_strDeviceName),
+    m_iVendorId(scanResult.m_iVendorId),
+    m_iProductId(scanResult.m_iProductId),
+    m_strVersionInfo(g_localizeStrings.Get(13205)), // "unknown"
+    m_bInitialised(false),
+    m_bHidden(false),
+    m_bError(false),
+    m_bus(bus)
 {
   PeripheralTypeTranslator::FormatHexString(scanResult.m_iVendorId, m_strVendorId);
   PeripheralTypeTranslator::FormatHexString(scanResult.m_iProductId, m_strProductId);
   if (scanResult.m_iSequence > 0)
   {
-    m_strFileLocation = StringUtils::Format("peripherals://%s/%s_%d.dev",
-                                            PeripheralTypeTranslator::BusTypeToString(scanResult.m_busType),
-                                            scanResult.m_strLocation.c_str(),
-                                            scanResult.m_iSequence);
+    m_strFileLocation =
+        StringUtils::Format("peripherals://%s/%s_%d.dev",
+                            PeripheralTypeTranslator::BusTypeToString(scanResult.m_busType),
+                            scanResult.m_strLocation.c_str(), scanResult.m_iSequence);
   }
   else
   {
-    m_strFileLocation = StringUtils::Format("peripherals://%s/%s.dev",
-                                            PeripheralTypeTranslator::BusTypeToString(scanResult.m_busType),
-                                            scanResult.m_strLocation.c_str());
+    m_strFileLocation = StringUtils::Format(
+        "peripherals://%s/%s.dev", PeripheralTypeTranslator::BusTypeToString(scanResult.m_busType),
+        scanResult.m_strLocation.c_str());
   }
 }
 
@@ -79,15 +81,13 @@ CPeripheral::~CPeripheral(void)
   ClearSettings();
 }
 
-bool CPeripheral::operator ==(const CPeripheral &right) const
+bool CPeripheral::operator==(const CPeripheral& right) const
 {
-  return m_type == right.m_type &&
-      m_strLocation == right.m_strLocation &&
-      m_iVendorId == right.m_iVendorId &&
-      m_iProductId == right.m_iProductId;
+  return m_type == right.m_type && m_strLocation == right.m_strLocation &&
+         m_iVendorId == right.m_iVendorId && m_iProductId == right.m_iProductId;
 }
 
-bool CPeripheral::operator !=(const CPeripheral &right) const
+bool CPeripheral::operator!=(const CPeripheral& right) const
 {
   return !(*this == right);
 }
@@ -120,7 +120,7 @@ bool CPeripheral::HasFeature(const PeripheralFeature feature) const
   return bReturn;
 }
 
-void CPeripheral::GetFeatures(std::vector<PeripheralFeature> &features) const
+void CPeripheral::GetFeatures(std::vector<PeripheralFeature>& features) const
 {
   for (unsigned int iFeaturePtr = 0; iFeaturePtr < m_features.size(); iFeaturePtr++)
     features.push_back(m_features.at(iFeaturePtr));
@@ -147,24 +147,25 @@ bool CPeripheral::Initialise(void)
 
   if (m_iVendorId == 0x0000 && m_iProductId == 0x0000)
   {
-    m_strSettingsFile = StringUtils::Format("special://profile/peripheral_data/%s_%s.xml",
-                                            PeripheralTypeTranslator::BusTypeToString(m_mappedBusType),
-                                            CUtil::MakeLegalFileName(safeDeviceName, LEGAL_WIN32_COMPAT).c_str());
+    m_strSettingsFile =
+        StringUtils::Format("special://profile/peripheral_data/%s_%s.xml",
+                            PeripheralTypeTranslator::BusTypeToString(m_mappedBusType),
+                            CUtil::MakeLegalFileName(safeDeviceName, LEGAL_WIN32_COMPAT).c_str());
   }
   else
   {
     // Backwards compatibility - old settings files didn't include the device name
-    m_strSettingsFile = StringUtils::Format("special://profile/peripheral_data/%s_%s_%s.xml",
-                                            PeripheralTypeTranslator::BusTypeToString(m_mappedBusType),
-                                            m_strVendorId.c_str(),
-                                            m_strProductId.c_str());
+    m_strSettingsFile =
+        StringUtils::Format("special://profile/peripheral_data/%s_%s_%s.xml",
+                            PeripheralTypeTranslator::BusTypeToString(m_mappedBusType),
+                            m_strVendorId.c_str(), m_strProductId.c_str());
 
     if (!XFILE::CFile::Exists(m_strSettingsFile))
-      m_strSettingsFile = StringUtils::Format("special://profile/peripheral_data/%s_%s_%s_%s.xml",
-                                              PeripheralTypeTranslator::BusTypeToString(m_mappedBusType),
-                                              m_strVendorId.c_str(),
-                                              m_strProductId.c_str(),
-                                              CUtil::MakeLegalFileName(safeDeviceName, LEGAL_WIN32_COMPAT).c_str());
+      m_strSettingsFile =
+          StringUtils::Format("special://profile/peripheral_data/%s_%s_%s_%s.xml",
+                              PeripheralTypeTranslator::BusTypeToString(m_mappedBusType),
+                              m_strVendorId.c_str(), m_strProductId.c_str(),
+                              CUtil::MakeLegalFileName(safeDeviceName, LEGAL_WIN32_COMPAT).c_str());
   }
 
   LoadPersistedSettings();
@@ -181,14 +182,15 @@ bool CPeripheral::Initialise(void)
   if (bReturn)
   {
     CLog::Log(LOGDEBUG, "%s - initialised peripheral on '%s' with %d features and %d sub devices",
-      __FUNCTION__, m_strLocation.c_str(), (int)m_features.size(), (int)m_subDevices.size());
+              __FUNCTION__, m_strLocation.c_str(), (int)m_features.size(),
+              (int)m_subDevices.size());
     m_bInitialised = true;
   }
 
   return bReturn;
 }
 
-void CPeripheral::GetSubdevices(PeripheralVector &subDevices) const
+void CPeripheral::GetSubdevices(PeripheralVector& subDevices) const
 {
   subDevices = m_subDevices;
 }
@@ -211,7 +213,7 @@ std::vector<std::shared_ptr<CSetting>> CPeripheral::GetSettings(void) const
   return settings;
 }
 
-void CPeripheral::AddSetting(const std::string &strKey, SettingConstPtr setting, int order)
+void CPeripheral::AddSetting(const std::string& strKey, SettingConstPtr setting, int order)
 {
   if (!setting)
   {
@@ -221,13 +223,15 @@ void CPeripheral::AddSetting(const std::string &strKey, SettingConstPtr setting,
 
   if (!HasSetting(strKey))
   {
-    PeripheralDeviceSetting deviceSetting = { NULL, order };
-    switch(setting->GetType())
+    PeripheralDeviceSetting deviceSetting = {NULL, order};
+    switch (setting->GetType())
     {
-    case SettingType::Boolean:
+      case SettingType::Boolean:
       {
-        std::shared_ptr<const CSettingBool> mappedSetting = std::static_pointer_cast<const CSettingBool>(setting);
-        std::shared_ptr<CSettingBool> boolSetting = std::make_shared<CSettingBool>(strKey, *mappedSetting);
+        std::shared_ptr<const CSettingBool> mappedSetting =
+            std::static_pointer_cast<const CSettingBool>(setting);
+        std::shared_ptr<CSettingBool> boolSetting =
+            std::make_shared<CSettingBool>(strKey, *mappedSetting);
         if (boolSetting)
         {
           boolSetting->SetVisible(mappedSetting->IsVisible());
@@ -235,10 +239,12 @@ void CPeripheral::AddSetting(const std::string &strKey, SettingConstPtr setting,
         }
       }
       break;
-    case SettingType::Integer:
+      case SettingType::Integer:
       {
-        std::shared_ptr<const CSettingInt> mappedSetting = std::static_pointer_cast<const CSettingInt>(setting);
-        std::shared_ptr<CSettingInt> intSetting = std::make_shared<CSettingInt>(strKey, *mappedSetting);
+        std::shared_ptr<const CSettingInt> mappedSetting =
+            std::static_pointer_cast<const CSettingInt>(setting);
+        std::shared_ptr<CSettingInt> intSetting =
+            std::make_shared<CSettingInt>(strKey, *mappedSetting);
         if (intSetting)
         {
           intSetting->SetVisible(mappedSetting->IsVisible());
@@ -246,10 +252,12 @@ void CPeripheral::AddSetting(const std::string &strKey, SettingConstPtr setting,
         }
       }
       break;
-    case SettingType::Number:
+      case SettingType::Number:
       {
-        std::shared_ptr<const CSettingNumber> mappedSetting = std::static_pointer_cast<const CSettingNumber>(setting);
-        std::shared_ptr<CSettingNumber> floatSetting = std::make_shared<CSettingNumber>(strKey, *mappedSetting);
+        std::shared_ptr<const CSettingNumber> mappedSetting =
+            std::static_pointer_cast<const CSettingNumber>(setting);
+        std::shared_ptr<CSettingNumber> floatSetting =
+            std::make_shared<CSettingNumber>(strKey, *mappedSetting);
         if (floatSetting)
         {
           floatSetting->SetVisible(mappedSetting->IsVisible());
@@ -257,10 +265,12 @@ void CPeripheral::AddSetting(const std::string &strKey, SettingConstPtr setting,
         }
       }
       break;
-    case SettingType::String:
+      case SettingType::String:
       {
-        std::shared_ptr<const CSettingString> mappedSetting = std::static_pointer_cast<const CSettingString>(setting);
-        std::shared_ptr<CSettingString> stringSetting = std::make_shared<CSettingString>(strKey, *mappedSetting);
+        std::shared_ptr<const CSettingString> mappedSetting =
+            std::static_pointer_cast<const CSettingString>(setting);
+        std::shared_ptr<CSettingString> stringSetting =
+            std::make_shared<CSettingString>(strKey, *mappedSetting);
         if (stringSetting)
         {
           stringSetting->SetVisible(mappedSetting->IsVisible());
@@ -268,9 +278,9 @@ void CPeripheral::AddSetting(const std::string &strKey, SettingConstPtr setting,
         }
       }
       break;
-    default:
-      //! @todo add more types if needed
-      break;
+      default:
+        //! @todo add more types if needed
+        break;
     }
 
     if (deviceSetting.m_setting != NULL)
@@ -278,9 +288,9 @@ void CPeripheral::AddSetting(const std::string &strKey, SettingConstPtr setting,
   }
 }
 
-bool CPeripheral::HasSetting(const std::string &strKey) const
+bool CPeripheral::HasSetting(const std::string& strKey) const
 {
-  std::map<std::string, PeripheralDeviceSetting>:: const_iterator it = m_settings.find(strKey);
+  std::map<std::string, PeripheralDeviceSetting>::const_iterator it = m_settings.find(strKey);
   return it != m_settings.end();
 }
 
@@ -307,12 +317,13 @@ bool CPeripheral::HasConfigurableSettings(void) const
   return bReturn;
 }
 
-bool CPeripheral::GetSettingBool(const std::string &strKey) const
+bool CPeripheral::GetSettingBool(const std::string& strKey) const
 {
   std::map<std::string, PeripheralDeviceSetting>::const_iterator it = m_settings.find(strKey);
   if (it != m_settings.end() && (*it).second.m_setting->GetType() == SettingType::Boolean)
   {
-    std::shared_ptr<CSettingBool> boolSetting = std::static_pointer_cast<CSettingBool>((*it).second.m_setting);
+    std::shared_ptr<CSettingBool> boolSetting =
+        std::static_pointer_cast<CSettingBool>((*it).second.m_setting);
     if (boolSetting)
       return boolSetting->GetValue();
   }
@@ -320,12 +331,13 @@ bool CPeripheral::GetSettingBool(const std::string &strKey) const
   return false;
 }
 
-int CPeripheral::GetSettingInt(const std::string &strKey) const
+int CPeripheral::GetSettingInt(const std::string& strKey) const
 {
   std::map<std::string, PeripheralDeviceSetting>::const_iterator it = m_settings.find(strKey);
   if (it != m_settings.end() && (*it).second.m_setting->GetType() == SettingType::Integer)
   {
-    std::shared_ptr<CSettingInt> intSetting = std::static_pointer_cast<CSettingInt>((*it).second.m_setting);
+    std::shared_ptr<CSettingInt> intSetting =
+        std::static_pointer_cast<CSettingInt>((*it).second.m_setting);
     if (intSetting)
       return intSetting->GetValue();
   }
@@ -333,12 +345,13 @@ int CPeripheral::GetSettingInt(const std::string &strKey) const
   return 0;
 }
 
-float CPeripheral::GetSettingFloat(const std::string &strKey) const
+float CPeripheral::GetSettingFloat(const std::string& strKey) const
 {
   std::map<std::string, PeripheralDeviceSetting>::const_iterator it = m_settings.find(strKey);
   if (it != m_settings.end() && (*it).second.m_setting->GetType() == SettingType::Number)
   {
-    std::shared_ptr<CSettingNumber> floatSetting = std::static_pointer_cast<CSettingNumber>((*it).second.m_setting);
+    std::shared_ptr<CSettingNumber> floatSetting =
+        std::static_pointer_cast<CSettingNumber>((*it).second.m_setting);
     if (floatSetting)
       return (float)floatSetting->GetValue();
   }
@@ -346,12 +359,13 @@ float CPeripheral::GetSettingFloat(const std::string &strKey) const
   return 0;
 }
 
-const std::string CPeripheral::GetSettingString(const std::string &strKey) const
+const std::string CPeripheral::GetSettingString(const std::string& strKey) const
 {
   std::map<std::string, PeripheralDeviceSetting>::const_iterator it = m_settings.find(strKey);
   if (it != m_settings.end() && (*it).second.m_setting->GetType() == SettingType::String)
   {
-    std::shared_ptr<CSettingString> stringSetting = std::static_pointer_cast<CSettingString>((*it).second.m_setting);
+    std::shared_ptr<CSettingString> stringSetting =
+        std::static_pointer_cast<CSettingString>((*it).second.m_setting);
     if (stringSetting)
       return stringSetting->GetValue();
   }
@@ -359,13 +373,14 @@ const std::string CPeripheral::GetSettingString(const std::string &strKey) const
   return "";
 }
 
-bool CPeripheral::SetSetting(const std::string &strKey, bool bValue)
+bool CPeripheral::SetSetting(const std::string& strKey, bool bValue)
 {
   bool bChanged(false);
   std::map<std::string, PeripheralDeviceSetting>::iterator it = m_settings.find(strKey);
   if (it != m_settings.end() && (*it).second.m_setting->GetType() == SettingType::Boolean)
   {
-    std::shared_ptr<CSettingBool> boolSetting = std::static_pointer_cast<CSettingBool>((*it).second.m_setting);
+    std::shared_ptr<CSettingBool> boolSetting =
+        std::static_pointer_cast<CSettingBool>((*it).second.m_setting);
     if (boolSetting)
     {
       bChanged = boolSetting->GetValue() != bValue;
@@ -377,13 +392,14 @@ bool CPeripheral::SetSetting(const std::string &strKey, bool bValue)
   return bChanged;
 }
 
-bool CPeripheral::SetSetting(const std::string &strKey, int iValue)
+bool CPeripheral::SetSetting(const std::string& strKey, int iValue)
 {
   bool bChanged(false);
   std::map<std::string, PeripheralDeviceSetting>::iterator it = m_settings.find(strKey);
   if (it != m_settings.end() && (*it).second.m_setting->GetType() == SettingType::Integer)
   {
-    std::shared_ptr<CSettingInt> intSetting = std::static_pointer_cast<CSettingInt>((*it).second.m_setting);
+    std::shared_ptr<CSettingInt> intSetting =
+        std::static_pointer_cast<CSettingInt>((*it).second.m_setting);
     if (intSetting)
     {
       bChanged = intSetting->GetValue() != iValue;
@@ -395,13 +411,14 @@ bool CPeripheral::SetSetting(const std::string &strKey, int iValue)
   return bChanged;
 }
 
-bool CPeripheral::SetSetting(const std::string &strKey, float fValue)
+bool CPeripheral::SetSetting(const std::string& strKey, float fValue)
 {
   bool bChanged(false);
   std::map<std::string, PeripheralDeviceSetting>::iterator it = m_settings.find(strKey);
   if (it != m_settings.end() && (*it).second.m_setting->GetType() == SettingType::Number)
   {
-    std::shared_ptr<CSettingNumber> floatSetting = std::static_pointer_cast<CSettingNumber>((*it).second.m_setting);
+    std::shared_ptr<CSettingNumber> floatSetting =
+        std::static_pointer_cast<CSettingNumber>((*it).second.m_setting);
     if (floatSetting)
     {
       bChanged = floatSetting->GetValue() != fValue;
@@ -413,14 +430,14 @@ bool CPeripheral::SetSetting(const std::string &strKey, float fValue)
   return bChanged;
 }
 
-void CPeripheral::SetSettingVisible(const std::string &strKey, bool bSetTo)
+void CPeripheral::SetSettingVisible(const std::string& strKey, bool bSetTo)
 {
   std::map<std::string, PeripheralDeviceSetting>::iterator it = m_settings.find(strKey);
   if (it != m_settings.end())
     (*it).second.m_setting->SetVisible(bSetTo);
 }
 
-bool CPeripheral::IsSettingVisible(const std::string &strKey) const
+bool CPeripheral::IsSettingVisible(const std::string& strKey) const
 {
   std::map<std::string, PeripheralDeviceSetting>::const_iterator it = m_settings.find(strKey);
   if (it != m_settings.end())
@@ -428,7 +445,7 @@ bool CPeripheral::IsSettingVisible(const std::string &strKey) const
   return false;
 }
 
-bool CPeripheral::SetSetting(const std::string &strKey, const std::string &strValue)
+bool CPeripheral::SetSetting(const std::string& strKey, const std::string& strValue)
 {
   bool bChanged(false);
   std::map<std::string, PeripheralDeviceSetting>::iterator it = m_settings.find(strKey);
@@ -436,7 +453,8 @@ bool CPeripheral::SetSetting(const std::string &strKey, const std::string &strVa
   {
     if ((*it).second.m_setting->GetType() == SettingType::String)
     {
-      std::shared_ptr<CSettingString> stringSetting = std::static_pointer_cast<CSettingString>((*it).second.m_setting);
+      std::shared_ptr<CSettingString> stringSetting =
+          std::static_pointer_cast<CSettingString>((*it).second.m_setting);
       if (stringSetting)
       {
         bChanged = !StringUtils::EqualsNoCase(stringSetting->GetValue(), strValue);
@@ -448,7 +466,7 @@ bool CPeripheral::SetSetting(const std::string &strKey, const std::string &strVa
     else if ((*it).second.m_setting->GetType() == SettingType::Integer)
       bChanged = SetSetting(strKey, strValue.empty() ? 0 : atoi(strValue.c_str()));
     else if ((*it).second.m_setting->GetType() == SettingType::Number)
-      bChanged = SetSetting(strKey, (float) (strValue.empty() ? 0 : atof(strValue.c_str())));
+      bChanged = SetSetting(strKey, (float)(strValue.empty() ? 0 : atof(strValue.c_str())));
     else if ((*it).second.m_setting->GetType() == SettingType::Boolean)
       bChanged = SetSetting(strKey, strValue == "1");
   }
@@ -467,7 +485,7 @@ void CPeripheral::PersistSettings(bool bExiting /* = false */)
     std::string strValue;
     switch (itr.second.m_setting->GetType())
     {
-    case SettingType::String:
+      case SettingType::String:
       {
         std::shared_ptr<CSettingString> stringSetting =
             std::static_pointer_cast<CSettingString>(itr.second.m_setting);
@@ -475,7 +493,7 @@ void CPeripheral::PersistSettings(bool bExiting /* = false */)
           strValue = stringSetting->GetValue();
       }
       break;
-    case SettingType::Integer:
+      case SettingType::Integer:
       {
         std::shared_ptr<CSettingInt> intSetting =
             std::static_pointer_cast<CSettingInt>(itr.second.m_setting);
@@ -483,7 +501,7 @@ void CPeripheral::PersistSettings(bool bExiting /* = false */)
           strValue = StringUtils::Format("%d", intSetting->GetValue());
       }
       break;
-    case SettingType::Number:
+      case SettingType::Number:
       {
         std::shared_ptr<CSettingNumber> floatSetting =
             std::static_pointer_cast<CSettingNumber>(itr.second.m_setting);
@@ -491,16 +509,16 @@ void CPeripheral::PersistSettings(bool bExiting /* = false */)
           strValue = StringUtils::Format("%.2f", floatSetting->GetValue());
       }
       break;
-    case SettingType::Boolean:
+      case SettingType::Boolean:
       {
         std::shared_ptr<CSettingBool> boolSetting =
             std::static_pointer_cast<CSettingBool>(itr.second.m_setting);
         if (boolSetting)
-          strValue = StringUtils::Format("%d", boolSetting->GetValue() ? 1:0);
+          strValue = StringUtils::Format("%d", boolSetting->GetValue() ? 1 : 0);
       }
       break;
-    default:
-      break;
+      default:
+        break;
     }
     nodeSetting.SetAttribute("value", strValue.c_str());
     doc.RootElement()->InsertEndChild(nodeSetting);
@@ -521,10 +539,10 @@ void CPeripheral::LoadPersistedSettings(void)
   CXBMCTinyXML doc;
   if (doc.LoadFile(m_strSettingsFile))
   {
-    const TiXmlElement *setting = doc.RootElement()->FirstChildElement("setting");
+    const TiXmlElement* setting = doc.RootElement()->FirstChildElement("setting");
     while (setting)
     {
-      std::string    strId = XMLUtils::GetAttribute(setting, "id");
+      std::string strId = XMLUtils::GetAttribute(setting, "id");
       std::string strValue = XMLUtils::GetAttribute(setting, "value");
       SetSetting(strId, strValue);
 
@@ -558,7 +576,8 @@ void CPeripheral::RegisterInputHandler(IInputHandler* handler, bool bPromiscuous
   auto it = m_inputHandlers.find(handler);
   if (it == m_inputHandlers.end())
   {
-    CAddonInputHandling* addonInput = new CAddonInputHandling(m_manager, this, handler, GetDriverReceiver());
+    CAddonInputHandling* addonInput =
+        new CAddonInputHandling(m_manager, this, handler, GetDriverReceiver());
     RegisterJoystickDriverHandler(addonInput, bPromiscuous);
     m_inputHandlers[handler].reset(addonInput);
   }
@@ -576,12 +595,14 @@ void CPeripheral::UnregisterInputHandler(IInputHandler* handler)
   }
 }
 
-void CPeripheral::RegisterKeyboardHandler(KEYBOARD::IKeyboardInputHandler* handler, bool bPromiscuous)
+void CPeripheral::RegisterKeyboardHandler(KEYBOARD::IKeyboardInputHandler* handler,
+                                          bool bPromiscuous)
 {
   auto it = m_keyboardHandlers.find(handler);
   if (it == m_keyboardHandlers.end())
   {
-    std::unique_ptr<CAddonInputHandling> addonInput(new CAddonInputHandling(m_manager, this, handler));
+    std::unique_ptr<CAddonInputHandling> addonInput(
+        new CAddonInputHandling(m_manager, this, handler));
     RegisterKeyboardDriverHandler(addonInput.get(), bPromiscuous);
     m_keyboardHandlers[handler] = std::move(addonInput);
   }
@@ -602,7 +623,8 @@ void CPeripheral::RegisterMouseHandler(MOUSE::IMouseInputHandler* handler, bool
   auto it = m_mouseHandlers.find(handler);
   if (it == m_mouseHandlers.end())
   {
-    std::unique_ptr<CAddonInputHandling> addonInput(new CAddonInputHandling(m_manager, this, handler));
+    std::unique_ptr<CAddonInputHandling> addonInput(
+        new CAddonInputHandling(m_manager, this, handler));
     RegisterMouseDriverHandler(addonInput.get(), bPromiscuous);
     m_mouseHandlers[handler] = std::move(addonInput);
   }
@@ -623,7 +645,8 @@ void CPeripheral::RegisterJoystickButtonMapper(IButtonMapper* mapper)
   auto it = m_buttonMappers.find(mapper);
   if (it == m_buttonMappers.end())
   {
-    std::unique_ptr<CAddonButtonMapping> addonMapping(new CAddonButtonMapping(m_manager, this, mapper));
+    std::unique_ptr<CAddonButtonMapping> addonMapping(
+        new CAddonButtonMapping(m_manager, this, mapper));
 
     RegisterJoystickDriverHandler(addonMapping.get(), false);
     RegisterKeyboardDriverHandler(addonMapping.get(), false);
@@ -667,12 +690,12 @@ std::string CPeripheral::GetIcon() const
   return icon;
 }
 
-bool CPeripheral::operator ==(const PeripheralScanResult& right) const
+bool CPeripheral::operator==(const PeripheralScanResult& right) const
 {
   return StringUtils::EqualsNoCase(m_strLocation, right.m_strLocation);
 }
 
-bool CPeripheral::operator !=(const PeripheralScanResult& right) const
+bool CPeripheral::operator!=(const PeripheralScanResult& right) const
 {
   return !(*this == right);
 }
diff --git a/xbmc/peripherals/devices/Peripheral.h b/xbmc/peripherals/devices/Peripheral.h
index ade9ab9e045a..5ba510a88179 100644
--- a/xbmc/peripherals/devices/Peripheral.h
+++ b/xbmc/peripherals/devices/Peripheral.h
@@ -27,244 +27,261 @@ namespace KODI
 {
 namespace JOYSTICK
 {
-  class IButtonMapper;
-  class IDriverHandler;
-  class IDriverReceiver;
-  class IInputHandler;
-}
+class IButtonMapper;
+class IDriverHandler;
+class IDriverReceiver;
+class IInputHandler;
+} // namespace JOYSTICK
 
 namespace KEYBOARD
 {
-  class IKeyboardDriverHandler;
+class IKeyboardDriverHandler;
 }
 
 namespace MOUSE
 {
-  class IMouseDriverHandler;
-}
+class IMouseDriverHandler;
 }
+} // namespace KODI
 
 namespace PERIPHERALS
 {
-  class CAddonButtonMapping;
-  class CGUIDialogPeripheralSettings;
-  class CPeripheralBus;
-  class CPeripherals;
+class CAddonButtonMapping;
+class CGUIDialogPeripheralSettings;
+class CPeripheralBus;
+class CPeripherals;
+
+typedef enum
+{
+  STATE_SWITCH_TOGGLE,
+  STATE_ACTIVATE_SOURCE,
+  STATE_STANDBY
+} CecStateChange;
+
+class CPeripheral : public KODI::JOYSTICK::IInputProvider,
+                    public KODI::KEYBOARD::IKeyboardInputProvider,
+                    public KODI::MOUSE::IMouseInputProvider
+{
+  friend class CGUIDialogPeripheralSettings;
+
+public:
+  CPeripheral(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
+  ~CPeripheral(void) override;
+
+  bool operator==(const CPeripheral& right) const;
+  bool operator!=(const CPeripheral& right) const;
+  bool operator==(const PeripheralScanResult& right) const;
+  bool operator!=(const PeripheralScanResult& right) const;
+
+  const std::string& FileLocation(void) const { return m_strFileLocation; }
+  const std::string& Location(void) const { return m_strLocation; }
+  int VendorId(void) const { return m_iVendorId; }
+  const char* VendorIdAsString(void) const { return m_strVendorId.c_str(); }
+  int ProductId(void) const { return m_iProductId; }
+  const char* ProductIdAsString(void) const { return m_strProductId.c_str(); }
+  PeripheralType Type(void) const { return m_type; }
+  PeripheralBusType GetBusType(void) const { return m_busType; };
+  const std::string& DeviceName(void) const { return m_strDeviceName; }
+  bool IsHidden(void) const { return m_bHidden; }
+  void SetHidden(bool bSetTo = true) { m_bHidden = bSetTo; }
+  const std::string& GetVersionInfo(void) const { return m_strVersionInfo; }
+
+  /*!
+   * @brief Get an icon for this peripheral
+   * @return Path to an icon, or skin icon file name
+   */
+  virtual std::string GetIcon() const;
+
+  /*!
+   * @brief Check whether this device has the given feature.
+   * @param feature The feature to check for.
+   * @return True when the device has the feature, false otherwise.
+   */
+  bool HasFeature(const PeripheralFeature feature) const;
+
+  /*!
+   * @brief Get all features that are supported by this device.
+   * @param features The features.
+   */
+  void GetFeatures(std::vector<PeripheralFeature>& features) const;
+
+  /*!
+   * @brief Initialises the peripheral.
+   * @return True when the peripheral has been initialised successfully, false otherwise.
+   */
+  bool Initialise(void);
+
+  /*!
+   * @brief Initialise one of the features of this peripheral.
+   * @param feature The feature to initialise.
+   * @return True when the feature has been initialised successfully, false otherwise.
+   */
+  virtual bool InitialiseFeature(const PeripheralFeature feature) { return true; }
+
+  /*!
+   * @brief Briefly activate a feature to notify the user
+   */
+  virtual void OnUserNotification() {}
+
+  /*!
+   * @brief Briefly test one of the features of this peripheral.
+   * @param feature The feature to test.
+   * @return True if the test succeeded, false otherwise.
+   */
+  virtual bool TestFeature(PeripheralFeature feature) { return false; }
+
+  /*!
+   * @brief Called when a setting changed.
+   * @param strChangedSetting The changed setting.
+   */
+  virtual void OnSettingChanged(const std::string& strChangedSetting){};
+
+  /*!
+   * @brief Called when this device is removed, before calling the destructor.
+   */
+  virtual void OnDeviceRemoved(void) {}
+
+  /*!
+   * @brief Get all subdevices if this device is multifunctional.
+   * @param subDevices The subdevices.
+   */
+  virtual void GetSubdevices(PeripheralVector& subDevices) const;
+
+  /*!
+   * @return True when this device is multifunctional, false otherwise.
+   */
+  virtual bool IsMultiFunctional(void) const;
+
+  /*!
+   * @brief Add a setting to this peripheral. This will overwrite a previous setting with the same
+   * key.
+   * @param strKey The key of the setting.
+   * @param setting The setting.
+   */
+  virtual void AddSetting(const std::string& strKey,
+                          std::shared_ptr<const CSetting> setting,
+                          int order);
+
+  /*!
+   * @brief Check whether a setting is known with the given key.
+   * @param strKey The key to search.
+   * @return True when found, false otherwise.
+   */
+  virtual bool HasSetting(const std::string& strKey) const;
+
+  /*!
+   * @return True when this device has any settings, false otherwise.
+   */
+  virtual bool HasSettings(void) const;
+
+  /*!
+   * @return True when this device has any configurable settings, false otherwise.
+   */
+  virtual bool HasConfigurableSettings(void) const;
+
+  /*!
+   * @brief Get the value of a setting.
+   * @param strKey The key to search.
+   * @return The value or an empty string if it wasn't found.
+   */
+  virtual const std::string GetSettingString(const std::string& strKey) const;
+  virtual bool SetSetting(const std::string& strKey, const std::string& strValue);
+  virtual void SetSettingVisible(const std::string& strKey, bool bSetTo);
+  virtual bool IsSettingVisible(const std::string& strKey) const;
+
+  virtual int GetSettingInt(const std::string& strKey) const;
+  virtual bool SetSetting(const std::string& strKey, int iValue);
+
+  virtual bool GetSettingBool(const std::string& strKey) const;
+  virtual bool SetSetting(const std::string& strKey, bool bValue);
+
+  virtual float GetSettingFloat(const std::string& strKey) const;
+  virtual bool SetSetting(const std::string& strKey, float fValue);
+
+  virtual void PersistSettings(bool bExiting = false);
+  virtual void LoadPersistedSettings(void);
+  virtual void ResetDefaultSettings(void);
+
+  virtual std::vector<std::shared_ptr<CSetting>> GetSettings(void) const;
+
+  virtual bool ErrorOccured(void) const { return m_bError; }
+
+  virtual void RegisterJoystickDriverHandler(KODI::JOYSTICK::IDriverHandler* handler,
+                                             bool bPromiscuous)
+  {
+  }
+  virtual void UnregisterJoystickDriverHandler(KODI::JOYSTICK::IDriverHandler* handler) {}
 
-  typedef enum
+  virtual void RegisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler,
+                                             bool bPromiscuous)
   {
-    STATE_SWITCH_TOGGLE,
-    STATE_ACTIVATE_SOURCE,
-    STATE_STANDBY
-  } CecStateChange;
-
-  class CPeripheral : public KODI::JOYSTICK::IInputProvider,
-                      public KODI::KEYBOARD::IKeyboardInputProvider,
-                      public KODI::MOUSE::IMouseInputProvider
+  }
+  virtual void UnregisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler) {}
+
+  virtual void RegisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler,
+                                          bool bPromiscuous)
   {
-    friend class CGUIDialogPeripheralSettings;
-
-  public:
-    CPeripheral(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheral(void) override;
-
-    bool operator ==(const CPeripheral &right) const;
-    bool operator !=(const CPeripheral &right) const;
-    bool operator ==(const PeripheralScanResult& right) const;
-    bool operator !=(const PeripheralScanResult& right) const;
-
-    const std::string &FileLocation(void) const     { return m_strFileLocation; }
-    const std::string &Location(void) const         { return m_strLocation; }
-    int VendorId(void) const                       { return m_iVendorId; }
-    const char *VendorIdAsString(void) const       { return m_strVendorId.c_str(); }
-    int ProductId(void) const                      { return m_iProductId; }
-    const char *ProductIdAsString(void) const      { return m_strProductId.c_str(); }
-    PeripheralType Type(void) const          { return m_type; }
-    PeripheralBusType GetBusType(void) const { return m_busType; };
-    const std::string &DeviceName(void) const       { return m_strDeviceName; }
-    bool IsHidden(void) const                      { return m_bHidden; }
-    void SetHidden(bool bSetTo = true)             { m_bHidden = bSetTo; }
-    const std::string &GetVersionInfo(void) const   { return m_strVersionInfo; }
-
-    /*!
-     * @brief Get an icon for this peripheral
-     * @return Path to an icon, or skin icon file name
-     */
-    virtual std::string GetIcon() const;
-
-    /*!
-     * @brief Check whether this device has the given feature.
-     * @param feature The feature to check for.
-     * @return True when the device has the feature, false otherwise.
-     */
-    bool HasFeature(const PeripheralFeature feature) const;
-
-    /*!
-     * @brief Get all features that are supported by this device.
-     * @param features The features.
-     */
-    void GetFeatures(std::vector<PeripheralFeature> &features) const;
-
-    /*!
-     * @brief Initialises the peripheral.
-     * @return True when the peripheral has been initialised successfully, false otherwise.
-     */
-    bool Initialise(void);
-
-    /*!
-     * @brief Initialise one of the features of this peripheral.
-     * @param feature The feature to initialise.
-     * @return True when the feature has been initialised successfully, false otherwise.
-     */
-    virtual bool InitialiseFeature(const PeripheralFeature feature) { return true; }
-
-    /*!
-    * @brief Briefly activate a feature to notify the user
-    */
-    virtual void OnUserNotification() { }
-
-    /*!
-     * @brief Briefly test one of the features of this peripheral.
-     * @param feature The feature to test.
-     * @return True if the test succeeded, false otherwise.
-     */
-    virtual bool TestFeature(PeripheralFeature feature) { return false; }
-
-    /*!
-     * @brief Called when a setting changed.
-     * @param strChangedSetting The changed setting.
-     */
-    virtual void OnSettingChanged(const std::string &strChangedSetting) {};
-
-    /*!
-     * @brief Called when this device is removed, before calling the destructor.
-     */
-    virtual void OnDeviceRemoved(void) {}
-
-    /*!
-     * @brief Get all subdevices if this device is multifunctional.
-     * @param subDevices The subdevices.
-     */
-    virtual void GetSubdevices(PeripheralVector &subDevices) const;
-
-    /*!
-     * @return True when this device is multifunctional, false otherwise.
-     */
-    virtual bool IsMultiFunctional(void) const;
-
-    /*!
-     * @brief Add a setting to this peripheral. This will overwrite a previous setting with the same key.
-     * @param strKey The key of the setting.
-     * @param setting The setting.
-     */
-    virtual void AddSetting(const std::string &strKey, std::shared_ptr<const CSetting> setting, int order);
-
-    /*!
-     * @brief Check whether a setting is known with the given key.
-     * @param strKey The key to search.
-     * @return True when found, false otherwise.
-     */
-    virtual bool HasSetting(const std::string &strKey) const;
-
-    /*!
-     * @return True when this device has any settings, false otherwise.
-     */
-    virtual bool HasSettings(void) const;
-
-    /*!
-     * @return True when this device has any configurable settings, false otherwise.
-     */
-    virtual bool HasConfigurableSettings(void) const;
-
-    /*!
-     * @brief Get the value of a setting.
-     * @param strKey The key to search.
-     * @return The value or an empty string if it wasn't found.
-     */
-    virtual const std::string GetSettingString(const std::string &strKey) const;
-    virtual bool SetSetting(const std::string &strKey, const std::string &strValue);
-    virtual void SetSettingVisible(const std::string &strKey, bool bSetTo);
-    virtual bool IsSettingVisible(const std::string &strKey) const;
-
-    virtual int GetSettingInt(const std::string &strKey) const;
-    virtual bool SetSetting(const std::string &strKey, int iValue);
-
-    virtual bool GetSettingBool(const std::string &strKey) const;
-    virtual bool SetSetting(const std::string &strKey, bool bValue);
-
-    virtual float GetSettingFloat(const std::string &strKey) const;
-    virtual bool SetSetting(const std::string &strKey, float fValue);
-
-    virtual void PersistSettings(bool bExiting = false);
-    virtual void LoadPersistedSettings(void);
-    virtual void ResetDefaultSettings(void);
-
-    virtual std::vector<std::shared_ptr<CSetting>> GetSettings(void) const;
-
-    virtual bool ErrorOccured(void) const { return m_bError; }
-
-    virtual void RegisterJoystickDriverHandler(KODI::JOYSTICK::IDriverHandler* handler, bool bPromiscuous) { }
-    virtual void UnregisterJoystickDriverHandler(KODI::JOYSTICK::IDriverHandler* handler) { }
-
-    virtual void RegisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler, bool bPromiscuous) { }
-    virtual void UnregisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler) { }
-
-    virtual void RegisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler, bool bPromiscuous) { }
-    virtual void UnregisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler) { }
-
-    // implementation of IInputProvider
-    void RegisterInputHandler(KODI::JOYSTICK::IInputHandler* handler, bool bPromiscuous) override;
-    void UnregisterInputHandler(KODI::JOYSTICK::IInputHandler* handler) override;
-
-    // implementation of IKeyboardInputProvider
-    void RegisterKeyboardHandler(KODI::KEYBOARD::IKeyboardInputHandler* handler, bool bPromiscuous) override;
-    void UnregisterKeyboardHandler(KODI::KEYBOARD::IKeyboardInputHandler* handler) override;
-
-    // implementation of IMouseInputProvider
-    void RegisterMouseHandler(KODI::MOUSE::IMouseInputHandler* handler, bool bPromiscuous) override;
-    void UnregisterMouseHandler(KODI::MOUSE::IMouseInputHandler* handler) override;
-
-    virtual void RegisterJoystickButtonMapper(KODI::JOYSTICK::IButtonMapper* mapper);
-    virtual void UnregisterJoystickButtonMapper(KODI::JOYSTICK::IButtonMapper* mapper);
-
-    virtual KODI::JOYSTICK::IDriverReceiver* GetDriverReceiver() { return nullptr; }
-
-    virtual IKeymap *GetKeymap(const std::string &controllerId) { return nullptr; }
-
-    /*!
-     * \brief Return the last time this peripheral was active
-     *
-     * \return The time of last activation, or invalid if unknown/never active
-     */
-    virtual CDateTime LastActive() { return CDateTime(); }
-
-  protected:
-    virtual void ClearSettings(void);
-
-    CPeripherals&                    m_manager;
-    PeripheralType                   m_type;
-    PeripheralBusType                m_busType;
-    PeripheralBusType                m_mappedBusType;
-    std::string                       m_strLocation;
-    std::string                       m_strDeviceName;
-    std::string                       m_strSettingsFile;
-    std::string                       m_strFileLocation;
-    int                              m_iVendorId;
-    std::string                       m_strVendorId;
-    int                              m_iProductId;
-    std::string                       m_strProductId;
-    std::string                       m_strVersionInfo;
-    bool                             m_bInitialised;
-    bool                             m_bHidden;
-    bool                             m_bError;
-    std::vector<PeripheralFeature>   m_features;
-    PeripheralVector                 m_subDevices;
-    std::map<std::string, PeripheralDeviceSetting> m_settings;
-    std::set<std::string>             m_changedSettings;
-    CPeripheralBus*                  m_bus;
-    std::map<KODI::JOYSTICK::IInputHandler*, std::unique_ptr<KODI::JOYSTICK::IDriverHandler>> m_inputHandlers;
-    std::map<KODI::KEYBOARD::IKeyboardInputHandler*, std::unique_ptr<KODI::KEYBOARD::IKeyboardDriverHandler>> m_keyboardHandlers;
-    std::map<KODI::MOUSE::IMouseInputHandler*, std::unique_ptr<KODI::MOUSE::IMouseDriverHandler>> m_mouseHandlers;
-    std::map<KODI::JOYSTICK::IButtonMapper*, std::unique_ptr<CAddonButtonMapping>> m_buttonMappers;
-  };
-}
+  }
+  virtual void UnregisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler) {}
+
+  // implementation of IInputProvider
+  void RegisterInputHandler(KODI::JOYSTICK::IInputHandler* handler, bool bPromiscuous) override;
+  void UnregisterInputHandler(KODI::JOYSTICK::IInputHandler* handler) override;
+
+  // implementation of IKeyboardInputProvider
+  void RegisterKeyboardHandler(KODI::KEYBOARD::IKeyboardInputHandler* handler,
+                               bool bPromiscuous) override;
+  void UnregisterKeyboardHandler(KODI::KEYBOARD::IKeyboardInputHandler* handler) override;
+
+  // implementation of IMouseInputProvider
+  void RegisterMouseHandler(KODI::MOUSE::IMouseInputHandler* handler, bool bPromiscuous) override;
+  void UnregisterMouseHandler(KODI::MOUSE::IMouseInputHandler* handler) override;
+
+  virtual void RegisterJoystickButtonMapper(KODI::JOYSTICK::IButtonMapper* mapper);
+  virtual void UnregisterJoystickButtonMapper(KODI::JOYSTICK::IButtonMapper* mapper);
+
+  virtual KODI::JOYSTICK::IDriverReceiver* GetDriverReceiver() { return nullptr; }
+
+  virtual IKeymap* GetKeymap(const std::string& controllerId) { return nullptr; }
+
+  /*!
+   * \brief Return the last time this peripheral was active
+   *
+   * \return The time of last activation, or invalid if unknown/never active
+   */
+  virtual CDateTime LastActive() { return CDateTime(); }
+
+protected:
+  virtual void ClearSettings(void);
+
+  CPeripherals& m_manager;
+  PeripheralType m_type;
+  PeripheralBusType m_busType;
+  PeripheralBusType m_mappedBusType;
+  std::string m_strLocation;
+  std::string m_strDeviceName;
+  std::string m_strSettingsFile;
+  std::string m_strFileLocation;
+  int m_iVendorId;
+  std::string m_strVendorId;
+  int m_iProductId;
+  std::string m_strProductId;
+  std::string m_strVersionInfo;
+  bool m_bInitialised;
+  bool m_bHidden;
+  bool m_bError;
+  std::vector<PeripheralFeature> m_features;
+  PeripheralVector m_subDevices;
+  std::map<std::string, PeripheralDeviceSetting> m_settings;
+  std::set<std::string> m_changedSettings;
+  CPeripheralBus* m_bus;
+  std::map<KODI::JOYSTICK::IInputHandler*, std::unique_ptr<KODI::JOYSTICK::IDriverHandler>>
+      m_inputHandlers;
+  std::map<KODI::KEYBOARD::IKeyboardInputHandler*,
+           std::unique_ptr<KODI::KEYBOARD::IKeyboardDriverHandler>>
+      m_keyboardHandlers;
+  std::map<KODI::MOUSE::IMouseInputHandler*, std::unique_ptr<KODI::MOUSE::IMouseDriverHandler>>
+      m_mouseHandlers;
+  std::map<KODI::JOYSTICK::IButtonMapper*, std::unique_ptr<CAddonButtonMapping>> m_buttonMappers;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralBluetooth.cpp b/xbmc/peripherals/devices/PeripheralBluetooth.cpp
index a3578e6ed914..6f3802d026bf 100644
--- a/xbmc/peripherals/devices/PeripheralBluetooth.cpp
+++ b/xbmc/peripherals/devices/PeripheralBluetooth.cpp
@@ -10,8 +10,10 @@
 
 using namespace PERIPHERALS;
 
-CPeripheralBluetooth::CPeripheralBluetooth(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheral(manager, scanResult, bus)
+CPeripheralBluetooth::CPeripheralBluetooth(CPeripherals& manager,
+                                           const PeripheralScanResult& scanResult,
+                                           CPeripheralBus* bus)
+  : CPeripheral(manager, scanResult, bus)
 {
   m_features.push_back(FEATURE_BLUETOOTH);
 }
diff --git a/xbmc/peripherals/devices/PeripheralBluetooth.h b/xbmc/peripherals/devices/PeripheralBluetooth.h
index 32a276595e2f..11fa7cae881f 100644
--- a/xbmc/peripherals/devices/PeripheralBluetooth.h
+++ b/xbmc/peripherals/devices/PeripheralBluetooth.h
@@ -12,10 +12,12 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralBluetooth : public CPeripheral
-  {
-  public:
-    CPeripheralBluetooth(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheralBluetooth(void) override = default;
-  };
-}
+class CPeripheralBluetooth : public CPeripheral
+{
+public:
+  CPeripheralBluetooth(CPeripherals& manager,
+                       const PeripheralScanResult& scanResult,
+                       CPeripheralBus* bus);
+  ~CPeripheralBluetooth(void) override = default;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 9b6069fe75ab..c65ce2d33f5a 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -32,31 +32,32 @@ using namespace CEC;
 
 #define CEC_LIB_SUPPORTED_VERSION LIBCEC_VERSION_TO_UINT(4, 0, 0)
 
-/* time in seconds to ignore standby commands from devices after the screensaver has been activated */
-#define SCREENSAVER_TIMEOUT       20
-#define VOLUME_CHANGE_TIMEOUT     250
-#define VOLUME_REFRESH_TIMEOUT    100
-
-#define LOCALISED_ID_TV           36037
-#define LOCALISED_ID_AVR          36038
-#define LOCALISED_ID_TV_AVR       36039
-#define LOCALISED_ID_STOP         36044
-#define LOCALISED_ID_PAUSE        36045
-#define LOCALISED_ID_POWEROFF     13005
-#define LOCALISED_ID_SUSPEND      13011
-#define LOCALISED_ID_HIBERNATE    13010
-#define LOCALISED_ID_QUIT         13009
-#define LOCALISED_ID_IGNORE       36028
-
-#define LOCALISED_ID_NONE         231
+/* time in seconds to ignore standby commands from devices after the screensaver has been activated
+ */
+#define SCREENSAVER_TIMEOUT 20
+#define VOLUME_CHANGE_TIMEOUT 250
+#define VOLUME_REFRESH_TIMEOUT 100
+
+#define LOCALISED_ID_TV 36037
+#define LOCALISED_ID_AVR 36038
+#define LOCALISED_ID_TV_AVR 36039
+#define LOCALISED_ID_STOP 36044
+#define LOCALISED_ID_PAUSE 36045
+#define LOCALISED_ID_POWEROFF 13005
+#define LOCALISED_ID_SUSPEND 13011
+#define LOCALISED_ID_HIBERNATE 13010
+#define LOCALISED_ID_QUIT 13009
+#define LOCALISED_ID_IGNORE 36028
+
+#define LOCALISED_ID_NONE 231
 
 /* time in seconds to suppress source activation after receiving OnStop */
 #define CEC_SUPPRESS_ACTIVATE_SOURCE_AFTER_ON_STOP 2
 
-CPeripheralCecAdapter::CPeripheralCecAdapter(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheralHID(manager, scanResult, bus),
-  CThread("CECAdapter"),
-  m_cecAdapter(NULL)
+CPeripheralCecAdapter::CPeripheralCecAdapter(CPeripherals& manager,
+                                             const PeripheralScanResult& scanResult,
+                                             CPeripheralBus* bus)
+  : CPeripheralHID(manager, scanResult, bus), CThread("CECAdapter"), m_cecAdapter(NULL)
 {
   ResetMembers();
   m_features.push_back(FEATURE_CEC);
@@ -85,47 +86,53 @@ void CPeripheralCecAdapter::ResetMembers(void)
 {
   if (m_cecAdapter)
     CECDestroy(m_cecAdapter);
-  m_cecAdapter               = NULL;
-  m_bStarted                   = false;
-  m_bHasButton                 = false;
-  m_bIsReady                   = false;
-  m_bHasConnectedAudioSystem   = false;
-  m_strMenuLanguage            = "???";
-  m_lastKeypress               = 0;
-  m_lastChange                 = VOLUME_CHANGE_NONE;
-  m_iExitCode                  = EXITCODE_QUIT;
-  m_bIsMuted                   = false; //! @todo fetch the correct initial value when system audiostatus is implemented in libCEC
-  m_bGoingToStandby            = false;
-  m_bIsRunning                 = false;
-  m_bDeviceRemoved             = false;
-  m_bActiveSourcePending       = false;
-  m_bStandbyPending            = false;
+  m_cecAdapter = NULL;
+  m_bStarted = false;
+  m_bHasButton = false;
+  m_bIsReady = false;
+  m_bHasConnectedAudioSystem = false;
+  m_strMenuLanguage = "???";
+  m_lastKeypress = 0;
+  m_lastChange = VOLUME_CHANGE_NONE;
+  m_iExitCode = EXITCODE_QUIT;
+  m_bIsMuted = false; //! @todo fetch the correct initial value when system audiostatus is
+                      //! implemented in libCEC
+  m_bGoingToStandby = false;
+  m_bIsRunning = false;
+  m_bDeviceRemoved = false;
+  m_bActiveSourcePending = false;
+  m_bStandbyPending = false;
   m_bActiveSourceBeforeStandby = false;
-  m_bOnPlayReceived            = false;
-  m_bPlaybackPaused            = false;
-  m_queryThread                = NULL;
-  m_bPowerOnScreensaver        = false;
-  m_bUseTVMenuLanguage         = false;
-  m_bSendInactiveSource        = false;
-  m_bPowerOffScreensaver       = false;
-  m_bShutdownOnStandby         = false;
-
-  m_currentButton.iButton    = 0;
-  m_currentButton.iDuration  = 0;
+  m_bOnPlayReceived = false;
+  m_bPlaybackPaused = false;
+  m_queryThread = NULL;
+  m_bPowerOnScreensaver = false;
+  m_bUseTVMenuLanguage = false;
+  m_bSendInactiveSource = false;
+  m_bPowerOffScreensaver = false;
+  m_bShutdownOnStandby = false;
+
+  m_currentButton.iButton = 0;
+  m_currentButton.iDuration = 0;
   m_standbySent.SetValid(false);
   m_configuration.Clear();
 }
 
-void CPeripheralCecAdapter::Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data)
+void CPeripheralCecAdapter::Announce(ANNOUNCEMENT::AnnouncementFlag flag,
+                                     const char* sender,
+                                     const char* message,
+                                     const CVariant& data)
 {
-  if (flag == ANNOUNCEMENT::System && !strcmp(sender, "xbmc") && !strcmp(message, "OnQuit") && m_bIsReady)
+  if (flag == ANNOUNCEMENT::System && !strcmp(sender, "xbmc") && !strcmp(message, "OnQuit") &&
+      m_bIsReady)
   {
     CSingleLock lock(m_critSection);
     m_iExitCode = static_cast<int>(data["exitcode"].asInteger(EXITCODE_QUIT));
     CServiceBroker::GetAnnouncementManager()->RemoveAnnouncer(this);
     StopThread(false);
   }
-  else if (flag == ANNOUNCEMENT::GUI && !strcmp(sender, "xbmc") && !strcmp(message, "OnScreensaverDeactivated") && m_bIsReady)
+  else if (flag == ANNOUNCEMENT::GUI && !strcmp(sender, "xbmc") &&
+           !strcmp(message, "OnScreensaverDeactivated") && m_bIsReady)
   {
     bool bIgnoreDeactivate(false);
     if (data["shuttingdown"].isBoolean())
@@ -135,15 +142,16 @@ void CPeripheralCecAdapter::Announce(ANNOUNCEMENT::AnnouncementFlag flag, const
       // may not action the standby command.
       bIgnoreDeactivate = data["shuttingdown"].asBoolean();
       if (bIgnoreDeactivate)
-        CLog::Log(LOGDEBUG, "%s - ignoring OnScreensaverDeactivated for power action", __FUNCTION__);
+        CLog::Log(LOGDEBUG, "%s - ignoring OnScreensaverDeactivated for power action",
+                  __FUNCTION__);
     }
-    if (m_bPowerOnScreensaver && !bIgnoreDeactivate &&
-        m_configuration.bActivateSource)
+    if (m_bPowerOnScreensaver && !bIgnoreDeactivate && m_configuration.bActivateSource)
     {
       ActivateSource();
     }
   }
-  else if (flag == ANNOUNCEMENT::GUI && !strcmp(sender, "xbmc") && !strcmp(message, "OnScreensaverActivated") && m_bIsReady)
+  else if (flag == ANNOUNCEMENT::GUI && !strcmp(sender, "xbmc") &&
+           !strcmp(message, "OnScreensaverActivated") && m_bIsReady)
   {
     // Don't put devices to standby if application is currently playing
     if (!g_application.GetAppPlayer().IsPlaying() && m_bPowerOffScreensaver)
@@ -183,16 +191,18 @@ void CPeripheralCecAdapter::Announce(ANNOUNCEMENT::AnnouncementFlag flag, const
     m_preventActivateSourceOnPlay = CDateTime::GetCurrentDateTime();
     m_bOnPlayReceived = false;
   }
-  else if (flag == ANNOUNCEMENT::Player && !strcmp(sender, "xbmc") && (!strcmp(message, "OnPlay") || !strcmp(message, "OnResume")))
+  else if (flag == ANNOUNCEMENT::Player && !strcmp(sender, "xbmc") &&
+           (!strcmp(message, "OnPlay") || !strcmp(message, "OnResume")))
   {
     // activate the source when playback started, and the option is enabled
     bool bActivateSource(false);
     {
       CSingleLock lock(m_critSection);
-      bActivateSource = (m_configuration.bActivateSource &&
-          !m_bOnPlayReceived &&
-          !m_cecAdapter->IsLibCECActiveSource() &&
-          (!m_preventActivateSourceOnPlay.IsValid() || CDateTime::GetCurrentDateTime() - m_preventActivateSourceOnPlay > CDateTimeSpan(0, 0, 0, CEC_SUPPRESS_ACTIVATE_SOURCE_AFTER_ON_STOP)));
+      bActivateSource = (m_configuration.bActivateSource && !m_bOnPlayReceived &&
+                         !m_cecAdapter->IsLibCECActiveSource() &&
+                         (!m_preventActivateSourceOnPlay.IsValid() ||
+                          CDateTime::GetCurrentDateTime() - m_preventActivateSourceOnPlay >
+                              CDateTimeSpan(0, 0, 0, CEC_SUPPRESS_ACTIVATE_SOURCE_AFTER_ON_STOP)));
       m_bOnPlayReceived = true;
     }
     if (bActivateSource)
@@ -212,25 +222,29 @@ bool CPeripheralCecAdapter::InitialiseFeature(const PeripheralFeature feature)
 
     SetConfigurationFromSettings();
     m_callbacks.Clear();
-    m_callbacks.logMessage           = &CecLogMessage;
-    m_callbacks.keyPress             = &CecKeyPress;
-    m_callbacks.commandReceived      = &CecCommand;
+    m_callbacks.logMessage = &CecLogMessage;
+    m_callbacks.keyPress = &CecKeyPress;
+    m_callbacks.commandReceived = &CecCommand;
     m_callbacks.configurationChanged = &CecConfiguration;
-    m_callbacks.alert                = &CecAlert;
-    m_callbacks.sourceActivated      = &CecSourceActivated;
-    m_configuration.callbackParam    = this;
-    m_configuration.callbacks        = &m_callbacks;
+    m_callbacks.alert = &CecAlert;
+    m_callbacks.sourceActivated = &CecSourceActivated;
+    m_configuration.callbackParam = this;
+    m_configuration.callbacks = &m_callbacks;
 
     m_cecAdapter = CECInitialise(&m_configuration);
 
     if (m_configuration.serverVersion < CEC_LIB_SUPPORTED_VERSION)
     {
       /* unsupported libcec version */
-      CLog::Log(LOGERROR, g_localizeStrings.Get(36040).c_str(), m_cecAdapter ? m_configuration.serverVersion : -1, CEC_LIB_SUPPORTED_VERSION);
+      CLog::Log(LOGERROR, g_localizeStrings.Get(36040).c_str(),
+                m_cecAdapter ? m_configuration.serverVersion : -1, CEC_LIB_SUPPORTED_VERSION);
 
       // display warning: incompatible libCEC
-      std::string strMessage = StringUtils::Format(g_localizeStrings.Get(36040).c_str(), m_cecAdapter ? m_configuration.serverVersion : -1, CEC_LIB_SUPPORTED_VERSION);
-      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(36000), strMessage);
+      std::string strMessage = StringUtils::Format(
+          g_localizeStrings.Get(36040).c_str(), m_cecAdapter ? m_configuration.serverVersion : -1,
+          CEC_LIB_SUPPORTED_VERSION);
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(36000),
+                                            strMessage);
       m_bError = true;
       if (m_cecAdapter)
         CECDestroy(m_cecAdapter);
@@ -241,7 +255,8 @@ bool CPeripheralCecAdapter::InitialiseFeature(const PeripheralFeature feature)
     }
     else
     {
-      CLog::Log(LOGDEBUG, "%s - using libCEC v%s", __FUNCTION__, m_cecAdapter->VersionToString(m_configuration.serverVersion).c_str());
+      CLog::Log(LOGDEBUG, "%s - using libCEC v%s", __FUNCTION__,
+                m_cecAdapter->VersionToString(m_configuration.serverVersion).c_str());
       SetVersionInfo(m_configuration);
     }
 
@@ -252,9 +267,12 @@ bool CPeripheralCecAdapter::InitialiseFeature(const PeripheralFeature feature)
   return CPeripheral::InitialiseFeature(feature);
 }
 
-void CPeripheralCecAdapter::SetVersionInfo(const libcec_configuration &configuration)
+void CPeripheralCecAdapter::SetVersionInfo(const libcec_configuration& configuration)
 {
-  m_strVersionInfo = StringUtils::Format("libCEC %s - firmware v%d", m_cecAdapter->VersionToString(configuration.serverVersion).c_str(), configuration.iFirmwareVersion);
+  m_strVersionInfo =
+      StringUtils::Format("libCEC %s - firmware v%d",
+                          m_cecAdapter->VersionToString(configuration.serverVersion).c_str(),
+                          configuration.iFirmwareVersion);
 
   // append firmware build date
   if (configuration.iFirmwareBuildDate != CEC_FW_BUILD_UNKNOWN)
@@ -276,11 +294,15 @@ bool CPeripheralCecAdapter::OpenConnection(void)
   }
 
   // open the CEC adapter
-  CLog::Log(LOGDEBUG, "%s - opening a connection to the CEC adapter: %s", __FUNCTION__, m_strComPort.c_str());
+  CLog::Log(LOGDEBUG, "%s - opening a connection to the CEC adapter: %s", __FUNCTION__,
+            m_strComPort.c_str());
 
-  // scanning the CEC bus takes about 5 seconds, so display a notification to inform users that we're busy
-  std::string strMessage = StringUtils::Format(g_localizeStrings.Get(21336).c_str(), g_localizeStrings.Get(36000).c_str());
-  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000), strMessage);
+  // scanning the CEC bus takes about 5 seconds, so display a notification to inform users that
+  // we're busy
+  std::string strMessage = StringUtils::Format(g_localizeStrings.Get(21336).c_str(),
+                                               g_localizeStrings.Get(36000).c_str());
+  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000),
+                                        strMessage);
 
   bool bConnectionFailedDisplayed(false);
 
@@ -291,7 +313,8 @@ bool CPeripheralCecAdapter::OpenConnection(void)
       // display warning: couldn't initialise libCEC
       CLog::Log(LOGERROR, "%s - could not opening a connection to the CEC adapter", __FUNCTION__);
       if (!bConnectionFailedDisplayed)
-        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(36000), g_localizeStrings.Get(36012));
+        CGUIDialogKaiToast::QueueNotification(
+            CGUIDialogKaiToast::Error, g_localizeStrings.Get(36000), g_localizeStrings.Get(36012));
       bConnectionFailedDisplayed = true;
 
       CThread::Sleep(10000);
@@ -353,8 +376,7 @@ void CPeripheralCecAdapter::Process(void)
   bool bSendStandbyCommands(false);
   {
     CSingleLock lock(m_critSection);
-    bSendStandbyCommands = m_iExitCode != EXITCODE_REBOOT &&
-                           m_iExitCode != EXITCODE_RESTARTAPP &&
+    bSendStandbyCommands = m_iExitCode != EXITCODE_REBOOT && m_iExitCode != EXITCODE_RESTARTAPP &&
                            !m_bDeviceRemoved &&
                            (!m_bGoingToStandby || GetSettingBool("standby_tv_on_pc_standby")) &&
                            GetSettingBool("enabled");
@@ -381,7 +403,8 @@ void CPeripheralCecAdapter::Process(void)
     }
     else
     {
-      CLog::Log(LOGDEBUG, "%s - XBMC is not the active source, not sending any standby commands", __FUNCTION__);
+      CLog::Log(LOGDEBUG, "%s - XBMC is not the active source, not sending any standby commands",
+                __FUNCTION__);
     }
   }
 
@@ -441,7 +464,8 @@ void CPeripheralCecAdapter::ProcessVolumeChange(void)
       else
         pendingVolumeChange = VOLUME_CHANGE_NONE;
     }
-    else if (m_lastKeypress > 0 && XbmcThreads::SystemClockMillis() - m_lastKeypress > VOLUME_CHANGE_TIMEOUT)
+    else if (m_lastKeypress > 0 &&
+             XbmcThreads::SystemClockMillis() - m_lastKeypress > VOLUME_CHANGE_TIMEOUT)
     {
       /* send a key release */
       m_lastKeypress = 0;
@@ -452,23 +476,23 @@ void CPeripheralCecAdapter::ProcessVolumeChange(void)
 
   switch (pendingVolumeChange)
   {
-  case VOLUME_CHANGE_UP:
-    m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_VOLUME_UP, false);
-    break;
-  case VOLUME_CHANGE_DOWN:
-    m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_VOLUME_DOWN, false);
-    break;
-  case VOLUME_CHANGE_MUTE:
-    m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_MUTE, false);
-    {
-      CSingleLock lock(m_critSection);
-      m_bIsMuted = !m_bIsMuted;
-    }
-    break;
-  case VOLUME_CHANGE_NONE:
-    if (bSendRelease)
-      m_cecAdapter->SendKeyRelease(CECDEVICE_AUDIOSYSTEM, false);
-    break;
+    case VOLUME_CHANGE_UP:
+      m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_VOLUME_UP, false);
+      break;
+    case VOLUME_CHANGE_DOWN:
+      m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_VOLUME_DOWN, false);
+      break;
+    case VOLUME_CHANGE_MUTE:
+      m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_MUTE, false);
+      {
+        CSingleLock lock(m_critSection);
+        m_bIsMuted = !m_bIsMuted;
+      }
+      break;
+    case VOLUME_CHANGE_NONE:
+      if (bSendRelease)
+        m_cecAdapter->SendKeyRelease(CECDEVICE_AUDIOSYSTEM, false);
+      break;
   }
 }
 
@@ -509,7 +533,7 @@ bool CPeripheralCecAdapter::IsMuted(void)
   return false;
 }
 
-void CPeripheralCecAdapter::SetMenuLanguage(const char *strLanguage)
+void CPeripheralCecAdapter::SetMenuLanguage(const char* strLanguage)
 {
   if (StringUtils::EqualsNoCase(m_strMenuLanguage, strLanguage))
     return;
@@ -570,7 +594,8 @@ void CPeripheralCecAdapter::SetMenuLanguage(const char *strLanguage)
     CLog::Log(LOGDEBUG, "%s - language set to '%s'", __FUNCTION__, strGuiLanguage.c_str());
   }
   else
-    CLog::Log(LOGWARNING, "%s - TV menu language set to unknown value '%s'", __FUNCTION__, strLanguage);
+    CLog::Log(LOGWARNING, "%s - TV menu language set to unknown value '%s'", __FUNCTION__,
+              strLanguage);
 }
 
 void CPeripheralCecAdapter::OnTvStandby(void)
@@ -578,39 +603,42 @@ void CPeripheralCecAdapter::OnTvStandby(void)
   int iActionOnTvStandby = GetSettingInt("standby_pc_on_tv_standby");
   switch (iActionOnTvStandby)
   {
-  case LOCALISED_ID_POWEROFF:
-    m_bStarted = false;
-    KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_SYSTEM_POWERDOWN, TMSG_SHUTDOWN);
-    break;
-  case LOCALISED_ID_SUSPEND:
-    m_bStarted = false;
-    KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_SYSTEM_POWERDOWN, TMSG_SUSPEND);
-    break;
-  case LOCALISED_ID_HIBERNATE:
-    m_bStarted = false;
-    KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_SYSTEM_POWERDOWN, TMSG_HIBERNATE);
-    break;
-  case LOCALISED_ID_QUIT:
-    m_bStarted = false;
-    KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_QUIT);
-    break;
-  case LOCALISED_ID_PAUSE:
-    KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PAUSE);
-    break;
-  case LOCALISED_ID_STOP:
-    KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
-    break;
-  case LOCALISED_ID_IGNORE:
-  break;
-  default:
-    CLog::Log(LOGERROR, "%s - Unexpected [standby_pc_on_tv_standby] setting value", __FUNCTION__);
-    break;
+    case LOCALISED_ID_POWEROFF:
+      m_bStarted = false;
+      KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_SYSTEM_POWERDOWN,
+                                                                    TMSG_SHUTDOWN);
+      break;
+    case LOCALISED_ID_SUSPEND:
+      m_bStarted = false;
+      KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_SYSTEM_POWERDOWN,
+                                                                    TMSG_SUSPEND);
+      break;
+    case LOCALISED_ID_HIBERNATE:
+      m_bStarted = false;
+      KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_SYSTEM_POWERDOWN,
+                                                                    TMSG_HIBERNATE);
+      break;
+    case LOCALISED_ID_QUIT:
+      m_bStarted = false;
+      KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_QUIT);
+      break;
+    case LOCALISED_ID_PAUSE:
+      KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_PAUSE);
+      break;
+    case LOCALISED_ID_STOP:
+      KODI::MESSAGING::CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
+      break;
+    case LOCALISED_ID_IGNORE:
+      break;
+    default:
+      CLog::Log(LOGERROR, "%s - Unexpected [standby_pc_on_tv_standby] setting value", __FUNCTION__);
+      break;
   }
 }
 
-void CPeripheralCecAdapter::CecCommand(void *cbParam, const cec_command* command)
+void CPeripheralCecAdapter::CecCommand(void* cbParam, const cec_command* command)
 {
-  CPeripheralCecAdapter *adapter = static_cast<CPeripheralCecAdapter *>(cbParam);
+  CPeripheralCecAdapter* adapter = static_cast<CPeripheralCecAdapter*>(cbParam);
   if (!adapter)
     return;
 
@@ -618,63 +646,64 @@ void CPeripheralCecAdapter::CecCommand(void *cbParam, const cec_command* command
   {
     switch (command->opcode)
     {
-    case CEC_OPCODE_STANDBY:
-      if (command->initiator == CECDEVICE_TV &&
-          (!adapter->m_standbySent.IsValid() || CDateTime::GetCurrentDateTime() - adapter->m_standbySent > CDateTimeSpan(0, 0, 0, SCREENSAVER_TIMEOUT)))
-      {
-        adapter->OnTvStandby();
-      }
-      break;
-    case CEC_OPCODE_SET_MENU_LANGUAGE:
-      if (adapter->m_bUseTVMenuLanguage == 1 && command->initiator == CECDEVICE_TV && command->parameters.size == 3)
-      {
-        char strNewLanguage[4];
-        for (int iPtr = 0; iPtr < 3; iPtr++)
-          strNewLanguage[iPtr] = command->parameters[iPtr];
-        strNewLanguage[3] = 0;
-        adapter->SetMenuLanguage(strNewLanguage);
-      }
-      break;
-    case CEC_OPCODE_DECK_CONTROL:
-      if (command->initiator == CECDEVICE_TV &&
-          command->parameters.size == 1 &&
-          command->parameters[0] == CEC_DECK_CONTROL_MODE_STOP)
-      {
-        cec_keypress key;
-        key.duration = 500;
-        key.keycode = CEC_USER_CONTROL_CODE_STOP;
-        adapter->PushCecKeypress(key);
-      }
-      break;
-    case CEC_OPCODE_PLAY:
-      if (command->initiator == CECDEVICE_TV &&
-          command->parameters.size == 1)
-      {
-        if (command->parameters[0] == CEC_PLAY_MODE_PLAY_FORWARD)
+      case CEC_OPCODE_STANDBY:
+        if (command->initiator == CECDEVICE_TV &&
+            (!adapter->m_standbySent.IsValid() ||
+             CDateTime::GetCurrentDateTime() - adapter->m_standbySent >
+                 CDateTimeSpan(0, 0, 0, SCREENSAVER_TIMEOUT)))
         {
-          cec_keypress key;
-          key.duration = 500;
-          key.keycode = CEC_USER_CONTROL_CODE_PLAY;
-          adapter->PushCecKeypress(key);
+          adapter->OnTvStandby();
+        }
+        break;
+      case CEC_OPCODE_SET_MENU_LANGUAGE:
+        if (adapter->m_bUseTVMenuLanguage == 1 && command->initiator == CECDEVICE_TV &&
+            command->parameters.size == 3)
+        {
+          char strNewLanguage[4];
+          for (int iPtr = 0; iPtr < 3; iPtr++)
+            strNewLanguage[iPtr] = command->parameters[iPtr];
+          strNewLanguage[3] = 0;
+          adapter->SetMenuLanguage(strNewLanguage);
         }
-        else if (command->parameters[0] == CEC_PLAY_MODE_PLAY_STILL)
+        break;
+      case CEC_OPCODE_DECK_CONTROL:
+        if (command->initiator == CECDEVICE_TV && command->parameters.size == 1 &&
+            command->parameters[0] == CEC_DECK_CONTROL_MODE_STOP)
         {
           cec_keypress key;
           key.duration = 500;
-          key.keycode = CEC_USER_CONTROL_CODE_PAUSE;
+          key.keycode = CEC_USER_CONTROL_CODE_STOP;
           adapter->PushCecKeypress(key);
         }
-      }
-      break;
-    default:
-      break;
+        break;
+      case CEC_OPCODE_PLAY:
+        if (command->initiator == CECDEVICE_TV && command->parameters.size == 1)
+        {
+          if (command->parameters[0] == CEC_PLAY_MODE_PLAY_FORWARD)
+          {
+            cec_keypress key;
+            key.duration = 500;
+            key.keycode = CEC_USER_CONTROL_CODE_PLAY;
+            adapter->PushCecKeypress(key);
+          }
+          else if (command->parameters[0] == CEC_PLAY_MODE_PLAY_STILL)
+          {
+            cec_keypress key;
+            key.duration = 500;
+            key.keycode = CEC_USER_CONTROL_CODE_PAUSE;
+            adapter->PushCecKeypress(key);
+          }
+        }
+        break;
+      default:
+        break;
     }
   }
 }
 
-void CPeripheralCecAdapter::CecConfiguration(void *cbParam, const libcec_configuration* config)
+void CPeripheralCecAdapter::CecConfiguration(void* cbParam, const libcec_configuration* config)
 {
-  CPeripheralCecAdapter *adapter = static_cast<CPeripheralCecAdapter *>(cbParam);
+  CPeripheralCecAdapter* adapter = static_cast<CPeripheralCecAdapter*>(cbParam);
   if (!adapter)
     return;
 
@@ -682,9 +711,11 @@ void CPeripheralCecAdapter::CecConfiguration(void *cbParam, const libcec_configu
   adapter->SetConfigurationFromLibCEC(*config);
 }
 
-void CPeripheralCecAdapter::CecAlert(void *cbParam, const libcec_alert alert, const libcec_parameter data)
+void CPeripheralCecAdapter::CecAlert(void* cbParam,
+                                     const libcec_alert alert,
+                                     const libcec_parameter data)
 {
-  CPeripheralCecAdapter *adapter = static_cast<CPeripheralCecAdapter *>(cbParam);
+  CPeripheralCecAdapter* adapter = static_cast<CPeripheralCecAdapter*>(cbParam);
   if (!adapter)
     return;
 
@@ -692,25 +723,25 @@ void CPeripheralCecAdapter::CecAlert(void *cbParam, const libcec_alert alert, co
   int iAlertString(0);
   switch (alert)
   {
-  case CEC_ALERT_SERVICE_DEVICE:
-    iAlertString = 36027;
-    break;
-  case CEC_ALERT_CONNECTION_LOST:
-    bReopenConnection = true;
-    iAlertString = 36030;
-    break;
+    case CEC_ALERT_SERVICE_DEVICE:
+      iAlertString = 36027;
+      break;
+    case CEC_ALERT_CONNECTION_LOST:
+      bReopenConnection = true;
+      iAlertString = 36030;
+      break;
 #if defined(CEC_ALERT_PERMISSION_ERROR)
-  case CEC_ALERT_PERMISSION_ERROR:
-    bReopenConnection = true;
-    iAlertString = 36031;
-    break;
-  case CEC_ALERT_PORT_BUSY:
-    bReopenConnection = true;
-    iAlertString = 36032;
-    break;
+    case CEC_ALERT_PERMISSION_ERROR:
+      bReopenConnection = true;
+      iAlertString = 36031;
+      break;
+    case CEC_ALERT_PORT_BUSY:
+      bReopenConnection = true;
+      iAlertString = 36032;
+      break;
 #endif
-  default:
-    break;
+    default:
+      break;
   }
 
   // display the alert
@@ -718,8 +749,9 @@ void CPeripheralCecAdapter::CecAlert(void *cbParam, const libcec_alert alert, co
   {
     std::string strLog(g_localizeStrings.Get(iAlertString));
     if (data.paramType == CEC_PARAMETER_TYPE_STRING && data.paramData)
-      strLog += StringUtils::Format(" - %s", (const char *)data.paramData);
-    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000), strLog);
+      strLog += StringUtils::Format(" - %s", (const char*)data.paramData);
+    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000),
+                                          strLog);
   }
 
   if (bReopenConnection)
@@ -731,9 +763,9 @@ void CPeripheralCecAdapter::CecAlert(void *cbParam, const libcec_alert alert, co
   }
 }
 
-void CPeripheralCecAdapter::CecKeyPress(void *cbParam, const cec_keypress* key)
+void CPeripheralCecAdapter::CecKeyPress(void* cbParam, const cec_keypress* key)
 {
-  CPeripheralCecAdapter *adapter = static_cast<CPeripheralCecAdapter *>(cbParam);
+  CPeripheralCecAdapter* adapter = static_cast<CPeripheralCecAdapter*>(cbParam);
   if (!!adapter)
     adapter->PushCecKeypress(*key);
 }
@@ -754,9 +786,10 @@ void CPeripheralCecAdapter::GetNextKey(void)
   }
 }
 
-void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
+void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress& key)
 {
-  CLog::Log(LOGDEBUG, "%s - received key %2x duration %d", __FUNCTION__, key.iButton, key.iDuration);
+  CLog::Log(LOGDEBUG, "%s - received key %2x duration %d", __FUNCTION__, key.iButton,
+            key.iDuration);
 
   CSingleLock lock(m_critSection);
   // avoid the queue getting too long
@@ -772,8 +805,10 @@ void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
       // ignore this one, since it's already been handled by xbmc
       return;
     }
-    // if we received a keypress with a duration set, try to find the same one without a duration set, and replace it
-    for (std::vector<CecButtonPress>::reverse_iterator it = m_buttonQueue.rbegin(); it != m_buttonQueue.rend(); ++it)
+    // if we received a keypress with a duration set, try to find the same one without a duration
+    // set, and replace it
+    for (std::vector<CecButtonPress>::reverse_iterator it = m_buttonQueue.rbegin();
+         it != m_buttonQueue.rend(); ++it)
     {
       if ((*it).iButton == key.iButton)
       {
@@ -792,282 +827,282 @@ void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
   m_buttonQueue.push_back(key);
 }
 
-void CPeripheralCecAdapter::PushCecKeypress(const cec_keypress &key)
+void CPeripheralCecAdapter::PushCecKeypress(const cec_keypress& key)
 {
   CecButtonPress xbmcKey;
   xbmcKey.iDuration = key.duration;
 
   switch (key.keycode)
   {
-  case CEC_USER_CONTROL_CODE_SELECT:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_SELECT;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_UP:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_UP;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_DOWN:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_DOWN;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_LEFT:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_LEFT;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_LEFT_UP:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_LEFT;
-    PushCecKeypress(xbmcKey);
-    xbmcKey.iButton = XINPUT_IR_REMOTE_UP;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_LEFT_DOWN:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_LEFT;
-    PushCecKeypress(xbmcKey);
-    xbmcKey.iButton = XINPUT_IR_REMOTE_DOWN;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_RIGHT:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_RIGHT;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_RIGHT_UP:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_RIGHT;
-    PushCecKeypress(xbmcKey);
-    xbmcKey.iButton = XINPUT_IR_REMOTE_UP;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_RIGHT_DOWN:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_RIGHT;
-    PushCecKeypress(xbmcKey);
-    xbmcKey.iButton = XINPUT_IR_REMOTE_DOWN;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_SETUP_MENU:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_TITLE;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_CONTENTS_MENU:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_CONTENTS_MENU;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_ROOT_MENU:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_ROOT_MENU;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_TOP_MENU:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_TOP_MENU;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_DVD_MENU:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_DVD_MENU;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_FAVORITE_MENU:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_MENU;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_EXIT:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_BACK;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_ENTER:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_ENTER;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_CHANNEL_MINUS;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_CHANNEL_UP:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_CHANNEL_PLUS;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_TELETEXT;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_SOUND_SELECT:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_LANGUAGE;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_POWER:
-  case CEC_USER_CONTROL_CODE_POWER_TOGGLE_FUNCTION:
-  case CEC_USER_CONTROL_CODE_POWER_OFF_FUNCTION:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_POWER;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_VOLUME_UP:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_VOLUME_PLUS;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_VOLUME_DOWN:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_VOLUME_MINUS;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_MUTE:
-  case CEC_USER_CONTROL_CODE_MUTE_FUNCTION:
-  case CEC_USER_CONTROL_CODE_RESTORE_VOLUME_FUNCTION:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_MUTE;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_PLAY:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_PLAY;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_STOP:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_STOP;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_PAUSE:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_PAUSE;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_REWIND:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_REVERSE;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_FAST_FORWARD:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_FORWARD;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER0:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_0;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER1:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_1;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER2:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_2;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER3:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_3;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER4:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_4;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER5:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_5;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER6:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_6;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER7:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_7;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER8:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_8;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NUMBER9:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_9;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_RECORD:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_RECORD;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_CLEAR:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_CLEAR;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_DISPLAY_INFORMATION:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_INFO;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_PAGE_UP:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_CHANNEL_PLUS;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_PAGE_DOWN:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_CHANNEL_MINUS;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_FORWARD:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_SKIP_PLUS;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_BACKWARD:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_SKIP_MINUS;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_F1_BLUE:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_BLUE;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_F2_RED:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_RED;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_F3_GREEN:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_GREEN;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_F4_YELLOW:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_YELLOW;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_GUIDE;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_AN_CHANNELS_LIST:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_LIVE_TV;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_NEXT_FAVORITE:
-  case CEC_USER_CONTROL_CODE_DOT:
-  case CEC_USER_CONTROL_CODE_AN_RETURN:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_TITLE; // context menu
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_DATA:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_TELETEXT;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_SUB_PICTURE:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_SUBTITLE;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_EJECT:
-    xbmcKey.iButton = XINPUT_IR_REMOTE_EJECT;
-    PushCecKeypress(xbmcKey);
-    break;
-  case CEC_USER_CONTROL_CODE_POWER_ON_FUNCTION:
-  case CEC_USER_CONTROL_CODE_INPUT_SELECT:
-  case CEC_USER_CONTROL_CODE_INITIAL_CONFIGURATION:
-  case CEC_USER_CONTROL_CODE_HELP:
-  case CEC_USER_CONTROL_CODE_STOP_RECORD:
-  case CEC_USER_CONTROL_CODE_PAUSE_RECORD:
-  case CEC_USER_CONTROL_CODE_ANGLE:
-  case CEC_USER_CONTROL_CODE_VIDEO_ON_DEMAND:
-  case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
-  case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
-  case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
-  case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
-  case CEC_USER_CONTROL_CODE_PAUSE_RECORD_FUNCTION:
-  case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
-  case CEC_USER_CONTROL_CODE_TUNE_FUNCTION:
-  case CEC_USER_CONTROL_CODE_SELECT_MEDIA_FUNCTION:
-  case CEC_USER_CONTROL_CODE_SELECT_AV_INPUT_FUNCTION:
-  case CEC_USER_CONTROL_CODE_SELECT_AUDIO_INPUT_FUNCTION:
-  case CEC_USER_CONTROL_CODE_F5:
-  case CEC_USER_CONTROL_CODE_NUMBER_ENTRY_MODE:
-  case CEC_USER_CONTROL_CODE_NUMBER11:
-  case CEC_USER_CONTROL_CODE_NUMBER12:
-  case CEC_USER_CONTROL_CODE_SELECT_BROADCAST_TYPE:
-  case CEC_USER_CONTROL_CODE_SELECT_SOUND_PRESENTATION:
-  case CEC_USER_CONTROL_CODE_UNKNOWN:
-  default:
-    break;
+    case CEC_USER_CONTROL_CODE_SELECT:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_SELECT;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_UP:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_UP;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_DOWN:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_DOWN;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_LEFT:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_LEFT;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_LEFT_UP:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_LEFT;
+      PushCecKeypress(xbmcKey);
+      xbmcKey.iButton = XINPUT_IR_REMOTE_UP;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_LEFT_DOWN:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_LEFT;
+      PushCecKeypress(xbmcKey);
+      xbmcKey.iButton = XINPUT_IR_REMOTE_DOWN;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_RIGHT:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_RIGHT;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_RIGHT_UP:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_RIGHT;
+      PushCecKeypress(xbmcKey);
+      xbmcKey.iButton = XINPUT_IR_REMOTE_UP;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_RIGHT_DOWN:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_RIGHT;
+      PushCecKeypress(xbmcKey);
+      xbmcKey.iButton = XINPUT_IR_REMOTE_DOWN;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_SETUP_MENU:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_TITLE;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_CONTENTS_MENU:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_CONTENTS_MENU;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_ROOT_MENU:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_ROOT_MENU;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_TOP_MENU:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_TOP_MENU;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_DVD_MENU:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_DVD_MENU;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_FAVORITE_MENU:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_MENU;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_EXIT:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_BACK;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_ENTER:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_ENTER;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_CHANNEL_MINUS;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_CHANNEL_UP:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_CHANNEL_PLUS;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_TELETEXT;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_SOUND_SELECT:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_LANGUAGE;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_POWER:
+    case CEC_USER_CONTROL_CODE_POWER_TOGGLE_FUNCTION:
+    case CEC_USER_CONTROL_CODE_POWER_OFF_FUNCTION:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_POWER;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_VOLUME_UP:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_VOLUME_PLUS;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_VOLUME_DOWN:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_VOLUME_MINUS;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_MUTE:
+    case CEC_USER_CONTROL_CODE_MUTE_FUNCTION:
+    case CEC_USER_CONTROL_CODE_RESTORE_VOLUME_FUNCTION:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_MUTE;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_PLAY:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_PLAY;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_STOP:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_STOP;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_PAUSE:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_PAUSE;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_REWIND:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_REVERSE;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_FAST_FORWARD:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_FORWARD;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER0:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_0;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER1:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_1;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER2:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_2;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER3:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_3;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER4:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_4;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER5:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_5;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER6:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_6;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER7:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_7;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER8:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_8;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NUMBER9:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_9;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_RECORD:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_RECORD;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_CLEAR:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_CLEAR;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_DISPLAY_INFORMATION:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_INFO;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_PAGE_UP:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_CHANNEL_PLUS;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_PAGE_DOWN:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_CHANNEL_MINUS;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_FORWARD:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_SKIP_PLUS;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_BACKWARD:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_SKIP_MINUS;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_F1_BLUE:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_BLUE;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_F2_RED:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_RED;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_F3_GREEN:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_GREEN;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_F4_YELLOW:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_YELLOW;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_GUIDE;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_AN_CHANNELS_LIST:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_LIVE_TV;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_NEXT_FAVORITE:
+    case CEC_USER_CONTROL_CODE_DOT:
+    case CEC_USER_CONTROL_CODE_AN_RETURN:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_TITLE; // context menu
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_DATA:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_TELETEXT;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_SUB_PICTURE:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_SUBTITLE;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_EJECT:
+      xbmcKey.iButton = XINPUT_IR_REMOTE_EJECT;
+      PushCecKeypress(xbmcKey);
+      break;
+    case CEC_USER_CONTROL_CODE_POWER_ON_FUNCTION:
+    case CEC_USER_CONTROL_CODE_INPUT_SELECT:
+    case CEC_USER_CONTROL_CODE_INITIAL_CONFIGURATION:
+    case CEC_USER_CONTROL_CODE_HELP:
+    case CEC_USER_CONTROL_CODE_STOP_RECORD:
+    case CEC_USER_CONTROL_CODE_PAUSE_RECORD:
+    case CEC_USER_CONTROL_CODE_ANGLE:
+    case CEC_USER_CONTROL_CODE_VIDEO_ON_DEMAND:
+    case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
+    case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
+    case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
+    case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
+    case CEC_USER_CONTROL_CODE_PAUSE_RECORD_FUNCTION:
+    case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
+    case CEC_USER_CONTROL_CODE_TUNE_FUNCTION:
+    case CEC_USER_CONTROL_CODE_SELECT_MEDIA_FUNCTION:
+    case CEC_USER_CONTROL_CODE_SELECT_AV_INPUT_FUNCTION:
+    case CEC_USER_CONTROL_CODE_SELECT_AUDIO_INPUT_FUNCTION:
+    case CEC_USER_CONTROL_CODE_F5:
+    case CEC_USER_CONTROL_CODE_NUMBER_ENTRY_MODE:
+    case CEC_USER_CONTROL_CODE_NUMBER11:
+    case CEC_USER_CONTROL_CODE_NUMBER12:
+    case CEC_USER_CONTROL_CODE_SELECT_BROADCAST_TYPE:
+    case CEC_USER_CONTROL_CODE_SELECT_SOUND_PRESENTATION:
+    case CEC_USER_CONTROL_CODE_UNKNOWN:
+    default:
+      break;
   }
 }
 
@@ -1097,12 +1132,12 @@ void CPeripheralCecAdapter::ResetButton(void)
   // wait for the key release if the duration isn't 0
   if (m_currentButton.iDuration > 0)
   {
-    m_currentButton.iButton   = 0;
+    m_currentButton.iButton = 0;
     m_currentButton.iDuration = 0;
   }
 }
 
-void CPeripheralCecAdapter::OnSettingChanged(const std::string &strChangedSetting)
+void CPeripheralCecAdapter::OnSettingChanged(const std::string& strChangedSetting)
 {
   if (StringUtils::EqualsNoCase(strChangedSetting, "enabled"))
   {
@@ -1136,9 +1171,11 @@ void CPeripheralCecAdapter::OnSettingChanged(const std::string &strChangedSettin
   }
 }
 
-void CPeripheralCecAdapter::CecSourceActivated(void *cbParam, const CEC::cec_logical_address address, const uint8_t activated)
+void CPeripheralCecAdapter::CecSourceActivated(void* cbParam,
+                                               const CEC::cec_logical_address address,
+                                               const uint8_t activated)
 {
-  CPeripheralCecAdapter *adapter = static_cast<CPeripheralCecAdapter *>(cbParam);
+  CPeripheralCecAdapter* adapter = static_cast<CPeripheralCecAdapter*>(cbParam);
   if (!adapter)
     return;
 
@@ -1148,19 +1185,26 @@ void CPeripheralCecAdapter::CecSourceActivated(void *cbParam, const CEC::cec_log
 
   if (adapter->GetSettingInt("pause_or_stop_playback_on_deactivate") != LOCALISED_ID_NONE)
   {
-    bool bShowingSlideshow = (CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow() == WINDOW_SLIDESHOW);
-    CGUIWindowSlideShow *pSlideShow = bShowingSlideshow ? CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIWindowSlideShow>(WINDOW_SLIDESHOW) : NULL;
-    bool bPlayingAndDeactivated = activated == 0 && (
-        (pSlideShow && pSlideShow->IsPlaying()) || !g_application.GetAppPlayer().IsPausedPlayback());
-    bool bPausedAndActivated = activated == 1 && adapter->m_bPlaybackPaused && (
-        (pSlideShow && pSlideShow->IsPaused()) || g_application.GetAppPlayer().IsPausedPlayback());
+    bool bShowingSlideshow =
+        (CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow() == WINDOW_SLIDESHOW);
+    CGUIWindowSlideShow* pSlideShow =
+        bShowingSlideshow
+            ? CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIWindowSlideShow>(
+                  WINDOW_SLIDESHOW)
+            : NULL;
+    bool bPlayingAndDeactivated =
+        activated == 0 && ((pSlideShow && pSlideShow->IsPlaying()) ||
+                           !g_application.GetAppPlayer().IsPausedPlayback());
+    bool bPausedAndActivated =
+        activated == 1 && adapter->m_bPlaybackPaused &&
+        ((pSlideShow && pSlideShow->IsPaused()) || g_application.GetAppPlayer().IsPausedPlayback());
     if (bPlayingAndDeactivated)
       adapter->m_bPlaybackPaused = true;
     else if (bPausedAndActivated)
       adapter->m_bPlaybackPaused = false;
 
-    if ((bPlayingAndDeactivated || bPausedAndActivated)
-      && adapter->GetSettingInt("pause_or_stop_playback_on_deactivate") == LOCALISED_ID_PAUSE)
+    if ((bPlayingAndDeactivated || bPausedAndActivated) &&
+        adapter->GetSettingInt("pause_or_stop_playback_on_deactivate") == LOCALISED_ID_PAUSE)
     {
       if (pSlideShow)
         // pause/resume slideshow
@@ -1169,8 +1213,8 @@ void CPeripheralCecAdapter::CecSourceActivated(void *cbParam, const CEC::cec_log
         // pause/resume player
         CApplicationMessenger::GetInstance().SendMsg(TMSG_MEDIA_PAUSE);
     }
-    else if (bPlayingAndDeactivated
-      && adapter->GetSettingInt("pause_or_stop_playback_on_deactivate") == LOCALISED_ID_STOP)
+    else if (bPlayingAndDeactivated &&
+             adapter->GetSettingInt("pause_or_stop_playback_on_deactivate") == LOCALISED_ID_STOP)
     {
       if (pSlideShow)
         pSlideShow->OnAction(CAction(ACTION_STOP));
@@ -1180,30 +1224,30 @@ void CPeripheralCecAdapter::CecSourceActivated(void *cbParam, const CEC::cec_log
   }
 }
 
-void CPeripheralCecAdapter::CecLogMessage(void *cbParam, const cec_log_message* message)
+void CPeripheralCecAdapter::CecLogMessage(void* cbParam, const cec_log_message* message)
 {
-  CPeripheralCecAdapter *adapter = static_cast<CPeripheralCecAdapter *>(cbParam);
+  CPeripheralCecAdapter* adapter = static_cast<CPeripheralCecAdapter*>(cbParam);
   if (!adapter)
     return;
 
   int iLevel = -1;
   switch (message->level)
   {
-  case CEC_LOG_ERROR:
-    iLevel = LOGERROR;
-    break;
-  case CEC_LOG_WARNING:
-    iLevel = LOGWARNING;
-    break;
-  case CEC_LOG_NOTICE:
-    iLevel = LOGDEBUG;
-    break;
-  case CEC_LOG_TRAFFIC:
-  case CEC_LOG_DEBUG:
-    iLevel = LOGDEBUG;
-    break;
-  default:
-    break;
+    case CEC_LOG_ERROR:
+      iLevel = LOGERROR;
+      break;
+    case CEC_LOG_WARNING:
+      iLevel = LOGWARNING;
+      break;
+    case CEC_LOG_NOTICE:
+      iLevel = LOGDEBUG;
+      break;
+    case CEC_LOG_TRAFFIC:
+    case CEC_LOG_DEBUG:
+      iLevel = LOGDEBUG;
+      break;
+    default:
+      break;
   }
 
   if (iLevel >= CEC_LOG_NOTICE ||
@@ -1211,7 +1255,7 @@ void CPeripheralCecAdapter::CecLogMessage(void *cbParam, const cec_log_message*
     CLog::Log(iLevel, LOGCEC, "%s - %s", __FUNCTION__, message->message);
 }
 
-void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configuration &config)
+void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configuration& config)
 {
   bool bChanged(false);
 
@@ -1227,7 +1271,9 @@ void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configu
 
   // set the connected device
   m_configuration.baseDevice = config.baseDevice;
-  bChanged |= SetSetting("connected_device", config.baseDevice == CECDEVICE_AUDIOSYSTEM ? LOCALISED_ID_AVR : LOCALISED_ID_TV);
+  bChanged |=
+      SetSetting("connected_device",
+                 config.baseDevice == CECDEVICE_AUDIOSYSTEM ? LOCALISED_ID_AVR : LOCALISED_ID_TV);
 
   // set the HDMI port number
   m_configuration.iHDMIPort = config.iHDMIPort;
@@ -1236,8 +1282,8 @@ void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configu
   // set the physical address, when baseDevice or iHDMIPort are not set
   std::string strPhysicalAddress("0");
   if (!bPAAutoDetected && (m_configuration.baseDevice == CECDEVICE_UNKNOWN ||
-      m_configuration.iHDMIPort < CEC_MIN_HDMI_PORTNUMBER ||
-      m_configuration.iHDMIPort > CEC_MAX_HDMI_PORTNUMBER))
+                           m_configuration.iHDMIPort < CEC_MIN_HDMI_PORTNUMBER ||
+                           m_configuration.iHDMIPort > CEC_MAX_HDMI_PORTNUMBER))
   {
     m_configuration.iPhysicalAddress = config.iPhysicalAddress;
     strPhysicalAddress = StringUtils::Format("%x", config.iPhysicalAddress);
@@ -1250,7 +1296,8 @@ void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configu
 
   // set the devices to power off when stopping
   m_configuration.powerOffDevices = config.powerOffDevices;
-  bChanged |= WriteLogicalAddresses(config.powerOffDevices, "standby_devices", "standby_devices_advanced");
+  bChanged |=
+      WriteLogicalAddresses(config.powerOffDevices, "standby_devices", "standby_devices_advanced");
 
   // set the boolean settings
   m_configuration.bActivateSource = config.bActivateSource;
@@ -1296,7 +1343,8 @@ void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
   m_configuration.deviceTypes.Add((cec_device_type)iDeviceType);
 
   // always try to autodetect the address.
-  // when the firmware supports this, it will override the physical address, connected device and hdmi port settings
+  // when the firmware supports this, it will override the physical address, connected device and
+  // hdmi port settings
   m_configuration.bAutodetectAddress = CEC_DEFAULT_SETTING_AUTODETECT_ADDRESS;
 
   // set the physical address
@@ -1304,8 +1352,7 @@ void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
   std::string strPhysicalAddress = GetSettingString("physical_address");
   int iPhysicalAddress;
   if (sscanf(strPhysicalAddress.c_str(), "%x", &iPhysicalAddress) &&
-      iPhysicalAddress >= CEC_PHYSICAL_ADDRESS_TV &&
-      iPhysicalAddress <= CEC_MAX_PHYSICAL_ADDRESS)
+      iPhysicalAddress >= CEC_PHYSICAL_ADDRESS_TV && iPhysicalAddress <= CEC_MAX_PHYSICAL_ADDRESS)
     m_configuration.iPhysicalAddress = iPhysicalAddress;
   else
     m_configuration.iPhysicalAddress = CEC_PHYSICAL_ADDRESS_TV;
@@ -1319,14 +1366,12 @@ void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
 
   // set the HDMI port number
   int iHDMIPort = GetSettingInt("cec_hdmi_port");
-  if (iHDMIPort >= CEC_MIN_HDMI_PORTNUMBER &&
-      iHDMIPort <= CEC_MAX_HDMI_PORTNUMBER)
+  if (iHDMIPort >= CEC_MIN_HDMI_PORTNUMBER && iHDMIPort <= CEC_MAX_HDMI_PORTNUMBER)
     m_configuration.iHDMIPort = iHDMIPort;
 
   // set the tv vendor override
   int iVendor = GetSettingInt("tv_vendor");
-  if (iVendor >= CEC_MIN_VENDORID &&
-      iVendor <= CEC_MAX_VENDORID)
+  if (iVendor >= CEC_MIN_VENDORID && iVendor <= CEC_MAX_VENDORID)
     m_configuration.tvVendor = iVendor;
 
   // read the devices to wake when starting
@@ -1348,16 +1393,17 @@ void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
     ReadLogicalAddresses(GetSettingInt("standby_devices"), m_configuration.powerOffDevices);
 
   // read the boolean settings
-  m_bUseTVMenuLanguage                 = GetSettingBool("use_tv_menu_language");
-  m_configuration.bActivateSource      = GetSettingBool("activate_source") ? 1 : 0;
-  m_bPowerOffScreensaver               = GetSettingBool("cec_standby_screensaver");
-  m_bPowerOnScreensaver                = GetSettingBool("cec_wake_screensaver");
-  m_bSendInactiveSource                = GetSettingBool("send_inactive_source");
-  m_configuration.bAutoWakeAVR         = GetSettingBool("power_avr_on_as") ? 1 : 0;
+  m_bUseTVMenuLanguage = GetSettingBool("use_tv_menu_language");
+  m_configuration.bActivateSource = GetSettingBool("activate_source") ? 1 : 0;
+  m_bPowerOffScreensaver = GetSettingBool("cec_standby_screensaver");
+  m_bPowerOnScreensaver = GetSettingBool("cec_wake_screensaver");
+  m_bSendInactiveSource = GetSettingBool("send_inactive_source");
+  m_configuration.bAutoWakeAVR = GetSettingBool("power_avr_on_as") ? 1 : 0;
 
   // read the mutually exclusive boolean settings
   int iStandbyAction(GetSettingInt("standby_pc_on_tv_standby"));
-  m_configuration.bPowerOffOnStandby = (iStandbyAction == LOCALISED_ID_SUSPEND || iStandbyAction == LOCALISED_ID_HIBERNATE) ? 1 : 0;
+  m_configuration.bPowerOffOnStandby =
+      (iStandbyAction == LOCALISED_ID_SUSPEND || iStandbyAction == LOCALISED_ID_HIBERNATE) ? 1 : 0;
   m_bShutdownOnStandby = iStandbyAction == LOCALISED_ID_POWEROFF;
 
   // double tap prevention timeout in ms
@@ -1372,7 +1418,8 @@ void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
   }
 }
 
-void CPeripheralCecAdapter::ReadLogicalAddresses(const std::string &strString, cec_logical_addresses &addresses)
+void CPeripheralCecAdapter::ReadLogicalAddresses(const std::string& strString,
+                                                 cec_logical_addresses& addresses)
 {
   for (size_t iPtr = 0; iPtr < strString.size(); iPtr++)
   {
@@ -1387,28 +1434,30 @@ void CPeripheralCecAdapter::ReadLogicalAddresses(const std::string &strString, c
   }
 }
 
-void CPeripheralCecAdapter::ReadLogicalAddresses(int iLocalisedId, cec_logical_addresses &addresses)
+void CPeripheralCecAdapter::ReadLogicalAddresses(int iLocalisedId, cec_logical_addresses& addresses)
 {
   addresses.Clear();
   switch (iLocalisedId)
   {
-  case LOCALISED_ID_TV:
-    addresses.Set(CECDEVICE_TV);
-    break;
-  case LOCALISED_ID_AVR:
-    addresses.Set(CECDEVICE_AUDIOSYSTEM);
-    break;
-  case LOCALISED_ID_TV_AVR:
-    addresses.Set(CECDEVICE_TV);
-    addresses.Set(CECDEVICE_AUDIOSYSTEM);
-    break;
-  case LOCALISED_ID_NONE:
-  default:
-    break;
+    case LOCALISED_ID_TV:
+      addresses.Set(CECDEVICE_TV);
+      break;
+    case LOCALISED_ID_AVR:
+      addresses.Set(CECDEVICE_AUDIOSYSTEM);
+      break;
+    case LOCALISED_ID_TV_AVR:
+      addresses.Set(CECDEVICE_TV);
+      addresses.Set(CECDEVICE_AUDIOSYSTEM);
+      break;
+    case LOCALISED_ID_NONE:
+    default:
+      break;
   }
 }
 
-bool CPeripheralCecAdapter::WriteLogicalAddresses(const cec_logical_addresses& addresses, const std::string& strSettingName, const std::string& strAdvancedSettingName)
+bool CPeripheralCecAdapter::WriteLogicalAddresses(const cec_logical_addresses& addresses,
+                                                  const std::string& strSettingName,
+                                                  const std::string& strAdvancedSettingName)
 {
   bool bChanged(false);
 
@@ -1433,8 +1482,9 @@ bool CPeripheralCecAdapter::WriteLogicalAddresses(const cec_logical_addresses& a
   return SetSetting(strSettingName, iSettingPowerOffDevices) || bChanged;
 }
 
-CPeripheralCecAdapterUpdateThread::CPeripheralCecAdapterUpdateThread(CPeripheralCecAdapter *adapter, libcec_configuration *configuration) :
-    CThread("CECAdapterUpdate"),
+CPeripheralCecAdapterUpdateThread::CPeripheralCecAdapterUpdateThread(
+    CPeripheralCecAdapter* adapter, libcec_configuration* configuration)
+  : CThread("CECAdapterUpdate"),
     m_adapter(adapter),
     m_configuration(*configuration),
     m_bNextConfigurationScheduled(false),
@@ -1456,7 +1506,7 @@ void CPeripheralCecAdapterUpdateThread::Signal(void)
   m_event.Set();
 }
 
-bool CPeripheralCecAdapterUpdateThread::UpdateConfiguration(libcec_configuration *configuration)
+bool CPeripheralCecAdapterUpdateThread::UpdateConfiguration(libcec_configuration* configuration)
 {
   CSingleLock lock(m_critSection);
   if (!configuration)
@@ -1483,9 +1533,8 @@ bool CPeripheralCecAdapterUpdateThread::WaitReady(void)
 
   // wait for the TV if we're configured to become the active source.
   // wait for the first device in the wake list otherwise.
-  cec_logical_address waitFor = (m_configuration.bActivateSource == 1) ?
-      CECDEVICE_TV :
-      m_configuration.wakeDevices.primary;
+  cec_logical_address waitFor =
+      (m_configuration.bActivateSource == 1) ? CECDEVICE_TV : m_configuration.wakeDevices.primary;
 
   cec_power_status powerStatus(CEC_POWER_STATUS_UNKNOWN);
   bool bContinue(true);
@@ -1524,7 +1573,9 @@ std::string CPeripheralCecAdapterUpdateThread::UpdateAudioSystemStatus(void)
   {
     // request the OSD name of the amp
     std::string ampName(m_adapter->m_cecAdapter->GetDeviceOSDName(CECDEVICE_AUDIOSYSTEM));
-    CLog::Log(LOGDEBUG, "%s - CEC capable amplifier found (%s). volume will be controlled on the amp", __FUNCTION__, ampName.c_str());
+    CLog::Log(LOGDEBUG,
+              "%s - CEC capable amplifier found (%s). volume will be controlled on the amp",
+              __FUNCTION__, ampName.c_str());
     strAmpName += StringUtils::Format("%s", ampName.c_str());
 
     // set amp present
@@ -1550,8 +1601,10 @@ bool CPeripheralCecAdapterUpdateThread::SetInitialConfiguration(void)
 
   // devices to wake are set
   cec_logical_addresses tvOnly;
-  tvOnly.Clear(); tvOnly.Set(CECDEVICE_TV);
-  if (!m_configuration.wakeDevices.IsEmpty() && (m_configuration.wakeDevices != tvOnly || m_configuration.bActivateSource == 0))
+  tvOnly.Clear();
+  tvOnly.Set(CECDEVICE_TV);
+  if (!m_configuration.wakeDevices.IsEmpty() &&
+      (m_configuration.wakeDevices != tvOnly || m_configuration.bActivateSource == 0))
     m_adapter->m_cecAdapter->PowerOnDevices(CECDEVICE_BROADCAST);
 
   // wait until devices are powered up
@@ -1563,7 +1616,8 @@ bool CPeripheralCecAdapterUpdateThread::SetInitialConfiguration(void)
   // request the OSD name of the TV
   std::string strNotification;
   std::string tvName(m_adapter->m_cecAdapter->GetDeviceOSDName(CECDEVICE_TV));
-  strNotification = StringUtils::Format("%s: %s", g_localizeStrings.Get(36016).c_str(), tvName.c_str());
+  strNotification =
+      StringUtils::Format("%s: %s", g_localizeStrings.Get(36016).c_str(), tvName.c_str());
 
   std::string strAmpName = UpdateAudioSystemStatus();
   if (!strAmpName.empty())
@@ -1572,7 +1626,8 @@ bool CPeripheralCecAdapterUpdateThread::SetInitialConfiguration(void)
   m_adapter->m_bIsReady = true;
 
   // and let the gui know that we're done
-  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000), strNotification);
+  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000),
+                                        strNotification);
 
   CSingleLock lock(m_critSection);
   m_bIsUpdating = false;
@@ -1619,7 +1674,8 @@ void CPeripheralCecAdapterUpdateThread::Process(void)
         UpdateAudioSystemStatus();
       }
 
-      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000), g_localizeStrings.Get(bConfigSet ? 36023 : 36024));
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000),
+                                            g_localizeStrings.Get(bConfigSet ? 36023 : 36024));
 
       {
         CSingleLock lock(m_critSection);
@@ -1652,26 +1708,23 @@ namespace PERIPHERALS
 class CPeripheralCecAdapterReopenJob : public CJob
 {
 public:
-  CPeripheralCecAdapterReopenJob(CPeripheralCecAdapter *adapter)
-    : m_adapter(adapter) {}
+  CPeripheralCecAdapterReopenJob(CPeripheralCecAdapter* adapter) : m_adapter(adapter) {}
   ~CPeripheralCecAdapterReopenJob() override = default;
 
-  bool DoWork(void) override
-  {
-    return m_adapter->ReopenConnection(false);
-  }
+  bool DoWork(void) override { return m_adapter->ReopenConnection(false); }
 
 private:
-  CPeripheralCecAdapter *m_adapter;
+  CPeripheralCecAdapter* m_adapter;
 };
 
-};
+}; // namespace PERIPHERALS
 
 bool CPeripheralCecAdapter::ReopenConnection(bool bAsync /* = false */)
 {
   if (bAsync)
   {
-    CJobManager::GetInstance().AddJob(new CPeripheralCecAdapterReopenJob(this), nullptr, CJob::PRIORITY_NORMAL);
+    CJobManager::GetInstance().AddJob(new CPeripheralCecAdapterReopenJob(this), nullptr,
+                                      CJob::PRIORITY_NORMAL);
     return true;
   }
 
@@ -1744,11 +1797,13 @@ void CPeripheralCecAdapter::ProcessStandbyDevices(void)
   }
 }
 
-bool CPeripheralCecAdapter::ToggleDeviceState(CecStateChange mode /*= STATE_SWITCH_TOGGLE */, bool forceType /*= false */)
+bool CPeripheralCecAdapter::ToggleDeviceState(CecStateChange mode /*= STATE_SWITCH_TOGGLE */,
+                                              bool forceType /*= false */)
 {
   if (!IsRunning())
     return false;
-  if (m_cecAdapter->IsLibCECActiveSource() && (mode == STATE_SWITCH_TOGGLE || mode == STATE_STANDBY))
+  if (m_cecAdapter->IsLibCECActiveSource() &&
+      (mode == STATE_SWITCH_TOGGLE || mode == STATE_STANDBY))
   {
     CLog::Log(LOGDEBUG, "%s - putting CEC device on standby...", __FUNCTION__);
     StandbyDevices();
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.h b/xbmc/peripherals/devices/PeripheralCecAdapter.h
index 442519b3b5bf..94b7d543bd5d 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.h
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.h
@@ -11,31 +11,36 @@
 #if !defined(HAVE_LIBCEC)
 #include "Peripheral.h"
 
-// an empty implementation, so CPeripherals can be compiled without a bunch of #ifdef's when libCEC is not available
+// an empty implementation, so CPeripherals can be compiled without a bunch of #ifdef's when libCEC
+// is not available
 namespace PERIPHERALS
 {
-  class CPeripheralCecAdapter : public CPeripheral
+class CPeripheralCecAdapter : public CPeripheral
+{
+public:
+  bool HasAudioControl(void) { return false; }
+  void VolumeUp(void) {}
+  void VolumeDown(void) {}
+  bool IsMuted(void) { return false; }
+  void ToggleMute(void) {}
+  bool ToggleDeviceState(CecStateChange mode = STATE_SWITCH_TOGGLE, bool forceType = false)
   {
-  public:
-    bool HasAudioControl(void) { return false; }
-    void VolumeUp(void) {}
-    void VolumeDown(void) {}
-    bool IsMuted(void) { return false; }
-    void ToggleMute(void) {}
-    bool ToggleDeviceState(CecStateChange mode = STATE_SWITCH_TOGGLE, bool forceType = false) { return false; }
-
-    int GetButton(void) { return 0; }
-    unsigned int GetHoldTime(void) { return 0; }
-    void ResetButton(void) {}
-  };
-}
+    return false;
+  }
+
+  int GetButton(void) { return 0; }
+  unsigned int GetHoldTime(void) { return 0; }
+  void ResetButton(void) {}
+};
+} // namespace PERIPHERALS
 
 #else
 
 #include "PeripheralHID.h"
 #include "interfaces/AnnouncementManager.h"
-#include "threads/Thread.h"
 #include "threads/CriticalSection.h"
+#include "threads/Thread.h"
+
 #include <queue>
 #include <vector>
 
@@ -49,156 +54,171 @@ class CVariant;
 
 namespace CEC
 {
-  class ICECAdapter;
+class ICECAdapter;
 };
 
 namespace PERIPHERALS
 {
-  class CPeripheralCecAdapterUpdateThread;
-  class CPeripheralCecAdapterReopenJob;
+class CPeripheralCecAdapterUpdateThread;
+class CPeripheralCecAdapterReopenJob;
 
-  typedef struct
-  {
-    int iButton;
-    unsigned int iDuration;
-  } CecButtonPress;
+typedef struct
+{
+  int iButton;
+  unsigned int iDuration;
+} CecButtonPress;
 
-  typedef enum
-  {
-    VOLUME_CHANGE_NONE,
-    VOLUME_CHANGE_UP,
-    VOLUME_CHANGE_DOWN,
-    VOLUME_CHANGE_MUTE
-  } CecVolumeChange;
+typedef enum
+{
+  VOLUME_CHANGE_NONE,
+  VOLUME_CHANGE_UP,
+  VOLUME_CHANGE_DOWN,
+  VOLUME_CHANGE_MUTE
+} CecVolumeChange;
+
+class CPeripheralCecAdapter : public CPeripheralHID,
+                              public ANNOUNCEMENT::IAnnouncer,
+                              private CThread
+{
+  friend class CPeripheralCecAdapterUpdateThread;
+  friend class CPeripheralCecAdapterReopenJob;
+
+public:
+  CPeripheralCecAdapter(CPeripherals& manager,
+                        const PeripheralScanResult& scanResult,
+                        CPeripheralBus* bus);
+  ~CPeripheralCecAdapter(void) override;
+
+  void Announce(ANNOUNCEMENT::AnnouncementFlag flag,
+                const char* sender,
+                const char* message,
+                const CVariant& data) override;
+
+  // audio control
+  bool HasAudioControl(void);
+  void VolumeUp(void);
+  void VolumeDown(void);
+  void ToggleMute(void);
+  bool IsMuted(void);
+
+  // CPeripheral callbacks
+  void OnSettingChanged(const std::string& strChangedSetting) override;
+  void OnDeviceRemoved(void) override;
+
+  // input
+  int GetButton(void);
+  unsigned int GetHoldTime(void);
+  void ResetButton(void);
+
+  // public CEC methods
+  void ActivateSource(void);
+  void StandbyDevices(void);
+  bool ToggleDeviceState(CecStateChange mode = STATE_SWITCH_TOGGLE, bool forceType = false);
+
+private:
+  bool InitialiseFeature(const PeripheralFeature feature) override;
+  void ResetMembers(void);
+  void Process(void) override;
+  bool IsRunning(void) const;
+
+  bool OpenConnection(void);
+  bool ReopenConnection(bool bAsync = false);
+
+  void SetConfigurationFromSettings(void);
+  void SetConfigurationFromLibCEC(const CEC::libcec_configuration& config);
+  void SetVersionInfo(const CEC::libcec_configuration& configuration);
+
+  static void ReadLogicalAddresses(const std::string& strString,
+                                   CEC::cec_logical_addresses& addresses);
+  static void ReadLogicalAddresses(int iLocalisedId, CEC::cec_logical_addresses& addresses);
+  bool WriteLogicalAddresses(const CEC::cec_logical_addresses& addresses,
+                             const std::string& strSettingName,
+                             const std::string& strAdvancedSettingName);
+
+  void ProcessActivateSource(void);
+  void ProcessStandbyDevices(void);
+  void ProcessVolumeChange(void);
+
+  void PushCecKeypress(const CEC::cec_keypress& key);
+  void PushCecKeypress(const CecButtonPress& key);
+  void GetNextKey(void);
+
+  void SetAudioSystemConnected(bool bSetTo);
+  void SetMenuLanguage(const char* strLanguage);
+  void OnTvStandby(void);
+
+  // callbacks from libCEC
+  static void CecLogMessage(void* cbParam, const CEC::cec_log_message* message);
+  static void CecCommand(void* cbParam, const CEC::cec_command* command);
+  static void CecConfiguration(void* cbParam, const CEC::libcec_configuration* config);
+  static void CecAlert(void* cbParam,
+                       const CEC::libcec_alert alert,
+                       const CEC::libcec_parameter data);
+  static void CecSourceActivated(void* param,
+                                 const CEC::cec_logical_address address,
+                                 const uint8_t activated);
+  static void CecKeyPress(void* cbParam, const CEC::cec_keypress* key);
+
+  CEC::ICECAdapter* m_cecAdapter;
+  bool m_bStarted;
+  bool m_bHasButton;
+  bool m_bIsReady;
+  bool m_bHasConnectedAudioSystem;
+  std::string m_strMenuLanguage;
+  CDateTime m_standbySent;
+  std::vector<CecButtonPress> m_buttonQueue;
+  CecButtonPress m_currentButton;
+  std::queue<CecVolumeChange> m_volumeChangeQueue;
+  unsigned int m_lastKeypress;
+  CecVolumeChange m_lastChange;
+  int m_iExitCode;
+  bool m_bIsMuted;
+  bool m_bGoingToStandby;
+  bool m_bIsRunning;
+  bool m_bDeviceRemoved;
+  CPeripheralCecAdapterUpdateThread* m_queryThread;
+  CEC::ICECCallbacks m_callbacks;
+  mutable CCriticalSection m_critSection;
+  CEC::libcec_configuration m_configuration;
+  bool m_bActiveSourcePending;
+  bool m_bStandbyPending;
+  CDateTime m_preventActivateSourceOnPlay;
+  bool m_bActiveSourceBeforeStandby;
+  bool m_bOnPlayReceived;
+  bool m_bPlaybackPaused;
+  std::string m_strComPort;
+  bool m_bPowerOnScreensaver;
+  bool m_bUseTVMenuLanguage;
+  bool m_bSendInactiveSource;
+  bool m_bPowerOffScreensaver;
+  bool m_bShutdownOnStandby;
+};
 
-  class CPeripheralCecAdapter : public CPeripheralHID, public ANNOUNCEMENT::IAnnouncer, private CThread
-  {
-    friend class CPeripheralCecAdapterUpdateThread;
-    friend class CPeripheralCecAdapterReopenJob;
-
-  public:
-    CPeripheralCecAdapter(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheralCecAdapter(void) override;
-
-    void Announce(ANNOUNCEMENT::AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data) override;
-
-    // audio control
-    bool HasAudioControl(void);
-    void VolumeUp(void);
-    void VolumeDown(void);
-    void ToggleMute(void);
-    bool IsMuted(void);
-
-    // CPeripheral callbacks
-    void OnSettingChanged(const std::string &strChangedSetting) override;
-    void OnDeviceRemoved(void) override;
-
-    // input
-    int GetButton(void);
-    unsigned int GetHoldTime(void);
-    void ResetButton(void);
-
-    // public CEC methods
-    void ActivateSource(void);
-    void StandbyDevices(void);
-    bool ToggleDeviceState(CecStateChange mode = STATE_SWITCH_TOGGLE, bool forceType = false);
-
-  private:
-    bool InitialiseFeature(const PeripheralFeature feature) override;
-    void ResetMembers(void);
-    void Process(void) override;
-    bool IsRunning(void) const;
-
-    bool OpenConnection(void);
-    bool ReopenConnection(bool bAsync = false);
-
-    void SetConfigurationFromSettings(void);
-    void SetConfigurationFromLibCEC(const CEC::libcec_configuration &config);
-    void SetVersionInfo(const CEC::libcec_configuration &configuration);
-
-    static void ReadLogicalAddresses(const std::string &strString, CEC::cec_logical_addresses &addresses);
-    static void ReadLogicalAddresses(int iLocalisedId, CEC::cec_logical_addresses &addresses);
-    bool WriteLogicalAddresses(const CEC::cec_logical_addresses& addresses, const std::string& strSettingName, const std::string& strAdvancedSettingName);
-
-    void ProcessActivateSource(void);
-    void ProcessStandbyDevices(void);
-    void ProcessVolumeChange(void);
-
-    void PushCecKeypress(const CEC::cec_keypress &key);
-    void PushCecKeypress(const CecButtonPress &key);
-    void GetNextKey(void);
-
-    void SetAudioSystemConnected(bool bSetTo);
-    void SetMenuLanguage(const char *strLanguage);
-    void OnTvStandby(void);
-
-    // callbacks from libCEC
-    static void CecLogMessage(void *cbParam, const CEC::cec_log_message* message);
-    static void CecCommand(void *cbParam, const CEC::cec_command* command);
-    static void CecConfiguration(void *cbParam, const CEC::libcec_configuration* config);
-    static void CecAlert(void *cbParam, const CEC::libcec_alert alert, const CEC::libcec_parameter data);
-    static void CecSourceActivated(void *param, const CEC::cec_logical_address address, const uint8_t activated);
-    static void CecKeyPress(void *cbParam, const CEC::cec_keypress* key);
-
-    CEC::ICECAdapter* m_cecAdapter;
-    bool m_bStarted;
-    bool m_bHasButton;
-    bool m_bIsReady;
-    bool m_bHasConnectedAudioSystem;
-    std::string m_strMenuLanguage;
-    CDateTime m_standbySent;
-    std::vector<CecButtonPress> m_buttonQueue;
-    CecButtonPress m_currentButton;
-    std::queue<CecVolumeChange> m_volumeChangeQueue;
-    unsigned int m_lastKeypress;
-    CecVolumeChange m_lastChange;
-    int m_iExitCode;
-    bool m_bIsMuted;
-    bool m_bGoingToStandby;
-    bool m_bIsRunning;
-    bool m_bDeviceRemoved;
-    CPeripheralCecAdapterUpdateThread*m_queryThread;
-    CEC::ICECCallbacks m_callbacks;
-    mutable CCriticalSection m_critSection;
-    CEC::libcec_configuration m_configuration;
-    bool m_bActiveSourcePending;
-    bool m_bStandbyPending;
-    CDateTime m_preventActivateSourceOnPlay;
-    bool m_bActiveSourceBeforeStandby;
-    bool m_bOnPlayReceived;
-    bool m_bPlaybackPaused;
-    std::string m_strComPort;
-    bool m_bPowerOnScreensaver;
-    bool m_bUseTVMenuLanguage;
-    bool m_bSendInactiveSource;
-    bool m_bPowerOffScreensaver;
-    bool m_bShutdownOnStandby;
-  };
-
-  class CPeripheralCecAdapterUpdateThread : public CThread
-  {
-  public:
-    CPeripheralCecAdapterUpdateThread(CPeripheralCecAdapter *adapter, CEC::libcec_configuration *configuration);
-    ~CPeripheralCecAdapterUpdateThread(void) override;
-
-    void Signal(void);
-    bool UpdateConfiguration(CEC::libcec_configuration *configuration);
-
-  protected:
-    void UpdateMenuLanguage(void);
-    std::string UpdateAudioSystemStatus(void);
-    bool WaitReady(void);
-    bool SetInitialConfiguration(void);
-    void Process(void) override;
-
-    CPeripheralCecAdapter* m_adapter;
-    CEvent m_event;
-    CCriticalSection m_critSection;
-    CEC::libcec_configuration m_configuration;
-    CEC::libcec_configuration m_nextConfiguration;
-    bool m_bNextConfigurationScheduled;
-    bool m_bIsUpdating;
-  };
-}
+class CPeripheralCecAdapterUpdateThread : public CThread
+{
+public:
+  CPeripheralCecAdapterUpdateThread(CPeripheralCecAdapter* adapter,
+                                    CEC::libcec_configuration* configuration);
+  ~CPeripheralCecAdapterUpdateThread(void) override;
+
+  void Signal(void);
+  bool UpdateConfiguration(CEC::libcec_configuration* configuration);
+
+protected:
+  void UpdateMenuLanguage(void);
+  std::string UpdateAudioSystemStatus(void);
+  bool WaitReady(void);
+  bool SetInitialConfiguration(void);
+  void Process(void) override;
+
+  CPeripheralCecAdapter* m_adapter;
+  CEvent m_event;
+  CCriticalSection m_critSection;
+  CEC::libcec_configuration m_configuration;
+  CEC::libcec_configuration m_nextConfiguration;
+  bool m_bNextConfigurationScheduled;
+  bool m_bIsUpdating;
+};
+} // namespace PERIPHERALS
 
 #endif
diff --git a/xbmc/peripherals/devices/PeripheralDisk.cpp b/xbmc/peripherals/devices/PeripheralDisk.cpp
index bc8f4ca58085..9b0682cf92d5 100644
--- a/xbmc/peripherals/devices/PeripheralDisk.cpp
+++ b/xbmc/peripherals/devices/PeripheralDisk.cpp
@@ -12,9 +12,12 @@
 
 using namespace PERIPHERALS;
 
-CPeripheralDisk::CPeripheralDisk(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheral(manager, scanResult, bus)
+CPeripheralDisk::CPeripheralDisk(CPeripherals& manager,
+                                 const PeripheralScanResult& scanResult,
+                                 CPeripheralBus* bus)
+  : CPeripheral(manager, scanResult, bus)
 {
-  m_strDeviceName = scanResult.m_strDeviceName.empty() ? g_localizeStrings.Get(35003) : scanResult.m_strDeviceName;
+  m_strDeviceName = scanResult.m_strDeviceName.empty() ? g_localizeStrings.Get(35003)
+                                                       : scanResult.m_strDeviceName;
   m_features.push_back(FEATURE_DISK);
 }
diff --git a/xbmc/peripherals/devices/PeripheralDisk.h b/xbmc/peripherals/devices/PeripheralDisk.h
index 1c8b9693da20..f81b31e8baa2 100644
--- a/xbmc/peripherals/devices/PeripheralDisk.h
+++ b/xbmc/peripherals/devices/PeripheralDisk.h
@@ -12,10 +12,12 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralDisk : public CPeripheral
-  {
-  public:
-    CPeripheralDisk(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheralDisk(void) override = default;
-  };
-}
+class CPeripheralDisk : public CPeripheral
+{
+public:
+  CPeripheralDisk(CPeripherals& manager,
+                  const PeripheralScanResult& scanResult,
+                  CPeripheralBus* bus);
+  ~CPeripheralDisk(void) override = default;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralHID.cpp b/xbmc/peripherals/devices/PeripheralHID.cpp
index 8fadb2c4b16d..7fdc23dbdba8 100644
--- a/xbmc/peripherals/devices/PeripheralHID.cpp
+++ b/xbmc/peripherals/devices/PeripheralHID.cpp
@@ -15,10 +15,13 @@
 
 using namespace PERIPHERALS;
 
-CPeripheralHID::CPeripheralHID(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheral(manager, scanResult, bus)
+CPeripheralHID::CPeripheralHID(CPeripherals& manager,
+                               const PeripheralScanResult& scanResult,
+                               CPeripheralBus* bus)
+  : CPeripheral(manager, scanResult, bus)
 {
-  m_strDeviceName = scanResult.m_strDeviceName.empty() ? g_localizeStrings.Get(35001) : scanResult.m_strDeviceName;
+  m_strDeviceName = scanResult.m_strDeviceName.empty() ? g_localizeStrings.Get(35001)
+                                                       : scanResult.m_strDeviceName;
   m_features.push_back(FEATURE_HID);
 }
 
@@ -64,18 +67,20 @@ bool CPeripheralHID::InitialiseFeature(const PeripheralFeature feature)
       }
     }
 
-    CLog::Log(LOGDEBUG, "%s - initialised HID device (%s:%s)", __FUNCTION__, m_strVendorId.c_str(), m_strProductId.c_str());
+    CLog::Log(LOGDEBUG, "%s - initialised HID device (%s:%s)", __FUNCTION__, m_strVendorId.c_str(),
+              m_strProductId.c_str());
   }
 
   return CPeripheral::InitialiseFeature(feature);
 }
 
-void CPeripheralHID::OnSettingChanged(const std::string &strChangedSetting)
+void CPeripheralHID::OnSettingChanged(const std::string& strChangedSetting)
 {
-  if (m_bInitialised && ((StringUtils::EqualsNoCase(strChangedSetting, "keymap") && !GetSettingBool("do_not_use_custom_keymap")) || StringUtils::EqualsNoCase(strChangedSetting, "keymap_enabled")))
+  if (m_bInitialised && ((StringUtils::EqualsNoCase(strChangedSetting, "keymap") &&
+                          !GetSettingBool("do_not_use_custom_keymap")) ||
+                         StringUtils::EqualsNoCase(strChangedSetting, "keymap_enabled")))
   {
     m_bInitialised = false;
     InitialiseFeature(FEATURE_HID);
   }
 }
-
diff --git a/xbmc/peripherals/devices/PeripheralHID.h b/xbmc/peripherals/devices/PeripheralHID.h
index 1100dae9ffcf..3b35dfd3d3b9 100644
--- a/xbmc/peripherals/devices/PeripheralHID.h
+++ b/xbmc/peripherals/devices/PeripheralHID.h
@@ -13,16 +13,21 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralHID : public CPeripheral
+class CPeripheralHID : public CPeripheral
+{
+public:
+  CPeripheralHID(CPeripherals& manager,
+                 const PeripheralScanResult& scanResult,
+                 CPeripheralBus* bus);
+  ~CPeripheralHID(void) override;
+  bool InitialiseFeature(const PeripheralFeature feature) override;
+  virtual bool LookupSymAndUnicode(XBMC_keysym& keysym, uint8_t* key, char* unicode)
   {
-  public:
-    CPeripheralHID(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheralHID(void) override;
-    bool InitialiseFeature(const PeripheralFeature feature) override;
-    virtual bool LookupSymAndUnicode(XBMC_keysym &keysym, uint8_t *key, char *unicode) { return false; }
-    void OnSettingChanged(const std::string &strChangedSetting) override;
+    return false;
+  }
+  void OnSettingChanged(const std::string& strChangedSetting) override;
 
-  protected:
-    std::string m_strKeymap;
-  };
-}
+protected:
+  std::string m_strKeymap;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralImon.cpp b/xbmc/peripherals/devices/PeripheralImon.cpp
index 247a87e64ac8..1661321a3cf0 100644
--- a/xbmc/peripherals/devices/PeripheralImon.cpp
+++ b/xbmc/peripherals/devices/PeripheralImon.cpp
@@ -17,8 +17,10 @@ using namespace PERIPHERALS;
 std::atomic<long> CPeripheralImon::m_lCountOfImonsConflictWithDInput(0L);
 
 
-CPeripheralImon::CPeripheralImon(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheralHID(manager, scanResult, bus)
+CPeripheralImon::CPeripheralImon(CPeripherals& manager,
+                                 const PeripheralScanResult& scanResult,
+                                 CPeripheralBus* bus)
+  : CPeripheralHID(manager, scanResult, bus)
 {
   m_features.push_back(FEATURE_IMON);
   m_bImonConflictsWithDInput = false;
@@ -55,15 +57,17 @@ bool CPeripheralImon::InitialiseFeature(const PeripheralFeature feature)
   return CPeripheralHID::InitialiseFeature(feature);
 }
 
-void CPeripheralImon::AddSetting(const std::string &strKey, std::shared_ptr<const CSetting> setting, int order)
+void CPeripheralImon::AddSetting(const std::string& strKey,
+                                 std::shared_ptr<const CSetting> setting,
+                                 int order)
 {
 #if !defined(TARGET_WINDOWS)
-  if (strKey.compare("disable_winjoystick")!=0)
+  if (strKey.compare("disable_winjoystick") != 0)
 #endif // !TARGET_WINDOWS
     CPeripheralHID::AddSetting(strKey, setting, order);
 }
 
-void CPeripheralImon::OnSettingChanged(const std::string &strChangedSetting)
+void CPeripheralImon::OnSettingChanged(const std::string& strChangedSetting)
 {
   if (strChangedSetting.compare("disable_winjoystick") == 0)
   {
@@ -73,7 +77,7 @@ void CPeripheralImon::OnSettingChanged(const std::string &strChangedSetting)
       if (--m_lCountOfImonsConflictWithDInput == 0)
         ActionOnImonConflict(false);
     }
-    else if(!m_bImonConflictsWithDInput && GetSettingBool("disable_winjoystick"))
+    else if (!m_bImonConflictsWithDInput && GetSettingBool("disable_winjoystick"))
     {
       m_bImonConflictsWithDInput = true;
       ++m_lCountOfImonsConflictWithDInput;
@@ -85,4 +89,3 @@ void CPeripheralImon::OnSettingChanged(const std::string &strChangedSetting)
 void CPeripheralImon::ActionOnImonConflict(bool deviceInserted /*= true*/)
 {
 }
-
diff --git a/xbmc/peripherals/devices/PeripheralImon.h b/xbmc/peripherals/devices/PeripheralImon.h
index eb93775afedc..d6e8d2c5d191 100644
--- a/xbmc/peripherals/devices/PeripheralImon.h
+++ b/xbmc/peripherals/devices/PeripheralImon.h
@@ -16,23 +16,28 @@ class CSetting;
 
 namespace PERIPHERALS
 {
-  class CPeripheralImon : public CPeripheralHID
+class CPeripheralImon : public CPeripheralHID
+{
+public:
+  CPeripheralImon(CPeripherals& manager,
+                  const PeripheralScanResult& scanResult,
+                  CPeripheralBus* bus);
+  ~CPeripheralImon(void) override = default;
+  bool InitialiseFeature(const PeripheralFeature feature) override;
+  void OnSettingChanged(const std::string& strChangedSetting) override;
+  void OnDeviceRemoved() override;
+  void AddSetting(const std::string& strKey,
+                  std::shared_ptr<const CSetting> setting,
+                  int order) override;
+  inline bool IsImonConflictsWithDInput() { return m_bImonConflictsWithDInput; }
+  static inline long GetCountOfImonsConflictWithDInput()
   {
-  public:
-    CPeripheralImon(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheralImon(void) override = default;
-    bool InitialiseFeature(const PeripheralFeature feature) override;
-    void OnSettingChanged(const std::string &strChangedSetting) override;
-    void OnDeviceRemoved() override;
-    void AddSetting(const std::string &strKey, std::shared_ptr<const CSetting> setting, int order) override;
-    inline bool IsImonConflictsWithDInput()
-    { return m_bImonConflictsWithDInput;}
-    static inline long GetCountOfImonsConflictWithDInput()
-    { return m_lCountOfImonsConflictWithDInput; }
-    static void ActionOnImonConflict(bool deviceInserted = true);
+    return m_lCountOfImonsConflictWithDInput;
+  }
+  static void ActionOnImonConflict(bool deviceInserted = true);
 
-  private:
-    bool m_bImonConflictsWithDInput;
-    static std::atomic<long> m_lCountOfImonsConflictWithDInput;
-  };
-}
+private:
+  bool m_bImonConflictsWithDInput;
+  static std::atomic<long> m_lCountOfImonsConflictWithDInput;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralJoystick.cpp b/xbmc/peripherals/devices/PeripheralJoystick.cpp
index 085dd3efb8d5..dcaf4f6a23f8 100644
--- a/xbmc/peripherals/devices/PeripheralJoystick.cpp
+++ b/xbmc/peripherals/devices/PeripheralJoystick.cpp
@@ -29,15 +29,17 @@ using namespace KODI;
 using namespace JOYSTICK;
 using namespace PERIPHERALS;
 
-CPeripheralJoystick::CPeripheralJoystick(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheral(manager, scanResult, bus),
-  m_requestedPort(JOYSTICK_PORT_UNKNOWN),
-  m_buttonCount(0),
-  m_hatCount(0),
-  m_axisCount(0),
-  m_motorCount(0),
-  m_supportsPowerOff(false),
-  m_rumbleGenerator(new CRumbleGenerator)
+CPeripheralJoystick::CPeripheralJoystick(CPeripherals& manager,
+                                         const PeripheralScanResult& scanResult,
+                                         CPeripheralBus* bus)
+  : CPeripheral(manager, scanResult, bus),
+    m_requestedPort(JOYSTICK_PORT_UNKNOWN),
+    m_buttonCount(0),
+    m_hatCount(0),
+    m_axisCount(0),
+    m_motorCount(0),
+    m_supportsPowerOff(false),
+    m_rumbleGenerator(new CRumbleGenerator)
 {
   m_features.push_back(FEATURE_JOYSTICK);
   // FEATURE_RUMBLE conditionally added via SetMotorCount()
@@ -73,7 +75,8 @@ bool CPeripheralJoystick::InitialiseFeature(const PeripheralFeature feature)
       // Ensure an add-on is present to translate input
       if (!m_manager.GetAddonWithButtonMap(this))
       {
-        CLog::Log(LOGERROR, "CPeripheralJoystick: No button mapping add-on for %s", m_strLocation.c_str());
+        CLog::Log(LOGERROR, "CPeripheralJoystick: No button mapping add-on for %s",
+                  m_strLocation.c_str());
       }
       else
       {
@@ -88,7 +91,8 @@ bool CPeripheralJoystick::InitialiseFeature(const PeripheralFeature feature)
         InitializeDeadzoneFiltering();
 
         // Give joystick monitor priority over default controller
-        m_appInput.reset(new CKeymapHandling(this, false, m_manager.GetInputManager().KeymapEnvironment()));
+        m_appInput.reset(
+            new CKeymapHandling(this, false, m_manager.GetInputManager().KeymapEnvironment()));
         m_joystickMonitor.reset(new CJoystickMonitor);
         RegisterInputHandler(m_joystickMonitor.get(), false);
       }
@@ -119,19 +123,23 @@ void CPeripheralJoystick::InitializeDeadzoneFiltering()
     }
     else
     {
-      CLog::Log(LOGERROR, "CPeripheralJoystick: Failed to load button map for deadzone filtering on %s", m_strLocation.c_str());
+      CLog::Log(LOGERROR,
+                "CPeripheralJoystick: Failed to load button map for deadzone filtering on %s",
+                m_strLocation.c_str());
       m_buttonMap.reset();
     }
   }
   else
   {
-    CLog::Log(LOGERROR, "CPeripheralJoystick: Failed to create button map for deadzone filtering on %s", m_strLocation.c_str());
+    CLog::Log(LOGERROR,
+              "CPeripheralJoystick: Failed to create button map for deadzone filtering on %s",
+              m_strLocation.c_str());
   }
 }
 
 void CPeripheralJoystick::OnUserNotification()
 {
-  IInputReceiver *inputReceiver = m_appInput->GetInputReceiver(m_rumbleGenerator->ControllerID());
+  IInputReceiver* inputReceiver = m_appInput->GetInputReceiver(m_rumbleGenerator->ControllerID());
   m_rumbleGenerator->NotifyUser(inputReceiver);
 }
 
@@ -141,21 +149,22 @@ bool CPeripheralJoystick::TestFeature(PeripheralFeature feature)
 
   switch (feature)
   {
-  case FEATURE_RUMBLE:
-  {
-    IInputReceiver *inputReceiver = m_appInput->GetInputReceiver(m_rumbleGenerator->ControllerID());
-    bSuccess = m_rumbleGenerator->DoTest(inputReceiver);
-    break;
-  }
-  case FEATURE_POWER_OFF:
-    if (m_supportsPowerOff)
+    case FEATURE_RUMBLE:
     {
-      PowerOff();
-      bSuccess = true;
+      IInputReceiver* inputReceiver =
+          m_appInput->GetInputReceiver(m_rumbleGenerator->ControllerID());
+      bSuccess = m_rumbleGenerator->DoTest(inputReceiver);
+      break;
     }
-    break;
-  default:
-    break;
+    case FEATURE_POWER_OFF:
+      if (m_supportsPowerOff)
+      {
+        PowerOff();
+        bSuccess = true;
+      }
+      break;
+    default:
+      break;
   }
 
   return bSuccess;
@@ -170,7 +179,7 @@ void CPeripheralJoystick::RegisterJoystickDriverHandler(IDriverHandler* handler,
 {
   CSingleLock lock(m_handlerMutex);
 
-  DriverHandler driverHandler = { handler, bPromiscuous };
+  DriverHandler driverHandler = {handler, bPromiscuous};
   m_driverHandlers.insert(m_driverHandlers.begin(), driverHandler);
 }
 
@@ -179,13 +188,13 @@ void CPeripheralJoystick::UnregisterJoystickDriverHandler(IDriverHandler* handle
   CSingleLock lock(m_handlerMutex);
 
   m_driverHandlers.erase(std::remove_if(m_driverHandlers.begin(), m_driverHandlers.end(),
-    [handler](const DriverHandler& driverHandler)
-    {
-      return driverHandler.handler == handler;
-    }), m_driverHandlers.end());
+                                        [handler](const DriverHandler& driverHandler) {
+                                          return driverHandler.handler == handler;
+                                        }),
+                         m_driverHandlers.end());
 }
 
-IKeymap *CPeripheralJoystick::GetKeymap(const std::string &controllerId)
+IKeymap* CPeripheralJoystick::GetKeymap(const std::string& controllerId)
 {
   return m_appInput->GetKeymap(controllerId);
 }
@@ -390,7 +399,8 @@ void CPeripheralJoystick::SetMotorCount(unsigned int motorCount)
   m_motorCount = motorCount;
 
   if (m_motorCount == 0)
-    m_features.erase(std::remove(m_features.begin(), m_features.end(), FEATURE_RUMBLE), m_features.end());
+    m_features.erase(std::remove(m_features.begin(), m_features.end(), FEATURE_RUMBLE),
+                     m_features.end());
   else if (std::find(m_features.begin(), m_features.end(), FEATURE_RUMBLE) == m_features.end())
     m_features.push_back(FEATURE_RUMBLE);
 }
@@ -400,7 +410,8 @@ void CPeripheralJoystick::SetSupportsPowerOff(bool bSupportsPowerOff)
   m_supportsPowerOff = bSupportsPowerOff;
 
   if (!m_supportsPowerOff)
-    m_features.erase(std::remove(m_features.begin(), m_features.end(), FEATURE_POWER_OFF), m_features.end());
+    m_features.erase(std::remove(m_features.begin(), m_features.end(), FEATURE_POWER_OFF),
+                     m_features.end());
   else if (std::find(m_features.begin(), m_features.end(), FEATURE_POWER_OFF) == m_features.end())
     m_features.push_back(FEATURE_POWER_OFF);
 }
diff --git a/xbmc/peripherals/devices/PeripheralJoystick.h b/xbmc/peripherals/devices/PeripheralJoystick.h
index d42cabd31e98..dc207530af4a 100644
--- a/xbmc/peripherals/devices/PeripheralJoystick.h
+++ b/xbmc/peripherals/devices/PeripheralJoystick.h
@@ -17,117 +17,120 @@
 #include <string>
 #include <vector>
 
-#define JOYSTICK_PORT_UNKNOWN  (-1)
+#define JOYSTICK_PORT_UNKNOWN (-1)
 
 namespace KODI
 {
 namespace JOYSTICK
 {
-  class CDeadzoneFilter;
-  class CKeymapHandling;
-  class CRumbleGenerator;
-  class IButtonMap;
-  class IDriverHandler;
-  class IInputHandler;
-}
-}
+class CDeadzoneFilter;
+class CKeymapHandling;
+class CRumbleGenerator;
+class IButtonMap;
+class IDriverHandler;
+class IInputHandler;
+} // namespace JOYSTICK
+} // namespace KODI
 
 namespace PERIPHERALS
 {
-  class CPeripherals;
+class CPeripherals;
 
-  class CPeripheralJoystick : public CPeripheral, //! @todo extend CPeripheralHID
-                              public KODI::JOYSTICK::IDriverReceiver
+class CPeripheralJoystick : public CPeripheral, //! @todo extend CPeripheralHID
+                            public KODI::JOYSTICK::IDriverReceiver
+{
+public:
+  CPeripheralJoystick(CPeripherals& manager,
+                      const PeripheralScanResult& scanResult,
+                      CPeripheralBus* bus);
+
+  ~CPeripheralJoystick(void) override;
+
+  // implementation of CPeripheral
+  bool InitialiseFeature(const PeripheralFeature feature) override;
+  void OnUserNotification() override;
+  bool TestFeature(PeripheralFeature feature) override;
+  void RegisterJoystickDriverHandler(KODI::JOYSTICK::IDriverHandler* handler,
+                                     bool bPromiscuous) override;
+  void UnregisterJoystickDriverHandler(KODI::JOYSTICK::IDriverHandler* handler) override;
+  KODI::JOYSTICK::IDriverReceiver* GetDriverReceiver() override { return this; }
+  IKeymap* GetKeymap(const std::string& controllerId) override;
+  CDateTime LastActive() override { return m_lastActive; }
+
+  bool OnButtonMotion(unsigned int buttonIndex, bool bPressed);
+  bool OnHatMotion(unsigned int hatIndex, KODI::JOYSTICK::HAT_STATE state);
+  bool OnAxisMotion(unsigned int axisIndex, float position);
+  void ProcessAxisMotions(void);
+
+  // implementation of IDriverReceiver
+  bool SetMotorState(unsigned int motorIndex, float magnitude) override;
+
+  /*!
+   * \brief Get the name of the driver or API providing this joystick
+   */
+  const std::string& Provider(void) const { return m_strProvider; }
+
+  /*!
+   * \brief Get the specific port number requested by this joystick
+   *
+   * This could indicate that the joystick is connected to a hardware port
+   * with a number label; some controllers, such as the Xbox 360 controller,
+   * also have LEDs that indicate the controller is on a specific port.
+   *
+   * \return The 0-indexed port number, or JOYSTICK_PORT_UNKNOWN if no port is requested
+   */
+  int RequestedPort(void) const { return m_requestedPort; }
+
+  /*!
+   * \brief Get the number of elements reported by the driver
+   */
+  unsigned int ButtonCount(void) const { return m_buttonCount; }
+  unsigned int HatCount(void) const { return m_hatCount; }
+  unsigned int AxisCount(void) const { return m_axisCount; }
+  unsigned int MotorCount(void) const { return m_motorCount; }
+  bool SupportsPowerOff(void) const { return m_supportsPowerOff; }
+
+  /*!
+   * \brief Set joystick properties
+   */
+  void SetProvider(const std::string& provider) { m_strProvider = provider; }
+  void SetRequestedPort(int port) { m_requestedPort = port; }
+  void SetButtonCount(unsigned int buttonCount) { m_buttonCount = buttonCount; }
+  void SetHatCount(unsigned int hatCount) { m_hatCount = hatCount; }
+  void SetAxisCount(unsigned int axisCount) { m_axisCount = axisCount; }
+  void SetMotorCount(unsigned int motorCount); // specialized to update m_features
+  void SetSupportsPowerOff(bool bSupportsPowerOff); // specialized to update m_features
+
+protected:
+  void InitializeDeadzoneFiltering();
+
+  void PowerOff();
+
+  struct DriverHandler
   {
-  public:
-    CPeripheralJoystick(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-
-    ~CPeripheralJoystick(void) override;
-
-    // implementation of CPeripheral
-    bool InitialiseFeature(const PeripheralFeature feature) override;
-    void OnUserNotification() override;
-    bool TestFeature(PeripheralFeature feature) override;
-    void RegisterJoystickDriverHandler(KODI::JOYSTICK::IDriverHandler* handler, bool bPromiscuous) override;
-    void UnregisterJoystickDriverHandler(KODI::JOYSTICK::IDriverHandler* handler) override;
-    KODI::JOYSTICK::IDriverReceiver* GetDriverReceiver() override { return this; }
-    IKeymap *GetKeymap(const std::string &controllerId) override;
-    CDateTime LastActive() override { return m_lastActive; }
-
-    bool OnButtonMotion(unsigned int buttonIndex, bool bPressed);
-    bool OnHatMotion(unsigned int hatIndex, KODI::JOYSTICK::HAT_STATE state);
-    bool OnAxisMotion(unsigned int axisIndex, float position);
-    void ProcessAxisMotions(void);
-
-    // implementation of IDriverReceiver
-    bool SetMotorState(unsigned int motorIndex, float magnitude) override;
-
-    /*!
-     * \brief Get the name of the driver or API providing this joystick
-     */
-    const std::string& Provider(void) const { return m_strProvider; }
-
-    /*!
-     * \brief Get the specific port number requested by this joystick
-     *
-     * This could indicate that the joystick is connected to a hardware port
-     * with a number label; some controllers, such as the Xbox 360 controller,
-     * also have LEDs that indicate the controller is on a specific port.
-     *
-     * \return The 0-indexed port number, or JOYSTICK_PORT_UNKNOWN if no port is requested
-     */
-    int RequestedPort(void) const { return m_requestedPort; }
-
-    /*!
-     * \brief Get the number of elements reported by the driver
-     */
-    unsigned int ButtonCount(void) const { return m_buttonCount; }
-    unsigned int HatCount(void) const { return m_hatCount; }
-    unsigned int AxisCount(void) const { return m_axisCount; }
-    unsigned int MotorCount(void) const { return m_motorCount; }
-    bool SupportsPowerOff(void) const { return m_supportsPowerOff; }
-
-    /*!
-     * \brief Set joystick properties
-     */
-    void SetProvider(const std::string& provider) { m_strProvider = provider; }
-    void SetRequestedPort(int port) { m_requestedPort = port; }
-    void SetButtonCount(unsigned int buttonCount) { m_buttonCount = buttonCount; }
-    void SetHatCount(unsigned int hatCount) { m_hatCount = hatCount; }
-    void SetAxisCount(unsigned int axisCount) { m_axisCount = axisCount; }
-    void SetMotorCount(unsigned int motorCount); // specialized to update m_features
-    void SetSupportsPowerOff(bool bSupportsPowerOff); // specialized to update m_features
-
-  protected:
-    void InitializeDeadzoneFiltering();
-
-    void PowerOff();
-
-    struct DriverHandler
-    {
-      KODI::JOYSTICK::IDriverHandler* handler;
-      bool bPromiscuous;
-    };
-
-    // State parameters
-    std::string m_strProvider;
-    int m_requestedPort;
-    unsigned int m_buttonCount;
-    unsigned int m_hatCount;
-    unsigned int m_axisCount;
-    unsigned int m_motorCount;
-    bool m_supportsPowerOff;
-    CDateTime m_lastActive;
-
-    // Input clients
-    std::unique_ptr<KODI::JOYSTICK::CKeymapHandling> m_appInput;
-    std::unique_ptr<KODI::JOYSTICK::CRumbleGenerator> m_rumbleGenerator;
-    std::unique_ptr<KODI::JOYSTICK::IInputHandler> m_joystickMonitor;
-    std::unique_ptr<KODI::JOYSTICK::IButtonMap> m_buttonMap;
-    std::unique_ptr<KODI::JOYSTICK::CDeadzoneFilter> m_deadzoneFilter;
-    std::vector<DriverHandler> m_driverHandlers;
-
-    // Synchronization parameters
-    CCriticalSection m_handlerMutex;
+    KODI::JOYSTICK::IDriverHandler* handler;
+    bool bPromiscuous;
   };
-}
+
+  // State parameters
+  std::string m_strProvider;
+  int m_requestedPort;
+  unsigned int m_buttonCount;
+  unsigned int m_hatCount;
+  unsigned int m_axisCount;
+  unsigned int m_motorCount;
+  bool m_supportsPowerOff;
+  CDateTime m_lastActive;
+
+  // Input clients
+  std::unique_ptr<KODI::JOYSTICK::CKeymapHandling> m_appInput;
+  std::unique_ptr<KODI::JOYSTICK::CRumbleGenerator> m_rumbleGenerator;
+  std::unique_ptr<KODI::JOYSTICK::IInputHandler> m_joystickMonitor;
+  std::unique_ptr<KODI::JOYSTICK::IButtonMap> m_buttonMap;
+  std::unique_ptr<KODI::JOYSTICK::CDeadzoneFilter> m_deadzoneFilter;
+  std::vector<DriverHandler> m_driverHandlers;
+
+  // Synchronization parameters
+  CCriticalSection m_handlerMutex;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralKeyboard.cpp b/xbmc/peripherals/devices/PeripheralKeyboard.cpp
index 66ab4c867516..5ed353a4f091 100644
--- a/xbmc/peripherals/devices/PeripheralKeyboard.cpp
+++ b/xbmc/peripherals/devices/PeripheralKeyboard.cpp
@@ -17,8 +17,10 @@
 using namespace KODI;
 using namespace PERIPHERALS;
 
-CPeripheralKeyboard::CPeripheralKeyboard(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheral(manager, scanResult, bus)
+CPeripheralKeyboard::CPeripheralKeyboard(CPeripherals& manager,
+                                         const PeripheralScanResult& scanResult,
+                                         CPeripheralBus* bus)
+  : CPeripheral(manager, scanResult, bus)
 {
   // Initialize CPeripheral
   m_features.push_back(FEATURE_KEYBOARD);
@@ -52,23 +54,23 @@ bool CPeripheralKeyboard::InitialiseFeature(const PeripheralFeature feature)
   return bSuccess;
 }
 
-void CPeripheralKeyboard::RegisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler, bool bPromiscuous)
+void CPeripheralKeyboard::RegisterKeyboardDriverHandler(
+    KODI::KEYBOARD::IKeyboardDriverHandler* handler, bool bPromiscuous)
 {
   CSingleLock lock(m_mutex);
 
-  KeyboardHandle handle{ handler, bPromiscuous };
+  KeyboardHandle handle{handler, bPromiscuous};
   m_keyboardHandlers.insert(m_keyboardHandlers.begin(), handle);
 }
 
-void CPeripheralKeyboard::UnregisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler)
+void CPeripheralKeyboard::UnregisterKeyboardDriverHandler(
+    KODI::KEYBOARD::IKeyboardDriverHandler* handler)
 {
   CSingleLock lock(m_mutex);
 
-  auto it = std::find_if(m_keyboardHandlers.begin(), m_keyboardHandlers.end(),
-    [handler](const KeyboardHandle &handle)
-    {
-      return handle.handler == handler;
-    });
+  auto it =
+      std::find_if(m_keyboardHandlers.begin(), m_keyboardHandlers.end(),
+                   [handler](const KeyboardHandle& handle) { return handle.handler == handler; });
 
   if (it != m_keyboardHandlers.end())
     m_keyboardHandlers.erase(it);
@@ -83,14 +85,14 @@ bool CPeripheralKeyboard::OnKeyPress(const CKey& key)
   bool bHandled = false;
 
   // Process promiscuous handlers
-  for (const KeyboardHandle &handle : m_keyboardHandlers)
+  for (const KeyboardHandle& handle : m_keyboardHandlers)
   {
     if (handle.bPromiscuous)
       handle.handler->OnKeyPress(key);
   }
 
   // Process handlers until one is handled
-  for (const KeyboardHandle &handle : m_keyboardHandlers)
+  for (const KeyboardHandle& handle : m_keyboardHandlers)
   {
     if (!handle.bPromiscuous)
     {
@@ -107,6 +109,6 @@ void CPeripheralKeyboard::OnKeyRelease(const CKey& key)
 {
   CSingleLock lock(m_mutex);
 
-  for (const KeyboardHandle &handle : m_keyboardHandlers)
+  for (const KeyboardHandle& handle : m_keyboardHandlers)
     handle.handler->OnKeyRelease(key);
 }
diff --git a/xbmc/peripherals/devices/PeripheralKeyboard.h b/xbmc/peripherals/devices/PeripheralKeyboard.h
index fe9b58c7ecc9..f79f93391749 100644
--- a/xbmc/peripherals/devices/PeripheralKeyboard.h
+++ b/xbmc/peripherals/devices/PeripheralKeyboard.h
@@ -16,33 +16,35 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralKeyboard : public CPeripheral,
-                              public KODI::KEYBOARD::IKeyboardDriverHandler
+class CPeripheralKeyboard : public CPeripheral, public KODI::KEYBOARD::IKeyboardDriverHandler
+{
+public:
+  CPeripheralKeyboard(CPeripherals& manager,
+                      const PeripheralScanResult& scanResult,
+                      CPeripheralBus* bus);
+
+  ~CPeripheralKeyboard(void) override;
+
+  // implementation of CPeripheral
+  bool InitialiseFeature(const PeripheralFeature feature) override;
+  void RegisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler,
+                                     bool bPromiscuous) override;
+  void UnregisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler) override;
+  CDateTime LastActive() override { return m_lastActive; }
+
+  // implementation of IKeyboardDriverHandler
+  bool OnKeyPress(const CKey& key) override;
+  void OnKeyRelease(const CKey& key) override;
+
+private:
+  struct KeyboardHandle
   {
-  public:
-    CPeripheralKeyboard(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-
-    ~CPeripheralKeyboard(void) override;
-
-    // implementation of CPeripheral
-    bool InitialiseFeature(const PeripheralFeature feature) override;
-    void RegisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler, bool bPromiscuous) override;
-    void UnregisterKeyboardDriverHandler(KODI::KEYBOARD::IKeyboardDriverHandler* handler) override;
-    CDateTime LastActive() override { return m_lastActive; }
-
-    // implementation of IKeyboardDriverHandler
-    bool OnKeyPress(const CKey& key) override;
-    void OnKeyRelease(const CKey& key) override;
-
-  private:
-    struct KeyboardHandle
-    {
-      KODI::KEYBOARD::IKeyboardDriverHandler* handler;
-      bool bPromiscuous;
-    };
-
-    std::vector<KeyboardHandle> m_keyboardHandlers;
-    CCriticalSection m_mutex;
-    CDateTime m_lastActive;
+    KODI::KEYBOARD::IKeyboardDriverHandler* handler;
+    bool bPromiscuous;
   };
-}
+
+  std::vector<KeyboardHandle> m_keyboardHandlers;
+  CCriticalSection m_mutex;
+  CDateTime m_lastActive;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralMouse.cpp b/xbmc/peripherals/devices/PeripheralMouse.cpp
index bfd839a279b7..86e55f96832d 100644
--- a/xbmc/peripherals/devices/PeripheralMouse.cpp
+++ b/xbmc/peripherals/devices/PeripheralMouse.cpp
@@ -17,8 +17,10 @@
 using namespace KODI;
 using namespace PERIPHERALS;
 
-CPeripheralMouse::CPeripheralMouse(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheral(manager, scanResult, bus)
+CPeripheralMouse::CPeripheralMouse(CPeripherals& manager,
+                                   const PeripheralScanResult& scanResult,
+                                   CPeripheralBus* bus)
+  : CPeripheral(manager, scanResult, bus)
 {
   // Initialize CPeripheral
   m_features.push_back(FEATURE_MOUSE);
@@ -46,13 +48,14 @@ bool CPeripheralMouse::InitialiseFeature(const PeripheralFeature feature)
   return bSuccess;
 }
 
-void CPeripheralMouse::RegisterMouseDriverHandler(MOUSE::IMouseDriverHandler* handler, bool bPromiscuous)
+void CPeripheralMouse::RegisterMouseDriverHandler(MOUSE::IMouseDriverHandler* handler,
+                                                  bool bPromiscuous)
 {
   using namespace KEYBOARD;
 
   CSingleLock lock(m_mutex);
 
-  MouseHandle handle{ handler, bPromiscuous };
+  MouseHandle handle{handler, bPromiscuous};
   m_mouseHandlers.insert(m_mouseHandlers.begin(), handle);
 }
 
@@ -60,11 +63,9 @@ void CPeripheralMouse::UnregisterMouseDriverHandler(MOUSE::IMouseDriverHandler*
 {
   CSingleLock lock(m_mutex);
 
-  auto it = std::find_if(m_mouseHandlers.begin(), m_mouseHandlers.end(),
-    [handler](const MouseHandle &handle)
-    {
-      return handle.handler == handler;
-    });
+  auto it =
+      std::find_if(m_mouseHandlers.begin(), m_mouseHandlers.end(),
+                   [handler](const MouseHandle& handle) { return handle.handler == handler; });
 
   if (it != m_mouseHandlers.end())
     m_mouseHandlers.erase(it);
@@ -77,14 +78,14 @@ bool CPeripheralMouse::OnPosition(int x, int y)
   bool bHandled = false;
 
   // Process promiscuous handlers
-  for (const MouseHandle &handle : m_mouseHandlers)
+  for (const MouseHandle& handle : m_mouseHandlers)
   {
     if (handle.bPromiscuous)
       handle.handler->OnPosition(x, y);
   }
 
   // Process handlers until one is handled
-  for (const MouseHandle &handle : m_mouseHandlers)
+  for (const MouseHandle& handle : m_mouseHandlers)
   {
     if (!handle.bPromiscuous)
     {
@@ -109,14 +110,14 @@ bool CPeripheralMouse::OnButtonPress(MOUSE::BUTTON_ID button)
   bool bHandled = false;
 
   // Process promiscuous handlers
-  for (const MouseHandle &handle : m_mouseHandlers)
+  for (const MouseHandle& handle : m_mouseHandlers)
   {
     if (handle.bPromiscuous)
       handle.handler->OnButtonPress(button);
   }
 
   // Process handlers until one is handled
-  for (const MouseHandle &handle : m_mouseHandlers)
+  for (const MouseHandle& handle : m_mouseHandlers)
   {
     if (!handle.bPromiscuous)
     {
@@ -133,6 +134,6 @@ void CPeripheralMouse::OnButtonRelease(MOUSE::BUTTON_ID button)
 {
   CSingleLock lock(m_mutex);
 
-  for (const MouseHandle &handle : m_mouseHandlers)
+  for (const MouseHandle& handle : m_mouseHandlers)
     handle.handler->OnButtonRelease(button);
 }
diff --git a/xbmc/peripherals/devices/PeripheralMouse.h b/xbmc/peripherals/devices/PeripheralMouse.h
index 6b21a426d5fa..4c47eef208d1 100644
--- a/xbmc/peripherals/devices/PeripheralMouse.h
+++ b/xbmc/peripherals/devices/PeripheralMouse.h
@@ -16,34 +16,36 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralMouse : public CPeripheral,
-                           public KODI::MOUSE::IMouseDriverHandler
+class CPeripheralMouse : public CPeripheral, public KODI::MOUSE::IMouseDriverHandler
+{
+public:
+  CPeripheralMouse(CPeripherals& manager,
+                   const PeripheralScanResult& scanResult,
+                   CPeripheralBus* bus);
+
+  ~CPeripheralMouse(void) override;
+
+  // implementation of CPeripheral
+  bool InitialiseFeature(const PeripheralFeature feature) override;
+  void RegisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler,
+                                  bool bPromiscuous) override;
+  void UnregisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler) override;
+  CDateTime LastActive() override { return m_lastActive; }
+
+  // implementation of IMouseDriverHandler
+  bool OnPosition(int x, int y) override;
+  bool OnButtonPress(KODI::MOUSE::BUTTON_ID button) override;
+  void OnButtonRelease(KODI::MOUSE::BUTTON_ID button) override;
+
+private:
+  struct MouseHandle
   {
-  public:
-    CPeripheralMouse(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-
-    ~CPeripheralMouse(void) override;
-
-    // implementation of CPeripheral
-    bool InitialiseFeature(const PeripheralFeature feature) override;
-    void RegisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler, bool bPromiscuous) override;
-    void UnregisterMouseDriverHandler(KODI::MOUSE::IMouseDriverHandler* handler) override;
-    CDateTime LastActive() override { return m_lastActive; }
-
-    // implementation of IMouseDriverHandler
-    bool OnPosition(int x, int y) override;
-    bool OnButtonPress(KODI::MOUSE::BUTTON_ID button) override;
-    void OnButtonRelease(KODI::MOUSE::BUTTON_ID button) override;
-
-  private:
-    struct MouseHandle
-    {
-      KODI::MOUSE::IMouseDriverHandler* handler;
-      bool bPromiscuous;
-    };
-
-    std::vector<MouseHandle> m_mouseHandlers;
-    CCriticalSection m_mutex;
-    CDateTime m_lastActive;
+    KODI::MOUSE::IMouseDriverHandler* handler;
+    bool bPromiscuous;
   };
-}
+
+  std::vector<MouseHandle> m_mouseHandlers;
+  CCriticalSection m_mutex;
+  CDateTime m_lastActive;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralNIC.cpp b/xbmc/peripherals/devices/PeripheralNIC.cpp
index 4cb2695838a4..a5b5c327ce2d 100644
--- a/xbmc/peripherals/devices/PeripheralNIC.cpp
+++ b/xbmc/peripherals/devices/PeripheralNIC.cpp
@@ -12,9 +12,12 @@
 
 using namespace PERIPHERALS;
 
-CPeripheralNIC::CPeripheralNIC(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheral(manager, scanResult, bus)
+CPeripheralNIC::CPeripheralNIC(CPeripherals& manager,
+                               const PeripheralScanResult& scanResult,
+                               CPeripheralBus* bus)
+  : CPeripheral(manager, scanResult, bus)
 {
-  m_strDeviceName = scanResult.m_strDeviceName.empty() ? g_localizeStrings.Get(35002) : scanResult.m_strDeviceName;
+  m_strDeviceName = scanResult.m_strDeviceName.empty() ? g_localizeStrings.Get(35002)
+                                                       : scanResult.m_strDeviceName;
   m_features.push_back(FEATURE_NIC);
 }
diff --git a/xbmc/peripherals/devices/PeripheralNIC.h b/xbmc/peripherals/devices/PeripheralNIC.h
index 16bfafa72741..01fe5f3c6b1a 100644
--- a/xbmc/peripherals/devices/PeripheralNIC.h
+++ b/xbmc/peripherals/devices/PeripheralNIC.h
@@ -12,10 +12,12 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralNIC : public CPeripheral
-  {
-  public:
-    CPeripheralNIC(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheralNIC(void) override = default;
-  };
-}
+class CPeripheralNIC : public CPeripheral
+{
+public:
+  CPeripheralNIC(CPeripherals& manager,
+                 const PeripheralScanResult& scanResult,
+                 CPeripheralBus* bus);
+  ~CPeripheralNIC(void) override = default;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralNyxboard.cpp b/xbmc/peripherals/devices/PeripheralNyxboard.cpp
index 0cb73c5007f0..682b0dc98a5b 100644
--- a/xbmc/peripherals/devices/PeripheralNyxboard.cpp
+++ b/xbmc/peripherals/devices/PeripheralNyxboard.cpp
@@ -14,22 +14,26 @@
 
 using namespace PERIPHERALS;
 
-CPeripheralNyxboard::CPeripheralNyxboard(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheralHID(manager, scanResult, bus)
+CPeripheralNyxboard::CPeripheralNyxboard(CPeripherals& manager,
+                                         const PeripheralScanResult& scanResult,
+                                         CPeripheralBus* bus)
+  : CPeripheralHID(manager, scanResult, bus)
 {
   m_features.push_back(FEATURE_NYXBOARD);
 }
 
-bool CPeripheralNyxboard::LookupSymAndUnicode(XBMC_keysym &keysym, uint8_t *key, char *unicode)
+bool CPeripheralNyxboard::LookupSymAndUnicode(XBMC_keysym& keysym, uint8_t* key, char* unicode)
 {
   std::string strCommand;
-  if (keysym.sym == XBMCK_F7 && keysym.mod == XBMCKMOD_NONE && GetSettingBool("enable_flip_commands"))
+  if (keysym.sym == XBMCK_F7 && keysym.mod == XBMCKMOD_NONE &&
+      GetSettingBool("enable_flip_commands"))
   {
     /* switched to keyboard side */
     CLog::Log(LOGDEBUG, "%s - switched to keyboard side", __FUNCTION__);
     strCommand = GetSettingString("flip_keyboard");
   }
-  else if (keysym.sym == XBMCK_F7 && keysym.mod == XBMCKMOD_LCTRL && GetSettingBool("enable_flip_commands"))
+  else if (keysym.sym == XBMCK_F7 && keysym.mod == XBMCKMOD_LCTRL &&
+           GetSettingBool("enable_flip_commands"))
   {
     /* switched to remote side */
     CLog::Log(LOGDEBUG, "%s - switched to remote side", __FUNCTION__);
@@ -42,7 +46,7 @@ bool CPeripheralNyxboard::LookupSymAndUnicode(XBMC_keysym &keysym, uint8_t *key,
     if (g_application.ExecuteXBMCAction(strCommand))
     {
       *key = 0;
-      *unicode = (char) 0;
+      *unicode = (char)0;
       return true;
     }
   }
diff --git a/xbmc/peripherals/devices/PeripheralNyxboard.h b/xbmc/peripherals/devices/PeripheralNyxboard.h
index f8e13b217b14..f81c3ef6f563 100644
--- a/xbmc/peripherals/devices/PeripheralNyxboard.h
+++ b/xbmc/peripherals/devices/PeripheralNyxboard.h
@@ -12,11 +12,13 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralNyxboard : public CPeripheralHID
-  {
-  public:
-    CPeripheralNyxboard(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheralNyxboard(void) override = default;
-    bool LookupSymAndUnicode(XBMC_keysym &keysym, uint8_t *key, char *unicode) override;
-  };
-}
+class CPeripheralNyxboard : public CPeripheralHID
+{
+public:
+  CPeripheralNyxboard(CPeripherals& manager,
+                      const PeripheralScanResult& scanResult,
+                      CPeripheralBus* bus);
+  ~CPeripheralNyxboard(void) override = default;
+  bool LookupSymAndUnicode(XBMC_keysym& keysym, uint8_t* key, char* unicode) override;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/devices/PeripheralTuner.cpp b/xbmc/peripherals/devices/PeripheralTuner.cpp
index 6b8e240ceb0d..770656d6516b 100644
--- a/xbmc/peripherals/devices/PeripheralTuner.cpp
+++ b/xbmc/peripherals/devices/PeripheralTuner.cpp
@@ -10,8 +10,10 @@
 
 using namespace PERIPHERALS;
 
-CPeripheralTuner::CPeripheralTuner(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
-  CPeripheral(manager, scanResult, bus)
+CPeripheralTuner::CPeripheralTuner(CPeripherals& manager,
+                                   const PeripheralScanResult& scanResult,
+                                   CPeripheralBus* bus)
+  : CPeripheral(manager, scanResult, bus)
 {
   m_features.push_back(FEATURE_TUNER);
 }
diff --git a/xbmc/peripherals/devices/PeripheralTuner.h b/xbmc/peripherals/devices/PeripheralTuner.h
index 61b2b215fc0b..aedfc12913ae 100644
--- a/xbmc/peripherals/devices/PeripheralTuner.h
+++ b/xbmc/peripherals/devices/PeripheralTuner.h
@@ -12,10 +12,12 @@
 
 namespace PERIPHERALS
 {
-  class CPeripheralTuner : public CPeripheral
-  {
-  public:
-    CPeripheralTuner(CPeripherals& manager, const PeripheralScanResult& scanResult, CPeripheralBus* bus);
-    ~CPeripheralTuner(void) override = default;
-  };
-}
+class CPeripheralTuner : public CPeripheral
+{
+public:
+  CPeripheralTuner(CPeripherals& manager,
+                   const PeripheralScanResult& scanResult,
+                   CPeripheralBus* bus);
+  ~CPeripheralTuner(void) override = default;
+};
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.cpp b/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.cpp
index 87dec25e36cb..e70a67fe3df1 100644
--- a/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.cpp
+++ b/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.cpp
@@ -26,7 +26,8 @@ using namespace PERIPHERALS;
 CGUIDialogPeripheralSettings::CGUIDialogPeripheralSettings()
   : CGUIDialogSettingsManualBase(WINDOW_DIALOG_PERIPHERAL_SETTINGS, "DialogSettings.xml"),
     m_item(NULL)
-{ }
+{
+}
 
 CGUIDialogPeripheralSettings::~CGUIDialogPeripheralSettings()
 {
@@ -36,7 +37,7 @@ CGUIDialogPeripheralSettings::~CGUIDialogPeripheralSettings()
   m_settingsMap.clear();
 }
 
-bool CGUIDialogPeripheralSettings::OnMessage(CGUIMessage &message)
+bool CGUIDialogPeripheralSettings::OnMessage(CGUIMessage& message)
 {
   if (message.GetMessage() == GUI_MSG_CLICKED &&
       message.GetSenderId() == CONTROL_SETTINGS_CUSTOM_BUTTON)
@@ -48,7 +49,7 @@ bool CGUIDialogPeripheralSettings::OnMessage(CGUIMessage &message)
   return CGUIDialogSettingsManualBase::OnMessage(message);
 }
 
-void CGUIDialogPeripheralSettings::SetFileItem(const CFileItem *item)
+void CGUIDialogPeripheralSettings::SetFileItem(const CFileItem* item)
 {
   if (item == NULL)
     return;
@@ -68,7 +69,8 @@ void CGUIDialogPeripheralSettings::OnSettingChanged(std::shared_ptr<const CSetti
 
   // we need to copy the new value of the setting from the copy to the
   // original setting
-  std::map<std::string, std::shared_ptr<CSetting>>::iterator itSetting = m_settingsMap.find(setting->GetId());
+  std::map<std::string, std::shared_ptr<CSetting>>::iterator itSetting =
+      m_settingsMap.find(setting->GetId());
   if (itSetting == m_settingsMap.end())
     return;
 
@@ -167,11 +169,12 @@ void CGUIDialogPeripheralSettings::InitializeSettings()
     // we need to create a copy of the setting because the CSetting instances
     // are destroyed when leaving the dialog
     SettingPtr settingCopy;
-    switch(setting->GetType())
+    switch (setting->GetType())
     {
       case SettingType::Boolean:
       {
-        std::shared_ptr<CSettingBool> settingBool = std::make_shared<CSettingBool>(setting->GetId(), *std::static_pointer_cast<CSettingBool>(setting));
+        std::shared_ptr<CSettingBool> settingBool = std::make_shared<CSettingBool>(
+            setting->GetId(), *std::static_pointer_cast<CSettingBool>(setting));
         settingBool->SetControl(GetCheckmarkControl());
 
         settingCopy = std::static_pointer_cast<CSetting>(settingBool);
@@ -180,7 +183,8 @@ void CGUIDialogPeripheralSettings::InitializeSettings()
 
       case SettingType::Integer:
       {
-        std::shared_ptr<CSettingInt> settingInt = std::make_shared<CSettingInt>(setting->GetId(), *std::static_pointer_cast<CSettingInt>(setting));
+        std::shared_ptr<CSettingInt> settingInt = std::make_shared<CSettingInt>(
+            setting->GetId(), *std::static_pointer_cast<CSettingInt>(setting));
         if (settingInt->GetTranslatableOptions().empty())
           settingInt->SetControl(GetSliderControl("integer", false, -1, usePopup, -1, "%i"));
         else
@@ -192,7 +196,8 @@ void CGUIDialogPeripheralSettings::InitializeSettings()
 
       case SettingType::Number:
       {
-        std::shared_ptr<CSettingNumber> settingNumber = std::make_shared<CSettingNumber>(setting->GetId(), *std::static_pointer_cast<CSettingNumber>(setting));
+        std::shared_ptr<CSettingNumber> settingNumber = std::make_shared<CSettingNumber>(
+            setting->GetId(), *std::static_pointer_cast<CSettingNumber>(setting));
         settingNumber->SetControl(GetSliderControl("number", false, -1, usePopup, -1, "%2.2f"));
 
         settingCopy = std::static_pointer_cast<CSetting>(settingNumber);
@@ -201,7 +206,8 @@ void CGUIDialogPeripheralSettings::InitializeSettings()
 
       case SettingType::String:
       {
-        std::shared_ptr<CSettingString> settingString = std::make_shared<CSettingString>(setting->GetId(), *std::static_pointer_cast<CSettingString>(setting));
+        std::shared_ptr<CSettingString> settingString = std::make_shared<CSettingString>(
+            setting->GetId(), *std::static_pointer_cast<CSettingString>(setting));
         settingString->SetControl(GetEditControl("string"));
 
         settingCopy = std::static_pointer_cast<CSetting>(settingString);
diff --git a/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.h b/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.h
index cde5f0aa0941..bd49a8722067 100644
--- a/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.h
+++ b/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.h
@@ -21,9 +21,9 @@ class CGUIDialogPeripheralSettings : public CGUIDialogSettingsManualBase
   ~CGUIDialogPeripheralSettings() override;
 
   // specializations of CGUIControl
-  bool OnMessage(CGUIMessage &message) override;
+  bool OnMessage(CGUIMessage& message) override;
 
-  virtual void SetFileItem(const CFileItem *item);
+  virtual void SetFileItem(const CFileItem* item);
 
 protected:
   // implementations of ISettingCallback
@@ -38,8 +38,8 @@ class CGUIDialogPeripheralSettings : public CGUIDialogSettingsManualBase
   // specialization of CGUIDialogSettingsManualBase
   void InitializeSettings() override;
 
-  CFileItem *m_item;
+  CFileItem* m_item;
   bool m_initialising = false;
   std::map<std::string, std::shared_ptr<CSetting>> m_settingsMap;
 };
-}
+} // namespace PERIPHERALS
diff --git a/xbmc/peripherals/dialogs/GUIDialogPeripherals.cpp b/xbmc/peripherals/dialogs/GUIDialogPeripherals.cpp
index 0489d9106ee2..4a6a6a7b4cbf 100644
--- a/xbmc/peripherals/dialogs/GUIDialogPeripherals.cpp
+++ b/xbmc/peripherals/dialogs/GUIDialogPeripherals.cpp
@@ -38,7 +38,7 @@ void CGUIDialogPeripherals::OnInitWindow()
   CGUIDialogSelect::OnInitWindow();
 }
 
-void CGUIDialogPeripherals::RegisterPeripheralManager(CPeripherals &manager)
+void CGUIDialogPeripherals::RegisterPeripheralManager(CPeripherals& manager)
 {
   m_manager = &manager;
   m_manager->RegisterObserver(this);
@@ -65,9 +65,11 @@ CFileItemPtr CGUIDialogPeripherals::GetItem(unsigned int pos) const
   return item;
 }
 
-void CGUIDialogPeripherals::Show(CPeripherals &manager)
+void CGUIDialogPeripherals::Show(CPeripherals& manager)
 {
-  CGUIDialogPeripherals* pDialog = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogPeripherals>(WINDOW_DIALOG_PERIPHERALS);
+  CGUIDialogPeripherals* pDialog =
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogPeripherals>(
+          WINDOW_DIALOG_PERIPHERALS);
   if (pDialog == nullptr)
     return;
 
@@ -76,7 +78,7 @@ void CGUIDialogPeripherals::Show(CPeripherals &manager)
   int iPos = -1;
   do
   {
-    pDialog->SetHeading(CVariant{ 35000 });
+    pDialog->SetHeading(CVariant{35000});
     pDialog->SetUseDetails(true);
 
     pDialog->RegisterPeripheralManager(manager);
@@ -95,11 +97,13 @@ void CGUIDialogPeripherals::Show(CPeripherals &manager)
       PeripheralPtr peripheral = manager.GetByPath(pItem->GetPath());
       if (!peripheral || peripheral->GetSettings().empty())
       {
-        MESSAGING::HELPERS::ShowOKDialogText(CVariant{ 35000 }, CVariant{ 35004 });
+        MESSAGING::HELPERS::ShowOKDialogText(CVariant{35000}, CVariant{35004});
         continue;
       }
 
-      CGUIDialogPeripheralSettings *pSettingsDialog = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogPeripheralSettings>(WINDOW_DIALOG_PERIPHERAL_SETTINGS);
+      CGUIDialogPeripheralSettings* pSettingsDialog =
+          CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogPeripheralSettings>(
+              WINDOW_DIALOG_PERIPHERAL_SETTINGS);
       if (pItem && pSettingsDialog)
       {
         // Pass peripheral item properties to settings dialog so skin authors
@@ -136,15 +140,15 @@ bool CGUIDialogPeripherals::OnMessage(CGUIMessage& message)
   return CGUIDialogSelect::OnMessage(message);
 }
 
-void CGUIDialogPeripherals::Notify(const Observable &obs, const ObservableMessage msg)
+void CGUIDialogPeripherals::Notify(const Observable& obs, const ObservableMessage msg)
 {
   switch (msg)
   {
-  case ObservableMessagePeripheralsChanged:
-    UpdatePeripheralsAsync();
-    break;
-  default:
-    break;
+    case ObservableMessagePeripheralsChanged:
+      UpdatePeripheralsAsync();
+      break;
+    default:
+      break;
   }
 }
 
diff --git a/xbmc/peripherals/dialogs/GUIDialogPeripherals.h b/xbmc/peripherals/dialogs/GUIDialogPeripherals.h
index b25565300e5d..d4a2f5dd2985 100644
--- a/xbmc/peripherals/dialogs/GUIDialogPeripherals.h
+++ b/xbmc/peripherals/dialogs/GUIDialogPeripherals.h
@@ -17,25 +17,24 @@ namespace PERIPHERALS
 {
 class CPeripherals;
 
-class CGUIDialogPeripherals : public CGUIDialogSelect,
-                              protected Observer
+class CGUIDialogPeripherals : public CGUIDialogSelect, protected Observer
 {
 public:
   CGUIDialogPeripherals();
   ~CGUIDialogPeripherals() override;
 
-  void RegisterPeripheralManager(CPeripherals &manager);
+  void RegisterPeripheralManager(CPeripherals& manager);
   void UnregisterPeripheralManager();
 
   CFileItemPtr GetItem(unsigned int pos) const;
 
-  static void Show(CPeripherals &manager);
+  static void Show(CPeripherals& manager);
 
   // implementation of CGUIControl via CGUIDialogSelect
   bool OnMessage(CGUIMessage& message) override;
 
   // implementation of Observer
-  void Notify(const Observable &obs, const ObservableMessage msg) override;
+  void Notify(const Observable& obs, const ObservableMessage msg) override;
 
 private:
   // implementation of CGUIWindow via CGUIDialogSelect
@@ -45,8 +44,8 @@ class CGUIDialogPeripherals : public CGUIDialogSelect,
   void UpdatePeripheralsAsync();
   void UpdatePeripheralsSync();
 
-  CPeripherals *m_manager = nullptr;
+  CPeripherals* m_manager = nullptr;
   CFileItemList m_peripherals;
   mutable CCriticalSection m_peripheralsMutex;
 };
-}
+} // namespace PERIPHERALS

From ab24c9b72430e627a3e069399cb228682f498d3c Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Fri, 22 May 2020 15:01:44 -0700
Subject: [PATCH 6/7] Add .git-blame-ignore-revs

---
 .git-blame-ignore-revs | 15 +++++++++++++++
 1 file changed, 15 insertions(+)
 create mode 100644 .git-blame-ignore-revs

diff --git a/.git-blame-ignore-revs b/.git-blame-ignore-revs
new file mode 100644
index 000000000000..5496b8cba9f9
--- /dev/null
+++ b/.git-blame-ignore-revs
@@ -0,0 +1,15 @@
+# Since version 2.23 (released in August 2019), git-blame has a feature
+# to ignore or bypass certain commits.
+#
+# This file contains a list of commits that are not likely what you
+# are looking for in a blame, such as mass reformatting or renaming.
+# You can set this file as a default ignore file for blame by running
+# the following command.
+#
+# $ git config blame.ignoreRevsFile .git-blame-ignore-revs
+
+# PR 17922: Clang-format our Game/Input code for GSoC
+838cf16f17a7fcf5d49ac0b3d51d9826a9fb7a6e
+d1e6fff19c1cf2a266f0429c8d0ddea3195ddcce
+0b34dc7e6f61424c8cce7249cdcd6060b8eada9e
+71a2c6b734420f540b0d06f6e3334ffe5a9e8225

From bba48776194421df7f9d3121e13f008ca64b1a63 Mon Sep 17 00:00:00 2001
From: Garrett Brown <themagnificentmrb@gmail.com>
Date: Fri, 29 May 2020 00:54:07 -0700
Subject: [PATCH 7/7] Fix doxy in input code after clang-format

---
 xbmc/input/ButtonTranslator.h |  4 ++--
 xbmc/input/InputCodingTable.h |  4 +++-
 xbmc/input/mouse/MouseStat.h  | 10 +++++-----
 3 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/xbmc/input/ButtonTranslator.h b/xbmc/input/ButtonTranslator.h
index 2aeb6629ac37..a0ed23f8e145 100644
--- a/xbmc/input/ButtonTranslator.h
+++ b/xbmc/input/ButtonTranslator.h
@@ -55,8 +55,8 @@ class CButtonTranslator
    \param window the window id
    \param key the key to query the action for
    \param fallback if no action is directly configured for the given window, obtain the action from
-   fallback window, if exists or from global config as last resort \return the action matching the
-   key
+   fallback window, if exists or from global config as last resort
+   \return the action matching the key
    */
   CAction GetAction(int window, const CKey& key, bool fallback = true);
 
diff --git a/xbmc/input/InputCodingTable.h b/xbmc/input/InputCodingTable.h
index 8e72a7fa4b0a..a071356784b7 100644
--- a/xbmc/input/InputCodingTable.h
+++ b/xbmc/input/InputCodingTable.h
@@ -38,7 +38,9 @@ class IInputCodingTable
   virtual void Deinitialize() {}
 
   /*! \brief Can be overridden if initialization is expensive to avoid calling initialize more than
-     needed \return true if initialization has been done and was successful, false otherwise.
+      needed
+
+      \return true if initialization has been done and was successful, false otherwise.
   */
   virtual bool IsInitialized() const { return true; }
   virtual bool GetWordListPage(const std::string& strCode, bool isFirstPage) = 0;
diff --git a/xbmc/input/mouse/MouseStat.h b/xbmc/input/mouse/MouseStat.h
index e44fd3eb6971..5700e2a22558 100644
--- a/xbmc/input/mouse/MouseStat.h
+++ b/xbmc/input/mouse/MouseStat.h
@@ -107,11 +107,11 @@ class CMouseStat
 
    The actions we detect are:
     * short clicks - down/up press of the mouse within short_click_time ms, where the pointer stays
-   within click_confines pixels
+      within click_confines pixels
     * long clicks - down/up press of the mouse greater than short_click_time ms, where the pointers
-   stays within click_confines pixels
+      stays within click_confines pixels
     * double clicks - a further down press of the mouse within double_click_time of the up press of
-   a short click, where the pointer stays within click_confines pixels
+      a short click, where the pointer stays within click_confines pixels
     * drag - the mouse is down and has been moved more than click_confines pixels
 
    \sa CMouseStat
@@ -172,9 +172,9 @@ class CMouseStat
 
   /*! \brief detect whether the mouse has moved
 
-  Uses a trigger threshold of 2 pixels to detect mouse movement
+   Uses a trigger threshold of 2 pixels to detect mouse movement
 
-  \return whether the mouse has moved past the trigger threshold.
+   \return whether the mouse has moved past the trigger threshold.
    */
   bool MovedPastThreshold() const;
 
